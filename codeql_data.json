[
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import semmle.code.csharp.Comments\n\nclass AstNode extends Element {\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n}\n\nclass SingleLineComment extends CommentLine {\n  SingleLineComment() {\n    // Must be either `// ...` or `/* ... */` on a single line.\n    this.getRawText().regexpMatch(\"//.*|/\\\\*.*\\\\*/\")\n  }\n\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n}\n\nimport AS::Make<AstNode, SingleLineComment>",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/AlertSuppression.ql",
        "language": "csharp"
    },
    {
        "query": "import definitions\n\nfrom Use use, Declaration def, string kind\nwhere def = definitionOf(use, kind)\nselect use, def, kind",
        "description": "Generates use-definition pairs that provide the data for jump-to-definition in the code viewer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/definitions.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.web.Http\n\nfrom IndexerAccess ia\nwhere\n  ia.getTarget().getDeclaringType().hasFullyQualifiedName(\"System.Web\", \"HttpRequest\") and\n  not isServerVariable(ia.getIndex(0))\nselect ia, \"Ambiguous access to variable.\"",
        "description": "Finds ambiguous accesses to client variables",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Input Validation/ValueShadowing.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.web.Http\n\nfrom IndexerAccess ia\nwhere\n  ia.getTarget().getDeclaringType().hasFullyQualifiedName(\"System.Web\", \"HttpRequest\") and\n  isServerVariable(ia.getIndex(0))\nselect ia, \"Ambiguous access to server variable.\"",
        "description": "Finds ambiguous accesses to server variables",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Input Validation/ValueShadowingServerVariable.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom PropertyAccess pa\nwhere\n  pa.getTarget().hasName(\"PostedFile\") and\n  pa.getTarget()\n      .getDeclaringType()\n      .hasFullyQualifiedName(\"System.Web.UI.HtmlControls\", \"HtmlInputFile\")\nselect pa, \"Avoid using file upload.\"",
        "description": "Finds uses of file upload",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Input Validation/UseOfFileUpload.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.GeneratedCode\nimport semmle.code.csharp.frameworks.Test\n\npredicate classify(File f, string category) {\n  f instanceof GeneratedCodeFile and category = \"generated\"\n  or\n  f instanceof TestFile and category = \"test\"\n}\n\nfrom File f, string category\nwhere classify(f, category)\nselect f, category",
        "description": "This query produces a list of all files in a snapshot that are classified as generated code or test code. Used by LGTM.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/filters/ClassifyFiles.ql",
        "language": "csharp"
    },
    {
        "query": "import DefaultToStringQuery",
        "description": "Calling the default implementation of 'ToString' returns a value that is unlikely to be what you expect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Useless code/DefaultToString.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate emptyStmt(Stmt s) {\n  s instanceof EmptyStmt\n  or\n  s =\n    any(BlockStmt bs |\n      bs.getNumberOfStmts() = 0 and\n      not any(CommentBlock cb).getParent() = bs\n      or\n      bs.getNumberOfStmts() = 1 and\n      emptyStmt(bs.getStmt(0))\n    )\n}\n\nfrom IfStmt ifstmt\nwhere\n  emptyStmt(ifstmt.getThen()) and\n  (not exists(ifstmt.getElse()) or emptyStmt(ifstmt.getElse()))\nselect ifstmt, \"If-statement with an empty then-branch and no else-branch.\"",
        "description": "If-statement with an empty then-branch and no else-branch.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Useless code/FutileConditional.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom LabelStmt label\nwhere not exists(GotoLabelStmt goto | label = goto.getTarget())\nselect label, \"This label is not used.\"",
        "description": "An unused label serves no purpose and should be removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Useless code/UnusedLabel.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Strings\nimport semmle.code.csharp.frameworks.System\n\nfrom MethodCall mc\nwhere\n  mc instanceof ImplicitToStringExpr and\n  mc.getTarget() instanceof ToStringMethod\nselect mc, \"Redundant call to 'ToString' on a String object.\"",
        "description": "Explicit calls to `ToString()` can be removed when the call appears in a context where an implicit conversion exists.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Useless code/RedundantToStringCall.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom MethodCall mc, IntegralType t\nwhere\n  mc.getTarget() instanceof GetHashCodeMethod and\n  t = mc.getQualifier().getType() and\n  (\n    t instanceof ByteType or\n    t instanceof SByteType or\n    t instanceof ShortType or\n    t instanceof UShortType or\n    t instanceof IntType\n  )\nselect mc, \"Calling GetHashCode() on type \" + t.toStringWithTypes() + \" is redundant.\"",
        "description": "Calling 'GetHashCode()' on integer types is redundant because the method always returns the original value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Useless code/IntGetHashCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate methodInClass(ValueOrRefType t, Method m, string name) {\n  m.getDeclaringType() = t and\n  m.getName() = name\n}\n\npredicate callIn(MethodCall mc, Method fromMethod) { fromMethod = mc.getEnclosingCallable() }\n\npredicate callTo(MethodCall mc, Method toMethod) {\n  toMethod = mc.getTarget().getUnboundDeclaration()\n}\n\npredicate candidates(Method forwarder, Method forwardee) {\n  exists(ValueOrRefType t, string name |\n    methodInClass(t, forwarder, name) and methodInClass(t, forwardee, name)\n  |\n    not ignored(forwarder) and not ignored(forwardee) and forwarder != forwardee\n  )\n}\n\npredicate ignored(Method m) {\n  m.isAbstract() or\n  m.implements() or\n  m.isOverride() or\n  m.isVirtual() or\n  m.getName() = \"Dispose\" or\n  not m.fromSource()\n}\n\nfrom Method forwarder, Method forwardee\nwhere\n  not extractionIsStandalone() and\n  candidates(forwarder, forwardee) and\n  forex(MethodCall c | callTo(c, forwardee) | callIn(c, forwarder)) and\n  forex(MethodCall c | callIn(c, forwarder) | callTo(c, forwardee))\nselect forwarder.getUnboundDeclaration(),\n  \"This method is a forwarder for $@, which is not called independently - the methods can be merged.\",\n  forwardee.getUnboundDeclaration(), forwardee.getName()",
        "description": "A method forwards calls to another method of the same name that is not called independently.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Useless code/PointlessForwardingMethod.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Class c, Method m\nwhere\n  m.hasModifier(\"extern\") and\n  m.getDeclaringType() = c\nselect c, 1",
        "description": "Counts the number of \"extern\" methods, implemented by unmanaged code, per class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TUnmanagedCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t\nwhere t.isSourceDeclaration()\nselect t, t.getLackOfCohesionHS() as n order by n desc",
        "description": "Types that lack cohesion (as defined by Henderson-Sellers) often have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TLackOfCohesionHS.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  n = count(Field f | f.getDeclaringType() = t and not f instanceof EnumConstant)\nselect t, n order by n desc",
        "description": "Types with a large number of fields might have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TNumberOfFields.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  n =\n    count(Stmt s |\n      s.getEnclosingCallable().getDeclaringType() = t and\n      s != s.getEnclosingCallable().getAChild()\n    ) // we do not count the top-level block\nselect t, n order by n desc",
        "description": "Types with a large number of statements might be confusing and have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TNumberOfStatements.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  n =\n    count(Callable c | c.getDeclaringType() = t and not c instanceof Accessor) +\n      count(Accessor a |\n        a.getDeclaringType() = t and\n        not a.getDeclaration().(Property).isAutoImplemented() and\n        not a.getDeclaration().(Event).isFieldLike()\n      )\nselect t, n order by n desc",
        "description": "Types with a large number of methods might have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TNumberOfCallables.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom RefType t\nwhere t.isSourceDeclaration()\nselect t, t.getResponse() as n order by n desc",
        "description": "Classes with calls to a large number of different methods might be confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TResponse.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  n = count(Event e | e.getDeclaringType() = t)\nselect t, n order by n desc",
        "description": "Types with a large number of events might have too many responsibilities or the events might be too detailed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TNumberOfEvents.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  n =\n    count(Field f |\n      f.getDeclaringType() = t and\n      not f instanceof MemberConstant\n    )\nselect t, n order by n desc",
        "description": "Types with a large number of writable fields might have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TNumberOfNonConstFields.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t\nwhere t.isSourceDeclaration()\nselect t, t.getAfferentCoupling() as n order by n desc",
        "description": "A large number of incoming type dependencies make a type difficult to change.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TAfferentCoupling.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t\nwhere t.isSourceDeclaration()\nselect t, t.getEfferentCoupling() as n order by n desc",
        "description": "A large number of outgoing type dependencies make a type brittle.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TEfferentCoupling.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  n = count(Property p | p.getDeclaringType() = t)\nselect t, n order by n desc",
        "description": "Types with a large number of properties might have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TNumberOfProperties.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t\nwhere t.isSourceDeclaration()\nselect t, t.getInheritanceDepth() as n order by n desc",
        "description": "Types that are many levels deep in an inheritance hierarchy are difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TInheritanceDepth.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom RefType t\nwhere t.isSourceDeclaration()\nselect t, t.getSpecialisationIndex() as n order by n desc",
        "description": "Types that override a large percentage of their ancestors' methods indicate a poorly designed inheritance hierarchy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TSpecialisationIndex.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  t.isPublic() and\n  n =\n    count(Method m | m.getDeclaringType() = t and m.isPublic()) +\n      count(Operator o | o.getDeclaringType() = t and o.isPublic()) +\n      count(Property p | p.getDeclaringType() = t and p.isPublic()) +\n      count(Indexer i | i.getDeclaringType() = t and i.isPublic()) +\n      count(Event e | e.getDeclaringType() = t and e.isPublic())\nselect t, n order by n desc",
        "description": "Types with a large public API might be difficult to use and might have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TSizeOfAPI.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t\nwhere t.isSourceDeclaration()\nselect t, t.getLackOfCohesionCK() as n order by n desc",
        "description": "Types that lack cohesion (as defined by Chidamber and Kemerer) often have too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TLackOfCohesionCK.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType t, int n\nwhere\n  t.isSourceDeclaration() and\n  n = count(Indexer i | i.getDeclaringType() = t)\nselect t, n order by n desc",
        "description": "Multiple indexers for a single type might be confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/RefTypes/TNumberOfIndexers.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nbindingset[i]\nprivate float getCompilationTimeSum(int i) {\n  result = sum(float f | compilation_time(_, _, i, f) | f)\n}\n\nselect getCompilationTimeSum(0) as sum_frontend_cpu_seconds,\n  getCompilationTimeSum(1) as sum_frontend_elapsed_seconds,\n  getCompilationTimeSum(4) as sum_frontend_user_seconds,\n  getCompilationTimeSum(2) as sum_extractor_cpu_seconds,\n  getCompilationTimeSum(3) as sum_extractor_elapsed_seconds,\n  getCompilationTimeSum(5) as sum_extractor_user_seconds,\n  sum(float f | compilation_finished(_, f, _) | f) as sum_total_cpu_seconds,\n  sum(float f | compilation_finished(_, _, f) | f) as sum_total_elapsed_seconds,\n  getCompilationTimeSum(6) as sum_peak_working_set_mb,\n  max(float f | compilation_time(_, _, 6, f) | f) as max_peak_working_set_mb",
        "description": "This query is for internal use only and may change without notice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/internal/ExtractorDiagnostics.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.csharp.metrics.ExternalDependencies\n\nfrom File file, int num, string encodedDependency\nwhere externalDependencies(file, encodedDependency, num)\nselect encodedDependency, num order by num desc",
        "description": "Count the number of dependencies a C# source file has on assembly files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Dependencies/ExternalDependencies.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.csharp.metrics.ExternalDependencies\n\nfrom File file, int num, string encodedDependency\nwhere externalDependencies(file, encodedDependency, num)\nselect encodedDependency, file",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Dependencies/ExternalDependenciesSourceLinks.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate realParent(Stmt inner, Stmt outer) {\n  if skipParent(inner) then realParent(inner.getParent(), outer) else outer = inner.getParent()\n}\n\npredicate skipParent(Stmt s) {\n  exists(Stmt parent | parent = s.getParent() |\n    s instanceof IfStmt and parent.(IfStmt).getElse() = s\n    or\n    parent instanceof BlockStmt\n  )\n}\n\npredicate nestingDepth(Stmt s, int depth) {\n  depth = count(Stmt enclosing | realParent+(s, enclosing))\n}\n\nfrom Method m, int depth\nwhere\n  depth =\n    max(Stmt s, int aDepth | s.getEnclosingCallable() = m and nestingDepth(s, aDepth) | aDepth)\nselect m, depth order by depth",
        "description": "The maximum number of nested statements (eg. if, for, while ...). Blocks are not counted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Callables/StatementNestingDepth.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Callable c\nwhere c.isSourceDeclaration()\nselect c, c.getNumberOfLinesOfComments() as n order by n desc",
        "description": "Methods with few lines of comment might not have sufficient documentation to make them understandable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Callables/CLinesOfComment.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Callable f, int loc\nwhere f.isSourceDeclaration() and loc = f.getNumberOfLines() and loc > 0\nselect f, 100.0 * (f.getNumberOfLinesOfComments().(float) / loc.(float))",
        "description": "Methods where a small percentage of the lines are commented might not have sufficient documentation to make them understandable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Callables/CPercentageOfComments.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Callable c\nwhere c.isSourceDeclaration()\nselect c, c.getNumberOfLinesOfCode() as n order by n desc",
        "description": "Long methods are difficult to read and understand. This means it is also more difficult to find defects in them.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Callables/CLinesOfCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Callable c\nwhere c.isSourceDeclaration()\nselect c, c.getNumberOfParameters() as n order by n desc",
        "description": "Methods with lots of parameters are difficult to call correctly and might be taking on too many responsibilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Callables/CNumberOfParameters.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Callable c, int n\nwhere\n  c.isSourceDeclaration() and\n  n =\n    count(Stmt s |\n      s.getEnclosingCallable() = c and\n      s != c.getAChild() // we do not count the top-level block\n    )\nselect c, n order by n desc",
        "description": "Counts the number of statements nesting in each callable element (callables are methods, constructors, operators, accessors, ...).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Callables/CNumberOfStatements.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Callable c\nwhere c.isSourceDeclaration()\nselect c, c.getCyclomaticComplexity() as n order by n desc",
        "description": "Methods with a large number of possible execution paths might be difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Callables/CCyclomaticComplexity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.dataflow.internal.ExternalFlow\n\nfrom string namespaceAndType, int rows\nwhere\n  exists(string namespace, string type |\n    namespaceAndType = namespace + \";\" + type and\n    rows = strictsum(int n, string kind | modelCoverage(namespace, _, kind, type, n) | n)\n  )\nselect namespaceAndType, rows",
        "description": "Expose metrics for the number of API endpoints covered by CSV models.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Summaries/FrameworkCoverage.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nselect sum(File f | f.fromSource() | f.getNumberOfLinesOfCode())",
        "description": "The total number of lines of code across all files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Summaries/LinesOfCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f\nselect f, f.getNumberOfLines() as n order by n desc",
        "description": "The number of lines in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FLines.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f, int n\nwhere n = count(Struct s | s.getFile() = f and s.isSourceDeclaration())\nselect f, n order by n desc",
        "description": "Files with a large number of structs are difficult to read. Additionally the structure of the project is not reflected in the file system.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FNumberOfStructs.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f, int total, float ratio\nwhere\n  total = f.getNumberOfLinesOfCode() + f.getNumberOfLinesOfComments() and\n  if total = 0\n  then ratio = 0.0\n  else ratio = 100.0 * f.getNumberOfLinesOfComments().(float) / total.(float)\nselect f, ratio order by ratio desc",
        "description": "The percentage of lines in the code base that contain comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FCommentRatio.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f, int n\nwhere n = count(Interface i | i.getFile() = f and i.isSourceDeclaration())\nselect f, n order by n desc",
        "description": "Files with more than one interface might cause problems when changed because the interfaces are poorly compartmentalized.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FNumberOfInterfaces.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f\nselect f, f.getNumberOfLinesOfComments() as n order by n desc",
        "description": "Files with few lines of comment might not have sufficient documentation to make them understandable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FLinesOfComment.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.metrics.Coupling\n\n// Self-containedness on file level\nfrom File f, float selfContaindness, int efferentSourceCoupling, int efferentCoupling\nwhere\n  efferentSourceCoupling =\n    count(File g |\n      exists(RefType c |\n        c.fromSource() and\n        c.getFile() = g and\n        exists(RefType d | d.fromSource() and d.getFile() = f and depends(d, c))\n      )\n    ) and\n  efferentCoupling =\n    count(File g |\n      exists(RefType c |\n        c.getFile() = g and\n        exists(RefType d | d.fromSource() and d.getFile() = f and depends(d, c))\n      )\n    ) and\n  if efferentCoupling = 0\n  then selfContaindness = 100\n  else selfContaindness = 100 * efferentSourceCoupling.(float) / efferentCoupling\nselect f, selfContaindness order by selfContaindness desc",
        "description": "Files that do not include source code for most of the types that they depend on are difficult to port to new platforms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FSelfContainedness.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f, int n\nwhere n = count(Class c | c.getFile() = f and c.isSourceDeclaration())\nselect f, n order by n desc",
        "description": "Files with a large number of classes are difficult to read. Additionally the structure of the project is not reflected in the file system.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FNumberOfClasses.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom File f\nselect f, f.getNumberOfLinesOfCode() as n order by n desc",
        "description": "Files with a large number of lines might be difficult to understand and increase the chance of merge conflicts.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FLinesOfCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.Test\n\nfrom SourceFile f, int n\nwhere n = strictcount(TestMethod test | test.fromSource() and test.getFile() = f)\nselect f, n order by n desc",
        "description": "The number of test methods defined in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FNumberOfTests.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f, int n\nwhere n = count(UsingNamespaceDirective u | u.getFile() = f)\nselect f, n order by n desc",
        "description": "Files that use a large number of other namespaces might be brittle.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FNumberOfUsingNamespaces.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom File f, float n\nwhere n = avg(Callable c | c.getFile() = f | c.getCyclomaticComplexity())\nselect f, n",
        "description": "Files with a large number of possible execution paths might be difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FCyclomaticComplexity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SourceFile f, int n\nwhere\n  n =\n    count(CommentLine line |\n      exists(CommentBlock block |\n        block.getLocation().getFile() = f and\n        line = block.getAProbableCodeLine()\n      )\n    )\nselect f, n order by n desc",
        "description": "The number of lines of commented-out code in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Metrics/Files/FLinesOfCommentedCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\ndeprecated import RequestForgery::RequestForgery\ndeprecated import RequestForgeryFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, RequestForgeryFlow::PathNode source, RequestForgeryFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  RequestForgeryFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"The URL of this request depends on a $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "Making a network request with user-controlled data in the URL allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/CWE-918/RequestForgery.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate isCreatingAzureClientSideEncryptionObject(ObjectCreation oc, Class c, Expr e) {\n  exists(Parameter p | p.hasName(\"version\") |\n    c.hasFullyQualifiedName(\"Azure.Storage\", \"ClientSideEncryptionOptions\") and\n    oc.getTarget() = c.getAConstructor() and\n    e = oc.getArgumentForParameter(p)\n  )\n}\n\npredicate isCreatingOutdatedAzureClientSideEncryptionObject(ObjectCreation oc, Class c) {\n  c.hasFullyQualifiedName(\"Microsoft.Azure.Storage.Blob\", \"BlobEncryptionPolicy\") and\n  oc.getTarget() = c.getAConstructor()\n}\n\npredicate doesAzureStorageAssemblySupportSafeClientSideEncryption(Assembly asm) {\n  exists(int versionCompare |\n    versionCompare = asm.getVersion().compareTo(\"12.12.0.0\") and\n    versionCompare >= 0\n  ) and\n  asm.getName() = \"Azure.Storage.Common\"\n}\n\npredicate isObjectCreationArgumentSafeAndUsingSafeVersionOfAssembly(Expr versionExpr, Assembly asm) {\n  // Check if the Azure.Storage assembly version has the fix\n  doesAzureStorageAssemblySupportSafeClientSideEncryption(asm) and\n  // and that the version argument for the constructor is guaranteed to be Version2\n  isExprAnAccessToSafeClientSideEncryptionVersionValue(versionExpr)\n}\n\npredicate isExprAnAccessToSafeClientSideEncryptionVersionValue(Expr e) {\n  exists(EnumConstant ec |\n    ec.hasFullyQualifiedName(\"Azure.Storage.ClientSideEncryptionVersion\", \"V2_0\") and\n    ec.getAnAccess() = e\n  )\n}\n\ndeprecated query predicate problems(Expr e, string message) {\n  exists(Class c, Assembly asm | asm = c.getLocation() |\n    exists(Expr e2 |\n      isCreatingAzureClientSideEncryptionObject(e, c, e2) and\n      not isObjectCreationArgumentSafeAndUsingSafeVersionOfAssembly(e2, asm)\n    )\n    or\n    isCreatingOutdatedAzureClientSideEncryptionObject(e, c)\n  ) and\n  message = \"Unsafe usage of v1 version of Azure Storage client-side encryption.\"\n}",
        "description": "Unsafe usage of v1 version of Azure Storage client-side encryption, please refer to http://aka.ms/azstorageclientencryptionblog",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/CWE-327/Azure/UnsafeUsageOfClientSideEncryptionVersion.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\ndeprecated import JsonWebTokenHandlerLib\nimport semmle.code.csharp.commons.QualifiedName\n\ndeprecated query predicate problems(\n  DataFlow::Node sink, string message, TokenValidationParametersPropertySensitiveValidation pw,\n  string fullyQualifiedName, DataFlow::Node source, string value\n) {\n  FalseValueFlowsToTokenValidationParametersPropertyWriteToBypassValidation::flow(source, sink) and\n  sink.asExpr() = pw.getAnAssignedValue() and\n  exists(string qualifier, string name | pw.hasFullyQualifiedName(qualifier, name) |\n    fullyQualifiedName = getQualifiedName(qualifier, name)\n  ) and\n  message = \"The security sensitive property $@ is being disabled by the following value: $@.\" and\n  value = \"false\"\n}",
        "description": "Check if security sensitive token validations for `JsonWebTokenHandler` are being disabled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/JsonWebTokenHandler/security-validation-disabled.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport DataFlow\ndeprecated import JsonWebTokenHandlerLib\nimport semmle.code.csharp.commons.QualifiedName\n\ndeprecated query predicate problems(\n  CallableAlwaysReturnsTrue e, string message, TokenValidationParametersProperty p,\n  string fullyQualifiedName\n) {\n  exists(string qualifier, string name | p.hasFullyQualifiedName(qualifier, name) |\n    fullyQualifiedName = getQualifiedName(qualifier, name)\n  ) and\n  e = p.getAnAssignedValue() and\n  message =\n    \"JsonWebTokenHandler security-sensitive property $@ is being delegated to this callable that always returns \\\"true\\\".\"\n}",
        "description": "Security sensitive validations for `JsonWebTokenHandler` are being delegated to a function that seems to always return true. Higher precision version checks for exception throws, so less false positives are expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/JsonWebTokenHandler/delegated-security-validations-always-return-true.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.runtime.InteropServices\n\npredicate isDangerousMethod(Method m) {\n  m.getName() = \"OpenProcessToken\" or\n  m.getName() = \"OpenThreadToken\" or\n  m.getName() = \"DuplicateToken\" or\n  m.getName() = \"DuplicateTokenEx\" or\n  m.getName().matches(\"LogonUser%\") or\n  m.getName().matches(\"WNetAddConnection%\") or\n  m.getName() = \"DeviceIoControl\" or\n  m.getName().matches(\"LoadLibrary%\") or\n  m.getName() = \"GetProcAddress\" or\n  m.getName().matches(\"CreateProcess%\") or\n  m.getName().matches(\"InitiateSystemShutdown%\") or\n  m.getName() = \"GetCurrentProcess\" or\n  m.getName() = \"GetCurrentProcessToken\" or\n  m.getName() = \"GetCurrentThreadToken\" or\n  m.getName() = \"GetCurrentThreadEffectiveToken\" or\n  m.getName() = \"OpenThreadToken\" or\n  m.getName() = \"SetTokenInformation\" or\n  m.getName().matches(\"LookupPrivilegeValue%\") or\n  m.getName() = \"AdjustTokenPrivileges\" or\n  m.getName() = \"SetProcessPrivilege\" or\n  m.getName() = \"ImpersonateLoggedOnUser\" or\n  m.getName().matches(\"Add%Ace%\")\n}\n\npredicate isExternMethod(Method externMethod) {\n  externMethod.isExtern()\n  or\n  externMethod.getAnAttribute().getType() instanceof\n    SystemRuntimeInteropServicesDllImportAttributeClass\n  or\n  externMethod.getDeclaringType().getAnAttribute().getType() instanceof\n    SystemRuntimeInteropServicesComImportAttributeClass\n}\n\ndeprecated query predicate problems(MethodCall mc, string message) {\n  isExternMethod(mc.getTarget()) and\n  isDangerousMethod(mc.getTarget()) and\n  message = \"Call to an external method '\" + mc.getTarget().getName() + \"'.\"\n}",
        "description": "Detects the use of native functions that can be used for malicious intent or unsafe handling.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/backdoor/DangerousNativeFunctionCall.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport experimental.code.csharp.Cryptography.NonCryptographicHashes\nimport DataFlowFromMethodToHash::PathGraph\n\nmodule DataFlowFromMethodToHashConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSuspiciousPropertyName(source.asExpr()) }\n\n  predicate isSink(DataFlow::Node sink) { isGetHash(sink.asExpr()) }\n}\n\nmodule DataFlowFromMethodToHash = TaintTracking::Global<DataFlowFromMethodToHashConfig>;\n\npredicate isGetHash(Expr arg) {\n  exists(MethodCall mc |\n    (\n      mc.getTarget().getName().matches(\"%Hash%\") or\n      mc.getTarget().getName().regexpMatch(\"Md[4-5]|Sha[1-9]{1,3}\")\n    ) and\n    mc.getAnArgument() = arg\n  )\n  or\n  exists(Callable callable, Parameter param, Call call |\n    isCallableAPotentialNonCryptographicHashFunction(callable, param) and\n    call = callable.getACall() and\n    arg = call.getArgumentForParameter(param)\n  )\n}\n\npredicate isSuspiciousPropertyName(PropertyRead pr) {\n  pr.getTarget().hasFullyQualifiedName(\"System.Diagnostics\", \"Process\", \"ProcessName\")\n}\n\ndeprecated query predicate problems(\n  DataFlow::Node srcNode, DataFlowFromMethodToHash::PathNode src,\n  DataFlowFromMethodToHash::PathNode sink, string message, DataFlow::Node sinkNode,\n  string sinkMessage\n) {\n  srcNode = src.getNode() and\n  sinkNode = sink.getNode() and\n  DataFlowFromMethodToHash::flow(srcNode, sinkNode) and\n  message =\n    \"The hash is calculated on $@, may be related to a backdoor. Please review the code for possible malicious intent.\" and\n  sinkMessage = \"this process name\"\n}",
        "description": "Flow from a function retrieving process name to a hash function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/backdoor/ProcessNameToHashTaintFlow.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Flow::PathGraph\n\nquery predicate edges(Flow::PathNode a, Flow::PathNode b, string key, string val) {\n  Flow::PathGraph::edges(a, b, key, val)\n  or\n  FlowsFromGetLastWriteTimeConfigToTimeSpanArithmeticCallableConfig::isSink(a.getNode()) and\n  FlowsFromTimeSpanArithmeticToTimeComparisonCallableConfig::isSource(b.getNode()) and\n  key = \"provenance\" and\n  val = \"\"\n  or\n  FlowsFromTimeSpanArithmeticToTimeComparisonCallableConfig::isSink(a.getNode()) and\n  FlowsFromTimeComparisonCallableToSelectionStatementConditionConfig::isSource(b.getNode()) and\n  key = \"provenance\" and\n  val = \"\"\n}\n\nclass GetLastWriteTimeMethod extends Method {\n  GetLastWriteTimeMethod() {\n    this.hasFullyQualifiedName(\"System.IO.File\",\n      [\"GetLastWriteTime\", \"GetFileCreationTime\", \"GetCreationTimeUtc\", \"GetLastAccessTimeUtc\"])\n  }\n}\n\nclass DateTimeStruct extends Struct {\n  DateTimeStruct() { this.hasFullyQualifiedName(\"System\", \"DateTime\") }\n\n  /**\n   * holds if the Callable is used for DateTime arithmetic operations\n   */\n  Callable getATimeSpanArithmeticCallable() {\n    (result = this.getAnOperator() or result = this.getAMethod()) and\n    result.getName() in [\n        \"Add\", \"AddDays\", \"AddHours\", \"AddMilliseconds\", \"AddMinutes\", \"AddMonths\", \"AddSeconds\",\n        \"AddTicks\", \"AddYears\", \"+\", \"-\"\n      ]\n  }\n\n  /**\n   * Holds if the Callable is used for DateTime comparison\n   */\n  Callable getAComparisonCallable() {\n    (result = this.getAnOperator() or result = this.getAMethod()) and\n    result.getName() in [\"Compare\", \"CompareTo\", \"Equals\", \"==\", \"!=\", \"<\", \">\", \"<=\", \">=\"]\n  }\n}\n\nprivate module FlowsFromGetLastWriteTimeConfigToTimeSpanArithmeticCallableConfig implements\n  DataFlow::ConfigSig\n{\n  predicate isSource(DataFlow::Node source) {\n    exists(Call call, GetLastWriteTimeMethod m |\n      m.getACall() = call and\n      source.asExpr() = call\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(Call call, DateTimeStruct dateTime |\n      call.getAChild*() = sink.asExpr() and\n      call = dateTime.getATimeSpanArithmeticCallable().getACall()\n    )\n  }\n}\n\nprivate module FlowsFromGetLastWriteTimeConfigToTimeSpanArithmeticCallable =\n  TaintTracking::Global<FlowsFromGetLastWriteTimeConfigToTimeSpanArithmeticCallableConfig>;\n\nprivate module FlowsFromTimeSpanArithmeticToTimeComparisonCallableConfig implements\n  DataFlow::ConfigSig\n{\n  predicate isSource(DataFlow::Node source) {\n    exists(DateTimeStruct dateTime, Call call | source.asExpr() = call |\n      call = dateTime.getATimeSpanArithmeticCallable().getACall()\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(Call call, DateTimeStruct dateTime |\n      call.getAnArgument().getAChild*() = sink.asExpr() and\n      call = dateTime.getAComparisonCallable().getACall()\n    )\n  }\n}\n\nprivate module FlowsFromTimeSpanArithmeticToTimeComparisonCallable =\n  TaintTracking::Global<FlowsFromTimeSpanArithmeticToTimeComparisonCallableConfig>;\n\nprivate module FlowsFromTimeComparisonCallableToSelectionStatementConditionConfig implements\n  DataFlow::ConfigSig\n{\n  predicate isSource(DataFlow::Node source) {\n    exists(DateTimeStruct dateTime, Call call | source.asExpr() = call |\n      call = dateTime.getAComparisonCallable().getACall()\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(SelectionStmt sel | sel.getCondition().getAChild*() = sink.asExpr())\n  }\n}\n\nprivate module FlowsFromTimeComparisonCallableToSelectionStatementCondition =\n  TaintTracking::Global<FlowsFromTimeComparisonCallableToSelectionStatementConditionConfig>;\n\nprivate module Flow =\n  DataFlow::MergePathGraph3<FlowsFromGetLastWriteTimeConfigToTimeSpanArithmeticCallable::PathNode,\n    FlowsFromTimeSpanArithmeticToTimeComparisonCallable::PathNode,\n    FlowsFromTimeComparisonCallableToSelectionStatementCondition::PathNode,\n    FlowsFromGetLastWriteTimeConfigToTimeSpanArithmeticCallable::PathGraph,\n    FlowsFromTimeSpanArithmeticToTimeComparisonCallable::PathGraph,\n    FlowsFromTimeComparisonCallableToSelectionStatementCondition::PathGraph>;\n\npredicate isPotentialTimeBomb(\n  Flow::PathNode pathSource, Flow::PathNode pathSink, Call getLastWriteTimeMethodCall,\n  Call timeArithmeticCall, Call timeComparisonCall, SelectionStmt selStatement\n) {\n  exists(DataFlow::Node sink, DateTimeStruct dateTime, DataFlow::Node sink2, DataFlow::Node sink3 |\n    pathSource.getNode() = DataFlow::exprNode(getLastWriteTimeMethodCall) and\n    FlowsFromGetLastWriteTimeConfigToTimeSpanArithmeticCallable::flow(DataFlow::exprNode(getLastWriteTimeMethodCall),\n      sink) and\n    timeArithmeticCall = dateTime.getATimeSpanArithmeticCallable().getACall() and\n    timeArithmeticCall.getAChild*() = sink.asExpr() and\n    FlowsFromTimeSpanArithmeticToTimeComparisonCallable::flow(DataFlow::exprNode(timeArithmeticCall),\n      sink2) and\n    timeComparisonCall = dateTime.getAComparisonCallable().getACall() and\n    timeComparisonCall.getAnArgument().getAChild*() = sink2.asExpr() and\n    FlowsFromTimeComparisonCallableToSelectionStatementCondition::flow(DataFlow::exprNode(timeComparisonCall),\n      sink3) and\n    selStatement.getCondition().getAChild*() = sink3.asExpr() and\n    pathSink.getNode() = sink3\n  )\n}\n\ndeprecated query predicate problems(\n  SelectionStmt selStatement, Flow::PathNode source, Flow::PathNode sink, string message,\n  Call timeComparisonCall, string timeComparisonCallString, Call timeArithmeticCall, string offset,\n  Call getLastWriteTimeMethodCall, string lastWriteTimeMethodCallMessage\n) {\n  isPotentialTimeBomb(source, sink, getLastWriteTimeMethodCall, timeArithmeticCall,\n    timeComparisonCall, selStatement) and\n  message =\n    \"Possible TimeBomb logic triggered by an $@ that takes into account $@ from the $@ as part of the potential trigger.\" and\n  timeComparisonCallString = timeComparisonCall.toString() and\n  offset = \"offset\" and\n  lastWriteTimeMethodCallMessage = \"last modification time of a file\"\n}",
        "description": "If there is data flow from a file's last modification date and an offset to a condition statement, this could trigger a \"time bomb\".",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/backdoor/PotentialTimeBomb.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.Collections\nimport HashWithoutSalt::PathGraph\n\nclass HashAlgorithmProvider extends RefType {\n  HashAlgorithmProvider() {\n    this.hasFullyQualifiedName(\"Windows.Security.Cryptography.Core\", \"HashAlgorithmProvider\")\n  }\n}\n\nclass HashAlgorithm extends RefType {\n  HashAlgorithm() { this.hasFullyQualifiedName(\"System.Security.Cryptography\", \"HashAlgorithm\") }\n}\n\nclass KeyedHashAlgorithm extends RefType {\n  KeyedHashAlgorithm() {\n    this.hasFullyQualifiedName(\"System.Security.Cryptography\", \"KeyedHashAlgorithm\")\n  }\n}\n\nclass HashMethod extends Method {\n  HashMethod() {\n    this.getDeclaringType().getABaseType*() instanceof HashAlgorithm and\n    this.getName().matches([\"%ComputeHash%\", \"%HashData\"])\n    or\n    this.getDeclaringType().getABaseType*() instanceof HashAlgorithmProvider and\n    this.hasName(\"HashData\")\n  }\n}\n\nstring getPasswordRegex() { result = \"(?i)pass(wd|word|code|phrase)\" }\n\nclass PasswordVarExpr extends Expr {\n  PasswordVarExpr() {\n    exists(Variable v | this = v.getAnAccess() | v.getName().regexpMatch(getPasswordRegex()))\n  }\n}\n\npredicate isHashCall(MethodCall mc) {\n  mc.getTarget() instanceof HashMethod\n  or\n  exists(MethodCall mcc |\n    mc.getTarget().calls(mcc.getTarget()) and\n    isHashCall(mcc) and\n    DataFlow::localExprFlow(mc.getTarget().getAParameter().getAnAccess(), mcc.getAnArgument())\n  )\n}\n\npredicate hasAnotherHashCall(MethodCall mc) {\n  exists(MethodCall mc2, DataFlow::Node src, DataFlow::Node sink |\n    isHashCall(mc2) and\n    mc2 != mc and\n    (\n      src.asExpr() = mc.getQualifier() or\n      src.asExpr() = mc.getAnArgument() or\n      src.asExpr() = mc\n    ) and\n    (\n      sink.asExpr() = mc2.getQualifier() or\n      sink.asExpr() = mc2.getAnArgument()\n    ) and\n    DataFlow::localFlow(src, sink)\n  )\n}\n\npredicate hasFurtherProcessing(MethodCall mc) {\n  exists(Method m | m = mc.getTarget() and m.fromLibrary() |\n    m.hasFullyQualifiedName(\"System\", \"Array\", \"Copy\") // Array.Copy(passwordHash, 0, password.Length), 0, key, 0, keyLen);\n    or\n    m.hasFullyQualifiedName(\"System\", \"String\", \"Concat\") // string.Concat(passwordHash, saltkey)\n    or\n    m.hasFullyQualifiedName(\"System\", \"Buffer\", \"BlockCopy\") // Buffer.BlockCopy(passwordHash, 0, allBytes, 0, 20)\n    or\n    m.hasFullyQualifiedName(\"System\", \"String\", \"Format\") // String.Format(\"{0}:{1}:{2}\", username, salt, password)\n    or\n    m.getName() = \"CopyTo\" and\n    m.getDeclaringType().getABaseType*() instanceof SystemCollectionsICollectionInterface // passBytes.CopyTo(rawSalted, 0);\n  )\n}\n\npredicate hasHashAncestor(MethodCall mc) {\n  exists(MethodCall mpc |\n    mpc.getTarget().calls(mc.getTarget()) and\n    isHashCall(mpc) and\n    DataFlow::localExprFlow(mpc.getTarget().getAParameter().getAnAccess(), mc.getAnArgument())\n  )\n}\n\nmodule HashWithoutSaltConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.asExpr() instanceof PasswordVarExpr }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall mc |\n      sink.asExpr() = mc.getArgument(0) and\n      isHashCall(mc) and\n      not hasAnotherHashCall(mc) and\n      not hasHashAncestor(mc) and\n      not exists(MethodCall mmc |\n        hasFurtherProcessing(mmc) and\n        DataFlow::localExprFlow(mc, mmc.getAnArgument())\n      ) and\n      not exists(Call c |\n        (\n          c.getTarget().getDeclaringType().getABaseType*() instanceof HashAlgorithm or\n          c.getTarget()\n              .getDeclaringType()\n              .getABaseType*()\n              .hasFullyQualifiedName(\"System.Security.Cryptography\", \"DeriveBytes\")\n        ) and\n        DataFlow::localExprFlow(mc, c.getAnArgument())\n      )\n    )\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(MethodCall mc |\n      mc.getTarget()\n          .hasFullyQualifiedName(\"Windows.Security.Cryptography\", \"CryptographicBuffer\",\n            \"ConvertStringToBinary\") and\n      mc.getArgument(0) = node1.asExpr() and\n      mc = node2.asExpr()\n    )\n  }\n\n  /**\n   * Holds if a password is concatenated with a salt then hashed together through calls such as `System.Array.CopyTo()`, for example,\n   *  `byte[] rawSalted  = new byte[passBytes.Length + salt.Length];`\n   *  `passBytes.CopyTo(rawSalted, 0);`\n   *  `salt.CopyTo(rawSalted, passBytes.Length);`\n   *  `byte[] saltedPassword = sha256.ComputeHash(rawSalted);`\n   *  Or the password is concatenated with a salt as a string.\n   */\n  predicate isBarrier(DataFlow::Node node) {\n    exists(MethodCall mc |\n      hasFurtherProcessing(mc) and\n      mc.getAnArgument() = node.asExpr()\n    )\n    or\n    exists(AddExpr e | node.asExpr() = e.getAnOperand()) // password+salt\n    or\n    exists(InterpolatedStringExpr e | node.asExpr() = e.getAnInsert())\n    or\n    exists(Call c |\n      c.getTarget()\n          .getDeclaringType()\n          .getABaseType*()\n          .hasFullyQualifiedName(\"System.Security.Cryptography\", \"DeriveBytes\")\n    )\n    or\n    // a salt or key is included in subclasses of `KeyedHashAlgorithm`\n    exists(MethodCall mc, Assignment a, ObjectCreation oc |\n      a.getRValue() = oc and\n      oc.getObjectType().getABaseType+() instanceof KeyedHashAlgorithm and\n      mc.getTarget() instanceof HashMethod and\n      a.getLValue() = mc.getQualifier().(VariableAccess).getTarget().getAnAccess() and\n      mc.getArgument(0) = node.asExpr()\n    )\n  }\n}\n\nmodule HashWithoutSalt = TaintTracking::Global<HashWithoutSaltConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, HashWithoutSalt::PathNode source, HashWithoutSalt::PathNode sink,\n  string message, DataFlow::Node sourceNode, string password\n) {\n  sinkNode = sink.getNode() and\n  sourceNode = source.getNode() and\n  HashWithoutSalt::flowPath(source, sink) and\n  message = \"$@ is hashed without a salt.\" and\n  password = \"The password\"\n}",
        "description": "Hashed passwords without a salt are vulnerable to dictionary attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/CWE-759/HashWithoutSalt.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\ndeprecated import DataSetSerialization\n\npredicate xmlSerializerConstructorArgument(Expr e) {\n  exists(ObjectCreation oc, Constructor c | e = oc.getArgument(0) |\n    c = oc.getTarget() and\n    c.getDeclaringType()\n        .getABaseType*()\n        .hasFullyQualifiedName(\"System.Xml.Serialization\", \"XmlSerializer\")\n  )\n}\n\ndeprecated predicate unsafeDataContractTypeCreation(Expr e) {\n  exists(MethodCall gt |\n    gt.getTarget().getName() = \"GetType\" and\n    e = gt and\n    gt.getQualifier().getType() instanceof DataSetOrTableRelatedClass\n  )\n  or\n  e.(TypeofExpr).getTypeAccess().getTarget() instanceof DataSetOrTableRelatedClass\n}\n\ndeprecated module FlowToDataSerializerConstructorConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { unsafeDataContractTypeCreation(node.asExpr()) }\n\n  predicate isSink(DataFlow::Node node) { xmlSerializerConstructorArgument(node.asExpr()) }\n}\n\ndeprecated module FlowToDataSerializerConstructor =\n  DataFlow::Global<FlowToDataSerializerConstructorConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sink, string message, DataFlow::Node source, string sourceMessage\n) {\n  FlowToDataSerializerConstructor::flow(source, sink) and\n  message =\n    \"Unsafe type is used in data contract serializer. Make sure $@ comes from the trusted source.\" and\n  sourceMessage = source.toString()\n}",
        "description": "Unsafe type is used in data contract serializer. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\"",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/Serialization/UnsafeTypeUsedDataContractSerializer.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\ndeprecated import DataSetSerialization\n\ndeprecated query predicate problems(UnsafeXmlReadMethodCall mc, string message) {\n  message =\n    \"Making an XML deserialization call with a type derived from DataSet or DataTable types and may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\" and\n  exists(mc)\n}",
        "description": "Making an XML deserialization call with a type derived from DataSet or DataTable types and may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\"",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/Serialization/XmlDeserializationWithDataSet.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\ndeprecated import DataSetSerialization\n\ndeprecated query predicate problems(DataSetOrTableRelatedClass dstc, string message) {\n  dstc.fromSource() and\n  message =\n    \"Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\"\n}",
        "description": "Defining a class that inherits or has a property derived from the obsolete DataSet or DataTable types may lead to the usage of dangerous functionality. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/Serialization/DefiningDatasetRelatedType.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\ndeprecated import DataSetSerialization\n\ndeprecated query predicate problems(\n  Member m, string message, UnsafeXmlSerializerImplementation c, string classMessage, Member member,\n  string memberMessage\n) {\n  c.fromSource() and\n  isClassUnsafeXmlSerializerImplementation(c, m) and\n  message =\n    \"Defining an serializable class $@ that has member $@ of a type that is derived from DataSet or DataTable types and may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.\" and\n  classMessage = c.toString() and\n  member = m and\n  memberMessage = m.toString()\n}",
        "description": "Defining an XML serializable class that includes members that derive from DataSet or DataTable type may lead to a security problem. Please visit https://go.microsoft.com/fwlink/?linkid=2132227 for details.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/Serialization/DefiningPotentiallyUnsafeXmlSerializer.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\nimport semmle.code.csharp.frameworks.system.Web\nimport semmle.code.csharp.frameworks.microsoft.AspNetCore\ndeprecated import experimental.dataflow.flowsources.AuthCookie\n\ndeprecated query predicate problems(Expr secureSink, string message) {\n  (\n    exists(Call c |\n      secureSink = c and\n      (\n        // default is not configured or is not set to `Always` or `SameAsRequest`\n        not (\n          getAValueForCookiePolicyProp(\"Secure\").getValue() = \"0\" or\n          getAValueForCookiePolicyProp(\"Secure\").getValue() = \"1\"\n        ) and\n        // there is no callback `OnAppendCookie` that sets `Secure` to true\n        not OnAppendCookieSecureTracking::flowTo(_) and\n        (\n          // `Secure` property in `CookieOptions` passed to IResponseCookies.Append(...) wasn't set\n          exists(ObjectCreation oc |\n            oc = c and\n            oc.getType() instanceof MicrosoftAspNetCoreHttpCookieOptions and\n            not isPropertySet(oc, \"Secure\") and\n            exists(DataFlow::Node creation |\n              CookieOptionsTracking::flow(creation, _) and\n              creation.asExpr() = oc\n            )\n          )\n          or\n          // IResponseCookies.Append(String, String) was called, `Secure` is set to `false` by default\n          exists(MethodCall mc, MicrosoftAspNetCoreHttpResponseCookies iResponse |\n            mc = c and\n            iResponse.getAppendMethod() = mc.getTarget() and\n            mc.getNumberOfArguments() < 3\n          )\n        )\n        or\n        exists(ObjectCreation oc |\n          oc = c and\n          oc.getType() instanceof SystemWebHttpCookie and\n          // the property wasn't explicitly set, so a default value from config is used\n          not isPropertySet(oc, \"Secure\") and\n          // the default in config is not set to `true`\n          // the `exists` below covers the `cs/web/requiressl-not-set`\n          not exists(XmlElement element |\n            element instanceof FormsElement and\n            element.(FormsElement).isRequireSsl()\n            or\n            element instanceof HttpCookiesElement and\n            element.(HttpCookiesElement).isRequireSsl()\n          )\n        )\n      )\n    )\n    or\n    exists(Assignment a, Expr val |\n      secureSink = a.getRValue() and\n      (\n        exists(ObjectCreation oc |\n          getAValueForProp(oc, a, \"Secure\") = val and\n          val.getValue() = \"false\" and\n          (\n            oc.getType() instanceof SystemWebHttpCookie\n            or\n            oc.getType() instanceof MicrosoftAspNetCoreHttpCookieOptions and\n            // there is no callback `OnAppendCookie` that sets `Secure` to true\n            not OnAppendCookieSecureTracking::flowTo(_) and\n            // the cookie option is passed to `Append`\n            exists(DataFlow::Node creation |\n              CookieOptionsTracking::flow(creation, _) and\n              creation.asExpr() = oc\n            )\n          )\n        )\n        or\n        exists(PropertyWrite pw |\n          (\n            pw.getProperty().getDeclaringType() instanceof MicrosoftAspNetCoreHttpCookieBuilder or\n            pw.getProperty().getDeclaringType() instanceof\n              MicrosoftAspNetCoreAuthenticationCookiesCookieAuthenticationOptions\n          ) and\n          pw.getProperty().getName() = \"SecurePolicy\" and\n          a.getLValue() = pw and\n          DataFlow::localExprFlow(val, a.getRValue()) and\n          val.getValue() = \"2\" // None\n        )\n      )\n    )\n  ) and\n  message = \"Cookie attribute 'Secure' is not set to true.\"\n}",
        "description": "Omitting the 'Secure' attribute allows data to be transmitted insecurely using HTTP. Always set 'Secure' to 'true' to ensure that HTTPS is used at all times.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/CWE-614/CookieWithoutSecure.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\nimport semmle.code.csharp.frameworks.system.Web\nimport semmle.code.csharp.frameworks.microsoft.AspNetCore\ndeprecated import experimental.dataflow.flowsources.AuthCookie\n\ndeprecated query predicate problems(Expr httpOnlySink, string message) {\n  (\n    exists(Assignment a, Expr val |\n      httpOnlySink = a.getRValue() and\n      val.getValue() = \"false\" and\n      (\n        exists(ObjectCreation oc |\n          getAValueForProp(oc, a, \"HttpOnly\") = val and\n          (\n            oc.getType() instanceof SystemWebHttpCookie and\n            isCookieWithSensitiveName(oc.getArgument(0))\n            or\n            exists(MethodCall mc, MicrosoftAspNetCoreHttpResponseCookies iResponse |\n              oc.getType() instanceof MicrosoftAspNetCoreHttpCookieOptions and\n              iResponse.getAppendMethod() = mc.getTarget() and\n              isCookieWithSensitiveName(mc.getArgument(0)) and\n              // there is no callback `OnAppendCookie` that sets `HttpOnly` to true\n              not OnAppendCookieHttpOnlyTracking::flowTo(_) and\n              // Passed as third argument to `IResponseCookies.Append`\n              exists(DataFlow::Node creation, DataFlow::Node append |\n                CookieOptionsTracking::flow(creation, append) and\n                creation.asExpr() = oc and\n                append.asExpr() = mc.getArgument(2)\n              )\n            )\n          )\n        )\n        or\n        exists(PropertyWrite pw |\n          (\n            pw.getProperty().getDeclaringType() instanceof MicrosoftAspNetCoreHttpCookieBuilder or\n            pw.getProperty().getDeclaringType() instanceof\n              MicrosoftAspNetCoreAuthenticationCookiesCookieAuthenticationOptions\n          ) and\n          pw.getProperty().getName() = \"HttpOnly\" and\n          a.getLValue() = pw and\n          DataFlow::localExprFlow(val, a.getRValue())\n        )\n      )\n    )\n    or\n    exists(Call c |\n      httpOnlySink = c and\n      (\n        exists(MicrosoftAspNetCoreHttpResponseCookies iResponse, MethodCall mc |\n          // default is not configured or is not set to `Always`\n          not getAValueForCookiePolicyProp(\"HttpOnly\").getValue() = \"1\" and\n          // there is no callback `OnAppendCookie` that sets `HttpOnly` to true\n          not OnAppendCookieHttpOnlyTracking::flowTo(_) and\n          iResponse.getAppendMethod() = mc.getTarget() and\n          isCookieWithSensitiveName(mc.getArgument(0)) and\n          (\n            // `HttpOnly` property in `CookieOptions` passed to IResponseCookies.Append(...) wasn't set\n            exists(ObjectCreation oc |\n              oc = c and\n              oc.getType() instanceof MicrosoftAspNetCoreHttpCookieOptions and\n              not isPropertySet(oc, \"HttpOnly\") and\n              exists(DataFlow::Node creation |\n                CookieOptionsTracking::flow(creation, _) and\n                creation.asExpr() = oc\n              )\n            )\n            or\n            // IResponseCookies.Append(String, String) was called, `HttpOnly` is set to `false` by default\n            mc = c and\n            mc.getNumberOfArguments() < 3\n          )\n        )\n        or\n        exists(ObjectCreation oc |\n          oc = c and\n          oc.getType() instanceof SystemWebHttpCookie and\n          isCookieWithSensitiveName(oc.getArgument(0)) and\n          // the property wasn't explicitly set, so a default value from config is used\n          not isPropertySet(oc, \"HttpOnly\") and\n          // the default in config is not set to `true`\n          not exists(XmlElement element |\n            element instanceof HttpCookiesElement and\n            element.(HttpCookiesElement).isHttpOnlyCookies()\n          )\n        )\n      )\n    )\n  ) and\n  message = \"Cookie attribute 'HttpOnly' is not set to true.\"\n}",
        "description": "Omitting the 'HttpOnly' attribute for security sensitive data allows malicious JavaScript to steal it in case of XSS vulnerability. Always set 'HttpOnly' to 'true' to authentication related cookie to make it not accessible by JavaScript.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/Security Features/CWE-1004/CookieWithoutHttpOnly.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\ndeprecated import TaintedWebClientLib\ndeprecated import TaintedWebClient::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, TaintedWebClient::PathNode source, TaintedWebClient::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  TaintedWebClient::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"A method of WebClient depepends on a $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "The WebClient class allows developers to request resources, accessing resources influenced by users can allow an attacker to access local files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/experimental/CWE-099/TaintedWebClient.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom XmlAttribute a\nwhere\n  a.getName().toLowerCase() = \"password\" and not a.getValue() = \"\"\n  or\n  a.getName().toLowerCase() = \"pwd\" and not a.getValue() = \"\"\n  or\n  a.getValue().regexpMatch(\"(?is).*(pwd|password)\\\\s*=(?!\\\\s*;).*\")\nselect a, \"Avoid plaintext passwords in configuration files.\"",
        "description": "Finds passwords in configuration files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Configuration/PasswordInConfigurationFile.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom XmlAttribute a\nwhere\n  a.getName().toLowerCase() = \"password\" and a.getValue() = \"\"\n  or\n  a.getName().toLowerCase() = \"pwd\" and a.getValue() = \"\"\n  or\n  a.getValue().regexpMatch(\"(?is).*(pwd|password)\\\\s*=\\\\s*;.*\")\nselect a, \"Do not use empty passwords.\"",
        "description": "Finds empty passwords in configuration files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Configuration/EmptyPasswordInConfigurationFile.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ObjectCreation oc\nwhere oc.getType().(Class).hasFullyQualifiedName(\"System.Web.UI.HtmlControls\", \"HtmlInputHidden\")\nselect oc, \"Avoid using 'HTMLInputHidden' fields.\"",
        "description": "Finds uses of hidden fields on forms",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/UseOfHtmlInputHidden.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom MethodCall call\nwhere call.getTarget().hasFullyQualifiedName(\"System.IO\", \"Path\", \"Combine\")\nselect call, \"Call to 'System.IO.Path.Combine'.\"",
        "description": "Finds calls to System.IO.Path's Combine method",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/PathCombine.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.ComparisonTest\nimport semmle.code.csharp.frameworks.System\n\nComparisonTest getComparisonTest(Expr e) { result.getExpr() = e }\n\nclass StringComparison extends Expr {\n  StringComparison() {\n    exists(ComparisonTest ct | ct = getComparisonTest(this) |\n      ct.getComparisonKind().isEquality() and\n      ct.getFirstArgument().stripCasts().getType() instanceof StringType and\n      ct.getSecondArgument().stripCasts().getType() instanceof StringType\n    )\n  }\n\n  Expr getAnOperand() { result = getComparisonTest(this).getAnArgument() }\n}\n\nfrom StringComparison sc, PropertyAccess pa\nwhere\n  sc.getAnOperand() instanceof StringLiteral and\n  sc.getAnOperand() = pa and\n  pa.getTarget() = any(SystemTypeClass c).getFullNameProperty()\nselect sc, \"Erroneous class compare.\"",
        "description": "Finds checks of an object's type based on its class name",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/ErroneousClassCompare.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Util\n\npredicate isConsoleOutRedefinedSomewhere() {\n  exists(MethodCall mc |\n    mc.getTarget().hasName(\"SetOut\") and\n    mc.getTarget().getDeclaringType().hasFullyQualifiedName(\"System\", \"Console\")\n  )\n}\n\npredicate isConsoleErrorRedefinedSomewhere() {\n  exists(MethodCall mc |\n    mc.getTarget().hasName(\"SetError\") and\n    mc.getTarget().getDeclaringType().hasFullyQualifiedName(\"System\", \"Console\")\n  )\n}\n\npredicate isCallToConsoleWrite(MethodCall mc) {\n  mc.getTarget().getName().matches(\"Write%\") and\n  mc.getTarget().getDeclaringType().hasFullyQualifiedName(\"System\", \"Console\")\n}\n\npredicate isAccessToConsoleOut(PropertyAccess pa) {\n  pa.getTarget().hasName(\"Out\") and\n  pa.getTarget().getDeclaringType().hasFullyQualifiedName(\"System\", \"Console\")\n}\n\npredicate isAccessToConsoleError(PropertyAccess pa) {\n  pa.getTarget().hasName(\"Error\") and\n  pa.getTarget().getDeclaringType().hasFullyQualifiedName(\"System\", \"Console\")\n}\n\nfrom Expr e\nwhere\n  (\n    isCallToConsoleWrite(e) and not isConsoleOutRedefinedSomewhere()\n    or\n    isAccessToConsoleOut(e) and not isConsoleOutRedefinedSomewhere()\n    or\n    isAccessToConsoleError(e) and not isConsoleErrorRedefinedSomewhere()\n  ) and\n  not e.getEnclosingCallable() instanceof MainMethod\nselect e, \"Poor logging: use of system output stream.\"",
        "description": "Finds uses of system output streams instead of proper logging",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/UseOfSystemOutputStream.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom CatchClause cc\nwhere\n  cc.getBlock().isEmpty() and\n  not exists(CommentBlock cb | cb.getParent() = cc.getBlock())\nselect cc, \"Poor error handling: empty catch block.\"",
        "description": "Finds catch clauses with an empty block",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/EmptyCatchBlock.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Util\n\nfrom MainMethod m\nwhere\n  m.fromSource() and\n  exists(UsingNamespaceDirective u |\n    u.getFile() = m.getFile() and\n    u.getImportedNamespace().hasFullyQualifiedName(\"System\", \"Web\")\n  )\nselect m, \"Remove debug code if your ASP.NET application is in production.\"",
        "description": "Finds leftover entry points in web applications",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/LeftoverDebugCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Class c, Method m, MethodCall call\nwhere\n  m.isExtern() and\n  m.getDeclaringType() = c and\n  call.getTarget() = m\nselect call, \"Replace this call with a call to managed code if possible.\"",
        "description": "Finds calls to \"extern\" methods (which are implemented by unmanaged code).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/CallsUnmanagedCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate virtualCallToSelfInConstructor(Expr e) {\n  exists(RefType t, Virtualizable d, Callable c |\n    c = e.getEnclosingCallable() and\n    (c instanceof Constructor or c instanceof Destructor) and\n    t = c.getDeclaringType() and\n    virtualAccessWithThisQualifier(e, d) and\n    t.getABaseType*() = d.getDeclaringType() and\n    not t.isSealed() and\n    not overriddenSealed(t.getABaseType*(), d)\n  )\n}\n\npredicate overriddenSealed(RefType t, Virtualizable d) {\n  exists(Virtualizable od |\n    od.getDeclaringType() = t and\n    (od.getOverridee() = d or od.getImplementee() = d) and\n    not od.isOverridableOrImplementable()\n  )\n}\n\npredicate virtualAccessWithThisQualifier(Expr e, Member d) {\n  exists(VirtualMethodCall c |\n    c = e and c.getTarget() = d and c.hasThisQualifier() and not c.isImplicit()\n  )\n  or\n  exists(VirtualMethodAccess c | c = e and c.getTarget() = d and c.hasThisQualifier())\n  or\n  exists(VirtualPropertyAccess c | c = e and c.getTarget() = d and c.hasThisQualifier())\n  or\n  exists(VirtualIndexerAccess c | c = e and c.getTarget() = d and c.hasThisQualifier())\n  or\n  exists(VirtualEventAccess c | c = e and c.getTarget() = d and c.hasThisQualifier())\n}\n\nfrom Expr e\nwhere virtualCallToSelfInConstructor(e)\nselect e, \"Avoid virtual calls in a constructor or destructor.\"",
        "description": "Finds virtual calls or accesses in a constructor or destructor",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/VirtualCallInConstructorOrDestructor.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom SpecificCatchClause scc\nwhere scc.getCaughtExceptionType().hasFullyQualifiedName(\"System\", \"NullReferenceException\")\nselect scc, \"Poor error handling: try to fix the cause of the 'NullReferenceException'.\"",
        "description": "Finds catch clauses that catch NullReferenceException",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/CatchOfNullReferenceException.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Class c, Method m\nwhere\n  m.isExtern() and\n  m.getDeclaringType() = c\nselect m, \"Minimise the use of unmanaged code.\"",
        "description": "Finds \"extern\" methods, implemented by unmanaged code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/UnmanagedCodeCheck.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass CommentedOutCode extends CommentBlock {\n  CommentedOutCode() {\n    not this.isXmlCommentBlock() and\n    2 * count(this.getAProbableCodeLine()) > count(this.getANonEmptyLine())\n  }\n}\n\nfrom CommentedOutCode comment\nselect comment, \"This comment appears to contain commented-out code.\"",
        "description": "Commented-out code makes the remaining code more difficult to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Comments/CommentedOutCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom CommentLine c\nwhere c.getText().regexpMatch(\"(?s).*FIXME.*|.*TODO.*|.*(?<!=)\\\\s*XXX.*\")\nselect c, \"TODO comments should be addressed.\"",
        "description": "A comment that contains 'TODO' or similar keywords may indicate code that is incomplete or broken, or it may highlight an ambiguity in the software's specification.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Comments/TodoComments.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Collections\nimport DataFlow\n\npredicate storesCollection(Callable c, Parameter p, Field f) {\n  f.getDeclaringType() = c.getDeclaringType().getABaseType*().getUnboundDeclaration() and\n  f.getType() instanceof CollectionType and\n  p = c.getAParameter() and\n  f.getAnAssignedValue() = p.getAnAccess() and\n  not c.(Modifiable).isStatic()\n}\n\npredicate returnsCollection(Callable c, Field f) {\n  f.getDeclaringType() = c.getDeclaringType().getABaseType*().getUnboundDeclaration() and\n  f.getType() instanceof CollectionType and\n  c.canReturn(f.getAnAccess()) and\n  not c.(Modifiable).isStatic()\n}\n\npredicate nodeMayWriteToCollection(Node modified) {\n  modified.asExpr() instanceof CollectionModificationAccess\n  or\n  exists(Node mid | nodeMayWriteToCollection(mid) | localFlowStep(modified, mid))\n  or\n  exists(Node mid, MethodCall mc, Callable c | nodeMayWriteToCollection(mid) |\n    mc = mid.asExpr() and\n    mc.getTarget() = c and\n    c.canReturn(modified.asExpr())\n  )\n}\n\npredicate mayWriteToCollection(Expr modified) {\n  nodeMayWriteToCollection(any(ExprNode n | n.getExpr() = modified))\n}\n\npredicate modificationAfter(Expr before, Expr after) {\n  mayWriteToCollection(after) and\n  localFlowStep+(exprNode(before), exprNode(after))\n}\n\nVariableAccess varPassedInto(Callable c, Parameter p) {\n  exists(Call call | call.getTarget() = c | call.getArgumentForParameter(p) = result)\n}\n\npredicate exposesByReturn(Callable c, Field f, Expr why, string whyText) {\n  returnsCollection(c, f) and\n  exists(MethodCall ma | ma.getTarget() = c |\n    mayWriteToCollection(ma) and\n    why = ma and\n    whyText = \"after this call to \" + c.getName()\n  )\n}\n\npredicate exposesByStore(Callable c, Field f, Expr why, string whyText) {\n  exists(VariableAccess v, Parameter p |\n    storesCollection(c, p, f) and\n    v = varPassedInto(c, p) and\n    modificationAfter(v, why) and\n    whyText = \"through the variable \" + v.getTarget().getName()\n  )\n}\n\nfrom Callable c, Field f, Expr why, string whyText\nwhere\n  exposesByReturn(c, f, why, whyText) or\n  exposesByStore(c, f, why, whyText)\nselect c,\n  \"'\" + c.getName() + \"' exposes the internal representation stored in field '\" + f.getName() +\n    \"'. The value may be modified $@.\", why, whyText",
        "description": "An object that accidentally exposes its internal representation may allow the object's fields to be modified in ways that the object is not prepared to handle.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Implementation Hiding/ExposeRepresentation.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate nonEmptyArrayLiteralOrNull(Expr e) {\n  e =\n    any(ArrayCreation arr |\n      exists(arr.getInitializer().getAnElement())\n      or\n      not arr.getALengthArgument().getValue() = \"0\"\n    )\n  or\n  e instanceof NullLiteral\n  or\n  e =\n    any(ConditionalExpr cond |\n      nonEmptyArrayLiteralOrNull(cond.getThen()) and\n      nonEmptyArrayLiteralOrNull(cond.getElse())\n    )\n}\n\nfrom Field f\nwhere\n  f.isPublic() and\n  f.isStatic() and\n  f.isReadOnly() and\n  f.getType() instanceof ArrayType and\n  f.fromSource() and\n  forall(AssignableDefinition def | def.getTarget() = f |\n    nonEmptyArrayLiteralOrNull(def.getSource())\n  )\nselect f, \"The array constant '\" + f.getName() + \"' is vulnerable to mutation.\"",
        "description": "Array constants are mutable and can be changed by malicious code or by accident.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Implementation Hiding/StaticArray.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.Collections\nimport semmle.code.csharp.frameworks.system.collections.Generic\n\nclass CollectionInterface extends Interface {\n  CollectionInterface() {\n    exists(Interface i | i = this.getABaseInterface*() |\n      i instanceof SystemCollectionsICollectionInterface or\n      i.getUnboundDeclaration() instanceof SystemCollectionsGenericICollectionInterface or\n      i instanceof SystemCollectionsIEnumerableInterface or\n      i.getUnboundDeclaration() instanceof SystemCollectionsGenericIEnumerableTInterface\n    )\n  }\n}\n\nfrom CastExpr e, Class c, CollectionInterface i\nwhere\n  e.getType() = c and\n  e.getExpr().getType() = i and\n  c.isImplicitlyConvertibleTo(i)\nselect e,\n  \"Questionable cast from abstract '\" + i.getName() + \"' to concrete implementation '\" + c.getName()\n    + \"'.\"",
        "description": "A cast from an abstract collection to a concrete implementation type makes the code brittle; it is best to program against the abstract collection interface only.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Implementation Hiding/AbstractToConcreteCollection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Method m, int n\nwhere\n  m.isSourceDeclaration() and\n  n = count(Parameter p | p = m.getAParameter() and p.isRef()) and\n  n > 2\nselect m,\n  \"Method '\" + m.getName() + \"' has \" + n + \" 'ref' parameters and might be hard to understand.\"",
        "description": "Methods with large numbers of 'ref' parameters can be hard to understand - consider using a wrapper object instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Declarations/TooManyRefParameters.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Interface i\nwhere\n  not exists(i.getAMember()) and\n  i.isSourceDeclaration() and\n  count(Interface base | i.getABaseInterface() = base) <= 1\nselect i, \"Interface '\" + i.getName() + \"' does not declare any members.\"",
        "description": "Empty interfaces (those that do not declare any members) are often used as \"markers\" to associate metadata with a class, but custom attributes are a better alternative.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Declarations/EmptyInterface.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npragma[noinline]\nprivate string localVarInType(ValueOrRefType t, LocalScopeVariable v) {\n  v.getCallable().getDeclaringType() = t and\n  result = v.getName() and\n  not v instanceof ImplicitAccessorParameter\n}\n\nprivate string memberInType(ValueOrRefType t, Member m) {\n  t.hasMember(m) and\n  result = m.getName() and\n  not m instanceof Method and\n  not m instanceof Constructor and\n  not m instanceof NestedType and\n  t.isSourceDeclaration()\n}\n\nprivate predicate acceptableShadowing(LocalScopeVariable v, Member m) {\n  exists(ValueOrRefType t | localVarInType(t, v) = memberInType(t, m) |\n    // If the callable declaring the local also accesses the shadowed member\n    // using an explicit `this` qualifier, the shadowing is likely deliberate.\n    exists(MemberAccess ma | ma.getTarget() = m |\n      ma.getEnclosingCallable() = v.getCallable() and\n      ma.targetIsLocalInstance() and\n      not ma.getQualifier().isImplicit()\n    )\n    or\n    t.getAConstructor().getAParameter() = v\n    or\n    // Record types have auto-generated Deconstruct methods, which declare an out parameter\n    // with the same name as the property field(s).\n    t.(RecordType).getAMethod(\"Deconstruct\").getAParameter() = v\n  )\n}\n\nprivate predicate shadowing(ValueOrRefType t, LocalScopeVariable v, Member m) {\n  localVarInType(t, v) = memberInType(t, m) and\n  not acceptableShadowing(v, m)\n}\n\nfrom LocalScopeVariable v, Callable c, ValueOrRefType t, Member m\nwhere\n  c = v.getCallable() and\n  shadowing(t, v, m) and\n  (c.(Modifiable).isStatic() implies m.isStatic())\nselect v, \"Local scope variable '\" + v.getName() + \"' shadows $@.\", m,\n  t.getName() + \".\" + m.getName()",
        "description": "A local scope variable that shadows a member with the same name can be confusing, and can result in logic errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Declarations/LocalScopeVariableShadowsMember.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass ConstantField extends Field {\n  ConstantField() {\n    this.isStatic() and this.isReadOnly()\n    or\n    this.isConst()\n  }\n}\n\nfrom Class c\nwhere\n  c.isSourceDeclaration() and\n  c.isAbstract() and\n  c.getAMember() instanceof ConstantField and\n  forex(Member m | m = c.getAMember() |\n    m instanceof ConstantField or\n    m instanceof Constructor\n  )\nselect c, \"Class '\" + c.getName() + \"' only declares common constants.\"",
        "description": "Constants should be placed in a class where they belong logically, rather than in an abstract class containing just constants.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Declarations/NoConstantsOnly.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nstring prefix(string qualifier, string typename) {\n  qualifier = \"System.Web.UI.WebControls\" and\n  (\n    typename = \"Label\" and result = \"lbl\"\n    or\n    typename = \"TextBox\" and result = \"txt\"\n    or\n    typename = [\"Button\", \"LinkButton\"] and result = \"btn\"\n    or\n    typename = \"ImageButton\" and result = \"ibtn\"\n    or\n    typename = \"Hyperlink\" and result = \"hpl\"\n    or\n    typename = \"DropDownList\" and result = \"cmb\"\n    or\n    typename = \"ListBox\" and result = \"lst\"\n    or\n    typename = \"Datagrid\" and result = \"dgr\"\n    or\n    typename = \"Datalist\" and result = \"dtl\"\n    or\n    typename = \"Repeater\" and result = \"rpt\"\n    or\n    typename = \"CheckBox\" and result = \"chk\"\n    or\n    typename = \"CheckBoxList\" and result = \"chklst\"\n    or\n    typename = \"RadioButtonList\" and result = \"radlst\"\n    or\n    typename = \"RadioButton\" and result = \"rad\"\n    or\n    typename = \"Image\" and result = \"img\"\n    or\n    typename = \"Panel\" and result = \"pnl\"\n    or\n    typename = \"PlaceHolder\" and result = \"plh\"\n    or\n    typename = \"Calendar\" and result = \"cal\"\n    or\n    typename = \"AdRotator\" and result = \"adr\"\n    or\n    typename = \"Table\" and result = \"tbl\"\n    or\n    typename = \"RequiredFieldValidator\" and result = \"rfv\"\n    or\n    typename = \"CompareValidator\" and result = \"cmv\"\n    or\n    typename = \"RegularExpressionValidator\" and result = \"rev\"\n    or\n    typename = \"CustomValidator\" and result = \"csv\"\n    or\n    typename = \"ValidationSummary\" and result = \"vsm\"\n    or\n    typename = \"XML\" and result = \"xml\"\n    or\n    typename = \"Literal\" and result = \"lit\"\n    or\n    typename = \"Form\" and result = \"frm\"\n    or\n    typename = \"Frame\" and result = \"fra\"\n    or\n    typename = \"CrystalReportViewer\" and result = \"crvr\"\n  )\n  or\n  qualifier = \"System.Web.UI.HtmlControls\" and\n  (\n    typename = \"TextArea\" and result = \"txa\"\n    or\n    typename = \"FileField\" and result = \"fle\"\n    or\n    typename = \"PasswordField\" and result = \"pwd\"\n    or\n    typename = \"Hidden\" and result = \"hdn\"\n    or\n    typename = \"Table\" and result = \"tbl\"\n    or\n    typename = \"FlowLayoutPanel\" and result = \"flp\"\n    or\n    typename = \"GridLayoutPanel\" and result = \"glp\"\n    or\n    typename = \"HorizontalRule\" and result = \"hr\"\n  )\n}\n\nfrom Field f, RefType t, string name, string prefix, string qualifier, string type\nwhere\n  f.getType() = t and\n  f.getName() = name and\n  t.hasFullyQualifiedName(qualifier, type) and\n  prefix = prefix(qualifier, type) and\n  not name.matches(prefix + \"%\")\nselect f, \"This field should have the prefix '\" + prefix + \"' to match its types.\"",
        "description": "Including standard prefixes in the field names of ASP.NET Web / HTML controls makes code easier to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/ControlNamePrefixes.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate sourceFile(File f) {\n  f.fromSource() and\n  not f.getAbsolutePath() = \"null\" and\n  not f.getAbsolutePath().matches(\"%ActivXTabControl%.cs\")\n}\n\nfrom Variable variable, string name\nwhere\n  name = variable.getName() and\n  variable.fromSource() and\n  sourceFile(variable.getFile()) and\n  not allowedName(name) and\n  not allowedVariable(variable) and\n  //\n  // Adjustable parameter:\n  //\n  name.length() < 3\n//\nselect variable, \"Variable name '\" + name + \"' is too short.\"\n\n//\n// Adjustable: acceptable short names\n//\npredicate allowedName(string name) {\n  name = [\"url\", \"cmd\", \"UK\", \"uri\", \"top\", \"row\", \"pin\", \"log\", \"key\", \"_\"]\n}\n\n//\n// Adjustable: variables that are allowed to have short names\n//\npredicate allowedVariable(Variable variable) {\n  exists(Parameter param |\n    variable = param and\n    not exists(param.getAnAccess()) and\n    param.getType().getName().matches(\"%EventArgs\")\n  )\n  or\n  exists(LocalVariable local |\n    variable = local and\n    local.getVariableDeclExpr().getParent() instanceof CatchClause\n  )\n  or\n  exists(Call c, LambdaExpr le | le.getAParameter() = variable | c.getAnArgument() = le)\n}",
        "description": "Using meaningful names for variables makes code easier to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/VariableNameTooShort.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom RefType sub, RefType sup\nwhere\n  sub.getABaseType() = sup and\n  sub.getName() = sup.getName() and\n  sub.fromSource()\nselect sub, \"Class has the same name as its base class.\"",
        "description": "Finds classes that have the same name as their super class; this may be confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/SameNameAsSuper.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate hasSubtypeStar(RefType t, RefType u) {\n  t = u or\n  u.getABaseType+() = t\n}\n\npredicate methodNames(RefType t, Method m, string lowercase) {\n  exists(RefType t2 |\n    m.getDeclaringType() = t2 and\n    hasSubtypeStar(t2, t)\n  ) and\n  lowercase = m.getName().toLowerCase() and\n  lowercase.length() > 1\n}\n\npredicate confusing(Method m1, Method m2) {\n  exists(RefType t, string lower |\n    methodNames(t, m1, lower) and\n    methodNames(t, m2, lower) and\n    m1.getName() != m2.getName()\n  )\n}\n\n// Two method names are confusing if all of the following conditions hold:\n//   They are both static methods or both instance methods.\n//   They are not declared in the same class, and the superclass method is\n//     not overridden in an intermediate class\n//   They have different names.\n//   They have the same names if case is ignored.\n//   There is no method in the subclass that has the same name as\n//     the superclass method\n// There is an additional check that only methods with names longer than one character\n// can be considered confusing.\nfrom Method m1, Method m2\nwhere\n  confusing(m1, m2) and\n  m1.getDeclaringType() != m2.getDeclaringType() and\n  (\n    m1.isStatic() and m2.isStatic()\n    or\n    not m1.isStatic() and not m2.isStatic()\n  ) and\n  not exists(Method mid |\n    confusing(m1, mid) and\n    mid.getDeclaringType().getABaseType+() = m2.getDeclaringType()\n  ) and\n  not exists(Method notConfusing |\n    notConfusing.getDeclaringType() = m1.getDeclaringType() and\n    notConfusing.getName() = m2.getName()\n  ) and\n  m1.fromSource()\nselect m1,\n  \"It is confusing to have methods \" + m1.getName() + \" in \" + m1.getDeclaringType().getName() +\n    \" and \" + m2.getName() + \" in \" + m2.getDeclaringType().getName() + \".\"",
        "description": "Finds methods m1 and m2, where m1 would override m2, except that their names differ in capitalization.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/ConfusingOverridesNames.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate controlName(string prefix) {\n  prefix =\n    [\n      \"[Ll]abel\", \"[Bb]utton\", \"[Pp]anel\", \"[Rr]adio[Bb]utton\", \"[Pp]rop\", \"[Ss]atus[Ss]trip\",\n      \"[Tt]able[Ll]ayout[Dd]esigner\", \"[Tt]ext[Bb]ox\", \"[Tt]ool[Ss]trip\", \"[Pp]icture[Bb]ox\"\n    ]\n}\n\npredicate usedInHumanWrittenCode(Field f) {\n  exists(File file |\n    f.getAnAccess().getFile() = file and\n    not file.getBaseName().toLowerCase().matches(\"%.designer.cs\")\n  )\n}\n\nfrom Field field, ValueOrRefType widget, string prefix\nwhere\n  widget.getABaseType*().hasFullyQualifiedName(\"System.Windows.Forms\", \"Control\") and\n  field.getType() = widget and\n  field.getName().regexpMatch(prefix + \"[0-9]+\") and\n  controlName(prefix) and\n  usedInHumanWrittenCode(field)\nselect field, \"Control '\" + field.getName() + \"' should have a meaningful name.\"",
        "description": "Replacing the generated names in windows forms with meaningful names makes it easier for other developers to understand the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/DefaultControlNames.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate typeWithConfusingName(ValueOrRefType type) {\n  strictcount(type.getAMethod().getName()) != strictcount(type.getAMethod().getName().toLowerCase())\n}\n\nfrom Method m, Method n, ValueOrRefType type\nwhere\n  typeWithConfusingName(type) and\n  type.fromSource() and\n  m = type.getAMethod() and\n  n = type.getAMethod() and\n  m != n and\n  m.getName().toLowerCase() = n.getName().toLowerCase() and\n  m.getName() < n.getName()\nselect m, \"Confusing method name, compare with $@.\", n, n.getName()",
        "description": "Finds methods whose name only differs in capitalization from another method defined in the same class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/ConfusingMethodNames.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass PublicConstantField extends Field {\n  PublicConstantField() {\n    this.isPublic() and\n    this.isStatic() and\n    this.isReadOnly()\n  }\n}\n\nfrom PublicConstantField f\nwhere\n  // The first character of the field's name is not uppercase.\n  not f.getName().charAt(0).isUppercase()\n  or\n  // The field's name is uppercase.\n  f.getName().isUppercase() and\n  // The field's name is at least 4 characters long.\n  f.getName().length() >= 4\nselect f, \"Public static read-only fields should be named in PascalCase.\"",
        "description": "Constant fields should use the relevant Microsoft-recommended naming scheme.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/ConstantNaming.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass VisibleInstanceField extends Field {\n  VisibleInstanceField() {\n    not this.isPrivate() and\n    not this.isStatic()\n  }\n}\n\nfrom RefType type, RefType supertype, VisibleInstanceField masked, VisibleInstanceField masking\nwhere\n  type.getABaseType+() = supertype and\n  masking.getDeclaringType() = type and\n  masked.getDeclaringType() = supertype and\n  masked.getName() = masking.getName() and\n  // exclude intentional masking\n  not exists(FieldAccess va |\n    va.getTarget() = masked and\n    va.getQualifier() instanceof BaseAccess\n  ) and\n  type.fromSource()\nselect masking, \"This field shadows another field in a superclass.\"",
        "description": "Finds fields that hide the definition of a field in a superclass, where additionally there are no references of the form 'base.f' in the subclass. This might be unintentional.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Naming Conventions/FieldMasksSuperField.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Assertions\nimport semmle.code.csharp.commons.Constants\n\nabstract class ConstantCondition extends Expr {\n  /** Gets the alert message for this constant condition. */\n  abstract string getMessage();\n\n  /** Holds if this constant condition is white-listed. */\n  predicate isWhiteListed() { none() }\n}\n\nclass ConstantBooleanCondition extends ConstantCondition {\n  boolean b;\n\n  ConstantBooleanCondition() { isConstantCondition(this, b) }\n\n  override string getMessage() { result = \"Condition always evaluates to '\" + b + \"'.\" }\n\n  override predicate isWhiteListed() {\n    // E.g. `x ?? false`\n    this.(BoolLiteral) = any(NullCoalescingExpr nce).getRightOperand() or\n    // No need to flag logical operations when the operands are constant\n    isConstantCondition(this.(LogicalNotExpr).getOperand(), _) or\n    this =\n      any(LogicalAndExpr lae |\n        isConstantCondition(lae.getAnOperand(), false)\n        or\n        isConstantCondition(lae.getLeftOperand(), true) and\n        isConstantCondition(lae.getRightOperand(), true)\n      ) or\n    this =\n      any(LogicalOrExpr loe |\n        isConstantCondition(loe.getAnOperand(), true)\n        or\n        isConstantCondition(loe.getLeftOperand(), false) and\n        isConstantCondition(loe.getRightOperand(), false)\n      )\n  }\n}\n\nclass ConstantIfCondition extends ConstantBooleanCondition {\n  ConstantIfCondition() {\n    this = any(IfStmt is).getCondition().getAChildExpr*() or\n    this = any(ConditionalExpr ce).getCondition().getAChildExpr*()\n  }\n\n  override predicate isWhiteListed() {\n    ConstantBooleanCondition.super.isWhiteListed()\n    or\n    // It is a common pattern to use a local constant/constant field to control\n    // whether code parts must be executed or not\n    this instanceof AssignableRead and\n    not this instanceof ParameterRead\n  }\n}\n\nclass ConstantLoopCondition extends ConstantBooleanCondition {\n  ConstantLoopCondition() { this = any(LoopStmt ls).getCondition() }\n\n  override predicate isWhiteListed() {\n    // Clearly intentional infinite loops are allowed\n    this.(BoolLiteral).getBoolValue() = true\n  }\n}\n\nclass ConstantNullnessCondition extends ConstantCondition {\n  boolean b;\n\n  ConstantNullnessCondition() {\n    forex(ControlFlow::Node cfn | cfn = this.getAControlFlowNode() |\n      exists(ControlFlow::NullnessSuccessor t, ControlFlow::Node s |\n        s = cfn.getASuccessorByType(t)\n      |\n        b = t.getValue() and\n        not s.isJoin()\n      ) and\n      strictcount(ControlFlow::SuccessorType t | exists(cfn.getASuccessorByType(t))) = 1\n    )\n  }\n\n  override string getMessage() {\n    if b = true\n    then result = \"Expression is always 'null'.\"\n    else result = \"Expression is never 'null'.\"\n  }\n}\n\nclass ConstantMatchingCondition extends ConstantCondition {\n  boolean b;\n\n  ConstantMatchingCondition() {\n    forex(ControlFlow::Node cfn | cfn = this.getAControlFlowNode() |\n      exists(ControlFlow::MatchingSuccessor t | exists(cfn.getASuccessorByType(t)) |\n        b = t.getValue()\n      ) and\n      strictcount(ControlFlow::SuccessorType t | exists(cfn.getASuccessorByType(t))) = 1\n    )\n  }\n\n  override predicate isWhiteListed() {\n    exists(Switch se, Case c, int i |\n      c = se.getCase(i) and\n      c.getPattern() = this.(DiscardExpr)\n    |\n      i > 0\n      or\n      i = 0 and\n      exists(Expr cond | c.getCondition() = cond and not isConstantCondition(cond, true))\n    )\n    or\n    this = any(PositionalPatternExpr ppe).getPattern(_)\n  }\n\n  override string getMessage() {\n    if b = true then result = \"Pattern always matches.\" else result = \"Pattern never matches.\"\n  }\n}\n\nfrom ConstantCondition c, string msg\nwhere\n  msg = c.getMessage() and\n  not c.isWhiteListed() and\n  not isExprInAssertion(c)\nselect c, msg",
        "description": "A condition that always evaluates to 'true' or always evaluates to 'false' should be removed, and if the condition is a loop condition, the condition is likely to cause an infinite loop.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Control-Flow/ConstantCondition.ql",
        "language": "csharp"
    },
    {
        "query": "import MagicConstants\n\npredicate selection(Element e, string msg) { magicConstant(e, msg) }\n\nfrom StringLiteral e, string msg\nwhere selection(e, msg)\nselect e, msg",
        "description": "'Magic constants' should be avoided: if a nontrivial constant is used repeatedly, it should be encapsulated into a const variable or macro definition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Magic Constants/MagicConstantsString.ql",
        "language": "csharp"
    },
    {
        "query": "import MagicConstants\n\nfrom Literal magicLiteral, string message, Field constant\nwhere\n  isNumber(magicLiteral) and\n  literalInsteadOfConstant(magicLiteral, _, message, constant)\nselect magicLiteral, message, constant, constant.getName()",
        "description": "A numeric literal that matches the initializer of a final variable was found. Consider using the final variable instead of the numeric literal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Magic Constants/MagicNumbersUseConstant.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport MagicConstants\n\npredicate selection(Element e, string msg) { magicConstant(e, msg) }\n\nfrom Literal e, string msg\nwhere\n  selection(e, msg) and\n  isNumber(e) and\n  not exists(Field f | f.getInitializer() = e)\nselect e, msg",
        "description": "'Magic constants' should be avoided: if a nontrivial constant is used repeatedly, it should be encapsulated into a const variable or macro definition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Magic Constants/MagicConstantsNumbers.ql",
        "language": "csharp"
    },
    {
        "query": "import MagicConstants\n\nfrom StringLiteral magicLiteral, string message, Field constant\nwhere literalInsteadOfConstant(magicLiteral, _, message, constant)\nselect magicLiteral, message, constant, constant.getName()",
        "description": "A string literal that matches the initializer of a final variable was found. Consider using the final variable instead of the string literal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Bad Practices/Magic Constants/MagicStringsUseConstant.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\nimport semmle.code.csharp.commons.QualifiedName\n\nfrom SourceMethodOrConstructor m, ThrowElement throw, RefType throwType\nwhere\n  declarationHasXmlComment(m) and\n  m = throw.getEnclosingCallable() and\n  throwType = throw.getExpr().getType() and\n  not exists(ExceptionXmlComment comment, string exceptionName, RefType throwBaseType |\n    comment = getADeclarationXmlComment(m) and\n    exceptionName = comment.getCref(_) and\n    throwType.getABaseType*() = throwBaseType and\n    (\n      throwBaseType.hasName(exceptionName)\n      or\n      exists(string qualifier, string type |\n        splitQualifiedName(exceptionName, qualifier, type) and\n        throwBaseType.hasFullyQualifiedName(qualifier, type)\n      )\n      // and comment.hasBody(offset) // Too slow\n    )\n  ) and\n  not getADeclarationXmlComment(m) instanceof InheritDocXmlComment\nselect m, \"Exception $@ should be documented.\", throw, throw.getExpr().getType().getName()",
        "description": "Exceptions thrown by the method should be documented using `<exception cref=\"...\"> </exception>` tags. Ensure that the correct type of the exception is given in the 'cref' attribute.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocMissingException.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\n\nfrom UnboundGeneric d, TypeParameter p\nwhere\n  p = d.getATypeParameter() and\n  declarationHasXmlComment(d) and\n  not exists(TypeparamXmlComment comment, int offset |\n    comment = getADeclarationXmlComment(d) and\n    comment.getName(offset) = p.getName() and\n    comment.hasBody(offset)\n  ) and\n  not getADeclarationXmlComment(d) instanceof InheritDocXmlComment\nselect p, \"Type parameter should be documented.\"",
        "description": "All type parameters should be documented using `<typeparam name=\"...\"> </typeparam>` tags. Ensure that the 'name' attribute matches the name of the type parameter.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocMissingTypeParam.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\n\nfrom SourceMethodOrConstructor m, SourceParameter p\nwhere\n  p = m.getAParameter() and\n  declarationHasXmlComment(m) and\n  not exists(ParamXmlComment c, int offset |\n    c = getADeclarationXmlComment(m) and\n    c.getName(offset) = p.getName() and\n    c.hasBody(offset)\n  ) and\n  not getADeclarationXmlComment(m) instanceof InheritDocXmlComment\nselect p, \"Parameter should be documented.\"",
        "description": "All parameters should be documented using `<param name=\"...\"> </param>` tags. Ensure that the name attribute matches the name of the parameter.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocMissingParam.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\n\nfrom SourceMethodOrConstructor m, ParamXmlComment comment, string paramName\nwhere\n  comment = getADeclarationXmlComment(m) and\n  comment.getName(_) = paramName and\n  not m.getAParameter().getName() = paramName\nselect m, \"Documentation specifies an invalid parameter name $@.\", comment, paramName",
        "description": "The parameter name given in a `<param>` tag does not exist. Rename the parameter or change the name in the documentation to ensure that they are the same.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocExtraParam.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\n\nfrom Declaration decl\nwhere\n  declarationHasXmlComment(decl) and\n  isDocumentationNeeded(decl) and\n  forall(SummaryXmlComment c | c = getADeclarationXmlComment(decl) |\n    forall(int offset | c.isOpenTag(offset) | c.isEmptyTag(offset))\n  ) and\n  not getADeclarationXmlComment(decl) instanceof InheritDocXmlComment\nselect decl, \"Documentation should have a summary.\"",
        "description": "The documentation comment does not contain a `<summary>` tag.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocMissingSummary.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\n\nfrom UnboundGeneric d, TypeparamXmlComment comment, string paramName\nwhere\n  comment = getADeclarationXmlComment(d) and\n  comment.getName(_) = paramName and\n  not d.getATypeParameter().getName() = paramName\nselect d, \"Documentation specifies an invalid type parameter name $@.\", comment, paramName",
        "description": "The type parameter name given in a `<typeparam>` tag does not exist. Rename the parameter or change the name in the documentation to ensure that they are the same.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocExtraTypeParam.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\n\nstring declarationDescription(Declaration d) {\n  d instanceof Class and result = \"class\"\n  or\n  d instanceof Interface and result = \"interface\"\n  or\n  d instanceof Method and result = \"method\"\n  or\n  d instanceof Constructor and result = \"constructor\"\n  or\n  d instanceof Struct and result = \"struct\"\n}\n\nfrom Declaration decl\nwhere\n  isDocumentationNeeded(decl) and\n  not declarationHasXmlComment(decl)\nselect decl, \"Public \" + declarationDescription(decl) + \" should be documented.\"",
        "description": "A public class, method or constructor that does not have a documentation comment affects maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocMissing.ql",
        "language": "csharp"
    },
    {
        "query": "import Documentation\n\nfrom SourceMethod m\nwhere\n  declarationHasXmlComment(m) and\n  forall(ReturnsXmlComment c | c = getADeclarationXmlComment(m) |\n    forall(int offset | c.isOpenTag(offset) | c.isEmptyTag(offset))\n  ) and\n  not m.getReturnType() instanceof VoidType and\n  not getADeclarationXmlComment(m) instanceof InheritDocXmlComment\nselect m, \"Return value should be documented.\"",
        "description": "The method returns a value, but the return value is not documented using a `<returns>` tag.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Documentation/XmldocMissingReturn.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Assertions\nimport semmle.code.csharp.commons.ComparisonTest\nimport semmle.code.csharp.commons.Constants\n\npredicate isBoxingTestCase(StaticEqualsCallComparisonTest ct) {\n  ct.isReferenceEquals() and\n  exists(TypeParameter tp |\n    tp = ct.getFirstArgument().stripCasts().getType() and\n    not tp.isValueType() and\n    not tp.isRefType()\n  )\n}\n\npredicate isMutatingOperation(Expr e) {\n  e.(MethodCall).getTarget().hasName(\"Pop\")\n  or\n  e.(MethodCall).getTarget().hasName(\"Push\")\n  or\n  e instanceof MutatorOperation\n}\n\nfrom ComparisonTest ct, Expr e, string msg\nwhere\n  comparesIdenticalValues(ct) and\n  e = ct.getExpr() and\n  not isBoxingTestCase(ct) and\n  (\n    exists(string m | comparesIdenticalValuesNan(ct, m) |\n      msg = \"Comparison is equivalent to using \" + m\n    )\n    or\n    not comparesIdenticalValuesNan(ct, _) and msg = \"Comparison of identical values.\"\n  ) and\n  not isMutatingOperation(ct.getAnArgument().getAChild*()) and\n  not isConstantCondition(e, _) and // Avoid overlap with cs/constant-condition\n  not isConstantComparison(e, _) and // Avoid overlap with cs/constant-comparison\n  not isExprInAssertion(e)\nselect ct, msg",
        "description": "When the same variable occurs on both sides of a comparison operator, the behavior is always constant, and probably not what it was intended to be.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/CSI/CompareIdenticalValues.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.dataflow.Nullness\n\nfrom Dereference d, Ssa::SourceVariable v\nwhere d.isFirstAlwaysNull(v)\nselect d, \"Variable $@ is always null at this dereference.\", v, v.toString()",
        "description": "Dereferencing a variable whose value is 'null' causes a 'NullReferenceException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/CSI/NullAlways.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.dataflow.Nullness\nimport PathGraph\n\nfrom\n  Dereference d, PathNode source, PathNode sink, Ssa::SourceVariable v, string msg, Element reason\nwhere d.isFirstMaybeNull(v.getAnSsaDefinition(), source, sink, msg, reason)\nselect d, source, sink, \"Variable $@ may be null at this access \" + msg + \".\", v, v.toString(),\n  reason, \"this\"",
        "description": "Dereferencing a variable whose value may be 'null' may cause a 'NullReferenceException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/CSI/NullMaybe.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.asp.AspNet\n\nfrom AspText text\nwhere exists(text.getBody().regexpFind(\"\\\\w{3,}\", _, _))\nselect text, \"This text has not been internationalized.\"",
        "description": "Including text directly on a page makes it more difficult to internationalize the website.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/ASP/NonInternationalizedText.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.asp.AspNet\n\nfrom AspCode code\nwhere exists(code.getBody().regexpFind(\"(Then|\\\\{)\\\\s*$\", _, _))\nselect code, \"Split control structure.\"",
        "description": "Splitting control structures across multiple code blocks makes .aspx pages more difficult to maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/ASP/SplitControlStructure.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.asp.AspNet\n\nfrom AspBlockCode code\nwhere code.getBody().trim().matches(\"Response.Write(%\")\nselect code, \"Non-inline code calls 'Response.Write()'.\"",
        "description": "Embedded code blocks with a single 'Response.Write()' reduce the readability of the page.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/ASP/BlockCodeResponseWrite.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.asp.AspNet\n\nfrom AspCode code\nwhere code.getBody().matches(\"%\\n%\")\nselect code, \"Inline code contains multi-line logic.\"",
        "description": "Embedding complex inline code makes .aspx pages more difficult to maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/ASP/ComplexInlineCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate nontrivialLogicalOperator(BinaryLogicalOperation e) {\n  not exists(BinaryLogicalOperation parent |\n    parent = e.getParent() and\n    parent.getOperator() = e.getOperator()\n  )\n}\n\npredicate logicalParent(LogicalOperation op, LogicalOperation parent) { parent = op.getParent() }\n\nfrom Expr e, int operators\nwhere\n  not e.getParent() instanceof LogicalOperation and\n  operators =\n    count(BinaryLogicalOperation op | logicalParent*(op, e) and nontrivialLogicalOperator(op)) and\n  operators > 3\nselect e, \"Complex condition: too many logical operations in this expression.\"",
        "description": "Boolean expressions should not be too deeply nested. Naming intermediate results as local variables will make the logic easier to read and understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Complexity/ComplexCondition.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass ComplexStmt extends Stmt {\n  ComplexStmt() {\n    this instanceof ForStmt or\n    this instanceof WhileStmt or\n    this instanceof DoStmt or\n    this instanceof SwitchStmt\n  }\n}\n\nfrom BlockStmt b, int n\nwhere n = count(ComplexStmt s | s = b.getAStmt()) and n > 3\nselect b, \"Block with too many statements (\" + n.toString() + \" complex statements in the block).\"",
        "description": "Blocks with too many consecutive statements are candidates for refactoring. Only complex statements are counted here (eg. 'for', 'while', 'switch' ...). The top-level logic will be clearer if each complex statement is extracted to a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Complexity/BlockWithTooManyStatements.ql",
        "language": "csharp"
    },
    {
        "query": "private import csharp\nprivate import semmle.code.csharp.telemetry.ExternalApi\n\nfrom Call c, ExternalApi api\nwhere\n  c.getTarget().getUnboundDeclaration() = api and\n  not api.isSupported()\nselect c, \"Call to unsupported external API $@.\", api, api.toString()",
        "description": "A call to an unsupported external library API.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/meta/frameworks/UnsupportedExternalAPIs.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.dataflow.internal.ExternalFlow\n\nfrom string namespace, int pkgs, string kind, string part, int n\nwhere modelCoverage(namespace, pkgs, kind, part, n)\nselect namespace, pkgs, kind, part, n",
        "description": "The number of API endpoints covered by MaD models sorted by package and source-, sink-, and summary-kind.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/meta/frameworks/Coverage.ql",
        "language": "csharp"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string noflow\nwhere noflow = captureNeutral(api)\nselect noflow order by noflow",
        "description": "Finds neutral models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/CaptureNeutralModels.ql",
        "language": "csharp"
    },
    {
        "query": "import internal.CaptureTypeBasedSummaryModels\n\nfrom TypeBasedFlowTargetApi api, string flow\nwhere flow = captureFlow(api)\nselect flow order by flow",
        "description": "Finds applicable summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/CaptureTypeBasedSummaryModels.ql",
        "language": "csharp"
    },
    {
        "query": "import internal.CaptureModels\nimport SinkModels\n\nfrom DataFlowSinkTargetApi api, string sink\nwhere sink = Heuristic::captureSink(api)\nselect sink order by sink",
        "description": "Finds public methods that act as sinks as they flow into a known sink.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/CaptureSinkModels.ql",
        "language": "csharp"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = ContentSensitive::captureFlow(api, _, _, _, _)\nselect flow order by flow",
        "description": "Finds applicable content based summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/CaptureContentSummaryModels.ql",
        "language": "csharp"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = captureFlow(api, _)\nselect flow order by flow",
        "description": "Finds applicable summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/CaptureSummaryModels.ql",
        "language": "csharp"
    },
    {
        "query": "import internal.CaptureModels\nimport SourceModels\n\nfrom DataFlowSourceTargetApi api, string source\nwhere source = Heuristic::captureSource(api)\nselect source order by source",
        "description": "Finds APIs that act as sources as they expose already known sources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/CaptureSourceModels.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport utils.modelgenerator.internal.CaptureModels\nimport SummaryModels\nimport PartialFlow::PartialPathGraph\n\nint explorationLimit() { result = 3 }\n\nmodule PartialFlow = Heuristic::PropagateTaintFlow::FlowExplorationFwd<explorationLimit/0>;\n\nfrom\n  PartialFlow::PartialPathNode source, PartialFlow::PartialPathNode sink,\n  DataFlowSummaryTargetApi api, DataFlow::ParameterNode p\nwhere\n  PartialFlow::partialFlow(source, sink, _) and\n  p = source.getNode() and\n  p.asParameter() = api.getAParameter()\nselect sink.getNode(), source, sink, \"There is flow from a $@ to $@.\", source.getNode(),\n  \"parameter\", sink.getNode(), \"intermediate value\"",
        "description": "Capture Summary Models Partial Path",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/debug/CaptureSummaryModelsPartialPath.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport utils.modelgenerator.internal.CaptureModels\nimport SummaryModels\nimport Heuristic::PropagateTaintFlow::PathGraph\n\nfrom\n  Heuristic::PropagateTaintFlow::PathNode source, Heuristic::PropagateTaintFlow::PathNode sink,\n  DataFlowSummaryTargetApi api, DataFlow::Node p, DataFlow::Node returnNodeExt\nwhere\n  Heuristic::PropagateTaintFlow::flowPath(source, sink) and\n  p = source.getNode() and\n  returnNodeExt = sink.getNode() and\n  Heuristic::captureThroughFlow0(api, p, returnNodeExt)\nselect sink.getNode(), source, sink, \"There is flow from $@ to the $@.\", source.getNode(),\n  \"parameter\", sink.getNode(), \"return value\"",
        "description": "Capture Summary Models Path",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelgenerator/debug/CaptureSummaryModelsPath.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport FrameworkModeEndpointsQuery\nimport ModelEditor\n\nfrom PublicEndpointFromSource endpoint, boolean supported, string type\nwhere\n  supported = isSupported(endpoint) and\n  type = supportedType(endpoint)\nselect endpoint, endpoint.getNamespace(), endpoint.getTypeName(), endpoint.getEndpointName(),\n  endpoint.getParameterTypes(), supported, endpoint.getFile().getBaseName(), type",
        "description": "A list of endpoints accessible (methods and attributes) for consumers of the library. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modeleditor/FrameworkModeEndpoints.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport ApplicationModeEndpointsQuery\nimport ModelEditor\n\nprivate Call aUsage(ExternalEndpoint api) { result.getTarget().getUnboundDeclaration() = api }\n\nfrom ExternalEndpoint endpoint, boolean supported, Call usage, string type, string classification\nwhere\n  supported = isSupported(endpoint) and\n  usage = aUsage(endpoint) and\n  type = supportedType(endpoint) and\n  classification = methodClassification(usage)\nselect usage, endpoint.getNamespace(), endpoint.getTypeName(), endpoint.getEndpointName(),\n  endpoint.getParameterTypes(), supported, endpoint.dllName(), endpoint.dllVersion(), type,\n  classification",
        "description": "A list of 3rd party endpoints (methods and attributes) used in the codebase. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modeleditor/ApplicationModeEndpoints.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport InterpretModel\n\nfrom\n  string namespace0, string namespace, string type0, string type, boolean subtypes, string name0,\n  string name, string signature0, string signature, string ext, string input, string output,\n  string kind, string provenance\nwhere\n  summaryModel(namespace0, type0, subtypes, name0, signature0, ext, input, output, kind, provenance,\n    _) and\n  interpretCallable(namespace0, namespace, type0, type, name0, name, signature0, signature)\nselect namespace, type, subtypes, name, signature, ext, input, output, kind, provenance order by\n    namespace, type, name, signature, input, output, kind",
        "description": "This extracts the Models as data summary model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelconverter/ExtractSummaries.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport InterpretModel\n\nfrom\n  string namespace0, string namespace, string type0, string type, string name0, string name,\n  string signature0, string signature, string kind, string provenance\nwhere\n  neutralModel(namespace0, type0, name0, signature0, kind, provenance) and\n  interpretCallable(namespace0, namespace, type0, type, name0, name, signature0, signature)\nselect namespace, type, name, signature, kind, provenance order by\n    namespace, type, name, signature, kind",
        "description": "This extracts the Models as data neutral model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelconverter/ExtractNeutrals.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport InterpretModel\n\nfrom\n  string namespace0, string namespace, string type0, string type, boolean subtypes, string name0,\n  string name, string signature0, string signature, string ext, string output, string kind,\n  string provenance\nwhere\n  sourceModel(namespace0, type0, subtypes, name0, signature0, ext, output, kind, provenance, _) and\n  interpretCallable(namespace0, namespace, type0, type, name0, name, signature0, signature)\nselect namespace, type, subtypes, name, signature, ext, output, kind, provenance order by\n    namespace, type, name, signature, output, kind",
        "description": "This extracts the Models as data source model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelconverter/ExtractSources.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport InterpretModel\n\nfrom\n  string namespace0, string namespace, string type0, string type, boolean subtypes, string name0,\n  string name, string signature0, string signature, string ext, string input, string kind,\n  string provenance\nwhere\n  sinkModel(namespace0, type0, subtypes, name0, signature0, ext, input, kind, provenance, _) and\n  interpretCallable(namespace0, namespace, type0, type, name0, name, signature0, signature)\nselect namespace, type, subtypes, name, signature, ext, input, kind, provenance order by\n    namespace, type, name, signature, input, kind",
        "description": "This extracts the Models as data sink model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/utils/modelconverter/ExtractSinks.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass FutureDateExpr extends MethodCall {\n  FutureDateExpr() {\n    exists(PropertyAccess pa |\n      pa = this.getQualifier() and\n      pa.getTarget().hasName(\"Now\") and\n      pa.getTarget().getDeclaringType().hasFullyQualifiedName(\"System\", \"DateTime\")\n    ) and\n    this.getTarget().getName().matches(\"Add%\")\n  }\n\n  float getTimeInSecond() {\n    this.getTarget().hasName(\"AddTicks\") and\n    result = this.getArgument(0).getValue().toFloat() / 10000000\n    or\n    this.getTarget().hasName(\"AddMilliseconds\") and\n    result = this.getArgument(0).getValue().toFloat() / 1000\n    or\n    this.getTarget().hasName(\"AddSeconds\") and result = this.getArgument(0).getValue().toFloat()\n    or\n    this.getTarget().hasName(\"AddMinutes\") and\n    result = this.getArgument(0).getValue().toFloat() * 60\n    or\n    this.getTarget().hasName(\"AddHours\") and\n    result = this.getArgument(0).getValue().toFloat() * 60 * 60\n    or\n    this.getTarget().hasName(\"AddDays\") and\n    result = this.getArgument(0).getValue().toFloat() * 60 * 60 * 24\n    or\n    this.getTarget().hasName(\"AddMonths\") and\n    result = this.getArgument(0).getValue().toFloat() * 60 * 60 * 24 * 365.25 / 12\n  }\n\n  predicate timeIsNotClear() {\n    this.getTarget().hasName(\"Add\") or\n    not exists(this.getArgument(0).getValue())\n  }\n}\n\nfrom Assignment a, PropertyAccess pa, FutureDateExpr fde\nwhere\n  a.getLValue() = pa and\n  a.getRValue() = fde and\n  pa.getTarget().hasName(\"Expires\") and\n  pa.getTarget().getDeclaringType().hasFullyQualifiedName(\"System.Web\", \"HttpCookie\") and\n  (fde.timeIsNotClear() or fde.getTimeInSecond() > 300) // 5 minutes max\nselect a, \"Avoid persistent cookies.\"",
        "description": "Persistent cookies are vulnerable to attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/PersistentCookie.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom MethodCall mc, BoolLiteral b\nwhere\n  mc.getTarget().hasName(\"Encrypt\") and\n  mc.getTarget()\n      .getDeclaringType()\n      .hasFullyQualifiedName(\"System.Security.Cryptography\", \"RSACryptoServiceProvider\") and\n  mc.getArgument(1) = b and\n  b.getValue() = \"false\"\nselect b, \"Enable RSA padding.\"",
        "description": "Finds uses of RSA encryption with inadequate padding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/InadequateRSAPadding.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate incorrectUseOfRC2(Assignment e, string msg) {\n  exists(PropertyAccess pa |\n    pa.getParent() = e and\n    pa.getTarget().hasName(\"EffectiveKeySize\") and\n    pa.getTarget()\n        .getDeclaringType()\n        .hasFullyQualifiedName(\"System.Security.Cryptography\", \"RC2CryptoServiceProvider\")\n  ) and\n  e.getRValue().getValue().toInt() < 128 and\n  msg = \"Key size should be at least 128 bits for RC2 encryption.\"\n}\n\npredicate incorrectUseOfDsa(ObjectCreation e, string msg) {\n  e.getTarget()\n      .getDeclaringType()\n      .hasFullyQualifiedName(\"System.Security.Cryptography\", \"DSACryptoServiceProvider\") and\n  exists(Expr i | e.getArgument(0) = i and i.getValue().toInt() < 2048) and\n  msg = \"Key size should be at least 2048 bits for DSA encryption.\"\n}\n\npredicate incorrectUseOfRsa(ObjectCreation e, string msg) {\n  e.getTarget()\n      .getDeclaringType()\n      .hasFullyQualifiedName(\"System.Security.Cryptography\", \"RSACryptoServiceProvider\") and\n  exists(Expr i | e.getArgument(0) = i and i.getValue().toInt() < 2048) and\n  msg = \"Key size should be at least 2048 bits for RSA encryption.\"\n}\n\nfrom Expr e, string msg\nwhere\n  incorrectUseOfRC2(e, msg) or\n  incorrectUseOfDsa(e, msg) or\n  incorrectUseOfRsa(e, msg)\nselect e, msg",
        "description": "Finds uses of encryption algorithms with too small a key size",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/InsufficientKeySize.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate incorrectUseOfDES(ObjectCreation e, string msg) {\n  e.getType()\n      .(Class)\n      .hasFullyQualifiedName(\"System.Security.Cryptography\", \"DESCryptoServiceProvider\") and\n  msg =\n    \"DES encryption uses keys of 56 bits only. Switch to AesCryptoServiceProvider or RijndaelManaged instead.\"\n}\n\npredicate incorrectUseOfTripleDES(ObjectCreation e, string msg) {\n  e.getType()\n      .(Class)\n      .hasFullyQualifiedName(\"System.Security.Cryptography\", \"TripleDESCryptoServiceProvider\") and\n  msg =\n    \"TripleDES encryption provides at most 112 bits of security. Switch to AesCryptoServiceProvider or RijndaelManaged instead.\"\n}\n\nfrom Expr e, string msg\nwhere\n  incorrectUseOfDES(e, msg) or\n  incorrectUseOfTripleDES(e, msg)\nselect e, msg",
        "description": "Finds uses of encryption algorithms that are weak and obsolete",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/WeakEncryption.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Assignment a, PropertyAccess pa\nwhere\n  a.getLValue() = pa and\n  pa.getTarget().hasName(\"Domain\") and\n  pa.getTarget().getDeclaringType().hasFullyQualifiedName(\"System.Web\", \"HttpCookie\") and\n  (\n    a.getRValue().getValue().regexpReplaceAll(\"[^.]\", \"\").length() < 2 or\n    a.getRValue().getValue().matches(\".%\")\n  )\nselect a, \"Overly broad domain for cookie.\"",
        "description": "Finds cookies with an overly broad domain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CookieWithOverlyBroadDomain.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom FieldAccess a, Field ecb, Enum e\nwhere\n  a.getTarget() = ecb and\n  ecb.hasName(\"ECB\") and\n  ecb.getDeclaringType() = e and\n  e.hasFullyQualifiedName(\"System.Security.Cryptography\", \"CipherMode\")\nselect a, \"The ECB (Electronic Code Book) encryption mode is vulnerable to replay attacks.\"",
        "description": "Highlights uses of the encryption mode 'CipherMode.ECB'. This mode should normally not be used because it is vulnerable to replay attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/Encryption using ECB.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Assignment a, PropertyAccess pa\nwhere\n  a.getLValue() = pa and\n  pa.getTarget().hasName(\"Path\") and\n  pa.getTarget().getDeclaringType().hasFullyQualifiedName(\"System.Web\", \"HttpCookie\") and\n  a.getRValue().getValue() = \"/\"\nselect a, \"Overly broad path for cookie.\"",
        "description": "Finds cookies with an overly broad path.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CookieWithOverlyBroadPath.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\n\nfrom Element l\nwhere\n  // header checking is disabled programmatically in the code\n  exists(Assignment a, PropertyAccess pa |\n    a.getLValue() = pa and\n    pa.getTarget().hasName(\"EnableHeaderChecking\") and\n    pa.getTarget()\n        .getDeclaringType()\n        .hasFullyQualifiedName(\"System.Web.Configuration\", \"HttpRuntimeSection\") and\n    a.getRValue().getValue() = \"false\" and\n    a = l\n  )\n  or\n  // header checking is disabled in a configuration file\n  exists(HttpRuntimeXmlElement e, XmlAttribute a |\n    a = e.getAttribute(\"enableHeaderChecking\") and\n    a.getValue().toLowerCase() = \"false\" and\n    a = l\n  )\nselect l, \"Do not disable header checking.\"",
        "description": "Finds places where header checking is disabled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/HeaderCheckingDisabled.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.Test\nimport Random::InsecureRandomness::PathGraph\n\nmodule Random {\n  import semmle.code.csharp.security.dataflow.flowsources.Remote\n  import semmle.code.csharp.security.SensitiveActions\n\n  /**\n   * A data flow sink for insecure randomness in security sensitive context.\n   */\n  abstract class Sink extends DataFlow::ExprNode { }\n\n  /**\n   * A data flow source for insecure randomness in security sensitive context.\n   */\n  abstract class Source extends DataFlow::ExprNode { }\n\n  /**\n   * A sanitizer for insecure randomness in security sensitive context.\n   */\n  abstract class Sanitizer extends DataFlow::ExprNode { }\n\n  /**\n   * A taint-tracking configuration for insecure randomness in security sensitive context.\n   */\n  module InsecureRandomnessConfig implements DataFlow::ConfigSig {\n    predicate isSource(DataFlow::Node source) { source instanceof Source }\n\n    predicate isSink(DataFlow::Node sink) { sink instanceof Sink }\n\n    predicate isBarrier(DataFlow::Node node) { node instanceof Sanitizer }\n\n    predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n      // succ = array_or_indexer[pred] - use of random numbers in an index\n      succ.asExpr().(ElementAccess).getAnIndex() = pred.asExpr()\n    }\n\n    predicate observeDiffInformedIncrementalMode() { any() }\n  }\n\n  /**\n   * A taint-tracking module for insecure randomness in security sensitive context.\n   */\n  module InsecureRandomness = TaintTracking::Global<InsecureRandomnessConfig>;\n\n  /** A source of cryptographically insecure random numbers. */\n  class RandomSource extends Source {\n    RandomSource() {\n      this.getExpr() =\n        any(MethodCall mc |\n          mc.getQualifier().getType().(RefType).hasFullyQualifiedName(\"System\", \"Random\")\n          or\n          // by using `% 87` on a `byte`, `System.Web.Security.Membership.GeneratePassword` has a bias\n          mc.getQualifier()\n              .getType()\n              .(RefType)\n              .hasFullyQualifiedName(\"System.Web.Security\", \"Membership\") and\n          mc.getTarget().hasName(\"GeneratePassword\")\n        )\n    }\n  }\n\n  /** A value assigned to a property, variable or parameter which holds security sensitive data. */\n  class SensitiveSink extends Sink {\n    SensitiveSink() {\n      exists(Expr e |\n        // Simple assignment\n        e = this.getExpr()\n      |\n        e = any(SensitiveVariable v).getAnAssignedValue()\n        or\n        e = any(SensitiveProperty v).getAnAssignedValue()\n        or\n        e = any(SensitiveLibraryParameter v).getAnAssignedArgument()\n        or\n        // Assignment operation, e.g. += or similar\n        exists(AssignOperation ao |\n          ao.getRValue() = e and\n          // \"expanded\" assignments will be covered by simple assignment\n          not ao.hasExpandedAssignment()\n        |\n          ao.getLValue() = any(SensitiveVariable v).getAnAccess() or\n          ao.getLValue() = any(SensitiveProperty v).getAnAccess() or\n          ao.getLValue() = any(SensitiveLibraryParameter v).getAnAccess()\n        )\n      )\n    }\n  }\n\n  /**\n   * Stop tracking beyond first assignment to sensitive element, so as to remove duplication in the\n   * reported results.\n   */\n  class AlreadyTrackedSanitizer extends Sanitizer {\n    AlreadyTrackedSanitizer() {\n      exists(Expr e | e = this.getExpr() |\n        e = any(SensitiveVariable v).getAnAccess() or\n        e = any(SensitiveProperty v).getAnAccess() or\n        e = any(SensitiveLibraryParameter v).getAnAccess()\n      )\n    }\n  }\n}\n\nfrom Random::InsecureRandomness::PathNode source, Random::InsecureRandomness::PathNode sink\nwhere Random::InsecureRandomness::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This uses a cryptographically insecure random number generated at $@ in a security context.\",\n  source.getNode(), source.getNode().toString()",
        "description": "Using a cryptographically weak pseudo-random number generator to generate a security sensitive value may allow an attacker to predict what sensitive value will be generated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/InsecureRandomness.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.SensitiveActions\nimport semmle.code.csharp.security.dataflow.flowsinks.Remote\nimport semmle.code.csharp.frameworks.system.data.Common\nimport semmle.code.csharp.frameworks.System\nimport ExposureInTransmittedData::PathGraph\n\nmodule ExposureInTransmittedDataConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    // `source` may contain a password\n    source.asExpr() instanceof PasswordExpr\n    or\n    // `source` is from a `DbException` property\n    exists(PropertyRead pr, Property prop |\n      source.asExpr() = pr and\n      pr.getQualifier().getType() = any(SystemDataCommon::DbException de).getASubType*() and\n      prop = pr.getTarget()\n    |\n      prop.getName() = \"Message\" or\n      prop.getName() = \"Data\"\n    )\n    or\n    // `source` is from `DbException.ToString()`\n    exists(MethodCall mc |\n      source.asExpr() = mc and\n      mc.getQualifier().getType() = any(SystemDataCommon::DbException de).getASubType*() and\n      mc.getTarget() = any(SystemObjectClass c).getToStringMethod().getAnOverrider*()\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof RemoteFlowSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule ExposureInTransmittedData = TaintTracking::Global<ExposureInTransmittedDataConfig>;\n\nfrom ExposureInTransmittedData::PathNode source, ExposureInTransmittedData::PathNode sink\nwhere ExposureInTransmittedData::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This data transmitted to the user depends on $@.\",\n  source.getNode(), \"sensitive information\"",
        "description": "Transmitting sensitive information to the user is a potential security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-201/ExposureInTransmittedData.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.CodeInjectionQuery\nimport CodeInjection::PathGraph\n\nfrom CodeInjection::PathNode source, CodeInjection::PathNode sink\nwhere CodeInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This code compilation depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Treating externally controlled strings as code can allow an attacker to execute malicious code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-094/CodeInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\nimport semmle.code.csharp.frameworks.system.Net\nimport semmle.code.csharp.frameworks.system.Web\nimport semmle.code.csharp.frameworks.system.web.UI\nimport semmle.code.csharp.security.dataflow.SqlInjectionQuery as SqlInjection\nimport semmle.code.csharp.security.dataflow.flowsinks.Html\nimport semmle.code.csharp.security.dataflow.UrlRedirectQuery as UrlRedirect\nimport semmle.code.csharp.security.Sanitizers\nimport EncodingConfigurations::Flow::PathGraph\n\nsignature module EncodingConfigSig {\n  /** Holds if `n` is a node whose value must be encoded. */\n  predicate requiresEncoding(DataFlow::Node n);\n\n  /** Holds if `e` is a possible valid encoded value. */\n  predicate isPossibleEncodedValue(Expr e);\n}\n\nmodule RequiresEncodingConfig<EncodingConfigSig EncodingConfig> implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    // all encoded values that do not match this configuration are\n    // considered sources\n    exists(Expr e | e = source.asExpr() |\n      e instanceof EncodedValue and\n      not EncodingConfig::isPossibleEncodedValue(e)\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { EncodingConfig::requiresEncoding(sink) }\n\n  predicate isBarrier(DataFlow::Node sanitizer) {\n    EncodingConfig::isPossibleEncodedValue(sanitizer.asExpr())\n  }\n\n  int fieldFlowBranchLimit() { result = 0 }\n}\n\nclass EncodedValue extends Expr {\n  EncodedValue() {\n    EncodingConfigurations::SqlExprEncodingConfig::isPossibleEncodedValue(this)\n    or\n    EncodingConfigurations::HtmlExprEncodingConfig::isPossibleEncodedValue(this)\n    or\n    EncodingConfigurations::UrlExprEncodingConfig::isPossibleEncodedValue(this)\n    or\n    this = any(SystemWebHttpUtility c).getAJavaScriptStringEncodeMethod().getACall()\n    or\n    // Also try to identify user-defined encoders, which are likely wrong\n    exists(Method m, string name, string regexp |\n      this.(MethodCall).getTarget() = m and\n      m.fromSource() and\n      m.getName().toLowerCase() = name and\n      name.toLowerCase().regexpMatch(regexp) and\n      regexp = \".*(encode|saniti(s|z)e|cleanse|escape).*\"\n    )\n  }\n}\n\nmodule EncodingConfigurations {\n  module SqlExprEncodingConfig implements EncodingConfigSig {\n    predicate requiresEncoding(DataFlow::Node n) { n instanceof SqlInjection::Sink }\n\n    predicate isPossibleEncodedValue(Expr e) { none() }\n  }\n\n  /** An encoding configuration for SQL expressions. */\n  module SqlExprConfig implements DataFlow::ConfigSig {\n    import RequiresEncodingConfig<SqlExprEncodingConfig> as Super\n\n    // no override for `isPossibleEncodedValue` as SQL parameters should\n    // be used instead of explicit encoding\n    predicate isSource(DataFlow::Node source) {\n      Super::isSource(source)\n      or\n      // consider quote-replacing calls as additional sources for\n      // SQL expressions (e.g., `s.Replace(\"\\\"\", \"\\\"\\\"\")`)\n      source.asExpr() =\n        any(MethodCall mc |\n          mc.getTarget() = any(SystemStringClass c).getReplaceMethod() and\n          mc.getArgument(0).getValue().regexpMatch(\"\\\"|'|`\")\n        )\n    }\n\n    predicate isSink = Super::isSink/1;\n\n    predicate isBarrier = Super::isBarrier/1;\n\n    int fieldFlowBranchLimit() { result = Super::fieldFlowBranchLimit() }\n  }\n\n  module SqlExpr = TaintTracking::Global<SqlExprConfig>;\n\n  module HtmlExprEncodingConfig implements EncodingConfigSig {\n    predicate requiresEncoding(DataFlow::Node n) { n instanceof HtmlSink }\n\n    predicate isPossibleEncodedValue(Expr e) { e instanceof HtmlSanitizedExpr }\n  }\n\n  /** An encoding configuration for HTML expressions. */\n  module HtmlExprConfig = RequiresEncodingConfig<HtmlExprEncodingConfig>;\n\n  module HtmlExpr = TaintTracking::Global<HtmlExprConfig>;\n\n  module UrlExprEncodingConfig implements EncodingConfigSig {\n    predicate requiresEncoding(DataFlow::Node n) { n instanceof UrlRedirect::Sink }\n\n    predicate isPossibleEncodedValue(Expr e) { e instanceof UrlSanitizedExpr }\n  }\n\n  /** An encoding configuration for URL expressions. */\n  module UrlExprConfig = RequiresEncodingConfig<UrlExprEncodingConfig>;\n\n  module UrlExpr = TaintTracking::Global<UrlExprConfig>;\n\n  module Flow =\n    DataFlow::MergePathGraph3<SqlExpr::PathNode, HtmlExpr::PathNode, UrlExpr::PathNode,\n      SqlExpr::PathGraph, HtmlExpr::PathGraph, UrlExpr::PathGraph>;\n\n  /**\n   * Holds if `encodedValue` is a possibly ill-encoded value that reaches\n   * `sink`, where `sink` is an expression of kind `kind` that is required\n   * to be encoded.\n   */\n  predicate hasWrongEncoding(Flow::PathNode encodedValue, Flow::PathNode sink, string kind) {\n    SqlExpr::flowPath(encodedValue.asPathNode1(), sink.asPathNode1()) and\n    kind = \"SQL expression\"\n    or\n    HtmlExpr::flowPath(encodedValue.asPathNode2(), sink.asPathNode2()) and\n    kind = \"HTML expression\"\n    or\n    UrlExpr::flowPath(encodedValue.asPathNode3(), sink.asPathNode3()) and\n    kind = \"URL expression\"\n  }\n}\n\nfrom\n  EncodingConfigurations::Flow::PathNode encodedValue, EncodingConfigurations::Flow::PathNode sink,\n  string kind\nwhere EncodingConfigurations::hasWrongEncoding(encodedValue, sink, kind)\nselect sink.getNode(), encodedValue, sink, \"This \" + kind + \" may include data from a $@.\",\n  encodedValue.getNode(), \"possibly inappropriately encoded value\"",
        "description": "Using an inappropriate encoding may give unintended results and may pose a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-838/InappropriateEncoding.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\nimport semmle.code.csharp.security.dataflow.flowsinks.Remote\nimport ExceptionInformationExposure::PathGraph\n\nmodule ExceptionInformationExposureConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(Expr expr |\n      // Writing an exception directly is bad\n      source.asExpr() = expr\n      or\n      // Writing a property of an exception is bad\n      source.asExpr().(PropertyAccess).getQualifier() = expr\n    |\n      // Expr has type `System.Exception`.\n      expr.getType().(RefType).getABaseType*() instanceof SystemExceptionClass and\n      // And is not within an exception callable.\n      not exists(Callable enclosingCallable | enclosingCallable = expr.getEnclosingCallable() |\n        enclosingCallable.getDeclaringType().getABaseType*() instanceof SystemExceptionClass\n      )\n    )\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node source, DataFlow::Node sink) {\n    sink.asExpr() =\n      any(MethodCall mc |\n        source.asExpr() = mc.getQualifier() and\n        mc.getTarget().hasName(\"ToString\") and\n        mc.getQualifier().getType().(RefType).getABaseType*() instanceof SystemExceptionClass\n      )\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof RemoteFlowSink }\n\n  predicate isBarrier(DataFlow::Node sanitizer) {\n    // Do not flow through Message\n    sanitizer.asExpr() = any(SystemExceptionClass se).getProperty(\"Message\").getAnAccess()\n  }\n\n  predicate isBarrierIn(DataFlow::Node sanitizer) {\n    // Do not flow through Message\n    sanitizer.asExpr().getType().(RefType).getABaseType*() instanceof SystemExceptionClass\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule ExceptionInformationExposure = TaintTracking::Global<ExceptionInformationExposureConfig>;\n\nfrom ExceptionInformationExposure::PathNode source, ExceptionInformationExposure::PathNode sink\nwhere ExceptionInformationExposure::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This information exposed to the user depends on $@.\",\n  source.getNode(), \"exception information\"",
        "description": "Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-209/ExceptionInformationExposure.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.ConditionalBypassQuery\nimport ConditionalBypass::PathGraph\n\nfrom ConditionalBypass::PathNode source, ConditionalBypass::PathNode sink\nwhere ConditionalBypass::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This condition guards a sensitive $@, but a $@ controls it.\",\n  sink.getNode().(Sink).getSensitiveMethodCall(), \"action\", source.getNode(), \"user-provided value\"",
        "description": "User-controlled bypassing of sensitive methods may allow attackers to avoid passing through authentication systems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-807/ConditionalBypass.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\nimport semmle.code.csharp.frameworks.system.Web\n\npredicate hasWebConfigXFrameOptions(WebConfigXml webConfig) {\n  // Looking for an entry in `webConfig` that looks like this:\n  // ```xml\n  // <system.webServer>\n  //   <httpProtocol>\n  //    <customHeaders>\n  //      <add name=\"X-Frame-Options\" value=\"SAMEORIGIN\" />\n  //    </customHeaders>\n  //   </httpProtocol>\n  // </system.webServer>\n  // ```\n  webConfig\n      .getARootElement()\n      .getAChild(\"system.webServer\")\n      .getAChild(\"httpProtocol\")\n      .getAChild(\"customHeaders\")\n      .getAChild(\"add\")\n      .getAttributeValue(\"name\") = \"X-Frame-Options\"\n}\n\npredicate hasCodeXFrameOptions() {\n  exists(MethodCall call |\n    call.getTarget() = any(SystemWebHttpResponseClass r).getAppendHeaderMethod() or\n    call.getTarget() = any(SystemWebHttpResponseClass r).getAddHeaderMethod()\n  |\n    call.getArgumentForName(\"name\").getValue() = \"X-Frame-Options\"\n  )\n}\n\nfrom WebConfigXml webConfig\nwhere\n  not hasWebConfigXFrameOptions(webConfig) and\n  not hasCodeXFrameOptions()\nselect webConfig, \"Configuration file is missing the X-Frame-Options setting.\"",
        "description": "If the 'X-Frame-Options' setting is not provided, a malicious user may be able to overlay their own UI on top of the site by using an iframe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-451/MissingXFrameOptions.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.auth.InsecureDirectObjectReferenceQuery\n\nfrom ActionMethod m\nwhere hasInsecureDirectObjectReference(m)\nselect m,\n  \"This method may be missing authorization checks for which users can access the resource of the provided ID.\"",
        "description": "Using user input to control which object is modified without proper authorization checks allows an attacker to modify arbitrary objects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-639/InsecureDirectObjectReference.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.UrlRedirectQuery\nimport UrlRedirect::PathGraph\n\nfrom UrlRedirect::PathNode source, UrlRedirect::PathNode sink\nwhere UrlRedirect::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Untrusted URL redirection due to $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-601/UrlRedirect.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.flowsources.FlowSources\nimport semmle.code.csharp.commons.Util\nimport AssemblyPathInjection::PathGraph\n\nmodule AssemblyPathInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall mc, string name, int arg |\n      mc.getTarget().getName().matches(name) and\n      mc.getTarget()\n          .getDeclaringType()\n          .getABaseType*()\n          .hasFullyQualifiedName(\"System.Reflection\", \"Assembly\") and\n      mc.getArgument(arg) = sink.asExpr()\n    |\n      name = \"LoadFrom\" and arg = 0 and mc.getNumberOfArguments() = [1 .. 2]\n      or\n      name = \"LoadFile\" and arg = 0\n      or\n      name = \"LoadWithPartialName\" and arg = 0\n      or\n      name = \"UnsafeLoadFrom\" and arg = 0\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule AssemblyPathInjection = TaintTracking::Global<AssemblyPathInjectionConfig>;\n\nfrom AssemblyPathInjection::PathNode source, AssemblyPathInjection::PathNode sink\nwhere AssemblyPathInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This assembly path depends on a $@.\", source,\n  \"user-provided value\"",
        "description": "Loading a .NET assembly based on a path constructed from user-controlled sources may allow a malicious user to load code which modifies the program in unintended ways.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-114/AssemblyPathInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.cryptography.HardcodedSymmetricEncryptionKey::HardcodedSymmetricEncryptionKey\nimport HardCodedSymmetricEncryption::PathGraph\n\nfrom HardCodedSymmetricEncryption::PathNode source, HardCodedSymmetricEncryption::PathNode sink\nwhere HardCodedSymmetricEncryption::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Hard-coded symmetric $@ is used in symmetric algorithm in \" +\n    sink.getNode().(Sink).getDescription() + \".\", source.getNode(), \"key\"",
        "description": "The .Key property or rgbKey parameter of a SymmetricAlgorithm should never be a hardcoded value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-321/HardcodedSymmetricEncryptionKey.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.cryptography.EncryptionKeyDataFlowQuery\nimport SymmetricKey::PathGraph\n\nclass ByteArrayLiteralSource extends KeySource {\n  ByteArrayLiteralSource() {\n    this.asExpr() =\n      any(ArrayCreation ac |\n        ac.getArrayType().getElementType() instanceof ByteType and\n        ac.hasInitializer()\n      )\n  }\n}\n\nclass StringLiteralSource extends KeySource {\n  StringLiteralSource() { this.asExpr() instanceof StringLiteral }\n}\n\nfrom\n  SymmetricKey::PathNode source, SymmetricKey::PathNode sink, KeySource srcNode,\n  SymmetricEncryptionKeySink sinkNode\nwhere\n  SymmetricKey::flowPath(source, sink) and\n  source.getNode() = srcNode and\n  sink.getNode() = sinkNode\nselect sink.getNode(), source, sink,\n  \"This hard-coded $@ is used in symmetric algorithm in \" + sinkNode.getDescription(), srcNode,\n  \"symmetric key\"",
        "description": "The .Key property or rgbKey parameter of a SymmetricAlgorithm should never be a hard-coded value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-321/HardcodedEncryptionKey.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\n\nfrom SystemWebServerXmlElement ws, XmlAttribute a\nwhere\n  ws.getAChild(\"directoryBrowse\").getAttribute(\"enabled\") = a and\n  a.getValue() = \"true\"\nselect a, \"Directory browsing is enabled in this ASP.NET configuration file.\"",
        "description": "Directory browsing should not be enabled in production as it can leak sensitive information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-548/ASPNetDirectoryListing.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.MissingXMLValidationQuery\nimport MissingXmlValidation::PathGraph\n\nfrom MissingXmlValidation::PathNode source, MissingXmlValidation::PathNode sink\nwhere MissingXmlValidation::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This XML processing depends on a $@ without validation because \" +\n    sink.getNode().(Sink).getReason(), source.getNode(), \"user-provided value\"",
        "description": "User input should not be processed as XML without validating it against a known schema.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-112/MissingXMLValidation.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport InsecureSqlConnection::PathGraph\n\nmodule InsecureSqlConnectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(string s | s = source.asExpr().(StringLiteral).getValue().toLowerCase() |\n      s.matches(\"%encrypt=false%\")\n      or\n      not s.matches(\"%encrypt=%\")\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(ObjectCreation oc |\n      oc.getRuntimeArgument(0) = sink.asExpr() and\n      (\n        oc.getType().getName() = \"SqlConnectionStringBuilder\"\n        or\n        oc.getType().getName() = \"SqlConnection\"\n      ) and\n      not exists(MemberInitializer mi |\n        mi = oc.getInitializer().(ObjectInitializer).getAMemberInitializer() and\n        mi.getLValue().(PropertyAccess).getTarget().getName() = \"Encrypt\" and\n        mi.getRValue().(BoolLiteral).getValue() = \"true\"\n      )\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule InsecureSqlConnection = DataFlow::Global<InsecureSqlConnectionConfig>;\n\nfrom InsecureSqlConnection::PathNode source, InsecureSqlConnection::PathNode sink\nwhere InsecureSqlConnection::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"$@ flows to this SQL connection and does not specify `Encrypt=True`.\", source.getNode(),\n  \"Connection string\"",
        "description": "Using an SQL Server connection without enforcing encryption is a security vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-327/InsecureSQLConnection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.dataflow.DataFlow::DataFlow\nimport AddCertToRootStore::PathGraph\n\nmodule AddCertToRootStoreConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(ObjectCreation oc | oc = source.asExpr() |\n      oc.getType()\n          .(RefType)\n          .hasFullyQualifiedName(\"System.Security.Cryptography.X509Certificates\", \"X509Store\") and\n      oc.getArgument(0).(Access).getTarget().hasName(\"Root\")\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall mc |\n      (\n        mc.getTarget()\n            .hasFullyQualifiedName(\"System.Security.Cryptography.X509Certificates\", \"X509Store\",\n              \"Add\") or\n        mc.getTarget()\n            .hasFullyQualifiedName(\"System.Security.Cryptography.X509Certificates\", \"X509Store\",\n              \"AddRange\")\n      ) and\n      sink.asExpr() = mc.getQualifier()\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node sink) { none() }\n}\n\nmodule AddCertToRootStore = DataFlow::Global<AddCertToRootStoreConfig>;\n\nfrom AddCertToRootStore::PathNode oc, AddCertToRootStore::PathNode mc\nwhere AddCertToRootStore::flowPath(oc, mc)\nselect mc.getNode(), oc, mc, \"This certificate is added to the root certificate store.\"",
        "description": "Application- or user-specific certificates placed in the system root store could weaken security for other processing running on the same system.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-327/DontInstallRootCert.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.ExposureOfPrivateInformationQuery\nimport ExposureOfPrivateInformation::PathGraph\n\nfrom ExposureOfPrivateInformation::PathNode source, ExposureOfPrivateInformation::PathNode sink\nwhere ExposureOfPrivateInformation::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Private data returned by $@ is written to an external location.\", source.getNode(),\n  source.getNode().toString()",
        "description": "If private information is written to an external location, it may be accessible by unauthorized persons.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-359/ExposureOfPrivateInformation.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.auth.MissingFunctionLevelAccessControlQuery\n\nfrom Method m\nwhere missingAuth(m)\nselect m, \"This action is missing an authorization check.\"",
        "description": "Sensitive actions should have authorization checks to prevent them from being used by malicious actors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-285/MissingAccessControl.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\nimport semmle.code.csharp.frameworks.system.Web\n\n// the query is a subset of `cs/web/cookie-secure-not-set` and\n// should be removed once it is promoted from experimental\nfrom XmlElement element\nwhere\n  element instanceof FormsElement and\n  not element.(FormsElement).isRequireSsl()\n  or\n  element instanceof HttpCookiesElement and\n  not element.(HttpCookiesElement).isRequireSsl() and\n  not any(SystemWebHttpCookie c).getSecureProperty().getAnAssignedValue().getValue() = \"true\"\nselect element, \"The 'requireSSL' attribute is not set to 'true'.\"",
        "description": "Omitting the 'requireSSL' attribute allows data to be transmitted insecurely using HTTP. Always set 'requireSSL' to 'true' to ensure that HTTPS is used at all times.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-614/RequireSSL.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.SqlInjectionQuery\nimport SqlInjection::PathGraph\nimport semmle.code.csharp.security.dataflow.flowsources.FlowSources\n\nstring getSourceType(DataFlow::Node node) { result = node.(SourceNode).getSourceType() }\n\nfrom SqlInjection::PathNode source, SqlInjection::PathNode sink\nwhere SqlInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This query depends on $@.\", source,\n  (\"this \" + getSourceType(source.getNode()))",
        "description": "Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-089/SqlInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\n\nclass Application_Error extends Method {\n  Application_Error() {\n    this.hasName(\"Application_Error\") and\n    this.getFile().getBaseName().toLowerCase() = \"global.asax.cs\" and\n    this.hasNonEmptyBody()\n  }\n}\n\nfrom CustomErrorsXmlElement customError\nwhere\n  // `<customErrors>` must be set to \"off\" to be dangerous\n  customError.getAttributeValue(\"mode\").toLowerCase() = \"off\" and\n  // There must not be an error handler in global.asax\n  not exists(Application_Error ae)\nselect customError,\n  \"'customErrors' mode set to off in Web.config, and no 'Application_Error' handler specified in the global.asax file.\"",
        "description": "ASP.NET applications should not set the 'customError' mode to \"off\" without providing a global error handler, otherwise they may leak exception information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-248/MissingASPNETGlobalErrorHandler.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.QualifiedName\nimport semmle.code.csharp.security.dataflow.ExternalAPIsQuery\nimport RemoteSourceToExternalApi::PathGraph\n\nfrom\n  RemoteSourceToExternalApi::PathNode source, RemoteSourceToExternalApi::PathNode sink,\n  string qualifier, string name\nwhere\n  RemoteSourceToExternalApi::flowPath(source, sink) and\n  sink.getNode().(ExternalApiDataNode).hasQualifiedName(qualifier, name)\nselect sink, source, sink,\n  \"Call to \" + getQualifiedName(qualifier, name) + \" with untrusted data from $@.\", source,\n  source.toString()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-020/UntrustedDataToExternalAPI.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.csharp.serialization.Serialization\nimport semmle.code.csharp.controlflow.Guards\nimport semmle.code.csharp.dataflow.DataFlow\n\nGuardedExpr checkedWrite(Field f, Variable v, IfStmt check) {\n  result = v.getAnAccess() and\n  result = f.getAnAssignedValue() and\n  check.getCondition().getAChildExpr*() = result.getAGuard(_, _)\n}\n\npragma[nomagic]\nExpr uncheckedWrite(Callable callable, Field f) {\n  result = f.getAnAssignedValue() and\n  result.getEnclosingCallable() = callable and\n  not callable.calls*(checkedWrite(f, _, _).getEnclosingCallable()) and\n  // Exclude object creations because they were not deserialized\n  not exists(Expr src | DataFlow::localExprFlow(src, result) |\n    src instanceof ObjectCreation or src.hasValue()\n  )\n}\n\nfrom BinarySerializableType t, Field f, IfStmt check, Expr write, Expr unsafeWrite\nwhere\n  f = t.getASerializedField() and\n  write = checkedWrite(f, t.getAConstructor().getAParameter(), check) and\n  unsafeWrite = uncheckedWrite(t.getADeserializationCallback(), f)\nselect unsafeWrite, \"This write to $@ may be circumventing a $@.\", f, f.toString(), check, \"check\"",
        "description": "A write that looks like it may be bypassing runtime checks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-020/RuntimeChecksBypass.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.ExternalAPIsQuery\n\nfrom ExternalApiUsedWithUntrustedData externalApi\nselect externalApi, count(externalApi.getUntrustedDataNode()) as numberOfUses,\n  externalApi.getNumberOfUntrustedSources() as numberOfUntrustedSources order by\n    numberOfUntrustedSources desc",
        "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-020/ExternalAPIsUsedWithUntrustedData.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\n\nfrom SystemWebXmlElement web, XmlAttribute debugAttribute\nwhere\n  exists(CompilationXmlElement compilation | compilation.getParent() = web |\n    debugAttribute = compilation.getAttribute(\"debug\") and\n    not debugAttribute.getValue().toLowerCase() = \"false\"\n  ) and\n  not exists(\n    TransformXmlAttribute attribute, CompilationXmlElement compilation,\n    WebConfigReleaseTransformXml file\n  |\n    compilation = attribute.getElement() and\n    file = compilation.getFile() and\n    attribute.getRemoveAttributes() = \"debug\" and\n    file.getParentContainer() = web.getFile().getParentContainer()\n  )\nselect debugAttribute, \"The 'debug' flag is set for an ASP.NET configuration file.\"",
        "description": "ASP.NET projects should not produce debug binaries when deploying to production as debug builds provide additional information useful to a malicious attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-011/ASPNetDebug.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\n\nfrom SystemWebXmlElement web, XmlAttribute maxReqLength\nwhere\n  maxReqLength =\n    web.getAChild(any(string s | s.toLowerCase() = \"httpruntime\"))\n        .getAttribute(any(string s | s.toLowerCase() = \"maxrequestlength\")) and\n  maxReqLength.getValue().toInt() > 4096\nselect maxReqLength, \"Large 'maxRequestLength' value (\" + maxReqLength.getValue() + \" KB).\"",
        "description": "Setting a large 'maxRequestLength' value may render a webpage vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-016/ASPNetMaxRequestLength.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.asp.WebConfig\n\nfrom SystemWebXmlElement web, XmlAttribute requestvalidateAttribute\nwhere\n  requestvalidateAttribute = web.getAChild(\"pages\").getAttribute(\"validateRequest\") and\n  requestvalidateAttribute.getValue().toLowerCase() = \"false\"\nselect requestvalidateAttribute, \"The 'validateRequest' attribute is set to 'false'.\"",
        "description": "ASP.NET pages should not disable the built-in request validation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-016/ASPNetPagesValidateRequest.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom XmlAttribute reqValidationMode\nwhere\n  reqValidationMode.getName().toLowerCase() = \"requestvalidationmode\" and\n  reqValidationMode.getValue().toFloat() < 4.5\nselect reqValidationMode,\n  \"Insecure value for requestValidationMode (\" + reqValidationMode.getValue() + \").\"",
        "description": "Setting 'requestValidationMode' to less than 4.5 disables built-in validations included by default in ASP.NET. Disabling or downgrading this protection is not recommended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-016/ASPNetRequestValidationMode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.ResourceInjectionQuery\nimport ResourceInjection::PathGraph\n\nfrom ResourceInjection::PathNode source, ResourceInjection::PathNode sink\nwhere ResourceInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This resource descriptor depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a resource descriptor from untrusted user input is vulnerable to a malicious user providing an unintended resource.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-099/ResourceInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.LDAPInjectionQuery\nimport LdapInjection::PathGraph\n\nfrom LdapInjection::PathNode source, LdapInjection::PathNode sink\nwhere LdapInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This LDAP query depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-090/LDAPInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.flowsources.FlowSources\nimport semmle.code.csharp.frameworks.system.Xml\nimport XmlInjection::PathGraph\n\nmodule XmlInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall mc |\n      mc.getTarget().hasName(\"WriteRaw\") and\n      mc.getTarget()\n          .getDeclaringType()\n          .getABaseType*()\n          .hasFullyQualifiedName(\"System.Xml\", \"XmlWriter\")\n    |\n      mc.getArgument(0) = sink.asExpr()\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    exists(MethodCall mc |\n      mc.getTarget().hasName(\"Escape\") and\n      mc.getTarget()\n          .getDeclaringType()\n          .getABaseType*()\n          .hasFullyQualifiedName(\"System.Security\", \"SecurityElement\")\n    |\n      mc = node.asExpr()\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule XmlInjection = TaintTracking::Global<XmlInjectionConfig>;\n\nfrom XmlInjection::PathNode source, XmlInjection::PathNode sink\nwhere XmlInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This XML element depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an XML document from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-091/XMLInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.controlflow.Guards\n\nfrom AddExpr add, VirtualMethodCall taintSrc\nwhere\n  // `add` is performing pointer arithmetic\n  add.getType() instanceof PointerType and\n  // one of the operands comes, in zero or more steps, from a virtual method call\n  DataFlow::localExprFlow(taintSrc, add.getAnOperand()) and\n  // virtual method call result has not been validated\n  not exists(Expr check, ComparisonOperation cmp | DataFlow::localExprFlow(taintSrc, check) |\n    cmp.getAnOperand() = check and\n    add.getAnOperand().(GuardedExpr).isGuardedBy(cmp, check, _)\n  )\nselect add, \"Unvalidated pointer arithmetic from virtual method $@.\", taintSrc,\n  taintSrc.getTarget().getName()",
        "description": "Using the result of a virtual method call in pointer arithmetic without validation is dangerous because the method may be overridden by a subtype to return any value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-119/LocalUnvalidatedArithmetic.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.LogForgingQuery\nimport LogForging::PathGraph\n\nfrom LogForging::PathNode source, LogForging::PathNode sink\nwhere LogForging::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This log entry depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-117/LogForging.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.web.Security\n\npredicate loginMethod(Method m, ControlFlow::SuccessorType flowFrom) {\n  (\n    m = any(SystemWebSecurityMembershipClass c).getValidateUserMethod()\n    or\n    m = any(SystemWebSecurityFormsAuthenticationClass c).getAuthenticateMethod()\n  ) and\n  flowFrom.(ControlFlow::BooleanSuccessor).getValue() = true\n  or\n  m = any(SystemWebSecurityFormsAuthenticationClass c).getSignOutMethod() and\n  flowFrom instanceof ControlFlow::DirectSuccessor\n}\n\nclass SystemWebSessionStateHttpSessionStateClass extends Class {\n  SystemWebSessionStateHttpSessionStateClass() {\n    this.hasFullyQualifiedName(\"System.Web.SessionState\", \"HttpSessionState\")\n  }\n\n  /** Gets the `Abandon` method. */\n  Method getAbandonMethod() { result = this.getAMethod(\"Abandon\") }\n\n  /** Gets the `Clear` method. */\n  Method getClearMethod() { result = this.getAMethod(\"Clear\") }\n}\n\npredicate sessionEndMethod(Method m) {\n  exists(SystemWebSessionStateHttpSessionStateClass ss |\n    m = ss.getAbandonMethod() or m = ss.getClearMethod()\n  )\n  or\n  exists(Method r | m.calls(r) and sessionEndMethod(r))\n}\n\npredicate sessionUse(MemberAccess ma) {\n  ma.getType() instanceof SystemWebSessionStateHttpSessionStateClass and\n  not exists(MethodCall end | end.getQualifier() = ma and sessionEndMethod(end.getTarget()))\n}\n\npredicate controlStep(ControlFlow::Node s1, ControlFlow::Node s2) {\n  s2 = s1.getASuccessor() and\n  not sessionEndMethod(s2.getAstNode().(MethodCall).getTarget())\n}\n\nfrom\n  ControlFlow::Node loginCall, Method loginMethod, ControlFlow::Node sessionUse,\n  ControlFlow::SuccessorType fromLoginFlow\nwhere\n  loginMethod = loginCall.getAstNode().(MethodCall).getTarget() and\n  loginMethod(loginMethod, fromLoginFlow) and\n  sessionUse(sessionUse.getAstNode()) and\n  controlStep+(loginCall.getASuccessorByType(fromLoginFlow), sessionUse)\nselect sessionUse, \"This session has not been invalidated following the call to $@.\", loginCall,\n  loginMethod.getName()",
        "description": "Reusing an existing session as a different user could allow an attacker to access someone else's account by using their session.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-384/AbandonSession.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.CleartextStorageQuery\nimport ClearTextStorage::PathGraph\n\nfrom ClearTextStorage::PathNode source, ClearTextStorage::PathNode sink\nwhere ClearTextStorage::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This stores sensitive data returned by $@ as clear text.\",\n  source.getNode(), source.toString()",
        "description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-312/CleartextStorage.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.Data\nimport semmle.code.csharp.security.dataflow.HardcodedCredentialsQuery\nimport ConnectionString::PathGraph\n\nclass ConnectionStringPasswordOrUsername extends NonEmptyStringLiteral {\n  ConnectionStringPasswordOrUsername() {\n    this.getExpr().getValue().regexpMatch(\"(?i).*(Password|PWD|User Id|UID)=.+\")\n  }\n}\n\nmodule ConnectionStringConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ConnectionStringPasswordOrUsername }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink.asExpr() =\n      any(SystemDataConnectionClass connection).getConnectionStringProperty().getAnAssignedValue()\n  }\n\n  predicate isBarrier(DataFlow::Node node) { node instanceof StringFormatSanitizer }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    any(Call call | call.getAnArgument() = sink.asExpr()).getLocation() = result\n  }\n}\n\nmodule ConnectionString = TaintTracking::Global<ConnectionStringConfig>;\n\nfrom ConnectionString::PathNode source, ConnectionString::PathNode sink\nwhere ConnectionString::flowPath(source, sink)\nselect source.getNode(), source, sink,\n  \"'ConnectionString' property includes hard-coded credentials set in $@.\",\n  any(Call call | call.getAnArgument() = sink.getNode().asExpr()) as call, call.toString()",
        "description": "Credentials are hard-coded in a connection string in the source code of the application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-798/HardcodedConnectionString.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.HardcodedCredentialsQuery\nimport HardcodedCredentials::PathGraph\n\nfrom\n  Source source, Sink sink, HardcodedCredentials::PathNode sourcePath,\n  HardcodedCredentials::PathNode sinkPath, string value\nwhere\n  source = sourcePath.getNode() and\n  sink = sinkPath.getNode() and\n  HardcodedCredentials::flowPath(sourcePath, sinkPath) and\n  // Print the source value if it's available\n  if exists(source.asExpr().getValue())\n  then value = \"The hard-coded value \\\"\" + source.asExpr().getValue() + \"\\\"\"\n  else value = \"This hard-coded value\"\nselect source, sourcePath, sinkPath, value + \" flows to \" + sink.getSinkDescription() + \".\", sink,\n  sink.getSinkName(), sink.getSupplementaryElement(), sink.getSupplementaryElement().toString()",
        "description": "Credentials are hard coded in the source code of the application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-798/HardcodedCredentials.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.flowsources.FlowSources\nimport semmle.code.csharp.frameworks.Format\nimport FormatString::PathGraph\n\nmodule FormatStringConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink.asExpr() = any(FormatStringParseCall call).getFormatExpr()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule FormatString = TaintTracking::Global<FormatStringConfig>;\n\nstring getSourceType(DataFlow::Node node) { result = node.(SourceNode).getSourceType() }\n\nfrom FormatString::PathNode source, FormatString::PathNode sink\nwhere FormatString::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This format string depends on $@.\", source.getNode(),\n  (\"this\" + getSourceType(source.getNode()))",
        "description": "Passing untrusted format strings from remote data sources can throw exceptions and cause a denial of service.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-134/UncontrolledFormatString.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.Web\nimport semmle.code.csharp.frameworks.system.web.Helpers\nimport semmle.code.csharp.frameworks.system.web.Mvc\n\nprivate Method getAValidatingMethod() {\n  result = any(AntiForgeryClass a).getValidateMethod()\n  or\n  result.calls(getAValidatingMethod())\n}\n\nclass AntiForgeryAuthorizationFilter extends AuthorizationFilter {\n  AntiForgeryAuthorizationFilter() { this.getOnAuthorizationMethod() = getAValidatingMethod() }\n}\n\nprivate Method getAStartedMethod() {\n  result = any(WebApplication wa).getApplication_StartMethod()\n  or\n  getAStartedMethod().calls(result)\n}\n\npredicate hasGlobalAntiForgeryFilter() {\n  // A global filter added\n  exists(MethodCall addGlobalFilter |\n    // addGlobalFilter adds a filter to the global filter collection\n    addGlobalFilter.getTarget() = any(GlobalFilterCollection gfc).getAddMethod() and\n    // The filter is an antiforgery filter\n    addGlobalFilter.getArgumentForName(\"filter\").getType() instanceof AntiForgeryAuthorizationFilter and\n    // The filter is added by the Application_Start() method\n    getAStartedMethod() = addGlobalFilter.getEnclosingCallable()\n  )\n}\n\nfrom Controller c, Method postMethod\nwhere\n  postMethod = c.getAPostActionMethod() and\n  // The method is not protected by a validate anti forgery token attribute\n  not postMethod.getAnAttribute() instanceof ValidateAntiForgeryTokenAttribute and\n  not c.getAnAttribute() instanceof ValidateAntiForgeryTokenAttribute and\n  // Verify that validate anti forgery token attributes are used somewhere within this project, to\n  // avoid reporting false positives on projects that use an alternative approach to mitigate CSRF\n  // issues.\n  exists(ValidateAntiForgeryTokenAttribute a, Element e | e = a.getTarget()) and\n  // Also ignore cases where a global anti forgery filter is in use.\n  not hasGlobalAntiForgeryFilter()\nselect postMethod,\n  \"Method '\" + postMethod.getName() +\n    \"' handles a POST request without performing CSRF token validation.\"",
        "description": "Handling a POST request without verifying that the request came from the user allows a malicious attacker to submit a request on behalf of the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-352/MissingAntiForgeryTokenValidation.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.UnsafeDeserializationQuery\n\nfrom Call deserializeCall, Sink sink\nwhere deserializeCall.getAnArgument() = sink.asExpr()\nselect deserializeCall,\n  \"Unsafe deserializer is used. Make sure the value being deserialized comes from a trusted source.\"",
        "description": "Calling an unsafe deserializer with data controlled by an attacker can lead to denial of service and other security problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-502/UnsafeDeserialization.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.UnsafeDeserializationQuery\nimport Flow::PathGraph\n\nbindingset[e1, e2]\npragma[inline_late]\nprivate predicate sameParent(DataFlow::Node e1, DataFlow::Node e2) {\n  e1.asExpr().getParent() = e2.asExpr().getParent()\n}\n\nmodule Flow =\n  DataFlow::MergePathGraph3<TaintToObjectMethodTracking::PathNode,\n    TaintToConstructorOrStaticMethodTracking::PathNode, JsonConvertTracking::PathNode,\n    TaintToObjectMethodTracking::PathGraph, TaintToConstructorOrStaticMethodTracking::PathGraph,\n    JsonConvertTracking::PathGraph>;\n\nfrom Flow::PathNode userInput, Flow::PathNode deserializeCallArg\nwhere\n  // all flows from user input to deserialization with weak and strong type serializers\n  TaintToObjectMethodTracking::flowPath(userInput.asPathNode1(), deserializeCallArg.asPathNode1()) and\n  // intersect with strong types, but user controlled or weak types deserialization usages\n  (\n    exists(DataFlow::Node weakTypeUsage, MethodCall mc |\n      WeakTypeCreationToUsageTracking::flowTo(weakTypeUsage) and\n      mc.getQualifier() = weakTypeUsage.asExpr() and\n      mc.getAnArgument() = deserializeCallArg.getNode().asExpr()\n    )\n    or\n    exists(DataFlow::Node taintedTypeUsage, MethodCall mc |\n      TaintToObjectTypeTracking::flowTo(taintedTypeUsage) and\n      mc.getQualifier() = taintedTypeUsage.asExpr() and\n      mc.getAnArgument() = deserializeCallArg.getNode().asExpr()\n    )\n  )\n  or\n  // no type check needed - straightforward taint -> sink\n  TaintToConstructorOrStaticMethodTracking::flowPath(userInput.asPathNode2(),\n    deserializeCallArg.asPathNode2())\n  or\n  // JsonConvert static method call, but with additional unsafe typename tracking\n  exists(DataFlow::Node settingsCallArg |\n    JsonConvertTracking::flowPath(userInput.asPathNode3(), deserializeCallArg.asPathNode3()) and\n    TypeNameTracking::flow(_, settingsCallArg) and\n    sameParent(deserializeCallArg.getNode(), settingsCallArg)\n  )\nselect deserializeCallArg, userInput, deserializeCallArg, \"$@ flows to unsafe deserializer.\",\n  userInput, \"User-provided data\"",
        "description": "Calling an unsafe deserializer with data controlled by an attacker can lead to denial of service and other security problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-502/UnsafeDeserializationUntrustedInput.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.linq.Expressions\nimport semmle.code.csharp.serialization.Deserializers\n\nfrom Call deserialization, Cast cast\nwhere\n  deserialization.getTarget() instanceof UnsafeDeserializer and\n  cast.getExpr() = deserialization and\n  cast.getTargetType() instanceof SystemLinqExpressions::DelegateExtType\nselect deserialization, \"Deserialization of delegate type.\"",
        "description": "Deserializing a delegate allows for remote code execution when an attacker can control the serialized data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-502/DeserializedDelegate.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.RegexInjectionQuery\nimport semmle.code.csharp.frameworks.system.text.RegularExpressions\nimport RegexInjection::PathGraph\n\nfrom RegexInjection::PathNode source, RegexInjection::PathNode sink\nwhere\n  RegexInjection::flowPath(source, sink) and\n  // No global timeout set\n  not exists(RegexGlobalTimeout r)\nselect sink.getNode(), source, sink, \"This regular expression is constructed from a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-730/RegexInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.ReDoSQuery\nimport semmle.code.csharp.frameworks.system.text.RegularExpressions\nimport ReDoS::PathGraph\n\nfrom ReDoS::PathNode source, ReDoS::PathNode sink\nwhere\n  ReDoS::flowPath(source, sink) and\n  // No global timeout set\n  not exists(RegexGlobalTimeout r) and\n  (\n    sink.getNode() instanceof Sink\n    or\n    sink.getNode() instanceof ExponentialRegexSink\n  )\nselect sink.getNode(), source, sink,\n  \"This regex operation with dangerous complexity depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "User input should not be matched against a regular expression that could require exponential time on certain input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-730/ReDoS.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.ZipSlipQuery\nimport ZipSlip::PathGraph\n\nfrom ZipSlip::PathNode source, ZipSlip::PathNode sink\nwhere ZipSlip::flowPath(source, sink)\nselect source.getNode(), source, sink,\n  \"Unsanitized archive entry, which may contain '..', is used in a $@.\", sink.getNode(),\n  \"file system operation\"",
        "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-022/ZipSlip.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.TaintedPathQuery\nimport TaintedPath::PathGraph\n\nfrom TaintedPath::PathNode source, TaintedPath::PathNode sink\nwhere TaintedPath::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-022/TaintedPath.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.XMLEntityInjectionQuery\nimport XmlEntityInjection::PathGraph\n\nfrom XmlEntityInjection::PathNode source, XmlEntityInjection::PathNode sink\nwhere XmlEntityInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This insecure XML processing depends on a $@ (\" + sink.getNode().(Sink).getReason() + \").\",\n  source.getNode(), \"user-provided value\"",
        "description": "Untrusted XML is read with an insecure resolver and DTD processing enabled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-611/UntrustedDataInsecureXml.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.xml.InsecureXMLQuery\n\nfrom InsecureXmlProcessing xmlProcessing, string reason\nwhere xmlProcessing.isUnsafe(reason)\nselect xmlProcessing, \"Insecure XML processing: \" + reason",
        "description": "XML may include dangerous external references, which should be restricted using a secure resolver or disabling DTD processing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-611/UseXmlSecureResolver.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.CommandInjectionQuery\nimport CommandInjection::PathGraph\n\nfrom CommandInjection::PathNode source, CommandInjection::PathNode sink\nwhere CommandInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This command line depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-078/CommandInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.XPathInjectionQuery\nimport XpathInjection::PathGraph\n\nfrom XpathInjection::PathNode source, XpathInjection::PathNode sink\nwhere XpathInjection::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This XPath expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-643/XPathInjection.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.XSSQuery\nimport PathGraph\n\nfrom XssNode source, XssNode sink, string message\nwhere xssFlow(source, sink, message)\nselect sink, source, sink, \"$@ flows to here and \" + message, source, \"User-provided value\"",
        "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Security Features/CWE-079/XSS.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom MethodCall c, Method gcCollect\nwhere\n  c.getTarget() = gcCollect and\n  gcCollect.hasName(\"Collect\") and\n  gcCollect.hasNoParameters() and\n  gcCollect.getDeclaringType().hasFullyQualifiedName(\"System\", \"GC\")\nselect c, \"Call to 'GC.Collect()'.\"",
        "description": "Explicit requests for garbage collection often indicate performance problems and memory leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/CallToGCCollect.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom Class c, Method present, string missing\nwhere\n  c.isSourceDeclaration() and\n  (\n    present = c.getAMethod().(EqualsMethod) and\n    not c.getAMethod() instanceof GetHashCodeMethod and\n    missing = \"GetHashCode()\"\n    or\n    present = c.getAMethod().(GetHashCodeMethod) and\n    not implementsEquals(c) and\n    missing = \"Equals(object)\"\n  )\nselect c, \"Class '\" + c.getName() + \"' overrides $@, but not \" + missing + \".\", present,\n  present.getName()",
        "description": "If a class overrides only one of 'Equals(object)' and 'GetHashCode()', it may mean that 'Equals(object)' and 'GetHashCode()' are inconsistent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/InconsistentEqualsGetHashCode.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.QualifiedName\n\nprivate predicate potentialOverride(Method vm, Method m) {\n  vm.getDeclaringType() = m.getDeclaringType().getBaseClass+()\n}\n\npredicate nonOverridingMethod(Method m, Method vm) {\n  vm.isVirtual() and\n  not vm.isOverride() and\n  not vm.overrides() and\n  potentialOverride(vm, m) and\n  not m.overrides() and\n  not m.isOverride() and\n  not m.isNew() and\n  m.isUnboundDeclaration() and\n  m.getNumberOfParameters() = vm.getNumberOfParameters() and\n  forall(int i, Parameter p1, Parameter p2 | p1 = m.getParameter(i) and p2 = vm.getParameter(i) |\n    p1.getType() = p2.getType()\n  ) and\n  m.getName().toLowerCase() = vm.getName().toLowerCase()\n}\n\nfrom Method m, Method vm, string namespace, string type, string name\nwhere\n  m.fromSource() and\n  nonOverridingMethod(m, vm) and\n  vm.hasFullyQualifiedName(namespace, type, name)\nselect m, \"Method '\" + m.getName() + \"' looks like it should override $@ but does not do so.\",\n  vm.getUnboundDeclaration(), getQualifiedName(namespace, type, name)",
        "description": "A method looks like it should override a virtual method from a base type, but does not actually do so.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/NonOverridingMethod.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass ObsoleteAttribute extends Attribute {\n  ObsoleteAttribute() { this.getType().hasFullyQualifiedName(\"System\", \"ObsoleteAttribute\") }\n}\n\nfrom MethodCall c, Method m\nwhere\n  m = c.getTarget() and\n  m.getAnAttribute() instanceof ObsoleteAttribute and\n  not c.getEnclosingCallable().(Attributable).getAnAttribute() instanceof ObsoleteAttribute\nselect c, \"Call to obsolete method $@.\", m, m.getName()",
        "description": "Calls to methods marked as [Obsolete] should be replaced because the method is no longer maintained and may be removed in the future.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/CallToObsoleteMethod.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ValueOrRefType c\nwhere\n  c.fromSource() and\n  c.getABaseInterface+().hasFullyQualifiedName(\"System\", \"ICloneable\") and\n  not c.isSealed() and\n  exists(Method m | m.getDeclaringType() = c and m.hasName(\"Clone\"))\nselect c, \"Class '\" + c.getName() + \"' implements 'ICloneable'.\"",
        "description": "Implementing 'ICloneable' is discouraged due to its imprecise semantics and its viral effect on your code base.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/ClassImplementsICloneable.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\npredicate implementsIComparable(ValueOrRefType t, Type paramType) {\n  exists(ConstructedType ct | t.getABaseType+() = ct |\n    ct = any(SystemIComparableTInterface i).getAConstructedGeneric() and\n    paramType = ct.getATypeArgument()\n  )\n  or\n  t instanceof SystemIComparableTInterface\n  or\n  t.getABaseType*() instanceof SystemIComparableInterface and\n  paramType instanceof ObjectType\n}\n\npredicate compareToMethod(Method m, Type paramType) {\n  m.hasName(\"CompareTo\") and\n  m.fromSource() and\n  m.isPublic() and\n  m.getReturnType() instanceof IntType and\n  m.getNumberOfParameters() = 1 and\n  paramType = m.getAParameter().getType()\n}\n\nfrom Method m, RefType declaringType, Type actualParamType, string paramTypeName\nwhere\n  m.isSourceDeclaration() and\n  declaringType = m.getDeclaringType() and\n  compareToMethod(m, actualParamType) and\n  not implementsIComparable(declaringType, actualParamType) and\n  paramTypeName = actualParamType.getName()\nselect m,\n  \"The parameter of this 'CompareTo' method is of type '\" + paramTypeName +\n    \"', but the declaring type does not implement 'IComparable<\" + paramTypeName + \">'.\"",
        "description": "The declaring type of a method with signature `CompareTo(T)` does not implement `IComparable<T>`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/IncorrectCompareToSignature.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.IO\nimport semmle.code.csharp.Chaining\n\npredicate important(Method m) {\n  exists(Method read | read = any(SystemIOStreamClass c).getReadMethod() |\n    m = read.getAnOverrider*()\n  )\n  or\n  exists(Method readByte | readByte = any(SystemIOStreamClass c).getReadByteMethod() |\n    m = readByte.getAnOverrider*()\n  )\n  // add more ...\n}\n\npredicate methodHasGenericReturnType(ConstructedMethod cm) {\n  exists(UnboundGenericMethod ugm |\n    ugm = cm.getUnboundGeneric() and\n    ugm.getReturnType() = ugm.getATypeParameter()\n  )\n}\n\n// statistically dubious:\npredicate dubious(Method m, int percentage) {\n  not important(m) and\n  // Suppress on Void methods\n  not m.getReturnType() instanceof VoidType and\n  // Suppress on methods designed for chaining\n  not designedForChaining(m) and\n  exists(int used, int total, Method target |\n    target = m.getUnboundDeclaration() and\n    used =\n      count(MethodCall mc |\n        mc.getTarget().getUnboundDeclaration() = target and\n        not mc instanceof DiscardedMethodCall and\n        (methodHasGenericReturnType(m) implies m.getReturnType() = mc.getTarget().getReturnType())\n      ) and\n    total =\n      count(MethodCall mc |\n        mc.getTarget().getUnboundDeclaration() = target and\n        (methodHasGenericReturnType(m) implies m.getReturnType() = mc.getTarget().getReturnType())\n      ) and\n    used != total and\n    percentage = used * 100 / total and\n    percentage >= 90 and\n    chainedUses(m) * 100 / total <= 45 // no more than 45% of calls to this method are chained\n  )\n}\n\nint chainedUses(Method m) {\n  result =\n    count(MethodCall mc, MethodCall qual |\n      m = mc.getTarget() and\n      hasQualifierAndTarget(mc, qual, qual.getTarget())\n    )\n}\n\npredicate hasQualifierAndTarget(MethodCall mc, Expr qualifier, Method m) {\n  qualifier = mc.getQualifier() and\n  m = mc.getTarget()\n}\n\npredicate whitelist(Method m) {\n  m.hasName(\"TryGetValue\")\n  or\n  m.hasName(\"TryParse\")\n  or\n  exists(Namespace n | n = m.getDeclaringType().getNamespace().getParentNamespace*() |\n    n.getName().regexpMatch(\"(Fluent)?NHibernate\") or\n    n.getName() = \"Moq\"\n  )\n  // add more ...\n}\n\nclass DiscardedMethodCall extends MethodCall {\n  DiscardedMethodCall() {\n    this.getParent() instanceof ExprStmt\n    or\n    exists(Callable c |\n      this = c.getExpressionBody() and\n      not c.canReturn(this)\n    )\n  }\n\n  string query() {\n    exists(Method m |\n      m = this.getTarget() and\n      not whitelist(m) and\n      // Do not alert on \"void wrapper methods\", i.e., methods that are inserted\n      // to deliberately ignore the returned value\n      not this.getEnclosingCallable().getStatementBody().getNumberOfStmts() = 1\n    |\n      important(m) and result = \"should always be checked\"\n      or\n      exists(int percentage | dubious(m, percentage) |\n        result = percentage.toString() + \"% of calls to this method have their result used\"\n      )\n    )\n  }\n}\n\nfrom DiscardedMethodCall dmc, string message\nwhere message = dmc.query()\nselect dmc, \"Result of call to '\" + dmc.getTarget().getName() + \"' is ignored, but \" + message + \".\"",
        "description": "If most of the calls to a method use the return value of that method, the calls that do not check the return value may be mistakes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/UncheckedReturnValue.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Dispose\nimport semmle.code.csharp.frameworks.System\n\nfrom DisposableType t, DisposableField f, Method dispose\nwhere\n  f.getDeclaringType() = t and\n  not f.isStatic() and\n  t.isSourceDeclaration() and\n  dispose = getInvokedDisposeMethod(t) and\n  dispose.getDeclaringType() = t and\n  not exists(MethodCall mc |\n    mc.getTarget() instanceof DisposeMethod and\n    mc.getQualifier() = f.getAnAccess() and\n    mc.getEnclosingCallable() = dispose\n  )\nselect dispose, \"This 'Dispose()' method does not call 'Dispose()' on `IDisposable` field $@.\", f,\n  f.getName()",
        "description": "Classes that implement 'IDisposable' and have members of 'IDisposable' type should dispose those members in their 'Dispose()' method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/MissingDisposeCall.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.Text\nimport semmle.code.csharp.frameworks.Format\nimport FormatFlow::PathGraph\n\nmodule FormatInvalidConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node n) { n.asExpr() instanceof StringLiteral }\n\n  predicate isSink(DataFlow::Node n) {\n    exists(FormatStringParseCall c | n.asExpr() = c.getFormatExpr())\n  }\n}\n\nmodule FormatInvalid = DataFlow::Global<FormatInvalidConfig>;\n\nmodule FormatLiteralConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node n) { n.asExpr() instanceof StringLiteral }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    // Add flow via `System.Text.CompositeFormat.Parse`.\n    exists(ParseFormatStringCall call |\n      pred.asExpr() = call.getFormatExpr() and\n      succ.asExpr() = call\n    )\n  }\n\n  predicate isSink(DataFlow::Node n) { exists(FormatCall c | n.asExpr() = c.getFormatExpr()) }\n}\n\nmodule FormatLiteral = DataFlow::Global<FormatLiteralConfig>;\n\nmodule FormatFlow =\n  DataFlow::MergePathGraph<FormatInvalid::PathNode, FormatLiteral::PathNode,\n    FormatInvalid::PathGraph, FormatLiteral::PathGraph>;\n\nprivate predicate invalidFormatString(\n  InvalidFormatString src, FormatInvalid::PathNode source, FormatInvalid::PathNode sink, string msg,\n  FormatStringParseCall call, string callString\n) {\n  source.getNode().asExpr() = src and\n  sink.getNode().asExpr() = call.getFormatExpr() and\n  FormatInvalid::flowPath(source, sink) and\n  msg = \"Invalid format string used in $@ formatting call.\" and\n  callString = \"this\"\n}\n\nprivate predicate unusedArgument(\n  FormatCall call, FormatLiteral::PathNode source, FormatLiteral::PathNode sink, string msg,\n  ValidFormatString src, string srcString, Expr unusedExpr, string unusedString\n) {\n  exists(int unused |\n    source.getNode().asExpr() = src and\n    sink.getNode().asExpr() = call.getFormatExpr() and\n    FormatLiteral::flowPath(source, sink) and\n    unused = call.getASuppliedArgument() and\n    not unused = src.getAnInsert() and\n    not src.getValue() = \"\" and\n    msg = \"The $@ ignores $@.\" and\n    srcString = \"format string\" and\n    unusedExpr = call.getSuppliedExpr(unused) and\n    unusedString = \"this supplied value\"\n  )\n}\n\nprivate predicate missingArgument(\n  FormatCall call, FormatLiteral::PathNode source, FormatLiteral::PathNode sink, string msg,\n  ValidFormatString src, string srcString\n) {\n  exists(int used, int supplied |\n    source.getNode().asExpr() = src and\n    sink.getNode().asExpr() = call.getFormatExpr() and\n    FormatLiteral::flowPath(source, sink) and\n    used = src.getAnInsert() and\n    supplied = call.getSuppliedArguments() and\n    used >= supplied and\n    msg = \"Argument '{\" + used + \"}' has not been supplied to $@ format string.\" and\n    srcString = \"this\"\n  )\n}\n\nfrom\n  Element alert, FormatFlow::PathNode source, FormatFlow::PathNode sink, string msg, Element extra1,\n  string extra1String, Element extra2, string extra2String\nwhere\n  invalidFormatString(alert, source.asPathNode1(), sink.asPathNode1(), msg, extra1, extra1String) and\n  extra2 = extra1 and\n  extra2String = extra1String\n  or\n  unusedArgument(alert, source.asPathNode2(), sink.asPathNode2(), msg, extra1, extra1String, extra2,\n    extra2String)\n  or\n  missingArgument(alert, source.asPathNode2(), sink.asPathNode2(), msg, extra1, extra1String) and\n  extra2 = extra1 and\n  extra2String = extra1String\nselect alert, source, sink, msg, extra1, extra1String, extra2, extra2String",
        "description": "Calling 'string.Format()' with either an invalid format string or incorrect number of arguments may result in dropped arguments or a 'System.FormatException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/FormatInvalid.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Dispose\nimport semmle.code.csharp.frameworks.System\n\nprivate class DisposeCall extends MethodCall {\n  DisposeCall() { this.getTarget() instanceof DisposeMethod }\n}\n\npragma[nomagic]\nprivate predicate isDisposedAccess(AssignableRead ar) {\n  exists(AssignableDefinition def, UsingStmt us |\n    ar = def.getAFirstRead() and\n    def.getTargetAccess() = us.getAVariableDeclExpr().getAccess()\n  )\n  or\n  exists(AssignableRead mid |\n    isDisposedAccess(mid) and\n    ar = mid.getANextRead()\n  )\n}\n\nprivate predicate localFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n  DataFlow::localFlowStep(nodeFrom, nodeTo) and\n  not isDisposedAccess(nodeTo.asExpr())\n}\n\nprivate predicate reachesDisposeCall(DisposeCall disposeCall, DataFlow::Node node) {\n  localFlowStep(node, DataFlow::exprNode(disposeCall.getQualifier()))\n  or\n  exists(DataFlow::Node mid | reachesDisposeCall(disposeCall, mid) | localFlowStep(node, mid))\n}\n\npredicate disposeReachableFromDisposableCreation(DisposeCall disposeCall, Expr disposableCreation) {\n  // The qualifier of the Dispose call flows from something that introduced a disposable into scope\n  (\n    disposableCreation instanceof LocalScopeDisposableCreation or\n    disposableCreation instanceof MethodCall\n  ) and\n  reachesDisposeCall(disposeCall, DataFlow::exprNode(disposableCreation))\n}\n\npragma[noinline]\npredicate isTriedAgainstException(ControlFlowElement cfe, ExceptionClass ec) {\n  (cfe instanceof ThrowElement or cfe instanceof MethodCall) and\n  exists(TryStmt ts |\n    ts.getATriedElement() = cfe and\n    exists(ts.getAnExceptionHandler(ec))\n  )\n}\n\nControlFlowElement getACatchOrFinallyClauseChild() {\n  exists(TryStmt ts | result = ts.getACatchClause() or result = ts.getFinally())\n  or\n  result = getACatchOrFinallyClauseChild().getAChild()\n}\n\nprivate predicate candidate(DisposeCall disposeCall, Call call, Expr disposableCreation) {\n  disposeReachableFromDisposableCreation(disposeCall, disposableCreation) and\n  // The dispose call is not, itself, within a dispose method.\n  not disposeCall.getEnclosingCallable() instanceof DisposeMethod and\n  // Dispose call not within a finally or catch block\n  not getACatchOrFinallyClauseChild() = disposeCall and\n  // At least one method call exists between the allocation and disposal that could throw\n  disposableCreation.getAReachableElement() = call and\n  call.getAReachableElement() = disposeCall\n}\n\nprivate class RelevantMethod extends Method {\n  RelevantMethod() {\n    exists(Call call |\n      candidate(_, call, _) and\n      this = call.getARuntimeTarget()\n    )\n    or\n    exists(RelevantMethod other | other.calls(this))\n  }\n\n  pragma[noinline]\n  private RelevantMethod callsNoTry() {\n    exists(MethodCall mc |\n      result = mc.getARuntimeTarget() and\n      not isTriedAgainstException(mc, _) and\n      mc.getEnclosingCallable() = this\n    )\n  }\n\n  pragma[noinline]\n  private RelevantMethod callsInTry(MethodCall mc) {\n    result = mc.getARuntimeTarget() and\n    isTriedAgainstException(mc, _) and\n    mc.getEnclosingCallable() = this\n  }\n\n  /**\n   * Gets an exception type that may be thrown during the execution of this method.\n   * Assumes any exception may be thrown by library types.\n   */\n  Class getAThrownException() {\n    this.fromLibrary() and\n    result instanceof SystemExceptionClass\n    or\n    exists(ControlFlowElement cfe |\n      result = cfe.(ThrowElement).getExpr().getType() and\n      cfe.getEnclosingCallable() = this\n      or\n      result = this.callsInTry(cfe).getAThrownException()\n    |\n      not isTriedAgainstException(cfe, result)\n    )\n    or\n    result = this.callsNoTry().getAThrownException()\n  }\n}\n\nclass MethodCallThatMayThrow extends MethodCall {\n  MethodCallThatMayThrow() {\n    exists(this.getARuntimeTarget().(RelevantMethod).getAThrownException())\n  }\n}\n\nfrom DisposeCall disposeCall, Expr disposableCreation, MethodCallThatMayThrow callThatThrows\nwhere candidate(disposeCall, callThatThrows, disposableCreation)\nselect disposeCall, \"Dispose missed if exception is thrown by $@.\", callThatThrows,\n  callThatThrows.toString()",
        "description": "Methods that create objects of type 'IDisposable' should call 'Dispose()' on those objects, even during exceptional circumstances, otherwise unmanaged resources may not be released.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/DisposeNotCalledOnException.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Dispose\nimport semmle.code.csharp.frameworks.System\nimport semmle.code.csharp.frameworks.system.threading.Tasks\nimport semmle.code.csharp.commons.Disposal\n\nprivate class ReturnNode extends DataFlow::ExprNode {\n  ReturnNode() {\n    exists(Callable c, Expr e | e = this.getExpr() | c.canReturn(e) or c.canYieldReturn(e))\n  }\n}\n\nprivate class Task extends Type {\n  Task() {\n    this instanceof SystemThreadingTasksTaskClass or\n    this instanceof SystemThreadingTasksTaskTClass\n  }\n}\n\nmodule DisposeCallOnLocalIDisposableConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) {\n    exists(LocalScopeDisposableCreation disposable, Type t |\n      node.asExpr() = disposable and\n      t = disposable.getType()\n    |\n      // Only care about library types - user types often have spurious IDisposable declarations\n      t.fromLibrary() and\n      // WebControls are usually disposed automatically\n      not t instanceof WebControl and\n      // It is typically not nessesary to dispose tasks\n      // https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/\n      not t instanceof Task\n    )\n  }\n\n  predicate isSink(DataFlow::Node node) {\n    // Things that return may be disposed elsewhere\n    node instanceof ReturnNode\n    or\n    exists(Expr e | e = node.asExpr() |\n      // Disposables constructed in the initializer of a `using` are safe\n      exists(UsingStmt us | us.getAnExpr() = e)\n      or\n      // Foreach calls Dispose\n      exists(ForeachStmt fs | fs.getIterableExpr() = e)\n      or\n      // As are disposables on which the Dispose method is called explicitly\n      exists(MethodCall mc |\n        mc.getTarget() instanceof DisposeMethod and\n        mc.getQualifier() = e\n      )\n      or\n      // A disposing method\n      exists(Call c, Parameter p | e = c.getArgumentForParameter(p) | mayBeDisposed(p))\n      or\n      // Things that are assigned to fields, properties, or indexers may be disposed\n      exists(AssignableDefinition def, Assignable a |\n        def.getSource() = e and\n        a = def.getTarget()\n      |\n        a instanceof Field or\n        a instanceof Property or\n        a instanceof Indexer\n      )\n      or\n      // Things that are added to a collection of some kind are likely to escape the scope\n      exists(MethodCall mc | mc.getAnArgument() = e | mc.getTarget().hasName(\"Add\"))\n      or\n      exists(MethodCall mc | mc.getQualifier() = e |\n        // Close can often be used instead of Dispose\n        mc.getTarget().hasName(\"Close\")\n        or\n        // Used as an alias for Dispose\n        mc.getTarget().hasName(\"Clear\")\n      )\n    )\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    node2.asExpr() =\n      any(LocalScopeDisposableCreation other | other.getAnArgument() = node1.asExpr())\n  }\n\n  predicate isBarrierOut(DataFlow::Node node) {\n    isSink(node) and\n    not node instanceof ReturnNode\n  }\n}\n\nmodule DisposeCallOnLocalIDisposable = DataFlow::Global<DisposeCallOnLocalIDisposableConfig>;\n\npredicate mayNotBeDisposed(LocalScopeDisposableCreation disposable) {\n  exists(DataFlow::ExprNode e |\n    e.getExpr() = disposable and\n    DisposeCallOnLocalIDisposableConfig::isSource(e) and\n    not exists(DataFlow::Node sink |\n      DisposeCallOnLocalIDisposable::flow(DataFlow::exprNode(disposable), sink)\n    |\n      sink instanceof ReturnNode\n      implies\n      sink.getEnclosingCallable() = disposable.getEnclosingCallable()\n    )\n  )\n}\n\nfrom LocalScopeDisposableCreation disposable\nwhere mayNotBeDisposed(disposable)\nselect disposable, \"Disposable '\" + disposable.getType() + \"' is created but not disposed.\"",
        "description": "Methods that create objects of type 'IDisposable' should call 'Dispose' on those objects, otherwise unmanaged resources may not be released.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/NoDisposeCallOnLocalIDisposable.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom MethodCall c, EqualsMethod equals\nwhere\n  c.getTarget().getUnboundDeclaration() = equals and\n  c.getArgument(0) instanceof NullLiteral and\n  not c.getQualifier().getType() instanceof NullableType\nselect c, \"Equality test with 'null' will never be true, but may throw a 'NullReferenceException'.\"",
        "description": "Calls of the form 'o.Equals(null)' always return false for non-null 'o', and throw a 'NullReferenceException' when 'o' is null.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/NullArgumentToEquals.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Dispose\nimport semmle.code.csharp.frameworks.System\n\nfrom DisposableType t, DisposableField f\nwhere\n  f.getDeclaringType() = t and\n  t.isSourceDeclaration() and\n  not f.isStatic() and\n  not implementsDispose(t) and\n  not isAutoDisposedWebControl(f)\nselect t, \"This type does not override 'Dispose()' but has disposable field $@.\", f, f.getName()",
        "description": "Classes that implement 'IDisposable' and have members of 'IDisposable' type should also declare/override 'Dispose()'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/MissingDisposeMethod.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nclass EqualsOtherMethod extends Method {\n  EqualsOtherMethod() {\n    this.hasName(\"Equals\") and\n    this.getNumberOfParameters() = 1 and\n    this.getReturnType() instanceof BoolType and\n    this.getDeclaringType() instanceof Class and\n    not this instanceof EqualsMethod and\n    not this instanceof IEquatableEqualsMethod\n  }\n\n  Type getType() { result = this.getParameter(0).getType() }\n}\n\nfrom EqualsOtherMethod equalsOther\nwhere\n  equalsOther.isSourceDeclaration() and\n  not implementsEquals(equalsOther.getDeclaringType())\nselect equalsOther,\n  \"The $@ of this 'Equals(\" + equalsOther.getType().getName() +\n    \")' method does not override 'Equals(object)'.\", equalsOther.getDeclaringType(),\n  \"declaring type\"",
        "description": "The declaring type of a method with signature 'Equals(T)' does not implement 'Equals(object)'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/IncorrectEqualsSignature.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom Class c, Element item, string message, string itemText\nwhere\n  c.isSourceDeclaration() and\n  not implementsEquals(c) and\n  not c.isAbstract() and\n  (\n    exists(MethodCall callToEquals |\n      callToEquals.getTarget() instanceof EqualsMethod and\n      callToEquals.getQualifier().getType() = c and\n      message = \"but $@\" and\n      item = callToEquals and\n      itemText = \"'Equals' is called on an instance of this class\"\n    )\n    or\n    item = c.getAnOperator().(EQOperator) and\n    message = \"but it implements $@\" and\n    itemText = \"operator ==\"\n    or\n    exists(IEquatableEqualsMethod eq |\n      item = eq and\n      eq = c.getAMethod() and\n      message = \"but it implements $@\" and\n      itemText = \"IEquatable<\" + eq.getParameter(0).getType() + \">.Equals\"\n    )\n  )\nselect c, \"Class '\" + c.getName() + \"' does not implement Equals(object), \" + message + \".\", item,\n  itemText",
        "description": "The class does not implement the 'Equals(object)' method, which can cause unexpected behavior. The default 'Equals(object)' method performs reference comparison, which may not be what was intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/API Abuse/ClassDoesNotImplementEquals.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Linq.Helpers\n\npredicate oversized(LocalVariableDeclStmt s) {\n  exists(Location loc |\n    loc = s.getLocation() and\n    loc.getEndColumn() - loc.getStartColumn() > 65\n  )\n}\n\nfrom ForeachStmtGenericEnumerable fes, LocalVariableDeclStmt s\nwhere\n  missedSelectOpportunity(fes, s) and\n  not oversized(s)\nselect fes,\n  \"This foreach loop immediately $@ - consider mapping the sequence explicitly using '.Select(...)'.\",\n  s, \"maps its iteration variable to another variable\"",
        "description": "The intent of a foreach loop that immediately maps its iteration variable to another variable and then never uses the iteration variable again can often be better expressed using LINQ's 'Select' method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Linq/MissedSelectOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Linq.Helpers\n\nfrom ForeachStmtEnumerable fes, LocalVariableDeclStmt s\nwhere missedOfTypeOpportunity(fes, s)\nselect fes,\n  \"This foreach loop immediately uses 'as' to $@ - consider using '.OfType(...)' instead.\", s,\n  \"coerce its iteration variable to another type\"",
        "description": "The intent of a foreach loop that immediately uses 'as' to coerce its iteration variable to another type and then never uses the iteration variable again can often be better expressed using LINQ's 'OfType' method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Linq/MissedOfTypeOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import Linq.Helpers\n\n\nfrom ForeachStmtGenericEnumerable fes\nwhere missedAllOpportunity(fes)\nselect fes,\n  \"This foreach loop looks as if it might be testing whether every sequence element satisfies a predicate - consider using '.All(...)'.\"",
        "description": "The intent of a foreach loop that checks whether every element of its target sequence satisfies some predicate can be expressed more directly using LINQ's 'All' method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Linq/MissedAllOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Linq.Helpers\n\npredicate isIdentityFunction(AnonymousFunctionExpr afe) {\n  afe.getNumberOfParameters() = 1 and\n  afe.getExpressionBody() = afe.getParameter(0).getAnAccess()\n}\n\nfrom SelectCall sc\nwhere isIdentityFunction(sc.getFunctionExpr())\nselect sc, \"This LINQ selection is redundant and can be removed.\"",
        "description": "Writing 'seq.Select(e => e)' or 'from e in seq select e' is redundant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Linq/RedundantSelect.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Linq.Helpers\n\npredicate likelyNonRepeatableSequence(IEnumerableSequence seq) {\n  // The source of the sequence is one of:\n  exists(Expr src | src = sequenceSource(seq) |\n    // A call to a method that both returns an IEnumerable and calls ReadLine.\n    exists(MethodCall mc |\n      mc = src and\n      isIEnumerableType(mc.getTarget().getReturnType()) and\n      exists(MethodCall readlineCall |\n        readlineCall.getTarget().hasName(\"ReadLine\") and\n        readlineCall.getEnclosingCallable() = mc.getTarget()\n      )\n    )\n    or\n    // A call to Select(...) that instantiates new objects.\n    exists(SelectCall sc |\n      sc = src and\n      sc.getFunctionExpr().getExpressionBody() instanceof ObjectCreation\n    )\n  )\n}\n\npredicate potentiallyConsumingAccess(VariableAccess va) {\n  exists(ForeachStmt fes | va = fes.getIterableExpr())\n  or\n  exists(MethodCall mc |\n    va = mc.getArgument(0) and\n    mc.getTarget() instanceof ExtensionMethod\n  )\n}\n\nExpr sequenceSource(IEnumerableSequence seq) {\n  result = seq.getInitializer()\n  or\n  exists(Assignment a | a.getLValue() = seq.getAnAccess() and result = a.getRValue())\n}\n\nfrom IEnumerableSequence seq, VariableAccess va\nwhere\n  likelyNonRepeatableSequence(seq) and\n  va = seq.getAnAccess() and\n  potentiallyConsumingAccess(va) and\n  count(VariableAccess x | x = seq.getAnAccess() and potentiallyConsumingAccess(x)) > 1\nselect seq, \"This enumerable sequence may not be repeatable, but $@.\", va,\n  \"it is potentially consumed multiple times\"",
        "description": "Not every enumerable sequence is repeatable, so it is dangerous to write code that can consume elements of a sequence in more than one place.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Linq/BadMultipleIteration.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Linq.Helpers\n\nfrom ForeachStmtEnumerable fes, LocalVariableDeclStmt s\nwhere missedCastOpportunity(fes, s)\nselect fes,\n  \"This foreach loop immediately $@ - consider casting the sequence explicitly using '.Cast(...)'.\",\n  s, \"casts its iteration variable to another type\"",
        "description": "The intent of a foreach loop that immediately casts its iteration variable to another type and then never uses the iteration variable again can often be better expressed using LINQ's 'Cast' method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Linq/MissedCastOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Linq.Helpers\n\nfrom ForeachStmtGenericEnumerable fes, IfStmt is\nwhere\n  missedWhereOpportunity(fes, is) and\n  not missedAllOpportunity(fes)\nselect fes,\n  \"This foreach loop $@ - consider filtering the sequence explicitly using '.Where(...)'.\",\n  is.getCondition(), \"implicitly filters its target sequence\"",
        "description": "The intent of a foreach loop that implicitly filters its target sequence can often be better expressed using LINQ's 'Where' method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Linq/MissedWhereOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport Concurrency\n\nfrom LockedBlock l, WaitStmt w, string lockedItem\nwhere\n  l.getALockedStmt() = w and\n  (\n    exists(Variable v |\n      v = l.getLockVariable() and not v = w.getWaitVariable() and lockedItem = v.getName()\n    )\n    or\n    exists(Type t |\n      t = l.getLockTypeObject() and\n      not t = w.getWaitTypeObject() and\n      lockedItem = \"typeof(\" + t.getName() + \")\"\n    )\n    or\n    l.isLockThis() and not w.isWaitThis() and lockedItem = \"this\"\n  )\nselect w, \"'\" + lockedItem + \"' is locked during this wait.\"",
        "description": "A lock is held during a call to System.Threading.Monitor.Wait(). This can lead to deadlocks and performance problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Concurrency/LockedWait.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom LockStmt s, ThisAccess a\nwhere a = s.getExpr()\nselect a, \"'this' used in lock statement.\"",
        "description": "It is bad practice to lock the 'this' object because it might be locked elsewhere.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Concurrency/LockThis.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nCallable getCallTarget(Call c) {\n  count(c.getARuntimeTarget()) = 1 and\n  result = c.getARuntimeTarget()\n}\n\nLockStmt getAReachableLockStmt(Callable callable) {\n  result.getEnclosingCallable() = callable\n  or\n  exists(Call call | call.getEnclosingCallable() = callable |\n    result = getAReachableLockStmt(getCallTarget(call))\n  )\n}\n\npredicate nestedLocks(Variable outerVariable, Variable innerVariable, LockStmt outer, LockStmt inner) {\n  outerVariable = outer.getLockVariable() and\n  innerVariable = inner.getLockVariable() and\n  outerVariable != innerVariable and\n  (\n    inner = outer.getALockedStmt()\n    or\n    exists(Call call | call.getEnclosingStmt() = outer.getALockedStmt() |\n      inner = getAReachableLockStmt(getCallTarget(call))\n    ) and\n    outerVariable.(Modifiable).isStatic() and\n    innerVariable.(Modifiable).isStatic()\n  )\n}\n\nfrom LockStmt outer1, LockStmt inner1, LockStmt outer2, LockStmt inner2, Variable v1, Variable v2\nwhere\n  nestedLocks(v1, v2, outer1, inner1) and\n  nestedLocks(v2, v1, outer2, inner2) and\n  v1.getName() <= v2.getName()\nselect v1, \"Inconsistent lock sequence with $@. Lock sequences $@, $@ and $@, $@ found.\", v2,\n  v2.getName(), outer1, v1.getName(), inner1, v2.getName(), outer2, v2.getName(), inner2,\n  v1.getName()",
        "description": "Locking in an inconsistent sequence can lead to deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Concurrency/LockOrder.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Property p, Field f\nwhere\n  f.getDeclaringType() = p.getDeclaringType() and\n  exists(Setter setter, LockStmt writelock, FieldWrite writeaccess |\n    p.getSetter() = setter and\n    writeaccess = f.getAnAccess() and\n    writelock.getEnclosingCallable() = setter and\n    writelock.getAChildStmt+().getAChildExpr+() = writeaccess\n  ) and\n  exists(Getter getter, FieldRead readaccess |\n    getter = p.getGetter() and\n    readaccess = f.getAnAccess() and\n    readaccess.getEnclosingCallable() = getter and\n    not exists(LockStmt readlock | readlock.getAChildStmt+().getAChildExpr+() = readaccess)\n  )\nselect p, \"Field $@ is guarded by a lock in the setter but not in the getter.\", f, f.getName()",
        "description": "If a property has a lock in its setter, but not in its getter, then the value returned by the getter can be inconsistent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Concurrency/SynchSetUnsynchGet.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate lockedFieldUpdate(LockStmt lock, Field f, AssignableDefinition def) {\n  lock.getAChild+() = def.getExpr() and\n  def.getTarget() = f\n}\n\nfrom LockStmt lock, Expr e, Field f, AssignableDefinition def\nwhere\n  e = lock.getExpr() and\n  f.getAnAccess() = e and\n  lockedFieldUpdate(lock, f, def)\nselect e,\n  \"Locking field $@ guards the initial value, not the value which may be seen from another thread after $@.\",\n  f, f.getName(), def, \"reassignment\"",
        "description": "Synchronizing on a field and updating that field while the lock is held is unlikely to provide the desired thread safety.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Concurrency/FutileSyncOnField.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.StructuralComparison\n\npredicate doubleCheckedLock(Field field, IfStmt unlockedIf) {\n  exists(LockStmt lock, IfStmt lockedIf |\n    lock = unlockedIf.getThen().stripSingletonBlocks() and\n    lockedIf.getParent*() = lock.getBlock() and\n    sameGvn(unlockedIf.getCondition(), lockedIf.getCondition()) and\n    field.getAnAccess() = unlockedIf.getCondition().getAChildExpr*()\n  )\n}\n\nfrom Field field, IfStmt ifs\nwhere\n  doubleCheckedLock(field, ifs) and\n  not field.isVolatile() and\n  exists(VariableWrite write | write = ifs.getThen().getAChild+() and write.getTarget() = field) and\n  field.getType() instanceof RefType\nselect ifs, \"Field $@ should be 'volatile' for this double-checked lock.\", field, field.getName()",
        "description": "A repeated check on a non-volatile field is not thread-safe on some platforms, and could result in unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Concurrency/UnsafeLazyInitialization.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport DataMembers\nimport ThreadCreation\n\npredicate correctlySynchronized(CollectionMember c, Expr access) {\n  access = c.getAReadOrWrite() and\n  (\n    c.getType().(ValueOrRefType).getABaseType*().getName().matches(\"Concurrent%\") or\n    access.getEnclosingStmt().getParent*() instanceof LockStmt or\n    any(LockingCall call).getAControlFlowNode().getASuccessor+() = access.getAControlFlowNode()\n  )\n}\n\nControlFlow::Node unlockedReachable(Callable a) {\n  result = a.getEntryPoint()\n  or\n  exists(ControlFlow::Node mid | mid = unlockedReachable(a) |\n    not mid.getAstNode() instanceof LockingCall and\n    result = mid.getASuccessor()\n  )\n}\n\npredicate unlockedCalls(Callable a, Callable b) {\n  exists(Call call |\n    call.getAControlFlowNode() = unlockedReachable(a) and\n    call.getARuntimeTarget() = b and\n    not call.getParent*() instanceof LockStmt\n  )\n}\n\npredicate writtenStaticDictionary(CollectionMember c) {\n  c.getType().(ValueOrRefType).getABaseType*().hasName(\"IDictionary\") and\n  c.isStatic() and\n  exists(Expr write | write = c.getAWrite() |\n    not write.getEnclosingCallable() instanceof StaticConstructor\n  )\n}\n\npredicate nonStaticCallable(Callable c) { not c.(Modifiable).isStatic() }\n\nfrom CollectionMember c, Expr a, ConcurrentEntryPoint e, Callable enclosing\nwhere\n  a = c.getAReadOrWrite() and\n  enclosing = a.getEnclosingCallable() and\n  nonStaticCallable(enclosing) and\n  not correctlySynchronized(c, a) and\n  unlockedCalls*(e, enclosing) and\n  writtenStaticDictionary(c)\nselect a, \"Unsynchronized access to $@ in non-static context from $@.\", c, c.getName(), e,\n  e.getName()",
        "description": "If an unsynchronized access to a static collection member occurs during an addition or resizing operation, an infinite loop can occur.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Concurrency/UnsynchronizedStaticAccess.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.metrics.Coupling\n\npredicate nestedWithin(ValueOrRefType outer, NestedType inner) {\n  inner.getDeclaringType() = outer or\n  nestedWithin(outer, inner.getDeclaringType())\n}\n\nfrom ValueOrRefType t1, ValueOrRefType t2\nwhere\n  t1 != t2 and\n  depends(t1, t2) and\n  depends(t2, t1) and\n  // PREVENT SYMMETRICAL RESULTS\n  t1.getName() < t2.getName() and\n  // ADDITIONAL CONSTRAINTS\n  t1.fromSource() and\n  t2.fromSource() and\n  // EXCLUSIONS\n  not (\n    nestedWithin(t1, t2) or\n    nestedWithin(t2, t1) or\n    t1.getName().toLowerCase().matches(\"%visitor%\") or\n    t2.getName().toLowerCase().matches(\"%visitor%\") or\n    t1.getAMember().getName().toLowerCase().matches(\"%visit%\") or\n    t2.getAMember().getName().toLowerCase().matches(\"%visit%\")\n  )\nselect t1, \"This type and type $@ are mutually dependent.\", t2, t2.getName()",
        "description": "Mutual dependency between types makes code difficult to understand and test.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Architecture/Dependencies/MutualDependency.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nMember getAUsedMember(Method m) {\n  exists(MemberAccess ma | ma.getEnclosingCallable() = m |\n    result = ma.getTarget().getUnboundDeclaration()\n  )\n  or\n  exists(Call c | c.getEnclosingCallable() = m | result = c.getTarget().getUnboundDeclaration())\n}\n\nint dependencyCount(Method source, RefType target) {\n  result = strictcount(Member m | m = getAUsedMember(source) and m = target.getAMember())\n}\n\npredicate methodDependsOn(Method m, RefType target) { exists(dependencyCount(m, target)) }\n\npredicate dependsOn(RefType source, RefType target) { methodDependsOn(source.getAMethod(), target) }\n\nint selfDependencyCount(Method source) {\n  result = sum(dependencyCount(source, source.getDeclaringType+()))\n}\n\npredicate dependsHighlyOn(Method source, RefType target, int selfCount, int depCount) {\n  depCount = dependencyCount(source, target) and\n  selfCount = selfDependencyCount(source) and\n  depCount > 2 * selfCount and\n  depCount > 4\n}\n\npredicate query(Method m, RefType targetType, int selfCount, int depCount) {\n  exists(RefType sourceType | sourceType = m.getDeclaringType() |\n    dependsHighlyOn(m, targetType, selfCount, depCount) and\n    // Interfaces are depended upon by their very nature\n    not targetType instanceof Interface and\n    // Do not move extension methods\n    not m instanceof ExtensionMethod and\n    // Do not move up/down the class hierarchy\n    not (\n      sourceType.getABaseType*().getUnboundDeclaration() = targetType or\n      targetType.getABaseType*().getUnboundDeclaration() = sourceType\n    ) and\n    // Do not move between nested types\n    not (sourceType.getDeclaringType*() = targetType or targetType.getDeclaringType*() = sourceType) and\n    // Check that the target type already depends on every type used by the method\n    forall(RefType dependency | methodDependsOn(m, dependency) |\n      dependsOn(targetType, dependency) or\n      targetType = dependency or\n      dependency.getNamespace().hasName(\"System\")\n    )\n  )\n}\n\nfrom Method m, RefType other, int selfCount, int depCount\nwhere\n  query(m, other, selfCount, depCount) and\n  // Don't include types that are used from many different places - we only highlight\n  // relatively local fixes that could reasonably be implemented.\n  count(Method yetAnotherMethod | query(yetAnotherMethod, other, _, _)) < 10\nselect m,\n  \"Method \" + m.getName() + \" is too closely tied to $@: \" + depCount +\n    \" dependencies to it, but only \" + selfCount + \" dependencies to its own type.\", other,\n  other.getName()",
        "description": "A method that uses more methods or variables from another (unrelated) class than from its own class violates the principle of putting data and behavior in the same place.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Architecture/Refactoring Opportunities/FeatureEnvy.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate enclosingRefType(Variable v, RefType type) {\n  v.(Field).getDeclaringType() = type or\n  v.(LocalScopeVariable).getDeclaringType() = type\n}\n\npredicate remoteVarAccess(RefType source, RefType target, VariableAccess va) {\n  va.getEnclosingCallable().getDeclaringType() = source and\n  enclosingRefType(va.getTarget(), target) and\n  source != target\n}\n\npredicate remoteFunAccess(RefType source, RefType target, Call fc) {\n  fc.getEnclosingCallable().getDeclaringType() = source and\n  target = fc.getTarget().getDeclaringType()\n}\n\npredicate candidateTypePair(RefType source, RefType target) {\n  remoteVarAccess(source, target, _) or remoteFunAccess(source, target, _)\n}\n\npredicate variableDependencyCount(RefType source, RefType target, int res) {\n  candidateTypePair(source, target) and\n  res = count(VariableAccess va | remoteVarAccess(source, target, va))\n}\n\npredicate functionDependencyCount(RefType source, RefType target, int res) {\n  candidateTypePair(source, target) and\n  res = count(Call fc | remoteFunAccess(source, target, fc))\n}\n\npredicate dependencyCount(RefType source, RefType target, int res) {\n  exists(int varCount, int funCount |\n    variableDependencyCount(source, target, varCount) and\n    functionDependencyCount(source, target, funCount) and\n    res = varCount + funCount and\n    res > 15\n  )\n}\n\nfrom RefType a, RefType b, int ca, int cb\nwhere\n  dependencyCount(a, b, ca) and\n  dependencyCount(b, a, cb) and\n  ca > 15 and\n  cb > 15 and\n  ca >= cb and\n  a != b\nselect a,\n  \"Type \" + a.getName() + \" is too closely tied to $@ (\" + ca.toString() +\n    \" dependencies one way and \" + cb.toString() + \" the other).\", b, b.getName()",
        "description": "Two otherwise unrelated classes that share too much information about each other are difficult to maintain, change and understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Architecture/Refactoring Opportunities/InappropriateIntimacy.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nclass DisposeCall extends MethodCall {\n  DisposeCall() { this.getTarget() instanceof DisposeMethod }\n\n  /** The object being disposed by the call (provided it can be easily determined). */\n  Variable getDisposee() {\n    exists(VariableAccess va |\n      va = this.getQualifier().stripCasts() and\n      result = va.getTarget()\n    )\n  }\n}\n\nfrom Variable v, DisposeCall c, TryStmt ts\nwhere\n  v = c.getDisposee() and\n  c = ts.getFinally().getAChild*()\nselect v,\n  \"This variable is manually $@ in a $@ - consider a C# using statement as a preferable resource management technique.\",\n  c, \"disposed\", ts.getFinally(), \"finally block\"",
        "description": "C# provides a 'using' statement as a better alternative to manual resource disposal in a finally block - it makes sense to use it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/MissedUsingOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nTypePatternExpr getTypeCondition(IfStmt is) { result = is.getCondition().(IsExpr).getPattern() }\n\nint isCountForIfChain(IfStmt is) {\n  exists(int rest |\n    (if is.getElse() instanceof IfStmt then rest = isCountForIfChain(is.getElse()) else rest = 0) and\n    (\n      if getTypeCondition(is).getCheckedType().fromSource()\n      then result = 1 + rest\n      else result = rest\n    )\n  )\n}\n\nfrom IfStmt is, int n\nwhere\n  n = isCountForIfChain(is) and\n  n > 5 and\n  not exists(IfStmt other | is = other.getElse())\nselect is,\n  \"This if block performs a chain of \" + n +\n    \" type tests - consider alternatives, e.g. polymorphism or the visitor pattern.\"",
        "description": "Long sequences of type tests on a variable are generally an indication of questionable design. They are hard to maintain and can cause performance problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/ChainedIs.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate literalChild(Expr expr, int child, boolean value) {\n  value = expr.getChild(child).(BoolLiteral).getBoolValue() and\n  forall(int c | c != child | not expr.getChild(c) instanceof BoolLiteral)\n}\n\npredicate literalChildren(Expr expr, int child1, boolean value1, int child2, boolean value2) {\n  value1 = expr.getChild(child1).(BoolLiteral).getBoolValue() and\n  value2 = expr.getChild(child2).(BoolLiteral).getBoolValue() and\n  forall(int c | c != child1 and c != child2 | not expr.getChild(c) instanceof BoolLiteral)\n}\n\npredicate rewriteBinaryExpr(BinaryOperation op, boolean value, string oldPattern) {\n  literalChild(op, 0, value) and oldPattern = value + \" \" + op.getOperator() + \" A\"\n  or\n  literalChild(op, 1, value) and oldPattern = \"A \" + op.getOperator() + \" \" + value\n}\n\nbindingset[withFalseOperand, withTrueOperand]\npredicate rewriteBinaryExpr(\n  BinaryOperation op, string oldPattern, string withFalseOperand, string withTrueOperand,\n  string newPattern\n) {\n  rewriteBinaryExpr(op, false, oldPattern) and newPattern = withFalseOperand\n  or\n  rewriteBinaryExpr(op, true, oldPattern) and newPattern = withTrueOperand\n}\n\npredicate rewriteConditionalExpr(ConditionalExpr cond, string oldPattern, string newPattern) {\n  literalChild(cond, 1, false) and oldPattern = \"A ? false : B\" and newPattern = \"!A && B\"\n  or\n  literalChild(cond, 1, true) and oldPattern = \"A ? true : B\" and newPattern = \"A || B\"\n  or\n  literalChild(cond, 2, false) and oldPattern = \"A ? B : false\" and newPattern = \"A && B\"\n  or\n  literalChild(cond, 2, true) and oldPattern = \"A ? B : true\" and newPattern = \"!A || B\"\n  or\n  exists(boolean b | literalChildren(cond, 1, b, 2, b) |\n    oldPattern = \"A ? \" + b + \" : \" + b and newPattern = b.toString()\n  )\n  or\n  literalChildren(cond, 1, true, 2, false) and oldPattern = \"A ? true : false\" and newPattern = \"A\"\n  or\n  literalChildren(cond, 1, false, 2, true) and oldPattern = \"A ? false : true\" and newPattern = \"!A\"\n}\n\npredicate negatedOperators(string op, string negated) {\n  op = \"==\" and negated = \"!=\"\n  or\n  op = \"<\" and negated = \">=\"\n  or\n  op = \">\" and negated = \"<=\"\n  or\n  negatedOperators(negated, op)\n}\n\npredicate simplifyBinaryExpr(string op, string withFalseOperand, string withTrueOperand) {\n  op = \"==\" and withTrueOperand = \"A\" and withFalseOperand = \"!A\"\n  or\n  op = \"!=\" and withTrueOperand = \"!A\" and withFalseOperand = \"A\"\n  or\n  op = \"&&\" and withTrueOperand = \"A\" and withFalseOperand = \"false\"\n  or\n  op = \"||\" and withTrueOperand = \"true\" and withFalseOperand = \"A\"\n}\n\npredicate pushNegation(LogicalNotExpr expr, string oldPattern, string newPattern) {\n  expr.getOperand() instanceof LogicalNotExpr and oldPattern = \"!!A\" and newPattern = \"A\"\n  or\n  exists(string oldOperator, string newOperator |\n    oldOperator = expr.getOperand().(BinaryOperation).getOperator() and\n    negatedOperators(oldOperator, newOperator)\n  |\n    oldPattern = \"!(A \" + oldOperator + \" B)\" and\n    newPattern = \"A \" + newOperator + \" B\"\n  )\n}\n\npredicate rewrite(Expr expr, string oldPattern, string newPattern) {\n  exists(string withFalseOperand, string withTrueOperand |\n    simplifyBinaryExpr(expr.(BinaryOperation).getOperator(), withFalseOperand, withTrueOperand)\n  |\n    rewriteBinaryExpr(expr, oldPattern, withFalseOperand, withTrueOperand, newPattern)\n  )\n  or\n  rewriteConditionalExpr(expr, oldPattern, newPattern)\n  or\n  pushNegation(expr, oldPattern, newPattern)\n}\n\nfrom Expr expr, string oldPattern, string newPattern, string action\nwhere\n  rewrite(expr, oldPattern, newPattern) and\n  if newPattern = \"true\" or newPattern = \"false\"\n  then action = \"is always\"\n  else action = \"can be simplified to\"\nselect expr, \"The expression '\" + oldPattern + \"' \" + action + \" '\" + newPattern + \"'.\"",
        "description": "Boolean expressions that are unnecessarily complicated hinder readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/SimplifyBoolExpr.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ExplicitCast cast, Expr e, Type type\nwhere\n  e = cast.getExpr() and\n  type = cast.getTargetType() and\n  type = e.getType() and\n  not type instanceof NullType and\n  not e.(ImplicitDelegateCreation).getArgument() instanceof AnonymousFunctionExpr\nselect cast, \"This cast is redundant because the expression already has type \" + type + \".\"",
        "description": "A cast to the same type as the original expression is always redundant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/UselessCastToSelf.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.StructuralComparison\n\nprivate predicate candidate(AsExpr ae, IsExpr ie) {\n  exists(IfStmt is, TypeAccessPatternExpr tape |\n    ie = is.getCondition().getAChild*() and\n    tape = ie.getPattern() and\n    ae.getTargetType() = tape.getTarget()\n  |\n    ae = is.getThen().getAChild*()\n    or\n    ae = is.getElse().getAChild*()\n  )\n}\n\nprivate predicate uselessIsBeforeAs(AsExpr ae, IsExpr ie) {\n  candidate(ae, ie) and\n  sameGvn(ie.getExpr(), ae.getExpr())\n}\n\nfrom AsExpr ae, IsExpr ie\nwhere\n  uselessIsBeforeAs(ae, ie) and\n  not exists(MethodCall mc | ae = mc.getAnArgument().getAChildExpr*())\nselect ae,\n  \"This 'as' expression performs a type test - it should be directly compared against null, rendering the $@ potentially redundant.\",\n  ie, \"is\"",
        "description": "The C# 'as' operator performs a type test - there is no need to precede it with an 'is'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/UselessIsBeforeAs.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate defTargetsField(AssignableDefinition def, Field f) {\n  def.getTarget().getUnboundDeclaration() = f\n}\n\npredicate isReadonlyCompatibleDefinition(AssignableDefinition def, Field f) {\n  defTargetsField(def, f) and\n  (\n    def.getEnclosingCallable().(StaticConstructor).getDeclaringType() = f.getDeclaringType()\n    or\n    def.getEnclosingCallable().(InstanceConstructor).getDeclaringType() = f.getDeclaringType() and\n    def.getTargetAccess().(QualifiableExpr).getQualifier() instanceof ThisAccess\n    or\n    def instanceof AssignableDefinitions::InitializerDefinition\n  )\n}\n\npredicate canBeReadonly(Field f) {\n  exists(Type t | t = f.getType() | not t instanceof Struct or t.(Struct).isReadonly()) and\n  forex(AssignableDefinition def | defTargetsField(def, f) | isReadonlyCompatibleDefinition(def, f))\n}\n\nfrom Field f\nwhere\n  canBeReadonly(f) and\n  not f.isConst() and\n  not f.isReadOnly() and\n  not f.isEffectivelyPublic()\nselect f, \"Field '\" + f.getName() + \"' can be 'readonly'.\"",
        "description": "A private field where all assignments occur as part of the declaration or in a constructor in the same class can be 'readonly'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/MissedReadonlyOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Assertions\n\nfrom IsExpr ie, ValueOrRefType t, ValueOrRefType ct\nwhere\n  ie.getExpr() instanceof ThisAccess and\n  t = ie.getExpr().getType() and\n  ct = ie.getPattern().(TypePatternExpr).getCheckedType() and\n  ct.getABaseType*() = t and\n  not isExprInAssertion(ie)\nselect ie,\n  \"Testing whether 'this' is an instance of $@ in $@ introduces a dependency cycle between the two types.\",\n  ct, ct.getName(), t, t.getName()",
        "description": "Testing whether 'this' is an instance of a derived type introduces a dependency cycle between the type of 'this' and the target type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/DubiousTypeTestOfThis.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ExplicitCast c, ValueOrRefType src, ValueOrRefType dest\nwhere\n  c.getExpr() instanceof ThisAccess and\n  src = c.getExpr().getType() and\n  dest = c.getTargetType() and\n  src = dest.getABaseType+()\nselect c, \"Downcasting 'this' from $@ to $@ introduces a dependency cycle between the two types.\",\n  src, src.getName(), dest, dest.getName()",
        "description": "Casting 'this' to a derived type introduces a dependency cycle between the type of 'this' and the target type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/DubiousDowncastOfThis.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Setter setter\nwhere\n  not exists(setter.getAParameter().getAnAccess()) and\n  not exists(ThrowStmt t | t.getEnclosingCallable() = setter) and\n  setter.hasBody() and // Trivial setter is OK\n  not setter.getDeclaration().overrides() and\n  not setter.getDeclaration().implements() and\n  not setter.getDeclaration().isVirtual()\nselect setter, \"Value ignored when setting property.\"",
        "description": "Ignoring the value assigned to a property is potentially confusing and can lead to unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/UnusedPropertyValue.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass StaticCallable extends Callable {\n  StaticCallable() { this.(Modifiable).isStatic() }\n}\n\nclass InstanceCallable extends Callable {\n  InstanceCallable() { not this instanceof StaticCallable }\n}\n\nclass StaticCall extends Call {\n  StaticCall() {\n    this.getTarget() instanceof StaticCallable and\n    not this = any(ExtensionMethodCall emc | not emc.isOrdinaryStaticCall())\n  }\n}\n\npragma[nomagic]\npredicate hasInstanceCallable(ValueOrRefType t, InstanceCallable c, string name) {\n  t.hasMember(c) and\n  name = c.getUndecoratedName()\n}\n\npragma[nomagic]\npredicate hasExtensionMethod(ValueOrRefType t, ExtensionMethod m, string name) {\n  t.isImplicitlyConvertibleTo(m.getExtendedType()) and\n  name = m.getUndecoratedName()\n}\n\npragma[noinline]\npredicate hasStaticCallable(ValueOrRefType t, StaticCallable c, string name) {\n  t.hasMember(c) and\n  name = c.getUndecoratedName()\n}\n\nint getMinimumArguments(Callable c) {\n  result =\n    count(Parameter p |\n      p = c.getAParameter() and\n      not p.hasDefaultValue()\n    )\n}\n\nint getMaximumArguments(Callable c) {\n  not c.getAParameter().isParams() and\n  result = c.getNumberOfParameters()\n}\n\nprivate class ConstructorCall extends Call {\n  ConstructorCall() {\n    this instanceof ObjectCreation or\n    this instanceof ConstructorInitializer\n  }\n}\n\nclass ExplicitUpcast extends ExplicitCast {\n  ValueOrRefType dest;\n\n  ExplicitUpcast() {\n    exists(ValueOrRefType src |\n      src = this.getSourceType() and\n      dest = this.getTargetType() and\n      (src instanceof RefType or src instanceof Struct) and\n      src.isImplicitlyConvertibleTo(dest) and\n      src != dest // Handled by `cs/useless-cast-to-self`\n    )\n  }\n\n  pragma[nomagic]\n  private predicate isArgument(Type t) {\n    exists(Parameter p |\n      this = p.getAnAssignedArgument() and\n      t = p.getType()\n    )\n  }\n\n  /** Holds if this upcast is the argument of a call to `target`. */\n  private predicate isArgument(Call c, Callable target) {\n    this.isArgument(this.getType()) and\n    c.getAnArgument() = this and\n    target = c.getTarget()\n  }\n\n  /** Holds if this upcast may be used to disambiguate the target of an instance call. */\n  pragma[nomagic]\n  private predicate isDisambiguatingInstanceCall(InstanceCallable other, int args) {\n    exists(Call c, InstanceCallable target, ValueOrRefType t | this.isArgument(c, target) |\n      t = c.(QualifiableExpr).getQualifier().getType() and\n      hasInstanceCallable(t, other, target.getUndecoratedName()) and\n      args = c.getNumberOfArguments() and\n      other != target\n    )\n  }\n\n  /** Holds if this upcast may be used to disambiguate the target of an extension method call. */\n  pragma[nomagic]\n  private predicate isDisambiguatingExtensionCall(ExtensionMethod other, int args) {\n    exists(ExtensionMethodCall c, ExtensionMethod target, ValueOrRefType t |\n      this.isArgument(c, target)\n    |\n      not c.isOrdinaryStaticCall() and\n      t = target.getParameter(0).getType() and\n      hasExtensionMethod(t, other, target.getUndecoratedName()) and\n      args = c.getNumberOfArguments() and\n      other != target\n    )\n  }\n\n  pragma[nomagic]\n  private predicate isDisambiguatingStaticCall0(\n    StaticCall c, StaticCallable target, string name, ValueOrRefType t\n  ) {\n    this.isArgument(c, target) and\n    name = target.getUndecoratedName() and\n    (\n      t = c.(QualifiableExpr).getQualifier().getType()\n      or\n      not c.(QualifiableExpr).hasQualifier() and\n      t = target.getDeclaringType()\n    )\n  }\n\n  /** Holds if this upcast may be used to disambiguate the target of a static call. */\n  pragma[nomagic]\n  private predicate isDisambiguatingStaticCall(StaticCallable other, int args) {\n    exists(StaticCall c, StaticCallable target, ValueOrRefType t, string name |\n      this.isDisambiguatingStaticCall0(c, target, name, t)\n    |\n      hasStaticCallable(t, other, name) and\n      args = c.getNumberOfArguments() and\n      other != target\n    )\n  }\n\n  /** Holds if this upcast may be used to disambiguate the target of a constructor call. */\n  pragma[nomagic]\n  private predicate isDisambiguatingConstructorCall(Constructor other, int args) {\n    exists(ConstructorCall cc, Constructor target, ValueOrRefType t | this.isArgument(cc, target) |\n      t = target.getDeclaringType() and\n      t.hasMember(other) and\n      args = cc.getNumberOfArguments() and\n      other != target\n    )\n  }\n\n  /** Holds if this upcast may be used to disambiguate the target of a call. */\n  private predicate isDisambiguatingCall() {\n    exists(Callable other, int args |\n      this.isDisambiguatingInstanceCall(other, args)\n      or\n      this.isDisambiguatingExtensionCall(other, args)\n      or\n      this.isDisambiguatingStaticCall(other, args)\n      or\n      this.isDisambiguatingConstructorCall(other, args)\n    |\n      args >= getMinimumArguments(other) and\n      not args > getMaximumArguments(other)\n    )\n  }\n\n  /** Holds if this is a useful upcast. */\n  predicate isUseful() {\n    this.isDisambiguatingCall()\n    or\n    this = any(Call c).(QualifiableExpr).getQualifier() and\n    dest instanceof Interface\n    or\n    this = any(OperatorCall oc).getAnArgument()\n    or\n    this =\n      any(Operation o |\n        not o instanceof Assignment and\n        not o instanceof UnaryBitwiseOperation and\n        not o instanceof SizeofExpr and\n        not o instanceof PointerIndirectionExpr and\n        not o instanceof AddressOfExpr and\n        not o instanceof UnaryLogicalOperation and\n        not o instanceof BinaryBitwiseOperation and\n        not o instanceof LogicalAndExpr and\n        not o instanceof LogicalOrExpr\n      ).getAnOperand()\n    or\n    this = any(LocalVariableDeclAndInitExpr decl | decl.isImplicitlyTyped()).getInitializer()\n    or\n    exists(LambdaExpr c | c.canReturn(this))\n    or\n    dest instanceof DynamicType\n  }\n}\n\nfrom ExplicitUpcast u, ValueOrRefType src, ValueOrRefType dest\nwhere\n  src = u.getSourceType() and\n  dest = u.getTargetType() and\n  not u.isUseful()\nselect u, \"There is no need to upcast from $@ to $@ - the conversion can be done implicitly.\", src,\n  src.getName(), dest, dest.getName()",
        "description": "Casting an expression is normally not needed when there exists an implicit conversion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/UselessUpcast.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npragma[noinline]\nprivate predicate isTypePattern(IsExpr ie, ValueOrRefType t, ValueOrRefType ct) {\n  t = ie.getExpr().getType() and\n  ct = ie.getPattern().(TypePatternExpr).getCheckedType()\n}\n\nfrom IsExpr ie, ValueOrRefType t, ValueOrRefType ct\nwhere\n  isTypePattern(ie, t, ct) and\n  ct = t.getABaseType+()\nselect ie,\n  \"There is no need to test whether an instance of $@ is also an instance of $@ - it always is.\", t,\n  t.getName(), ct, ct.getName()",
        "description": "There is no need to test whether or not an instance of a derived type is also an instance of a base type - it always is.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/UselessTypeTest.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.dataflow.internal.FlowSummaryImpl as FlowSummaryImpl\nimport semmle.code.csharp.dataflow.internal.DataFlowDispatch as DataFlowDispatch\nimport semmle.code.csharp.dataflow.internal.DataFlowPrivate as DataFlowPrivate\nimport semmle.code.csharp.frameworks.system.Collections\nimport semmle.code.csharp.frameworks.system.collections.Generic\n\npredicate lambdaCaptures(AnonymousFunctionExpr lambda, Variable v) {\n  exists(VariableAccess va | va.getEnclosingCallable() = lambda | va.getTarget() = v)\n}\n\npredicate lambdaCapturesLoopVariable(AnonymousFunctionExpr lambda, ForeachStmt loop, Variable v) {\n  lambdaCaptures(lambda, v) and\n  inForeachStmtBody(loop, lambda) and\n  loop.getVariable() = v\n}\n\npredicate inForeachStmtBody(ForeachStmt loop, Element e) {\n  e = loop.getBody()\n  or\n  exists(Element mid |\n    inForeachStmtBody(loop, mid) and\n    e = mid.getAChild()\n  )\n}\n\nmodule LambdaDataFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { lambdaCapturesLoopVariable(source.asExpr(), _, _) }\n\n  predicate isSink(DataFlow::Node sink) { exists(getAssignmentTarget(sink.asExpr())) }\n}\n\nmodule LambdaDataFlow {\n  private import DataFlow::Global<LambdaDataFlowConfig>\n\n  predicate capturesLoopVarAndIsStoredIn(\n    AnonymousFunctionExpr lambda, Variable loopVar, Element storage\n  ) {\n    exists(DataFlow::Node sink | flow(DataFlow::exprNode(lambda), sink) |\n      storage = getAssignmentTarget(sink.asExpr())\n    ) and\n    exists(ForeachStmt loop | lambdaCapturesLoopVariable(lambda, loop, loopVar) |\n      not declaredInsideLoop(loop, storage)\n    )\n  }\n}\n\nElement getAssignmentTarget(Expr e) {\n  exists(Assignment a | a.getRValue() = e |\n    result = a.getLValue().(PropertyAccess).getTarget() or\n    result = a.getLValue().(FieldAccess).getTarget() or\n    result = a.getLValue().(LocalVariableAccess).getTarget() or\n    result = a.getLValue().(EventAccess).getTarget()\n  )\n  or\n  exists(AddEventExpr aee |\n    e = aee.getRValue() and\n    result = aee.getLValue().getTarget()\n  )\n  or\n  result = getCollectionAssignmentTarget(e)\n}\n\nElement getCollectionAssignmentTarget(Expr e) {\n  // Store into collection via method\n  exists(DataFlowPrivate::PostUpdateNode postNode |\n    FlowSummaryImpl::Private::Steps::summarySetterStep(DataFlow::exprNode(e), _, postNode, _) and\n    result.(Variable).getAnAccess() = postNode.getPreUpdateNode().asExpr()\n  )\n  or\n  // Array initializer\n  e = result.(ArrayCreation).getInitializer().getAnElement()\n  or\n  // Collection initializer\n  e =\n    result\n        .(ObjectCreation)\n        .getInitializer()\n        .(CollectionInitializer)\n        .getElementInitializer(_)\n        .getAnArgument()\n  or\n  // Store values using indexer\n  exists(IndexerAccess ia, AssignExpr ae |\n    ia.getQualifier() = result.(Variable).getAnAccess() and\n    ia = ae.getLValue() and\n    e = ae.getRValue()\n  )\n}\n\n// Variable v is declared inside the loop body\npredicate declaredInsideLoop(ForeachStmt loop, LocalVariable v) {\n  exists(LocalVariableDeclStmt decl | decl.getVariableDeclExpr(_).getVariable() = v |\n    inForeachStmtBody(loop, decl)\n  )\n}\n\nfrom AnonymousFunctionExpr lambda, Variable loopVar, Element storage\nwhere LambdaDataFlow::capturesLoopVarAndIsStoredIn(lambda, loopVar, storage)\nselect lambda, \"Function which may be stored in $@ captures variable $@.\", storage,\n  storage.toString(), loopVar, loopVar.getName()",
        "description": "Code that captures a 'foreach' variable and uses it outside the loop behaves differently in C# version 4 and C# version 5",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/ForeachCapture.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nCatchClause containingCatchClause(Stmt s) {\n  result.getBlock() = s\n  or\n  exists(Stmt mid |\n    result = containingCatchClause(mid) and\n    mid.getAChildStmt() = s and\n    not mid instanceof CatchClause\n  )\n}\n\nfrom SpecificCatchClause cc, ThrowStmt throw\nwhere\n  throw.getExpr() = cc.getVariable().getAnAccess() and\n  containingCatchClause(throw) = cc\nselect throw, \"Rethrowing exception variable.\"",
        "description": "Throwing the exception variable will lose the original stack information. This can make errors harder to diagnose.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/RethrowException.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom IfStmt outer, IfStmt inner\nwhere\n  inner = outer.getThen().stripSingletonBlocks() and\n  not exists(outer.getElse()) and\n  not exists(inner.getElse())\nselect outer, \"These 'if' statements can be combined.\"",
        "description": "Nested 'if' statements can be simplified by combining them using '&&'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/NestedIf.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.StructuralComparison\n\npragma[noinline]\nprivate predicate same(AssignableAccess x, AssignableAccess y) {\n  exists(NullCoalescingExpr nce |\n    x = nce.getLeftOperand() and\n    y = nce.getRightOperand().getAChildExpr*()\n  ) and\n  sameGvn(x, y)\n}\n\nprivate predicate uselessNullCoalescingExpr(NullCoalescingExpr nce) {\n  exists(AssignableAccess x |\n    nce.getLeftOperand() = x and\n    forex(AssignableAccess y | same(x, y) | y instanceof AssignableRead and not y.isRefArgument())\n  )\n}\n\nfrom NullCoalescingExpr nce\nwhere uselessNullCoalescingExpr(nce)\nselect nce, \"Both operands of this null-coalescing expression access the same variable or property.\"",
        "description": "The null-coalescing operator is intended to help provide special handling for the case when a variable is null - its two operands should always do different things.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/UselessNullCoalescingExpression.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nclass GenericCatchClause extends CatchClause {\n  GenericCatchClause() {\n    this instanceof GeneralCatchClause\n    or\n    this =\n      any(SpecificCatchClause scc |\n        scc.getCaughtExceptionType() instanceof SystemExceptionClass and\n        not scc.hasFilterClause()\n      )\n  }\n}\n\nfrom GenericCatchClause gcc\nwhere\n  forall(ThrowStmt throw |\n    // ok to catch all exceptions if they may be rethrown\n    gcc.getBlock().getAChildStmt+() = throw\n  |\n    exists(throw.getExpr())\n  )\nselect gcc, \"Generic catch clause.\"",
        "description": "Catching all exceptions with a generic catch clause may be overly broad, which can make errors harder to diagnose.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/CatchOfGenericException.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.StructuralComparison\n\nprivate Expr getAssignedExpr(Stmt stmt) {\n  result = stmt.stripSingletonBlocks().(ExprStmt).getExpr().(AssignExpr).getLValue()\n}\n\nfrom IfStmt is, string what\nwhere\n  (\n    is.getThen().stripSingletonBlocks() instanceof ReturnStmt and\n    is.getElse().stripSingletonBlocks() instanceof ReturnStmt and\n    what = \"return\"\n    or\n    sameGvn(getAssignedExpr(is.getThen()), getAssignedExpr(is.getElse())) and\n    what = \"write to the same variable\"\n  ) and\n  not exists(IfStmt other | is = other.getElse())\nselect is,\n  \"Both branches of this 'if' statement \" + what + \" - consider using '?' to express intent better.\"",
        "description": "An 'if' statement where both branches either (a) return or (b) write to the same variable can often be expressed more clearly using the '?' operator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/MissedTernaryOpportunity.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom ExplicitCast c, ConstructedType src, TypeParameter dest\nwhere\n  c.getExpr() instanceof ThisAccess and\n  src = c.getExpr().getType() and\n  dest = c.getTargetType() and\n  dest = src.getUnboundGeneric().getATypeParameter()\nselect c,\n  \"Casting 'this' to $@, a type parameter of $@, masks an implicit type constraint that should be explicitly stated.\",\n  dest, dest.getName(), src, src.getName()",
        "description": "Casting 'this' to a type parameter of the current type masks an implicit type constraint that should be explicitly stated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Language Abuse/CastThisToTypeParameter.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Diagnostics\n\nfrom Diagnostic diagnostic\nselect diagnostic,\n  diagnostic.getSeverityText() + \" \" + diagnostic.getTag() + \" \" + diagnostic.getFullMessage()",
        "description": "A message emitted by the compiler, including warnings and errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Diagnostics/CompilerMessage.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Diagnostics\n\nprivate newtype TDiagnosticError =\n  TCompilerError(CompilerError c) or\n  TExtractorError(ExtractorError e)\n\nabstract private class DiagnosticError extends TDiagnosticError {\n  abstract string getMessage();\n\n  abstract string toString();\n\n  abstract Location getLocation();\n\n  string getLocationMessage() {\n    if this.getLocation().getFile().fromSource()\n    then result = \" in \" + this.getLocation().getFile()\n    else result = \"\"\n  }\n}\n\nprivate class DiagnosticCompilerError extends DiagnosticError {\n  CompilerError c;\n\n  DiagnosticCompilerError() { this = TCompilerError(c) }\n\n  override string getMessage() {\n    result = \"Compiler error\" + this.getLocationMessage() + \": \" + c.getMessage()\n  }\n\n  override string toString() { result = c.toString() }\n\n  override Location getLocation() { result = c.getLocation() }\n}\n\nprivate class DiagnosticExtractorError extends DiagnosticError {\n  ExtractorError e;\n\n  DiagnosticExtractorError() {\n    this = TExtractorError(e) and\n    not exists(CompilerError ce | ce.getLocation().getFile() = e.getLocation().getFile())\n  }\n\n  override string getMessage() {\n    result =\n      \"Unexpected \" + e.getOrigin() + \" error\" + this.getLocationMessage() + \": \" + e.getText()\n  }\n\n  override string toString() { result = e.toString() }\n\n  override Location getLocation() { result = e.getLocation() }\n}\n\nfrom DiagnosticError error\nselect error.getMessage(), 2",
        "description": "List all errors reported by the extractor or the compiler. Extractor errors are limited to those files where there are no compilation errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Diagnostics/DiagnosticExtractionErrors.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Diagnostics\n\nfrom CompilerError diagnostic\nselect diagnostic,\n  diagnostic.getSeverityText() + \" \" + diagnostic.getTag() + \" \" + diagnostic.getFullMessage()",
        "description": "A compilation error can cause extraction problems, and could lead to inaccurate results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Diagnostics/CompilerError.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Diagnostics\n\nfrom File file\nwhere file.fromSource()\nselect file, \"\"",
        "description": "A list of all files in the source code directory that were extracted without encountering an extraction or compiler error in the file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Diagnostics/ExtractedFiles.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Diagnostics\n\nfrom ExtractorMessage message\nselect message,\n  message.getSeverityText() + \" was generated by \" + message.getOrigin() + \": \" + message.getText() +\n    \"\\n\" + message.getStackTrace()",
        "description": "An error message reported by the extractor. This could lead to inaccurate results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Diagnostics/ExtractorMessage.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Diagnostics\n\nfrom ExtractorError error\nwhere not exists(CompilerError ce | ce.getLocation().getFile() = error.getLocation().getFile())\nselect error,\n  \"Unexpected \" + error.getOrigin() + \" error: \" + error.getText() + \"\\n\" + error.getStackTrace()",
        "description": "An error message reported by the extractor, limited to those files where there are no compilation errors. This indicates a bug or limitation in the extractor, and could lead to inaccurate results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Diagnostics/ExtractorError.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\nimport semmle.code.csharp.frameworks.system.runtime.InteropServices\n\n// Any field transitively contained in t.\nField getANestedField(ValueOrRefType t) {\n  result.getDeclaringType() = t\n  or\n  exists(Field mid |\n    mid = getANestedField(t) and\n    mid.getType() = result.getDeclaringType()\n  )\n}\n\n// Any ValueOrRefType referenced by a Type, including TypeParameters.\nValueOrRefType getAReferencedType(Type t) {\n  result = t\n  or\n  result = t.(TypeParameter).getASuppliedType()\n}\n\npredicate isTypeExternallyInitialized(ValueOrRefType t) {\n  // The type got created via a call to PtrToStructure().\n  exists(MethodCall mc, Type t0, Expr arg |\n    mc.getTarget() = any(SystemRuntimeInteropServicesMarshalClass c).getPtrToStructureTypeMethod() and\n    t = getAReferencedType(t0) and\n    arg = mc.getArgument(1)\n  |\n    t0 = arg.(TypeofExpr).getTypeAccess().getTarget()\n    or\n    t0 = arg.getType()\n  )\n  or\n  // An extern method exists which could initialize the type.\n  exists(Method m, Parameter p |\n    isExternMethod(m) and\n    p = m.getAParameter() and\n    t = p.getType()\n  |\n    p.isOut() or p.isRef()\n  )\n  or\n  // The data structure has been cast to a pointer - all bets are off.\n  exists(CastExpr c | t = getAReferencedType(c.getTargetType().(PointerType).getReferentType()))\n}\n\n// The type is potentially marshaled using an extern or interop.\npredicate isFieldExternallyInitialized(Field f) {\n  exists(ValueOrRefType t |\n    f = getANestedField(t) and\n    isTypeExternallyInitialized(t)\n  )\n}\n\npredicate isExternMethod(Method externMethod) {\n  externMethod.isExtern()\n  or\n  externMethod.getAnAttribute().getType() instanceof\n    SystemRuntimeInteropServicesDllImportAttributeClass\n  or\n  externMethod.getDeclaringType().getAnAttribute().getType() instanceof\n    SystemRuntimeInteropServicesComImportAttributeClass\n}\n\nfrom Field f, FieldRead fa\nwhere\n  f.fromSource() and\n  not extractionIsStandalone() and\n  not f.isReadOnly() and\n  not f.isConst() and\n  not f.getDeclaringType() instanceof Enum and\n  not f.getType() instanceof Struct and\n  not exists(Assignment ae, Field g |\n    ae.getLValue().(FieldAccess).getTarget() = g and\n    g.getUnboundDeclaration() = f and\n    not ae.getRValue() instanceof NullLiteral\n  ) and\n  not exists(MethodCall mc, int i, Field g |\n    exists(Parameter p | mc.getTarget().getParameter(i) = p | p.isOut() or p.isRef()) and\n    mc.getArgument(i) = g.getAnAccess() and\n    g.getUnboundDeclaration() = f\n  ) and\n  not isFieldExternallyInitialized(f) and\n  not exists(f.getAnAttribute()) and\n  not exists(Expr init, Field g |\n    g.getUnboundDeclaration() = f and\n    g.getInitializer() = init and\n    not init instanceof NullLiteral\n  ) and\n  not exists(AssignOperation ua, Field g |\n    ua.getLValue().(FieldAccess).getTarget() = g and\n    g.getUnboundDeclaration() = f\n  ) and\n  not exists(MutatorOperation op |\n    op.getAnOperand().(FieldAccess).getTarget().getUnboundDeclaration() = f\n  ) and\n  exists(Field g |\n    fa.getTarget() = g and\n    g.getUnboundDeclaration() = f\n  )\nselect f, \"The field '\" + f.getName() + \"' is never explicitly assigned a value, yet $@.\", fa,\n  \"the field is read\"",
        "description": "Fields are automatically initialised with the default values for their type, which may not be the intent: prefer explicit initialisation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Dead Code/NonAssignedFields.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport DeadCode\n\nfrom Field f\nwhere\n  not extractionIsStandalone() and\n  f.fromSource() and\n  isDeadField(f) and\n  not f.getDeclaringType().isPartial()\nselect f, \"Unused field (or field used from dead method only).\"",
        "description": "Finds private fields that seem to never be used, or solely used from dead methods",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Dead Code/UnusedField.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nCallable getACapturingCallableAncestor(LocalVariable v) {\n  result = v.getACapturingCallable()\n  or\n  exists(Callable mid | mid = getACapturingCallableAncestor(v) |\n    result = mid.getEnclosingCallable() and\n    not v.getEnclosingCallable() = result\n  )\n}\n\nExpr getADelegateExpr(Callable c) {\n  c = result.(CallableAccess).getTarget()\n  or\n  result = c.(AnonymousFunctionExpr)\n}\n\npredicate nonEscapingCall(Call c) {\n  exists(string name | c.getTarget().hasName(name) |\n    name =\n      [\n        \"ForEach\", \"Count\", \"Any\", \"All\", \"Average\", \"Aggregate\", \"First\", \"Last\", \"FirstOrDefault\",\n        \"LastOrDefault\", \"LongCount\", \"Max\", \"Single\", \"SingleOrDefault\", \"Sum\"\n      ]\n  )\n}\n\npredicate mayEscape(LocalVariable v) {\n  exists(Callable c, Expr e, Expr succ | c = getACapturingCallableAncestor(v) |\n    e = getADelegateExpr(c) and\n    DataFlow::localExprFlow(e, succ) and\n    not succ = any(DelegateCall dc).getExpr() and\n    not succ = any(Cast cast).getExpr() and\n    not succ = any(Call call | nonEscapingCall(call)).getAnArgument() and\n    not succ = any(AssignableDefinition ad | ad.getTarget() instanceof LocalVariable).getSource()\n  )\n}\n\nclass RelevantDefinition extends AssignableDefinition {\n  RelevantDefinition() {\n    this.(AssignableDefinitions::AssignmentDefinition).getAssignment() =\n      any(Assignment a | not a = any(UsingDeclStmt uds).getAVariableDeclExpr())\n    or\n    this instanceof AssignableDefinitions::MutationDefinition\n    or\n    this instanceof AssignableDefinitions::TupleAssignmentDefinition\n    or\n    // Discards in out assignments are only possible from C# 7 (2017), so we disable this case\n    // for now\n    //or\n    //this.(AssignableDefinitions::OutRefDefinition).getTargetAccess().isOutArgument()\n    this.(AssignableDefinitions::LocalVariableDefinition).getDeclaration() =\n      any(LocalVariableDeclExpr lvde |\n        lvde = any(SpecificCatchClause scc).getVariableDeclExpr()\n        or\n        lvde = any(ForeachStmt fs).getVariableDeclExpr() and\n        not lvde.getName() = \"_\"\n      )\n    or\n    this instanceof AssignableDefinitions::PatternDefinition\n  }\n\n  /** Holds if this assignment may be live. */\n  private predicate isMaybeLive() {\n    exists(LocalVariable v | v = this.getTarget() |\n      // SSA definitions are only created for live variables\n      this = any(Ssa::ExplicitDefinition ssaDef).getADefinition()\n      or\n      mayEscape(v)\n      or\n      v.isCaptured()\n    )\n  }\n\n  /** Holds if this definition is a variable initializer, for example `string s = null`. */\n  private predicate isInitializer() {\n    this.getSource() = this.getTarget().(LocalVariable).getInitializer()\n  }\n\n  /**\n   * Holds if this definition is a default-like variable initializer, for example\n   * `string s = null` or `int i = 0`, but not `string s = \"Hello\"`.\n   */\n  private predicate isDefaultLikeInitializer() {\n    this.isInitializer() and\n    exists(Expr e | e = this.getSource().stripCasts() |\n      e.getValue() = [\"0\", \"-1\", \"\", \"false\"]\n      or\n      e instanceof NullLiteral\n      or\n      e =\n        any(Field f |\n          f.isStatic() and\n          (f.isReadOnly() or f.isConst())\n        ).getAnAccess()\n      or\n      e instanceof DefaultValueExpr\n      or\n      e instanceof AnonymousObjectCreation\n    )\n  }\n\n  /** Holds if this definition is dead and we want to report it. */\n  predicate isDead() {\n    // Ensure that the definition is not in dead code\n    exists(this.getExpr().getAControlFlowNode()) and\n    not this.isMaybeLive() and\n    // Allow dead initializer assignments, such as `string s = string.Empty`, but only\n    // if the initializer expression assigns a default-like value, and there exists another\n    // definition of the same variable\n    if this.isDefaultLikeInitializer()\n    then this = unique(AssignableDefinition def | def.getTarget() = this.getTarget())\n    else any()\n  }\n}\n\nfrom RelevantDefinition def, LocalVariable v\nwhere\n  v = def.getTarget() and\n  def.isDead()\nselect def, \"This assignment to $@ is useless, since its value is never read.\", v, v.getName()",
        "description": "An assignment to a local variable that is not used later on, or whose value is always overwritten, has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Dead Code/DeadStoreOfLocal.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Util\nimport semmle.code.csharp.frameworks.Test\nimport semmle.code.csharp.metrics.Coupling\n\npredicate potentiallyUsedFromXaml(RefType t) {\n  t.getABaseType*()\n      .hasFullyQualifiedName(\"System.Windows.Data\", [\"IValueConverter\", \"IMultiValueConverter\"])\n}\n\nclass ExportAttribute extends Attribute {\n  ExportAttribute() {\n    this.getType().hasFullyQualifiedName(\"System.ComponentModel.Composition\", \"ExportAttribute\")\n  }\n}\n\nfrom RefType t\nwhere\n  not extractionIsStandalone() and\n  t.fromSource() and\n  t.isUnboundDeclaration() and\n  not t instanceof AnonymousClass and\n  not (t.isPublic() or t.isProtected()) and\n  not exists(ValueOrRefType dependent | depends(dependent, t) and dependent != t) and\n  not exists(ConstructedType ct | usesType(ct, t)) and\n  not exists(MethodCall call | usesType(call.getTarget().(ConstructedMethod).getATypeArgument(), t)) and\n  not t.getAMethod() instanceof MainMethod and\n  not potentiallyUsedFromXaml(t) and\n  not exists(TypeofExpr typeof | typeof.getTypeAccess().getTarget() = t) and\n  not t instanceof TestClass and\n  // MemberConstant nodes are compile-time constant and can appear in various contexts\n  // where they don't have enclosing callables or types (e.g. in attribute values).\n  // Classes that are declared purely to hold member constants which are used are,\n  // therefore, not dead.\n  not exists(t.getAMember().(MemberConstant).getAnAccess()) and\n  not t.getAnAttribute() instanceof ExportAttribute\nselect t, \"Unused reference type \" + t + \".\"",
        "description": "Finds non-public reference types (classes, interfaces) that are not accessed anywhere in the codebase.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Dead Code/DeadRefTypes.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport DeadCode\n\nfrom Method m\nwhere\n  not extractionIsStandalone() and\n  m.fromSource() and\n  isDeadMethod(m) and\n  not m.getDeclaringType().isPartial()\nselect m, \"Unused method (or method called from dead method only).\"",
        "description": "Finds private methods that seem to never be used, or solely used from other dead methods",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Dead Code/UnusedMethod.ql",
        "language": "csharp"
    },
    {
        "query": "private import csharp\nprivate import semmle.code.csharp.dispatch.Dispatch\nprivate import semmle.code.csharp.telemetry.ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.hasSummary() }\n\nfrom string info, int usages\nwhere Results<relevant/1>::restrict(info, usages)\nselect info, usages order by usages desc",
        "description": "A list of 3rd party APIs detected as flow steps. Excludes APIs exposed by test libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/SupportedExternalTaint.ql",
        "language": "csharp"
    },
    {
        "query": "private import csharp\nprivate import semmle.code.csharp.telemetry.ExternalApi\n\nprivate predicate relevant(ExternalApi api) { not api.isSupported() }\n\nfrom string info, int usages\nwhere Results<relevant/1>::restrict(info, usages)\nselect info, usages order by usages desc",
        "description": "A list of 3rd party APIs used in the codebase. Excludes APIs exposed by test libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/UnsupportedExternalAPIs.ql",
        "language": "csharp"
    },
    {
        "query": "private import csharp\nprivate import semmle.code.csharp.dispatch.Dispatch\nprivate import semmle.code.csharp.telemetry.ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.isSource() }\n\nfrom string info, int usages\nwhere Results<relevant/1>::restrict(info, usages)\nselect info, usages order by usages desc",
        "description": "A list of 3rd party APIs detected as sources. Excludes APIs exposed by test libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/SupportedExternalSources.ql",
        "language": "csharp"
    },
    {
        "query": "private import csharp\nprivate import semmle.code.csharp.dispatch.Dispatch\nprivate import semmle.code.csharp.telemetry.ExternalApi\n\nprivate predicate getRelevantUsages(string namespace, int usages) {\n  usages =\n    strictcount(Call c, ExternalApi api |\n      c.getTarget().getUnboundDeclaration() = api and\n      api.getNamespace() = namespace and\n      c.fromSource()\n    )\n}\n\nprivate int getOrder(string namespace) {\n  namespace =\n    rank[result](string i, int usages | getRelevantUsages(i, usages) | i order by usages desc, i)\n}\n\nfrom ExternalApi api, string namespace, int usages\nwhere\n  namespace = api.getNamespace() and\n  getRelevantUsages(namespace, usages) and\n  getOrder(namespace) <= resultLimit()\nselect namespace, usages order by usages desc",
        "description": "A list of external libraries used in the code given by their namespace.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/ExternalLibraryUsage.ql",
        "language": "csharp"
    },
    {
        "query": "private import csharp\nprivate import semmle.code.csharp.dispatch.Dispatch\nprivate import semmle.code.csharp.telemetry.ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.isSink() }\n\nfrom string info, int usages\nwhere Results<relevant/1>::restrict(info, usages)\nselect info, usages order by usages desc",
        "description": "A list of 3rd party APIs detected as sinks. Excludes APIs exposed by test libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/SupportedExternalSinks.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport DatabaseQuality\n\nprivate predicate diagnostic(string msg, float value, float threshold) {\n  CallTargetStatsReport::percentageOfOk(msg, value) and\n  threshold = 85\n  or\n  ExprTypeStatsReport::percentageOfOk(msg, value) and\n  threshold = 85\n}\n\nprivate newtype TDbQualityDiagnostic =\n  TTheDbQualityDiagnostic() {\n    exists(float percentageGood, float threshold |\n      diagnostic(_, percentageGood, threshold) and\n      percentageGood < threshold\n    )\n  }\n\nprivate string getDbHealth() {\n  result =\n    strictconcat(string msg, float value, float threshold |\n      diagnostic(msg, value, threshold)\n    |\n      msg + \": \" + value.floor() + \" % (threshold \" + threshold.floor() + \" %)\", \". \"\n    )\n}\n\nclass DbQualityDiagnostic extends TDbQualityDiagnostic {\n  string toString() {\n    result =\n      \"Scanning C# code completed successfully, but the scan encountered issues. \" +\n        \"This may be caused by problems identifying dependencies or use of generated source code. \" +\n        \"Some metrics of the database quality are: \" + getDbHealth() + \". \" +\n        \"Ideally these metrics should be above their thresholds. \" +\n        \"Addressing these issues is advisable to avoid false-positives or missing results. If they cannot be addressed, consider scanning C# \"\n        +\n        \"using either the `autobuild` or `manual` [build modes](https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages#comparison-of-the-build-modes).\"\n  }\n}\n\nquery predicate diagnosticAttributes(DbQualityDiagnostic e, string key, string value) {\n  exists(e) and // Quieten warning about unconstrained 'e'\n  key = [\"visibilityCliSummaryTable\", \"visibilityTelemetry\", \"visibilityStatusPage\"] and\n  value = \"true\"\n}\n\nfrom DbQualityDiagnostic d\nselect d, d.toString(), 1",
        "description": "Low C# analysis quality",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/DatabaseQualityDiagnostics.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Diagnostics\nimport DatabaseQuality\n\npredicate compilationInfo(string key, float value) {\n  not key.matches(\"Compiler diagnostic count for%\") and\n  not key.matches(\"Extractor message count for group%\") and\n  exists(Compilation c, string infoKey, string infoValue | infoValue = c.getInfo(infoKey) |\n    key = infoKey and\n    value = infoValue.toFloat()\n    or\n    not exists(infoValue.toFloat()) and\n    key = infoKey + \": \" + infoValue and\n    value = 1\n  )\n}\n\npredicate compilerDiagnostics(string key, int value) {\n  key.matches(\"Compiler diagnostic count for%\") and\n  strictsum(Compilation c | | c.getInfo(key).toInt()) = value\n}\n\npredicate extractorMessages(string key, int value) {\n  key.matches(\"Extractor message count for group%\") and\n  strictsum(Compilation c | | c.getInfo(key).toInt()) = value\n}\n\npredicate fileCount(string key, int value) {\n  key = \"Number of files\" and\n  value = strictcount(File f)\n}\n\npredicate fileCountByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Number of files with extension \" + extension and\n    value = strictcount(File f | f.getExtension() = extension)\n  )\n}\n\npredicate totalNumberOfLines(string key, int value) {\n  key = \"Total number of lines\" and\n  value = strictsum(File f | any() | f.getNumberOfLines())\n}\n\npredicate numberOfLinesOfCode(string key, int value) {\n  key = \"Number of lines of code\" and\n  value = strictsum(File f | any() | f.getNumberOfLinesOfCode())\n}\n\npredicate totalNumberOfLinesByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Total number of lines with extension \" + extension and\n    value = strictsum(File f | f.getExtension() = extension | f.getNumberOfLines())\n  )\n}\n\npredicate numberOfLinesOfCodeByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Number of lines of code with extension \" + extension and\n    value = strictsum(File f | f.getExtension() = extension | f.getNumberOfLinesOfCode())\n  )\n}\n\npredicate extractorDiagnostics(string key, int value) {\n  exists(int severity |\n    key = \"Number of diagnostics with severity \" + severity.toString() and\n    value = strictcount(Diagnostic d | d.getSeverity() = severity)\n  )\n}\n\nCompilerError getAmbiguityCompilerError() {\n  result.getSeverity() >= 3 and\n  result.getTag() = [\"CS0101\", \"CS0104\", \"CS0111\", \"CS0121\", \"CS0229\"]\n}\n\npredicate numberOfAmbiguityCompilerErrors(string key, int value) {\n  value = count(getAmbiguityCompilerError()) and\n  key = \"Number of compiler reported ambiguity errors\"\n}\n\npredicate numberOfDistinctAmbiguityCompilerErrorMessages(string key, int value) {\n  value = count(getAmbiguityCompilerError().getFullMessage()) and\n  key = \"Number of compiler reported ambiguity error messages\"\n}\n\npredicate extractionIsStandalone(string key, int value) {\n  (\n    value = 1 and\n    extractionIsStandalone()\n    or\n    value = 0 and\n    not extractionIsStandalone()\n  ) and\n  key = \"Is extracted with build-mode set to 'none'\"\n}\n\nmodule TypeMentionTypeStats implements StatsSig {\n  int getNumberOfOk() { result = count(TypeMention t | not t.getType() instanceof UnknownType) }\n\n  int getNumberOfNotOk() { result = count(TypeMention t | t.getType() instanceof UnknownType) }\n\n  string getOkText() { result = \"type mentions with known type\" }\n\n  string getNotOkText() { result = \"type mentions with unknown type\" }\n}\n\nmodule AccessTargetStats implements StatsSig {\n  int getNumberOfOk() { result = count(Access a | exists(a.getTarget())) }\n\n  int getNumberOfNotOk() { result = count(Access a | not exists(a.getTarget())) }\n\n  string getOkText() { result = \"access with target\" }\n\n  string getNotOkText() { result = \"access with missing target\" }\n}\n\nmodule ExprStats implements StatsSig {\n  int getNumberOfOk() { result = count(Expr e | not e instanceof @unknown_expr) }\n\n  int getNumberOfNotOk() { result = count(Expr e | e instanceof @unknown_expr) }\n\n  string getOkText() { result = \"expressions with known kind\" }\n\n  string getNotOkText() { result = \"expressions with unknown kind\" }\n}\n\nmodule TypeMentionTypeStatsReport = ReportStats<TypeMentionTypeStats>;\n\nmodule AccessTargetStatsReport = ReportStats<AccessTargetStats>;\n\nmodule ExprStatsReport = ReportStats<ExprStats>;\n\npredicate analyzerAssemblies(string key, float value) {\n  exists(Compilation c, string arg |\n    c.getExpandedArgument(_) = arg and\n    arg.indexOf(\"/analyzer:\") = 0 and\n    key = \"CSC analyzer: \" + arg.substring(10, arg.length())\n  ) and\n  value = 1.0\n}\n\nfrom string key, float value\nwhere\n  (\n    compilationInfo(key, value) or\n    compilerDiagnostics(key, value) or\n    extractorMessages(key, value) or\n    fileCount(key, value) or\n    fileCountByExtension(key, value) or\n    totalNumberOfLines(key, value) or\n    numberOfLinesOfCode(key, value) or\n    totalNumberOfLinesByExtension(key, value) or\n    numberOfLinesOfCodeByExtension(key, value) or\n    extractorDiagnostics(key, value) or\n    numberOfAmbiguityCompilerErrors(key, value) or\n    numberOfDistinctAmbiguityCompilerErrorMessages(key, value) or\n    extractionIsStandalone(key, value) or\n    CallTargetStatsReport::numberOfOk(key, value) or\n    CallTargetStatsReport::numberOfNotOk(key, value) or\n    CallTargetStatsReport::percentageOfOk(key, value) or\n    ExprTypeStatsReport::numberOfOk(key, value) or\n    ExprTypeStatsReport::numberOfNotOk(key, value) or\n    ExprTypeStatsReport::percentageOfOk(key, value) or\n    TypeMentionTypeStatsReport::numberOfOk(key, value) or\n    TypeMentionTypeStatsReport::numberOfNotOk(key, value) or\n    TypeMentionTypeStatsReport::percentageOfOk(key, value) or\n    AccessTargetStatsReport::numberOfOk(key, value) or\n    AccessTargetStatsReport::numberOfNotOk(key, value) or\n    AccessTargetStatsReport::percentageOfOk(key, value) or\n    ExprStatsReport::numberOfOk(key, value) or\n    ExprStatsReport::numberOfNotOk(key, value) or\n    ExprStatsReport::percentageOfOk(key, value) or\n    analyzerAssemblies(key, value)\n  ) and\n  /* Infinity */\n  value != 1.0 / 0.0 and\n  /* -Infinity */\n  value != -1.0 / 0.0 and\n  /* NaN */\n  value != 0.0 / 0.0\nselect key, value",
        "description": "Information about the extraction for a C# database",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/ExtractorInformation.ql",
        "language": "csharp"
    },
    {
        "query": "private import csharp\nprivate import semmle.code.csharp.dispatch.Dispatch\nprivate import semmle.code.csharp.telemetry.ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.isSupported() }\n\nfrom string info, int usages\nwhere Results<relevant/1>::restrict(info, usages)\nselect info, usages order by usages desc",
        "description": "A list of supported 3rd party APIs used in the codebase. Excludes APIs exposed by test libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Telemetry/SupportedExternalApis.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.Text\n\nfrom ObjectCreation creation, LoopStmt loop, ControlFlow::Node loopEntryNode\nwhere\n  creation.getType() instanceof SystemTextStringBuilderClass and\n  loopEntryNode = loop.getBody().getAControlFlowEntryNode() and\n  loop.getBody().getAChild*() = creation and\n  creation.getAControlFlowNode().postDominates(loopEntryNode)\nselect creation, \"Creating a 'StringBuilder' in a loop.\"",
        "description": "Creating a 'StringBuilder' in a loop is less efficient than reusing a single 'StringBuilder'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Performance/StringBuilderInLoop.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.StructuralComparison\nimport semmle.code.csharp.controlflow.Guards as G\n\npragma[noinline]\nprivate predicate candidate(MethodCall mc, IndexerRead access) {\n  mc.getTarget().hasName(\"ContainsKey\") and\n  access.getQualifier().(G::GuardedExpr).isGuardedBy(mc, mc.getQualifier(), _)\n}\n\nfrom MethodCall call, IndexerRead index\nwhere\n  candidate(call, index) and\n  sameGvn(call.getArgument(0), index.getIndex(0))\nselect call, \"Inefficient use of 'ContainsKey' and $@.\", index, \"indexer\"",
        "description": "Testing whether a dictionary contains a value before getting it is inefficient and redundant. Use 'TryGetValue' to combine these two steps.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Performance/UseTryGetValue.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\n// any use of + that has string type\nclass StringCat extends AddExpr {\n  StringCat() { this.getType() instanceof StringType }\n}\n\npredicate isSelfConcatAssignExpr(AssignExpr e, Variable v) {\n  not e = any(AssignAddExpr a).getExpandedAssignment() and\n  exists(VariableAccess use |\n    stringCatContains(e.getRValue(), use) and\n    use.getTarget() = e.getTargetVariable() and\n    v = use.getTarget()\n  )\n}\n\npredicate stringCatContains(StringCat expr, Expr child) {\n  child = expr or\n  stringCatContains(expr, child.getParent())\n}\n\npredicate isConcatExpr(AssignAddExpr e, Variable v) {\n  e.getLValue().getType() instanceof StringType and\n  v = e.getTargetVariable()\n}\n\nfrom Expr e\nwhere\n  exists(LoopStmt loop, Variable v |\n    e.getEnclosingStmt().getParent*() = loop and\n    (isSelfConcatAssignExpr(e, v) or isConcatExpr(e, v)) and\n    forall(LocalVariableDeclExpr l | l.getVariable() = v | not l.getParent*() = loop)\n  )\nselect e, \"String concatenation in loop: use 'StringBuilder'.\"",
        "description": "Finds code that performs string concatenation in a loop using the + operator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Performance/StringConcatenationInLoop.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nclass DangerousExpression extends Expr {\n  DangerousExpression() {\n    exists(Expr e | this = e.getParent*() |\n      exists(Expr q | q = e.(MemberAccess).getQualifier() |\n        not q instanceof ThisAccess and\n        not q instanceof BaseAccess\n      )\n      or\n      e instanceof MethodCall\n      or\n      e instanceof ArrayAccess\n    ) and\n    not exists(Expr e | this = e.getParent*() | e.(Call).getTarget().getAParameter().isOutOrRef())\n  }\n}\n\nclass NonShortCircuit extends BinaryBitwiseOperation {\n  NonShortCircuit() {\n    (\n      this instanceof BitwiseAndExpr\n      or\n      this instanceof BitwiseOrExpr\n    ) and\n    not exists(AssignBitwiseOperation abo | abo.getExpandedAssignment().getRValue() = this) and\n    this.getLeftOperand().getType() instanceof BoolType and\n    this.getRightOperand().getType() instanceof BoolType and\n    this.getRightOperand() instanceof DangerousExpression\n  }\n}\n\nfrom NonShortCircuit e\nselect e, \"Potentially dangerous use of non-short circuit logic.\"",
        "description": "The & and | operators do not use short-circuit evaluation and can be dangerous when applied to boolean operands. In particular, their use can result in errors if the left-hand operand checks for cases in which it is not safe to evaluate the right-hand one.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/DangerousNonShortCircuitLogic.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.system.collections.Generic\n\nclass UnsafeField extends Field {\n  UnsafeField() {\n    this.isStatic() and\n    not this.getAnAttribute().getType().hasFullyQualifiedName(\"System\", \"ThreadStaticAttribute\") and\n    this.getType() instanceof UsesICryptoTransform\n  }\n}\n\nValueOrRefType getAnEnumeratedType(ValueOrRefType type) {\n  exists(ConstructedInterface interface |\n    interface = type.getABaseInterface*() and\n    interface.getUnboundGeneric() instanceof SystemCollectionsGenericIEnumerableTInterface\n  |\n    result = interface.getATypeArgument()\n  )\n}\n\nclass UsesICryptoTransform extends ValueOrRefType {\n  UsesICryptoTransform() {\n    this instanceof ICryptoTransform\n    or\n    this.getAField().getType() instanceof UsesICryptoTransform\n    or\n    this.getAProperty().getType() instanceof UsesICryptoTransform\n    or\n    getAnEnumeratedType(this) instanceof UsesICryptoTransform\n  }\n}\n\nclass ICryptoTransform extends ValueOrRefType {\n  ICryptoTransform() {\n    this.getABaseType*().hasFullyQualifiedName(\"System.Security.Cryptography\", \"ICryptoTransform\")\n  }\n}\n\nfrom UnsafeField field\nwhere field.fromSource()\nselect field,\n  \"Static field '\" + field.getName() +\n    \"' contains a 'System.Security.Cryptography.ICryptoTransform' that could be used in an unsafe way.\"",
        "description": "The class has a field that directly or indirectly make use of a static System.Security.Cryptography.ICryptoTransform object. Using this an instance of this class in concurrent threads is dangerous as it may not only result in an error, but under some circumstances may also result in incorrect results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/ThreadUnsafeICryptoTransform.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom EqualityOperation e\nwhere\n  e.getAnOperand().getType() instanceof FloatingPointType and\n  not e.getAnOperand() instanceof NullLiteral\nselect e, \"Equality checks on floating point values can yield unexpected results.\"",
        "description": "Comparing results of floating-point computations with '==' or '!=' is likely to yield surprising results since floating-point computation does not follow the standard rules of algebra.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/EqualityCheckOnFloats.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom EqualsMethod m, IsExpr e, Class isType\nwhere\n  m.fromSource() and\n  e.getEnclosingCallable() = m and\n  e.getExpr().(VariableAccess).getTarget() = m.getParameter(0) and\n  isType = e.getPattern().(TypePatternExpr).getCheckedType() and\n  not isType.isSealed() and\n  not exists(MethodCall c |\n    c.getEnclosingCallable() = m and\n    c.getTarget().getName() = \"GetType\" and\n    c.getQualifier().(VariableAccess).getTarget() = m.getParameter(0)\n  )\nselect e,\n  m.getDeclaringType().getName() +\n    \".Equals(object) should not use \\\"is\\\" on its parameter, as it will not work properly for subclasses of \"\n    + isType.getName() + \".\"",
        "description": "Implementations of 'Equals' should not use \"is\" to test the type of the argument, but rather call GetType(). This guards against the possibility that the argument type will be subclassed. Otherwise, it is likely that the Equals method will not be symmetric, violating its contract.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/EqualsUsesIs.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom FieldWrite fw, Field f, Callable c\nwhere\n  fw.getTarget() = f and\n  f.isStatic() and\n  c = fw.getEnclosingCallable() and\n  not [c.(Member), c.(Accessor).getDeclaration()].isStatic() and\n  f.getDeclaringType() = c.getDeclaringType() and\n  c.fromSource()\nselect fw.(VariableAccess), \"Write to static field from instance method, property, or constructor.\"",
        "description": "Finds instance methods and properties that write to static fields. This is tricky to get right if multiple instances are being manipulated, and generally bad practice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/StaticFieldWrittenByInstance.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate isEraStart(int year, int month, int day) {\n  year = 1989 and month = 1 and day = 8\n  or\n  year = 2019 and month = 5 and day = 1\n}\n\npredicate isExactEraStartDateCreation(ObjectCreation cr) {\n  (\n    cr.getType().hasFullyQualifiedName(\"System\", \"DateTime\") or\n    cr.getType().hasFullyQualifiedName(\"System\", \"DateTimeOffset\")\n  ) and\n  isEraStart(cr.getArgument(0).getValue().toInt(), cr.getArgument(1).getValue().toInt(),\n    cr.getArgument(2).getValue().toInt())\n}\n\npredicate isDateFromJapaneseCalendarToDateTime(MethodCall mc) {\n  (\n    mc.getQualifier().getType().hasFullyQualifiedName(\"System.Globalization\", \"JapaneseCalendar\") or\n    mc.getQualifier()\n        .getType()\n        .hasFullyQualifiedName(\"System.Globalization\", \"JapaneseLunisolarCalendar\")\n  ) and\n  mc.getTarget().hasName(\"ToDateTime\") and\n  mc.getArgument(0).hasValue() and\n  (\n    mc.getNumberOfArguments() = 7 // implicitly current era\n    or\n    mc.getNumberOfArguments() = 8 and\n    mc.getArgument(7).getValue() = \"0\"\n  ) // explicitly current era\n}\n\npredicate isDateFromJapaneseCalendarCreation(ObjectCreation cr) {\n  (\n    cr.getType().hasFullyQualifiedName(\"System\", \"DateTime\") or\n    cr.getType().hasFullyQualifiedName(\"System\", \"DateTimeOffset\")\n  ) and\n  (\n    cr.getArgumentForName(\"calendar\")\n        .getType()\n        .hasFullyQualifiedName(\"System.Globalization\", \"JapaneseCalendar\") or\n    cr.getArgumentForName(\"calendar\")\n        .getType()\n        .hasFullyQualifiedName(\"System.Globalization\", \"JapaneseLunisolarCalendar\")\n  ) and\n  cr.getArgumentForName(\"year\").hasValue()\n}\n\nfrom Expr expr, string message\nwhere\n  isDateFromJapaneseCalendarToDateTime(expr) and\n  message =\n    \"'DateTime' created from Japanese calendar with explicit or current era and hard-coded year.\"\n  or\n  isDateFromJapaneseCalendarCreation(expr) and\n  message =\n    \"'DateTime' constructed from Japanese calendar with explicit or current era and hard-coded year.\"\n  or\n  isExactEraStartDateCreation(expr) and\n  message = \"Hard-coded the beginning of the Japanese Heisei era.\"\nselect expr, message",
        "description": "Japanese era should be handled with the built-in 'JapaneseCalendar' class. Avoid hard-coding Japanese era start dates and names.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/MishandlingJapaneseEra.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\npredicate whitelist(MethodCall mc) {\n  // Allow tests to verify that equals methods return false\n  mc.getParent*().(MethodCall).getTarget().hasName(\"IsFalse\")\n}\n\nfrom EqualsMethod equals, MethodCall ma, Type i, Type j\nwhere\n  ma.getTarget() = equals and\n  not whitelist(ma) and\n  // find the source types\n  ma.getArgument(0).getType() = i and\n  ma.getQualifier().getType() = j and\n  // If one of the types is object, then we know they overlap, so\n  // no point checking.\n  not i instanceof ObjectType and\n  not j instanceof ObjectType and\n  // In standalone extraction mode, we have to test the\n  // weaker condition that they are unrelated classes,\n  // and we have enough type information to relate the two classes,\n  // which would normally be 'object' without extraction errors.\n  (extractionIsStandalone() implies i.(Class).getBaseClass*() = j.(Class).getBaseClass*()) and\n  // check they are not related\n  not exists(ValueOrRefType k |\n    k.getABaseType*() = j and\n    k.getABaseType*() = i\n  ) and\n  // exclude wildcards since the check is not applicable to them\n  not (i instanceof TypeParameter or j instanceof TypeParameter) and\n  // exclude calls of the form x.Equals(null), since they're highlighted by a different query\n  not i instanceof NullType\nselect ma, \"Call to 'Equals()' comparing incomparable types $@ and $@.\", j, j.getName(), i,\n  i.getName()",
        "description": "Finds calls of the form 'x.Equals(y)' with incomparable types for x and y.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/IncomparableEquals.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\nimport semmle.code.csharp.frameworks.system.Collections\n\n// Does method m have an override in t or one of its derived classes?\npragma[nomagic]\npredicate methodOverriddenBelow(Method m, Class t) {\n  m.getAnOverrider*().getDeclaringType() = t.getASubType*()\n}\n\npredicate isIEnumerable(ValueOrRefType t) {\n  t instanceof ArrayType or // Extractor doesn't extract interfaces of ArrayType yet.\n  t.getABaseInterface*() instanceof SystemCollectionsIEnumerableInterface\n}\n\nfrom MethodCall m\nwhere\n  m.getTarget() instanceof EqualsMethod and\n  isIEnumerable(m.getQualifier().getType()) and\n  isIEnumerable(m.getArgument(0).getType()) and\n  not methodOverriddenBelow(m.getTarget(), m.getQualifier().getType())\nselect m, \"Using Equals(object) on a collection only checks reference equality.\"",
        "description": "Comparing collections using the Equals method only checks reference equality. A deep compare is more likely what is needed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/EqualsArray.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate convertedToFloatOrDecimal(Expr e, Type t) {\n  exists(CastExpr cast |\n    cast.getExpr() = e and\n    t = cast.getType()\n  |\n    t instanceof FloatingPointType or\n    t instanceof DecimalType\n  )\n  or\n  exists(BinaryArithmeticOperation op |\n    op.getAnOperand() = e and\n    convertedToFloatOrDecimal(op, t)\n  |\n    op instanceof AddExpr or\n    op instanceof SubExpr or\n    op instanceof MulExpr\n  )\n}\n\npredicate exactDivision(DivExpr div) {\n  exists(int numerator, int denominator |\n    numerator = div.getNumerator().stripCasts().getValue().toInt() and\n    denominator = div.getDenominator().stripCasts().getValue().toInt() and\n    numerator % denominator = 0\n  )\n}\n\nabstract class LossOfPrecision extends Expr {\n  Type convertedType;\n\n  LossOfPrecision() {\n    this.getType() instanceof IntegralType and\n    convertedToFloatOrDecimal(this, convertedType)\n  }\n\n  /** Gets the alert message. */\n  abstract string getMessage();\n}\n\nclass DivLossOfPrecision extends LossOfPrecision, DivExpr {\n  DivLossOfPrecision() { not exactDivision(this) }\n\n  override string getMessage() { result = \"Possible loss of precision: any fraction will be lost.\" }\n}\n\npredicate small(MulExpr e) {\n  exists(float lhs, float rhs, float res, IntegralType t |\n    lhs = e.getLeftOperand().stripCasts().getValue().toFloat() and\n    rhs = e.getRightOperand().stripCasts().getValue().toFloat() and\n    lhs * rhs = res and\n    t = e.getType() and\n    not res < t.minValue() and\n    not res > t.maxValue()\n  )\n}\n\nclass MulLossOfPrecision extends LossOfPrecision, MulExpr {\n  MulLossOfPrecision() { not small(this) }\n\n  override string getMessage() {\n    result =\n      \"Possible overflow: result of integer multiplication cast to \" +\n        convertedType.toStringWithTypes() + \".\"\n  }\n}\n\nfrom LossOfPrecision e\nselect e, e.getMessage()",
        "description": "Dividing or multiplying integral expressions and converting the result to a floating-point value may result in a loss of precision.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/PossibleLossOfPrecision.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.csharp.frameworks.System\n\nfrom Class c, Method compareTo, Method compareToImpl\nwhere\n  c.fromSource() and\n  (\n    compareTo = any(SystemIComparableInterface i).getCompareToMethod()\n    or\n    compareTo = any(SystemIComparableTInterface i).getAConstructedGeneric().getAMethod() and\n    compareTo.getUnboundDeclaration() = any(SystemIComparableTInterface i).getCompareToMethod()\n  ) and\n  compareToImpl = c.getAMethod() and\n  compareToImpl = compareTo.getAnUltimateImplementor() and\n  not compareToImpl.isAbstract() and\n  not c.getAMethod() = any(SystemObjectClass o).getEqualsMethod().getAnOverrider+()\nselect c,\n  \"Class \" + c.getName() +\n    \" implements CompareTo but does not override Equals; the two could be inconsistent.\"",
        "description": "If a class implements 'IComparable.CompareTo' but does not override 'Equals', the two can be inconsistent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/InconsistentCompareTo.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom MethodCall c, Method referenceEquals\nwhere\n  c.getTarget() = referenceEquals and\n  referenceEquals = any(SystemObjectClass o).getReferenceEqualsMethod() and\n  c.getArgument(0).stripCasts().getType() instanceof ValueType and\n  c.getArgument(1).stripCasts().getType() instanceof ValueType\nselect c,\n  \"'ReferenceEquals(...)' always returns false on value types - this check is at best redundant and at worst erroneous.\"",
        "description": "'ReferenceEquals(...)' always returns false on value types - its use is at best redundant and at worst erroneous.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/ReferenceEqualsOnValueTypes.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.StructuralComparison\n\nprivate predicate candidate(AssignExpr ae) {\n  // Member initializers are never self-assignments, in particular\n  // not initializers such as `new C { F = F };`\n  not ae instanceof MemberInitializer and\n  // Enum field initializers are never self assignments. `enum E { A = 42 }`\n  not ae.getParent().(Field).getDeclaringType() instanceof Enum and\n  forall(Expr e | e = ae.getLValue().getAChildExpr*() |\n    // Non-trivial property accesses may have side-effects,\n    // so these are not considered\n    e instanceof PropertyAccess implies e instanceof TrivialPropertyAccess\n  )\n}\n\nprivate predicate selfAssignExpr(AssignExpr ae) {\n  candidate(ae) and\n  sameGvn(ae.getLValue(), ae.getRValue())\n}\n\nprivate Declaration getDeclaration(Expr e) {\n  result = e.(VariableAccess).getTarget()\n  or\n  result = e.(MemberAccess).getTarget()\n  or\n  result = getDeclaration(e.(ArrayAccess).getQualifier())\n}\n\nfrom AssignExpr ae, Declaration target\nwhere selfAssignExpr(ae) and target = getDeclaration(ae.getLValue())\nselect ae, \"This assignment assigns $@ to itself.\", target, target.getName()",
        "description": "Assigning a variable to itself is useless and very likely indicates an error in the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/SelfAssignment.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom CastExpr ce, RefType target, RefType source\nwhere\n  ce.getExpr() instanceof ArrayCreation and\n  target = ce.getType().(ArrayType).getElementType() and\n  source = ce.getExpr().getType().(ArrayType).getElementType() and\n  target.getABaseType+() = source\nselect ce, \"Impossible downcast on array.\"",
        "description": "Downcasts on expressions of array type are sometimes guaranteed to fail at runtime, e.g. those applied to array creation expressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/ImpossibleArrayCast.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Assertions\nimport semmle.code.csharp.commons.Constants\n\nfrom ComparisonOperation cmp, boolean value\nwhere\n  isConstantComparison(cmp, value) and\n  not isConstantCondition(cmp, _) and // Avoid overlap with cs/constant-condition\n  not isExprInAssertion(cmp)\nselect cmp, \"This comparison is always \" + value + \".\"",
        "description": "The result of the comparison is always the same.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/ConstantComparison.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom EqualsMethod caller, MethodCall call\nwhere\n  call.getEnclosingCallable() = caller and\n  call.getTarget() = caller and\n  (call.hasQualifier() implies call.hasThisQualifier()) and\n  call.getArgument(0).stripCasts() = caller.getParameter(0).getAnAccess()\nselect call, \"This call to 'Equals' is recursive: did you mean to cast the argument?\"",
        "description": "A call to 'Equals(object)' is recursive: often this is due to a mistake in invoking a definition of 'Equals(...)' with a different signature.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/RecursiveEquals.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom Operator o, OperatorCall c\nwhere\n  o.hasName(\"==\") and\n  c.getEnclosingCallable() = o and\n  c.getTarget() = o\nselect c,\n  \"This call to 'operator==' is recursive: often this is due to a failed attempt to perform a reference equality comparison.\"",
        "description": "A call to 'operator==' is recursive: often this is due to a failed attempt to perform a reference equality comparison.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/RecursiveOperatorEquals.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\nimport semmle.code.csharp.frameworks.system.Collections\nimport semmle.code.csharp.frameworks.system.collections.Generic\n\npredicate dictionary(ValueOrRefType t) {\n  exists(Type base | base = t.getABaseType*().getUnboundDeclaration() |\n    base instanceof SystemCollectionsGenericIDictionaryInterface or\n    base instanceof SystemCollectionsGenericIReadOnlyDictionaryInterface or\n    base instanceof SystemCollectionsIDictionaryInterface\n  )\n}\n\npredicate hashSet(ValueOrRefType t) {\n  t.getABaseType*().getUnboundDeclaration() instanceof SystemCollectionsGenericHashSetClass\n}\n\npredicate hashStructure(Type t) { dictionary(t) or hashSet(t) }\n\npredicate usesHashing(Expr e) {\n  exists(MethodCall mc, string name |\n    name = [\"Add\", \"Contains\", \"ContainsKey\", \"Remove\", \"TryAdd\", \"TryGetValue\"] and\n    mc.getArgument(0) = e and\n    mc.getTarget().hasName(name) and\n    hashStructure(mc.getTarget().getDeclaringType())\n  )\n  or\n  exists(IndexerCall ic |\n    ic.getArgument(0) = e and\n    dictionary(ic.getTarget().getDeclaringType())\n  )\n}\n\npredicate eqWithoutHash(RefType t) {\n  t.getAMethod() instanceof EqualsMethod and\n  not t.getAMethod() instanceof GetHashCodeMethod\n}\n\npredicate hashCall(Expr e) {\n  exists(MethodCall mc |\n    mc.getQualifier() = e and\n    mc.getTarget() instanceof GetHashCodeMethod\n  )\n}\n\nfrom Expr e, Type t\nwhere\n  (usesHashing(e) or hashCall(e)) and\n  e.getType() = t and\n  eqWithoutHash(t)\nselect e,\n  \"This expression is hashed, but type '\" + t.getName() +\n    \"' only defines Equals(...) not GetHashCode().\"",
        "description": "Finds uses of hashing on types that define 'Equals(...)' but not 'GetHashCode()'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/HashedButNoHash.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate generateRandomNumberMethod(string s) { s = \"Next\" or s = \"NextBytes\" or s = \"NextDouble\" }\n\nfrom ObjectCreation c, MethodCall m\nwhere\n  c.getType().getUnboundDeclaration().(ValueOrRefType).hasFullyQualifiedName(\"System\", \"Random\") and\n  m.getQualifier() = c and\n  generateRandomNumberMethod(m.getTarget().getName())\nselect m, \"Random object created and used only once.\"",
        "description": "Creating an instance of 'Random' for each pseudo-random number required does not guarantee an evenly distributed sequence of random numbers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/RandomUsedOnce.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate isDefinitelyPositive(Expr e) {\n  e.getValue().toInt() >= 0 or\n  e.(PropertyAccess).getTarget().hasName(\"Length\") or\n  e.(MethodCall).getTarget().hasUndecoratedName(\"Count\")\n}\n\nfrom BinaryOperation t, RemExpr lhs, IntegerLiteral rhs, string parity\nwhere\n  t.getLeftOperand() = lhs and\n  t.getRightOperand() = rhs and\n  not isDefinitelyPositive(lhs.getLeftOperand().stripCasts()) and\n  lhs.getRightOperand().(IntegerLiteral).getValue() = \"2\" and\n  (\n    t instanceof EQExpr and rhs.getValue() = \"1\" and parity = \"oddness\"\n    or\n    t instanceof NEExpr and rhs.getValue() = \"1\" and parity = \"evenness\"\n    or\n    t instanceof GTExpr and rhs.getValue() = \"0\" and parity = \"oddness\"\n  )\nselect t, \"Possibly invalid test for \" + parity + \". This will fail for negative numbers.\"",
        "description": "Code that uses 'x % 2 == 1' or 'x % 2 > 0' to check whether a number is odd does not work for negative numbers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/BadCheckOdd.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nprivate predicate equalsMethodChild(EqualsMethod equals, Element child) {\n  child = equals\n  or\n  equalsMethodChild(equals, child.getParent())\n}\n\npredicate nodeBeforeParameterAccess(ControlFlow::Node node) {\n  exists(EqualsMethod equals | equals.getBody() = node.getAstNode())\n  or\n  exists(EqualsMethod equals, Parameter param, ControlFlow::Node mid |\n    equals.getParameter(0) = param and\n    equalsMethodChild(equals, mid.getAstNode()) and\n    nodeBeforeParameterAccess(mid) and\n    not param.getAnAccess() = mid.getAstNode() and\n    mid.getASuccessor() = node\n  )\n}\n\nfrom ParameterAccess access, CastExpr cast\nwhere\n  access = cast.getAChild() and\n  access.getTarget().getDeclaringElement() = access.getEnclosingCallable() and\n  nodeBeforeParameterAccess(access.getAControlFlowNode())\nselect cast, \"Equals() method does not check argument type.\"",
        "description": "The object passed as a parameter to 'Equals' is used in a cast without first checking its type, which can cause an unwanted 'InvalidCastException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/UncheckedCastInEquals.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.security.dataflow.flowsinks.ParallelSink\nimport ICryptoTransform\n\nmodule NotThreadSafeCryptoUsageIntoParallelInvokeConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof LambdaCapturingICryptoTransformSource\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof ParallelSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule NotThreadSafeCryptoUsageIntoParallelInvoke =\n  TaintTracking::Global<NotThreadSafeCryptoUsageIntoParallelInvokeConfig>;\n\nfrom Expr e, string m, LambdaExpr l\nwhere\n  NotThreadSafeCryptoUsageIntoParallelInvoke::flow(DataFlow::exprNode(l), DataFlow::exprNode(e)) and\n  m =\n    \"A $@ seems to be used to start a new thread is capturing a local variable that either implements 'System.Security.Cryptography.ICryptoTransform' or has a field of this type.\"\nselect e, m, l, \"lambda expression\"",
        "description": "An instance of a class that either implements or has a field of type System.Security.Cryptography.ICryptoTransform is being captured by a lambda, and used in what seems to be a thread initialization method. Using an instance of this class in concurrent threads is dangerous as it may not only result in an error, but under some circumstances may also result in incorrect results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/ThreadUnsafeICryptoTransformLambda.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nExpr getObjectOperand(EqualityOperation eq) {\n  result = eq.getAnOperand() and\n  (\n    result.getType() instanceof ObjectType or\n    result.getType() instanceof Interface\n  )\n}\n\nclass ReferenceEqualityTestOnObject extends EqualityOperation {\n  ReferenceEqualityTestOnObject() {\n    // One or both of the operands has type object or interface.\n    exists(getObjectOperand(this)) and\n    // Neither operand is 'null'.\n    not this.getAnOperand() instanceof NullLiteral and\n    not exists(Type t | t = this.getAnOperand().stripImplicit().getType() |\n      t instanceof NullType or\n      t instanceof ValueType\n    ) and\n    // Neither operand is a constant - a reference comparison may well be intended for those.\n    not this.getAnOperand().(FieldAccess).getTarget().isReadOnly() and\n    not this.getAnOperand().hasValue() and\n    // Not a short-cut test in a custom `Equals` method\n    not exists(EqualsMethod m |\n      this.getEnclosingCallable() = m and\n      this.getAnOperand() instanceof ThisAccess and\n      this.getAnOperand() = m.getParameter(0).getAnAccess()\n    ) and\n    // Reference comparisons in Moq methods are used to define mocks\n    not exists(MethodCall mc, Namespace n |\n      mc.getTarget().getDeclaringType().getNamespace().getParentNamespace*() = n and\n      n.hasName(\"Moq\") and\n      not exists(n.getParentNamespace()) and\n      mc.getAnArgument() = this.getEnclosingCallable()\n    )\n  }\n\n  Expr getObjectOperand() {\n    result = getObjectOperand(this) and\n    // Avoid duplicate results: only include left operand if both operands\n    // have object type\n    (result = this.getRightOperand() implies not this.getLeftOperand() = getObjectOperand(this))\n  }\n}\n\nfrom ReferenceEqualityTestOnObject scw, Expr operand, Type t\nwhere\n  operand = scw.getObjectOperand() and\n  t = operand.getType()\nselect scw,\n  \"Reference equality for System.Object comparisons ($@ argument has type \" + t.getName() + \").\",\n  operand, \"this\"",
        "description": "Comparisons ('==' or '!=') between something of type 'System.Object' and something of another type will use reference comparison, which may not have been what was intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/ObjectComparison.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.frameworks.System\n\nfrom EqualsMethod m, AsExpr e, Class asType\nwhere\n  m.fromSource() and\n  e.getEnclosingCallable() = m and\n  e.getExpr().(VariableAccess).getTarget() = m.getParameter(0) and\n  asType = e.getTargetType() and\n  not asType.isSealed() and\n  not exists(MethodCall c, Variable v |\n    c.getEnclosingCallable() = m and\n    c.getTarget().getName() = \"GetType\" and\n    v = c.getQualifier().(VariableAccess).getTarget()\n  |\n    v = m.getParameter(0) or\n    v.getAnAssignedValue() = e\n  )\nselect e,\n  m.getDeclaringType().getName() +\n    \".Equals(object) should not use \\\"as\\\" on its parameter, as it will not work properly for subclasses of \"\n    + asType.getName() + \".\"",
        "description": "Implementations of 'Equals' should not use \"as\" to test the type of the argument, but rather call GetType(). This guards against the possibility that the argument type will be subclassed. Otherwise, it is likely that the Equals method will not be symmetric, violating its contract.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/EqualsUsesAs.ql",
        "language": "csharp"
    },
    {
        "query": "import semmle.code.csharp.frameworks.system.Text\n\nfrom ObjectCreation c, Expr argument\nwhere\n  c.getObjectType() instanceof SystemTextStringBuilderClass and\n  argument = c.getAnArgument().stripCasts() and\n  argument.getType() instanceof CharType\nselect argument,\n  \"A character value passed to 'new StringBuilder()' is interpreted as the buffer capacity.\"",
        "description": "A character value is passed to the constructor of 'StringBuilder'. This value will be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/StringBuilderCharInit.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.ComparisonTest\nimport semmle.code.csharp.commons.StructuralComparison as SC\n\nprivate predicate hasChild(Stmt outer, Element child) {\n  outer = child.getParent() and\n  (outer instanceof ForStmt or outer = any(ForStmt f).getBody())\n  or\n  hasChild(outer, child.getParent())\n}\n\nclass NestedForLoopSameVariable extends ForStmt {\n  ForStmt outer;\n  Variable iteration;\n  MutatorOperation innerUpdate;\n  MutatorOperation outerUpdate;\n\n  NestedForLoopSameVariable() {\n    hasChild(outer, this) and\n    innerUpdate = this.getAnUpdate() and\n    outerUpdate = outer.getAnUpdate() and\n    innerUpdate.getOperand() = iteration.getAnAccess() and\n    outerUpdate.getOperand() = iteration.getAnAccess()\n  }\n\n  /** Gets this inner `for` statement. */\n  ForStmt getInnerForStmt() { result = this }\n\n  /** Gets the outer, enclosing `for` statement. */\n  ForStmt getOuterForStmt() { result = outer }\n\n  private ComparisonTest getAComparisonTest(VariableAccess access) {\n    access = iteration.getAnAccess() and\n    result.getAnArgument() = access\n  }\n\n  private predicate haveSameCondition() {\n    SC::sameGvn(this.getInnerForStmt().getCondition(), this.getOuterForStmt().getCondition())\n  }\n\n  private predicate haveSameUpdate() {\n    innerUpdate instanceof IncrementOperation and outerUpdate instanceof IncrementOperation\n    or\n    innerUpdate instanceof DecrementOperation and outerUpdate instanceof DecrementOperation\n  }\n\n  /** Holds if the logic is deemed to be correct in limited circumstances. */\n  predicate isSafe() {\n    this.haveSameUpdate() and this.haveSameCondition() and not exists(this.getAnUnguardedAccess())\n  }\n\n  /** Gets the result element. */\n  Expr getElement() { result = this.getCondition() }\n\n  /** Gets the result message. */\n  string getMessage() {\n    exists(string name, Location location, int startLine, string lineStr |\n      name = iteration.getName() and\n      location = outer.getLocation() and\n      location.hasLocationInfo(_, startLine, _, _, _) and\n      lineStr = startLine.toString() and\n      result =\n        \"Nested for statement uses loop variable \" + name + \" of enclosing for statement (on line \" +\n          lineStr + \").\"\n    )\n  }\n\n  /** Finds elements inside the outer loop that are no longer guarded by the loop invariant. */\n  private ControlFlow::Node getAnUnguardedNode() {\n    hasChild(this.getOuterForStmt().getBody(), result.getAstNode()) and\n    (\n      result =\n        this.getCondition().(ControlFlowElement).getAControlFlowExitNode().getAFalseSuccessor()\n      or\n      exists(ControlFlow::Node mid | mid = this.getAnUnguardedNode() |\n        mid.getASuccessor() = result and\n        not exists(this.getAComparisonTest(result.getAstNode()))\n      )\n    )\n  }\n\n  private VariableAccess getAnUnguardedAccess() {\n    result = this.getAnUnguardedNode().getAstNode() and\n    result.getTarget() = iteration\n  }\n}\n\nfrom NestedForLoopSameVariable inner\nwhere not inner.isSafe()\nselect inner.getElement(), inner.getMessage()",
        "description": "The behavior of nested loops that both have the same iteration variable can be difficult to understand, as the inner loop will affect the iteration of the outer loop. Most of the time this is an unintentional typo and a bug; in other cases it is merely very bad practice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/NestedLoopsSameVariable.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.dispatch.Dispatch\n\nabstract class BadDynamicCall extends DynamicExpr {\n  abstract predicate isBad(Variable v, ValueOrRefType pt, Expr pts, string message, string target);\n\n  abstract AssignableRead getARelevantVariableAccess(int i);\n\n  Type possibleBadTypeForRelevantSource(Variable v, int i, Expr source) {\n    exists(Type t | t = this.possibleTypeForRelevantSource(v, i, source) |\n      // If the source can have the type of an interface or an abstract class,\n      // then all possible sub types are, in principle, possible\n      t instanceof Interface and result.isImplicitlyConvertibleTo(t)\n      or\n      t.(Class).isAbstract() and result.isImplicitlyConvertibleTo(t)\n      or\n      result = t\n    ) and\n    not result instanceof Interface and\n    not result.(Class).isAbstract() and\n    not result instanceof NullType and\n    not result instanceof DynamicType\n  }\n\n  private Type possibleTypeForRelevantSource(Variable v, int i, Expr source) {\n    exists(AssignableRead read, Ssa::Definition ssaDef, Ssa::ExplicitDefinition ultimateSsaDef |\n      read = this.getARelevantVariableAccess(i) and\n      v = read.getTarget() and\n      result = source.getType() and\n      read = ssaDef.getARead() and\n      ultimateSsaDef = ssaDef.getAnUltimateDefinition()\n    |\n      ultimateSsaDef.getADefinition() =\n        any(AssignableDefinition def | source = def.getSource().stripImplicit())\n      or\n      ultimateSsaDef.getADefinition() =\n        any(AssignableDefinitions::ImplicitParameterDefinition p |\n          source = p.getParameter().getAnAssignedValue().stripImplicit()\n        )\n    )\n  }\n}\n\nclass BadDynamicMethodCall extends BadDynamicCall, DynamicMethodCall {\n  override AssignableRead getARelevantVariableAccess(int i) {\n    result = this.getQualifier() and i = -1\n  }\n\n  override predicate isBad(Variable v, ValueOrRefType pt, Expr pts, string message, string target) {\n    pt = this.possibleBadTypeForRelevantSource(v, -1, pts) and\n    not exists(Method m | m = this.getARuntimeTarget() |\n      pt.isImplicitlyConvertibleTo(m.getDeclaringType())\n    ) and\n    message =\n      \"The $@ of this dynamic method invocation can obtain (from $@) type $@, which does not have a method '\"\n        + this.getLateBoundTargetName() + \"' with the appropriate signature.\" and\n    target = \"target\"\n  }\n}\n\nclass BadDynamicOperatorCall extends BadDynamicCall, DynamicOperatorCall {\n  override AssignableRead getARelevantVariableAccess(int i) { result = this.getRuntimeArgument(i) }\n\n  override predicate isBad(Variable v, ValueOrRefType pt, Expr pts, string message, string target) {\n    exists(int i |\n      pt = this.possibleBadTypeForRelevantSource(v, i, pts) and\n      not pt.containsTypeParameters() and\n      not exists(Type paramType | paramType = this.getADynamicParameterType(_, i) |\n        pt.isImplicitlyConvertibleTo(paramType)\n        or\n        // If either the argument type or the parameter type contains type parameters,\n        // then assume they may match\n        paramType.containsTypeParameters()\n      ) and\n      exists(string number |\n        number = \"first\" and i = 0\n        or\n        number = \"second\" and i = 1\n      |\n        target = number + \" argument\"\n      )\n    ) and\n    message =\n      \"The $@ of this dynamic operator can obtain (from $@) type $@, which does not match an operator '\"\n        + this.getLateBoundTargetName() + \"' with the appropriate signature.\"\n  }\n\n  private Type getADynamicParameterType(Operator o, int i) {\n    o = this.getARuntimeTarget() and\n    result = o.getParameter(i).getType()\n  }\n}\n\nfrom BadDynamicCall call, Variable v, ValueOrRefType pt, Expr pts, string message, string target\nwhere call.isBad(v, pt, pts, message, target)\nselect call, message, v, target, pts, \"here\", pt, pt.getName()",
        "description": "The type of the target of a dynamic invocation expression must have a method or operator with the appropriate signature, or an exception will be thrown.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Dynamic/BadDynamicCall.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport UnsafeYearCreationFromArithmetic::PathGraph\n\nmodule UnsafeYearCreationFromArithmeticConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(ArithmeticOperation ao, PropertyAccess pa | ao = source.asExpr() |\n      pa = ao.getAChild*() and\n      pa.getProperty().hasFullyQualifiedName(\"System.DateTime\", \"Year\")\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(ObjectCreation oc |\n      sink.asExpr() = oc.getArgumentForName(\"year\") and\n      oc.getObjectType().getABaseType*().hasFullyQualifiedName(\"System\", \"DateTime\")\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule UnsafeYearCreationFromArithmetic =\n  TaintTracking::Global<UnsafeYearCreationFromArithmeticConfig>;\n\nfrom\n  UnsafeYearCreationFromArithmetic::PathNode source, UnsafeYearCreationFromArithmetic::PathNode sink\nwhere UnsafeYearCreationFromArithmetic::flowPath(source, sink)\nselect sink, source, sink,\n  \"This $@ based on a 'System.DateTime.Year' property is used in a construction of a new 'System.DateTime' object, flowing to the 'year' argument.\",\n  source, \"arithmetic operation\"",
        "description": "Constructing a 'DateTime' struct by setting the year argument to an increment or decrement of the year of a different 'DateTime' struct.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/LeapYear/UnsafeYearConstruction.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\nfrom LockStmt lock\nwhere lock.getBlock().(BlockStmt).getNumberOfStmts() = 0\nselect lock, \"Empty lock statement.\"",
        "description": "Empty lock statements are often a result of commenting-out code in a previously non-empty lock, but may sometimes be being used as a poor alternative to event wait handles or monitors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Statements/EmptyLockStatement.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\n// Iterate the control flow until we reach a Stmt\nStmt findSuccessorStmt(ControlFlow::Node n) {\n  result = n.getAstNode()\n  or\n  not n.getAstNode() instanceof Stmt and result = findSuccessorStmt(n.getASuccessor())\n}\n\n// Return a successor statement to s\nStmt getASuccessorStmt(Stmt s) {\n  result = findSuccessorStmt(s.getAControlFlowNode().getASuccessor())\n}\n\nclass IfThenStmt extends IfStmt {\n  IfThenStmt() { not exists(this.getElse()) }\n}\n\nclass IfThenElseStmt extends IfStmt {\n  IfThenElseStmt() { exists(this.getElse()) }\n}\n\nStmt getTrailingBody(Stmt s) {\n  result = s.(ForStmt).getBody() or\n  result = s.(ForeachStmt).getBody() or\n  result = s.(WhileStmt).getBody() or\n  result = s.(IfThenStmt).getThen() or\n  result = s.(IfThenElseStmt).getElse()\n}\n\n// Any control statement which has a trailing block\n// which could cause indentation confusion\nabstract class UnbracedControlStmt extends Stmt {\n  abstract Stmt getBody();\n\n  abstract Stmt getSuccessorStmt();\n\n  private Stmt getACandidate() {\n    this.getSuccessorStmt() = result and\n    getBlockStmt(this) = getBlockStmt(result)\n  }\n\n  private Location getBodyLocation() { result = this.getBody().getLocation() }\n\n  pragma[noopt]\n  Stmt getAConfusingTrailingStmt() {\n    result = this.getACandidate() and\n    exists(Location l1, Location l2 | l1 = this.getBodyLocation() and l2 = result.getLocation() |\n      // This test is slightly unreliable\n      // because tabs are counted as 1 column.\n      // But it's accurate enough to be useful, and will\n      // work for consistently formatted text.\n      l1.getStartColumn() = l2.getStartColumn() or\n      l1.getStartLine() = l2.getStartLine()\n    )\n  }\n}\n\nclass UnbracedIfStmt extends UnbracedControlStmt {\n  UnbracedIfStmt() {\n    this instanceof IfStmt and\n    not getTrailingBody(this) instanceof BlockStmt and\n    not getTrailingBody(this) instanceof IfStmt\n  }\n\n  override Stmt getBody() { result = getTrailingBody(this) }\n\n  override Stmt getSuccessorStmt() {\n    result = getASuccessorStmt(this.getBody()) and\n    result != this\n  }\n}\n\nclass UnbracedLoopStmt extends UnbracedControlStmt {\n  UnbracedLoopStmt() {\n    this instanceof LoopStmt and\n    not this instanceof DoStmt and\n    not getTrailingBody(this) instanceof BlockStmt\n  }\n\n  override Stmt getBody() { result = getTrailingBody(this) }\n\n  override Stmt getSuccessorStmt() {\n    result = getASuccessorStmt(this) and\n    result != this.getBody()\n  }\n}\n\nBlockStmt getBlockStmt(Element e) {\n  result = e.getParent() or\n  result = getBlockStmt(e.(IfStmt).getParent()) // Handle chained ifs\n}\n\nfrom UnbracedControlStmt s, Stmt n\nwhere n = s.getAConfusingTrailingStmt()\nselect s, \"Missing braces? Inspect indentation of $@.\", n, \"the control flow successor\"",
        "description": "If a control structure does not use braces, misleading indentation makes it difficult to see which statements are within its scope.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Statements/UseBraces.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\n\npredicate loopStmtWithEmptyBlock(BlockStmt child) {\n  exists(LoopStmt stmt, SourceLocation l |\n    stmt.getAChild() = child and\n    child.getNumberOfStmts() = 0 and\n    child.getLocation() = l and\n    l.getStartLine() != l.getEndLine()\n  )\n}\n\npredicate conditionalWithEmptyBlock(BlockStmt child) {\n  exists(IfStmt stmt |\n    stmt.getThen() = child and child.getNumberOfStmts() = 0 and not exists(stmt.getElse())\n  )\n  or\n  exists(IfStmt stmt, SourceLocation l |\n    stmt.getThen() = child and\n    child.getNumberOfStmts() = 0 and\n    exists(stmt.getElse()) and\n    child.getLocation() = l and\n    l.getStartLine() != l.getEndLine()\n  )\n  or\n  exists(IfStmt stmt | stmt.getElse() = child and child.getNumberOfStmts() = 0)\n}\n\nfrom BlockStmt s\nwhere\n  (loopStmtWithEmptyBlock(s) or conditionalWithEmptyBlock(s)) and\n  not exists(CommentBlock c | c.getParent() = s) and\n  not exists(ForStmt fs | fs.getBody() = s and exists(fs.getAnUpdate()))\nselect s, \"Empty block without comment.\"",
        "description": "Empty blocks that occur as a branch of a conditional or as a loop body may indicate badly-maintained code or a bug due to an unhandled case.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Statements/EmptyBlock.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Assertions\n\nprivate predicate propertyOverrides(Property p, string qualifier, string baseClass, string property) {\n  exists(Property p2 |\n    p2.getUnboundDeclaration().getDeclaringType().hasFullyQualifiedName(qualifier, baseClass) and\n    p2.hasName(property)\n  |\n    p.overridesOrImplementsOrEquals(p2)\n  )\n}\n\nprivate predicate containerSizeAccess(PropertyAccess pa, string containerKind) {\n  (\n    propertyOverrides(pa.getTarget(), \"System.Collections.Generic\", \"ICollection`1\", \"Count\") or\n    propertyOverrides(pa.getTarget(), \"System.Collections.Generic\", \"IReadOnlyCollection`1\", \"Count\") or\n    propertyOverrides(pa.getTarget(), \"System.Collections\", \"ICollection\", \"Count\")\n  ) and\n  containerKind = \"a collection\"\n  or\n  (\n    propertyOverrides(pa.getTarget(), \"System\", \"String\", \"Length\") and containerKind = \"a string\"\n    or\n    propertyOverrides(pa.getTarget(), \"System\", \"Array\", \"Length\") and containerKind = \"an array\"\n  )\n}\n\nclass ZeroLiteral extends Expr {\n  ZeroLiteral() { this.getValue() = \"0\" }\n}\n\nprivate predicate checkedLT(BinaryOperation e, Expr greater, Expr smaller, string trueOrFalse) {\n  greater = e.(GEExpr).getLeftOperand() and\n  smaller = e.(GEExpr).getRightOperand() and\n  trueOrFalse = \"true\"\n  or\n  greater = e.(LEExpr).getRightOperand() and\n  smaller = e.(LEExpr).getLeftOperand() and\n  trueOrFalse = \"true\"\n  or\n  greater = e.(GTExpr).getRightOperand() and\n  smaller = e.(GTExpr).getLeftOperand() and\n  trueOrFalse = \"false\"\n  or\n  greater = e.(LTExpr).getLeftOperand() and\n  smaller = e.(LTExpr).getRightOperand() and\n  trueOrFalse = \"false\"\n}\n\nprivate predicate comparisonOfContainerSizeToZero(\n  BinaryOperation e, string containerKind, string trueOrFalse\n) {\n  exists(Expr sizeAccess |\n    containerSizeAccess(sizeAccess, containerKind) and\n    checkedLT(e, sizeAccess, any(ZeroLiteral zl), trueOrFalse)\n  )\n}\n\nfrom BinaryOperation e, string containerKind, string trueOrFalse\nwhere\n  comparisonOfContainerSizeToZero(e, containerKind, trueOrFalse) and\n  not isExprInAssertion(e)\nselect e,\n  \"This expression is always \" + trueOrFalse + \", since \" + containerKind +\n    \" can never have negative size.\"",
        "description": "Comparing the size of a container to zero with this operator will always return the same value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Collections/ContainerSizeCmpZero.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Collections\n\nfrom Variable v\nwhere\n  v.fromSource() and\n  v.getType() instanceof CollectionType and\n  // Publics might get assigned elsewhere\n  (v instanceof LocalVariable or v.(Field).isPrivate()) and\n  // All initializers (if any) are empty collections.\n  forall(AssignableDefinition d | v = d.getTarget() |\n    d.getSource() instanceof EmptyCollectionCreation\n  ) and\n  // All accesses do not add data.\n  forex(Access a | v.getAnAccess() = a |\n    a instanceof NoAddAccess or a instanceof EmptyInitializationAccess\n  ) and\n  // Attributes indicate some kind of reflection\n  not exists(Attribute a | v = a.getTarget()) and\n  // There is at least one non-assignment access\n  v.getAnAccess() instanceof NoAddAccess\nselect v, \"The contents of this container are never initialized.\"",
        "description": "Querying the contents of a collection or map that is never initialized is not normally useful.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Collections/ReadOnlyContainer.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.commons.Collections\n\nfrom Variable v\nwhere\n  v.getType() instanceof CollectionType and\n  (\n    v instanceof LocalVariable or\n    v = any(Field f | not f.isEffectivelyPublic())\n  ) and\n  forex(Access a | a = v.getAnAccess() |\n    a = any(ModifierMethodCall m).getQualifier() or\n    a = any(Assignment ass | ass.getRValue() instanceof ObjectCreation).getLValue()\n  ) and\n  not v = any(ForeachStmt fs).getVariable() and\n  not v = any(BindingPatternExpr vpe).getVariableDeclExpr().getVariable() and\n  not v = any(Attribute a).getTarget()\nselect v, \"The contents of this container are never accessed.\"",
        "description": "A collection or map whose contents are never queried or accessed is useless.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Collections/WriteOnlyContainer.ql",
        "language": "csharp"
    },
    {
        "query": "import csharp\nimport semmle.code.csharp.controlflow.Guards\nimport semmle.code.csharp.commons.ComparisonTest\n\nclass IndexGuard extends ComparisonTest {\n  VariableAccess indexAccess;\n  Variable array;\n\n  IndexGuard() {\n    this.getFirstArgument() = indexAccess and\n    this.getSecondArgument() =\n      any(PropertyAccess lengthAccess |\n        lengthAccess.getQualifier() = array.getAnAccess() and\n        lengthAccess.getTarget().hasName(\"Length\")\n      )\n  }\n\n  /** Holds if this comparison applies to array `arr` and index `ind`. */\n  predicate controls(Variable arr, Variable ind) {\n    arr = array and\n    ind.getAnAccess() = indexAccess\n  }\n\n  /** Holds if this comparison guards `expr`. */\n  predicate guards(GuardedExpr expr, boolean condition) {\n    expr.isGuardedBy(this.getExpr(), indexAccess, condition)\n  }\n\n  /** Holds if this comparison is an incorrect `<=` or equivalent. */\n  predicate isIncorrect() { this.getComparisonKind().isLessThanEquals() }\n}\n\nfrom\n  IndexGuard incorrectGuard, Variable array, Variable index, ElementAccess ea,\n  GuardedExpr indexAccess\nwhere\n  // Look for `index <= array.Length` or `array.Length >= index`\n  incorrectGuard.controls(array, index) and\n  incorrectGuard.isIncorrect() and\n  // Look for `array[index]`\n  ea.getQualifier() = array.getAnAccess() and\n  ea.getIndex(0) = indexAccess and\n  indexAccess = index.getAnAccess() and\n  // Where the index access is guarded by the comparison\n  incorrectGuard.guards(indexAccess, true) and\n  // And there are no other guards\n  not exists(IndexGuard validGuard |\n    not validGuard.isIncorrect() and\n    validGuard.controls(array, index) and\n    validGuard.guards(indexAccess, _)\n  )\nselect incorrectGuard, \"Off-by-one index comparison against length may lead to out-of-bounds $@.\",\n  ea, ea.toString()",
        "description": "The index is compared to be less than or equal to the container length, then used in an array indexing operation that could be out of bounds.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/csharp/ql/src/Likely Bugs/Collections/ContainerLengthCmpOffByOne.ql",
        "language": "csharp"
    },
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import semmle.code.cpp.Element\n\nclass AstNode extends Locatable {\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n}\n\nclass SingleLineComment extends Comment, AstNode {\n  private string text;\n\n  SingleLineComment() {\n    this instanceof CppStyleComment and\n    // strip the beginning slashes\n    text = this.getContents().suffix(2)\n    or\n    this instanceof CStyleComment and\n    // strip both the beginning /* and the end */ the comment\n    exists(string text0 |\n      text0 = this.getContents().suffix(2) and\n      text = text0.prefix(text0.length() - 2)\n    ) and\n    // The /* */ comment must be a single-line comment\n    not text.matches(\"%\\n%\")\n  }\n\n  /** Gets the text in this comment, excluding the leading //. */\n  string getText() { result = text }\n}\n\nimport AS::Make<AstNode, SingleLineComment>",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/AlertSuppression.ql",
        "language": "cpp"
    },
    {
        "query": "import definitions\n\nfrom Top e, Top def, string kind\nwhere\n  def = definitionOf(e, kind) and\n  // We need to exclude definitions for elements inside template instantiations,\n  // as these often lead to multiple links to definitions from the same source location.\n  // LGTM does not support this behavior.\n  not e.isFromTemplateInstantiation(_)\nselect e, def, kind",
        "description": "Generates use-definition pairs that provide the data for jump-to-definition in the code viewer of LGTM.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/definitions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.AutogeneratedFile\nimport semmle.code.cpp.TestFile\n\npredicate classify(File f, string tag) {\n  f instanceof AutogeneratedFile and\n  tag = \"generated\"\n  or\n  f instanceof TestFile and\n  tag = \"test\"\n}\n\nfrom File f, string tag\nwhere classify(f, tag)\nselect f, tag",
        "description": "This query produces a list of all files in a snapshot that are classified as generated code or test code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/filters/ClassifyFiles.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getLackOfCohesionHS() as n order by n desc",
        "description": "Lack of cohesion for a class as defined by Henderson-Sellers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CLackOfCohesionHS.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricClass mc\nselect mc, mc.getHalsteadVocabulary()",
        "description": "Number of distinct operands and operators used",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CHalsteadVocabulary.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c, int ccLoc, int loc\nwhere\n  c.fromSource() and\n  ccLoc =\n    sum(Function f |\n      c.getACanonicalMemberFunction() = f and\n      f.getMetrics().getCyclomaticComplexity() > 18\n    |\n      f.getMetrics().getNumberOfLinesOfCode()\n    ) and\n  loc =\n    sum(Function f | c.getACanonicalMemberFunction() = f | f.getMetrics().getNumberOfLinesOfCode()) +\n      c.getMetrics().getNumberOfMembers() and\n  loc != 0\nselect c, (ccLoc * 100).(float) / loc as n order by n desc",
        "description": "The percentage of the code in a class that is part of a complex member function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CPercentageOfComplexCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getNumberOfMemberFunctions() as n order by n desc",
        "description": "The number of member functions in a class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CNumberOfFunctions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c, int n\nwhere\n  c.fromSource() and\n  n = count(Function f | c.getAPublicCanonicalMember() = f)\nselect c, n order by n desc",
        "description": "The number of public member functions in a public class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CSizeOfAPI.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricClass mc\nselect mc, mc.getHalsteadLength()",
        "description": "Total number of operands and operators",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CHalsteadLength.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c, int n\nwhere\n  c.fromSource() and\n  n =\n    c.getMetrics().getNumberOfMembers() +\n      sum(Function f | c.getACanonicalMemberFunction() = f | f.getMetrics().getNumberOfLinesOfCode())\nselect c, n order by n desc",
        "description": "The number of lines of code in a class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CLinesOfCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getAfferentCoupling() as n order by n desc",
        "description": "The number of classes that depend on a class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CAfferentCoupling.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getEfferentCoupling() as n order by n desc",
        "description": "The number of classes on which a class depends.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CEfferentCoupling.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricClass mc\nselect mc, mc.getHalsteadEffort()",
        "description": "Measures the effort to implement the program",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CHalsteadEffort.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricClass mc\nselect mc, mc.getHalsteadVolume()",
        "description": "The information contents of the program",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CHalsteadVolume.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getResponse()",
        "description": "The number of different member functions or constructors that can be executed by a class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CResponse.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricClass mc\nselect mc, mc.getHalsteadDifficulty()",
        "description": "Measures the error proneness of implementing the program",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CHalsteadDifficulty.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricClass mc\nselect mc, mc.getHalsteadDeliveredBugs()",
        "description": "Measures the expected number of delivered defects. The Halstead bug count is known to be an underestimate.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CHalsteadBugs.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getInheritanceDepth() as n order by n desc",
        "description": "The depth of a class in the inheritance hierarchy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CInheritanceDepth.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c, int n\nwhere\n  c.fromSource() and\n  n = count(Stmt s | s.getEnclosingFunction() = c.getACanonicalMemberFunction())\nselect c, n",
        "description": "The number of statements in the member functions of a class. For template functions, only the statements in the template itself, not in the instantiations, are counted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CNumberOfStatements.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getSpecialisationIndex()",
        "description": "The extent to which a subclass refines the behavior of its superclasses.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CSpecialisation.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getLackOfCohesionCK() as n order by n desc",
        "description": "Lack of cohesion for a class as defined by Chidamber and Kemerer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CLackOfCohesionCK.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getMetrics().getNumberOfFields() as n order by n desc",
        "description": "The number of fields in a class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Classes/CNumberOfFields.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass RangeFunction extends Function {\n  /**\n   * Holds if this function is at the specified location.\n   * The location spans column `startcolumn` of line `startline` to\n   * column `endcolumn` of line `endline` in file `filepath`.\n   * For more information, see\n   * [Locations](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    super.getLocation().hasLocationInfo(filepath, startline, startcolumn, _, _) and\n    (\n      this.getBlock().getLocation().hasLocationInfo(filepath, _, _, endline, endcolumn)\n      or\n      not exists(this.getBlock()) and endline = startline + 1 and endcolumn = 1\n    )\n  }\n}\n\nfrom RangeFunction f\nwhere f.fromSource()\nselect f.getLocation(), f",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/CallableExtents.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere f.fromSource()\nselect f, f.getName()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/CallableDisplayStrings.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass CannotOpenFileError extends CompilerError {\n  CannotOpenFileError() { this.hasTag([\"cannot_open_file\", \"cannot_open_file_reason\"]) }\n}\n\nselect count(CannotOpenFileError e) as failed_includes, count(Include i) as successful_includes",
        "description": "Counts unresolved and resolved #includes. This query is for internal use only and may change without notice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/IncludeResolutionStatus.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getName()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/ReftypeDisplayStrings.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere f.fromSource()\nselect f, f.getFile()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/CallableSourceLinks.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c, c.getFile()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/ReftypeSourceLinks.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate hasDuplicateFunctionEntryPointLocation(Function func) {\n  count(func.getEntryPoint().getLocation()) > 1\n}\n\npredicate hasDuplicateFunctionEntryPoint(Function func) { count(func.getEntryPoint()) > 1 }\n\npredicate hasDuplicateDeclarationEntry(DeclStmt stmt, int i) {\n  strictcount(stmt.getDeclarationEntry(i)) > 1\n}\n\nselect count(Function f | hasDuplicateFunctionEntryPoint(f)) as duplicateFunctionEntryPoint,\n  count(Function f | hasDuplicateFunctionEntryPointLocation(f)) as duplicateFunctionEntryPointLocation,\n  count(DeclStmt stmt, int i | hasDuplicateDeclarationEntry(stmt, i)) as duplicateDeclarationEntry",
        "description": "Counts the various AST inconsistencies that may occur. This query is for internal use only and may change without notice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/ASTConsistency.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.implementation.aliased_ssa.IR\nimport semmle.code.cpp.ir.implementation.aliased_ssa.IRConsistency as IRConsistency\n\nclass PresentIRFunction extends IRConsistency::PresentIRFunction {\n  override string toString() {\n    result = min(string name | name = this.getIRFunction().getFunction().getQualifiedName() | name)\n  }\n}\n\nselect count(Instruction i | IRConsistency::missingOperand(i, _, _, _) | i) as missingOperand,\n  count(Instruction i | IRConsistency::unexpectedOperand(i, _, _, _) | i) as unexpectedOperand,\n  count(Instruction i | IRConsistency::duplicateOperand(i, _, _, _) | i) as duplicateOperand,\n  count(PhiInstruction i | IRConsistency::missingPhiOperand(i, _, _, _) | i) as missingPhiOperand,\n  count(Operand o | IRConsistency::missingOperandType(o, _, _, _) | o) as missingOperandType,\n  count(ChiInstruction i | IRConsistency::duplicateChiOperand(i, _, _, _) | i) as duplicateChiOperand,\n  count(Instruction i | IRConsistency::sideEffectWithoutPrimary(i, _, _, _) | i) as sideEffectWithoutPrimary,\n  count(Instruction i | IRConsistency::instructionWithoutSuccessor(i, _, _, _) | i) as instructionWithoutSuccessor,\n  count(Instruction i | IRConsistency::ambiguousSuccessors(i, _, _, _) | i) as ambiguousSuccessors,\n  count(Instruction i | IRConsistency::unexplainedLoop(i, _, _, _) | i) as unexplainedLoop,\n  count(PhiInstruction i | IRConsistency::unnecessaryPhiInstruction(i, _, _, _) | i) as unnecessaryPhiInstruction,\n  count(Instruction i | IRConsistency::memoryOperandDefinitionIsUnmodeled(i, _, _, _) | i) as memoryOperandDefinitionIsUnmodeled,\n  count(Operand o | IRConsistency::operandAcrossFunctions(o, _, _, _, _, _) | o) as operandAcrossFunctions,\n  count(IRFunction f | IRConsistency::containsLoopOfForwardEdges(f, _) | f) as containsLoopOfForwardEdges,\n  count(IRBlock i | IRConsistency::lostReachability(i, _, _, _) | i) as lostReachability,\n  count(string m | IRConsistency::backEdgeCountMismatch(_, m) | m) as backEdgeCountMismatch,\n  count(Operand o | IRConsistency::useNotDominatedByDefinition(o, _, _, _) | o) as useNotDominatedByDefinition,\n  count(SwitchInstruction i | IRConsistency::switchInstructionWithoutDefaultEdge(i, _, _, _) | i) as switchInstructionWithoutDefaultEdge,\n  count(Instruction i | IRConsistency::notMarkedAsConflated(i, _, _, _) | i) as notMarkedAsConflated,\n  count(Instruction i | IRConsistency::wronglyMarkedAsConflated(i, _, _, _) | i) as wronglyMarkedAsConflated,\n  count(MemoryOperand o | IRConsistency::invalidOverlap(o, _, _, _) | o) as invalidOverlap,\n  count(Instruction i | IRConsistency::nonUniqueEnclosingIRFunction(i, _, _, _) | i) as nonUniqueEnclosingIRFunction,\n  count(FieldAddressInstruction i | IRConsistency::fieldAddressOnNonPointer(i, _, _, _) | i) as fieldAddressOnNonPointer,\n  count(Instruction i | IRConsistency::thisArgumentIsNonPointer(i, _, _, _) | i) as thisArgumentIsNonPointer,\n  count(Instruction i | IRConsistency::nonUniqueIRVariable(i, _, _, _) | i) as nonUniqueIRVariable,\n  count(Instruction i | IRConsistency::nonBooleanOperand(i, _, _, _) | i) as nonBooleanOperand",
        "description": "Counts the various IR inconsistencies that may occur. This query is for internal use only and may change without notice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/IRConsistency.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nselect sum(Compilation c, float seconds | compilation_time(c, _, 2, seconds) | seconds) as sum_frontend_elapsed_seconds,\n  sum(Compilation c, float seconds | compilation_time(c, _, 4, seconds) | seconds) as sum_extractor_elapsed_seconds",
        "description": "The sum of elapsed frontend time, and the sum of elapsed extractor time. This query is for internal use only and may change without notice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Internal/DiagnosticsSumElapsedTimes.ql",
        "language": "cpp"
    },
    {
        "query": "import ExternalDependencies\n\nfrom File file, int num, string encodedDependency\nwhere encodedDependencies(file, encodedDependency, num)\nselect encodedDependency, num order by num desc",
        "description": "Count the number of dependencies a C/C++ source file has on external libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Dependencies/ExternalDependencies.ql",
        "language": "cpp"
    },
    {
        "query": "import ExternalDependencies\n\n\nfrom File file, int num, string encodedDependency\nwhere encodedDependencies(file, encodedDependency, num)\nselect encodedDependency, file",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Dependencies/ExternalDependenciesSourceLinks.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Namespace n, float c\nwhere\n  n.fromSource() and\n  c = n.getMetrics().getDistanceFromMain() and\n  c > 0.7\nselect n as namespace, c as distanceFromMainline order by distanceFromMainline desc",
        "description": "Finds namespaces that do not have a good balance between abstractness and stability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Namespaces/HighDistanceFromMainLineNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Namespace n, int c\nwhere\n  n.fromSource() and\n  c = n.getMetrics().getAfferentCoupling() and\n  c > 20\nselect n as namespace, c as afferentCoupling order by afferentCoupling desc",
        "description": "Finds namespaces that have an afferent coupling greater than 20.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Namespaces/HighAfferentCouplingNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Namespace n, float c\nwhere\n  n.fromSource() and\n  c = n.getMetrics().getAbstractness() and\n  c > 0.2\nselect n as namespace, c as abstractness order by abstractness desc",
        "description": "Finds namespaces that have an abstractness greater than 0.20.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Namespaces/AbstractNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Namespace n, int c\nwhere\n  n.fromSource() and\n  c = n.getMetrics().getEfferentCoupling() and\n  c > 20\nselect n as namespace, c as efferentCoupling order by efferentCoupling desc",
        "description": "Finds namespaces that have an efferent coupling greater than 20.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Namespaces/HighEfferentCouplingNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Namespace n, float c\nwhere\n  n.fromSource() and\n  c = n.getMetrics().getInstability() and\n  c > 0.8\nselect n as package, c as instability order by instability desc",
        "description": "Finds namespaces that have an instability higher than 0.8.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Namespaces/UnstableNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Namespace n, float c\nwhere\n  n.fromSource() and\n  c = n.getMetrics().getAbstractness() and\n  c = 0\nselect n as namespace, c as abstractness order by abstractness desc",
        "description": "Finds namespaces that have an abstractness equal to 0.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Namespaces/ConcreteNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Namespace n, float c\nwhere\n  n.fromSource() and\n  c = n.getMetrics().getInstability() and\n  c < 0.2\nselect n as namespace, c as instability order by instability desc",
        "description": "Finds namespaces that have an instability lower than 0.2.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Namespaces/StableNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f,\n  avg(Function fn |\n    fn.getFile() = f and not fn instanceof MemberFunction\n  |\n    fn.getNumberOfParameters()\n  )",
        "description": "The average number of parameters of functions in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/NumberOfParameters.ql",
        "language": "cpp"
    },
    {
        "query": "import Documentation.CommentedOutCode\n\nfrom File f, int n\nwhere n = sum(CommentedOutCode comment | comment.getFile() = f | comment.numCodeLines())\nselect f, n order by n desc",
        "description": "The number of lines of commented-out code in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FLinesOfCommentedOutCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f, f.getMetrics().getNumberOfLines() as n order by n desc",
        "description": "The number of lines in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FLines.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFile mc\nwhere mc.fromSource()\nselect mc, mc.getHalsteadLength()",
        "description": "Total number of operands and operators",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FHalsteadLength.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f, int comments, int total\nwhere f.fromSource() and numlines(unresolveElement(f), total, _, comments) and total > 0\nselect f, 100.0 * (comments.(float) / total.(float)) as ratio order by ratio desc",
        "description": "The percentage of lines that contain comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FCommentRatio.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFile mc\nwhere mc.fromSource()\nselect mc, mc.getHalsteadVocabulary()",
        "description": "Number of distinct operands and operators used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FHalsteadVocabulary.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f, int n\nwhere\n  f.fromSource() and\n  n = count(File g | g = f.getAnIncludedFile+())\nselect f, n",
        "description": "The number of files included by the pre-processor - either directly by an `#include` directive, or indirectly (by being included by an included file).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FTransitiveIncludes.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f, int n\nwhere\n  f.fromSource() and\n  n = count(Class c | c.getAFile() = f)\nselect f, n order by n desc",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FNumberOfClasses.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f, f.getMetrics().getNumberOfLinesOfCode() as n order by n desc",
        "description": "Measures the number of lines in a file that contain code (rather than lines that only contain comments or are blank)",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FLinesOfCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.AutogeneratedFile\n\nfrom AutogeneratedFile af\nwhere af.fromSource()\nselect af, af.getMetrics().getNumberOfLinesOfCode() as n order by n desc",
        "description": "Measures the number of lines in autogenerated files that contain code (rather than lines that only contain comments or are blank).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/AutogeneratedLOC.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate macroLocation(File f, int startLine, int endLine) {\n  exists(MacroInvocation mi, Location l |\n    l = mi.getLocation() and\n    l.getFile() = f and\n    l.getStartLine() = startLine and\n    l.getEndLine() = endLine\n  )\n}\n\npragma[nomagic]\nLocation getVariableLocation(Variable v) { result = v.getLocation() }\n\npredicate globalLocation(GlobalVariable gv, File f, int startLine, int endLine) {\n  exists(Location l |\n    l = getVariableLocation(gv) and\n    l.hasLocationInfo(f.getAbsolutePath(), startLine, _, endLine, _)\n  )\n}\n\npredicate inMacro(GlobalVariable gv) {\n  exists(File f, int macroStart, int macroEnd, int varStart, int varEnd |\n    macroLocation(f, macroStart, macroEnd) and\n    globalLocation(gv, f, varStart, varEnd) and\n    varStart >= macroStart and\n    varEnd <= macroEnd\n  )\n}\n\nfrom File f\nwhere f.fromSource()\nselect f, count(GlobalVariable gv | gv.getFile() = f and not inMacro(gv))",
        "description": "The total number of global variables in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/NumberOfGlobals.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nExpr getTest() {\n  // cppunit tests; https://freedesktop.org/wiki/Software/cppunit/\n  result.(FunctionCall).getTarget().hasQualifiedName(\"CppUnit\", _, \"addTest\")\n  or\n  // boost tests; http://www.boost.org/\n  result.(FunctionCall).getTarget().hasQualifiedName(\"boost::unit_test\", \"make_test_case\")\n  or\n  // googletest tests; https://github.com/google/googletest/\n  result.(FunctionCall).getTarget().hasQualifiedName(\"testing::internal\", \"MakeAndRegisterTestInfo\")\n}\n\nfrom File f, int n\nwhere n = strictcount(Expr e | e = getTest() and e.getFile() = f)\nselect f, n order by n desc",
        "description": "The number of test methods defined in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FNumberOfTests.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate macroLocation(File f, int startLine, int endLine) {\n  exists(MacroInvocation mi, Location l |\n    l = mi.getLocation() and\n    l.getFile() = f and\n    l.getStartLine() = startLine and\n    l.getEndLine() = endLine\n  )\n}\n\npragma[nomagic]\nLocation getVariableLocation(Variable v) { result = v.getLocation() }\n\npredicate globalLocation(GlobalVariable gv, File f, int startLine, int endLine) {\n  exists(Location l |\n    l = getVariableLocation(gv) and\n    l.hasLocationInfo(f.getAbsolutePath(), startLine, _, endLine, _)\n  )\n}\n\npredicate inMacro(GlobalVariable gv) {\n  exists(File f, int macroStart, int macroEnd, int varStart, int varEnd |\n    macroLocation(f, macroStart, macroEnd) and\n    globalLocation(gv, f, varStart, varEnd) and\n    varStart >= macroStart and\n    varEnd <= macroEnd\n  )\n}\n\nfrom File f\nwhere f.fromSource()\nselect f,\n  count(GlobalVariable gv |\n    gv.getFile() = f and\n    not gv.isStatic() and\n    not inMacro(gv)\n  )",
        "description": "The total number of global variables in each file with external (public) visibility.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/NumberOfPublicGlobals.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom string x, float t\nwhere\n  exists(Compilation c, int i |\n    x = c.toString() + \":\" + i.toString() and\n    t = 1000 * c.getFrontendCpuSeconds(i) and\n    c.getFileCompiled(i).fromSource()\n  )\nselect x, t order by t desc",
        "description": "Measures the amount of time (in milliseconds) spent compiling a C/C++ file, including time spent processing all files included by the pre-processor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FTimeInFrontend.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f, int n\nwhere\n  f.fromSource() and\n  n =\n    count(Comment c |\n      c.getFile() = f and\n      (\n        c.getContents().matches(\"%TODO%\") or\n        c.getContents().matches(\"%FIXME%\")\n      )\n    )\nselect f, n order by n",
        "description": "The number of TODO or FIXME comments in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FTodoComments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f, float complexity, float loc\nwhere\n  f.fromSource() and\n  loc = sum(FunctionDeclarationEntry fde | fde.getFile() = f | fde.getNumberOfLines()) and\n  if loc > 0\n  then\n    // Weighted average of complexity by function length\n    complexity =\n      sum(FunctionDeclarationEntry fde |\n          fde.getFile() = f\n        |\n          fde.getNumberOfLines() * fde.getCyclomaticComplexity()\n        ).(float) / loc\n  else complexity = 0\nselect f, complexity",
        "description": "The average cyclomatic complexity of the functions in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FCyclomaticComplexity.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f,\n  count(Function fn |\n    fn.getFile() = f and\n    not fn instanceof MemberFunction\n  )",
        "description": "The total number of functions in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/NumberOfFunctions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFile mc\nwhere mc.fromSource()\nselect mc, mc.getHalsteadDifficulty()",
        "description": "Measures the error proneness of implementing the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FHalsteadDifficulty.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate isInCodebase(File f) {\n  exists(string prefix | sourceLocationPrefix(prefix) |\n    f.getAbsolutePath().prefix(prefix.length()) = prefix\n  )\n}\n\nfrom File f, int n\nwhere\n  f.fromSource() and\n  n = count(File g | g = f.getAnIncludedFile+() and isInCodebase(g))\nselect f, n",
        "description": "The number of source files included by the pre-processor - either directly by an `#include` directive, or indirectly (by being included by an included file). This metric excludes included files that aren't part of the main code base (like system headers).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FTransitiveSourceIncludes.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f, f.getMetrics().getNumberOfLinesOfComments() as n order by n desc",
        "description": "Measures the number of lines which contain a comment or part of a comment (that is, which are part of a multi-line comment).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FLinesOfComments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFile mc\nwhere mc.fromSource()\nselect mc, mc.getHalsteadDeliveredBugs()",
        "description": "Measures the expected number of delivered bugs. The Halstead bug count is known to be an underestimate.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FHalsteadBugs.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.headers.MultipleInclusion\n\npredicate preprocessorOpenCondition(PreprocessorDirective d, File f, int line) {\n  (\n    d instanceof PreprocessorIf or\n    d instanceof PreprocessorIfdef or\n    d instanceof PreprocessorIfndef\n  ) and\n  exists(Location l | l = d.getLocation() | f = l.getFile() and line = l.getStartLine())\n}\n\npredicate preprocessorCloseCondition(PreprocessorDirective d, File f, int line) {\n  d instanceof PreprocessorEndif and\n  exists(Location l | l = d.getLocation() | f = l.getFile() and line = l.getStartLine())\n}\n\nprivate predicate relevantLine(File f, int line) {\n  preprocessorOpenCondition(_, f, line) or\n  preprocessorCloseCondition(_, f, line)\n}\n\npredicate relevantDirective(PreprocessorDirective d, File f, int line) {\n  preprocessorOpenCondition(d, f, line) or\n  preprocessorCloseCondition(d, f, line)\n}\n\nprivate predicate relevantLineWithRank(File f, int rnk, int line) {\n  line = rank[rnk](int l | relevantLine(f, l) | l)\n}\n\nprivate PreprocessorDirective next(PreprocessorDirective ppd) {\n  exists(File f, int line, int rnk, int nextLine |\n    relevantDirective(ppd, f, line) and\n    relevantLineWithRank(f, rnk, line) and\n    relevantLineWithRank(f, rnk + 1, nextLine) and\n    relevantDirective(result, f, nextLine)\n  )\n}\n\nprivate int level(PreprocessorDirective ppd) {\n  relevantDirective(ppd, _, _) and\n  not ppd = next(_) and\n  result = 0\n  or\n  exists(PreprocessorDirective previous |\n    ppd = next(previous) and\n    preprocessorOpenCondition(previous, _, _) and\n    result = level(previous) + 1\n  )\n  or\n  exists(PreprocessorDirective previous |\n    ppd = next(previous) and\n    preprocessorCloseCondition(previous, _, _) and\n    result = level(previous) - 1\n  )\n}\n\nprivate predicate openWithDepth(int depth, File f, PreprocessorDirective open, int line) {\n  preprocessorOpenCondition(open, f, line) and\n  depth = level(open) and\n  depth < 2 // beyond 2, we don't care about the macros anymore\n}\n\nprivate predicate closeWithDepth(int depth, File f, PreprocessorDirective close, int line) {\n  preprocessorCloseCondition(close, f, line) and\n  depth = level(close) - 1 and\n  depth < 2 // beyond 2, we don't care about the macros anymore\n}\n\npredicate length(PreprocessorDirective open, int length) {\n  exists(int depth, File f, int start, int end |\n    openWithDepth(depth, f, open, start) and\n    end =\n      min(PreprocessorDirective endif, int closeLine |\n        closeWithDepth(depth, f, endif, closeLine) and\n        closeLine > start\n      |\n        closeLine\n      ) and\n    length = end - start - 1\n  )\n}\n\npredicate headerGuard(PreprocessorDirective notdef, File f) {\n  exists(CorrectIncludeGuard g | notdef = g.getIfndef() and f = notdef.getFile())\n}\n\npredicate headerGuardChild(PreprocessorDirective open) {\n  exists(File f |\n    headerGuard(_, f) and\n    openWithDepth(1, f, open, _)\n  )\n}\n\npredicate topLevelOpen(PreprocessorDirective open) {\n  openWithDepth(0, _, open, _) and not headerGuard(open, _)\n  or\n  headerGuardChild(open)\n}\n\nfrom File f\nwhere f.fromSource()\nselect f,\n  sum(PreprocessorDirective open, int length |\n    open.getFile() = f and\n    topLevelOpen(open) and\n    length(open, length)\n  |\n    length\n  )",
        "description": "The number of lines that are subject to conditional compilation constraints defined using `#if`, `#ifdef`, and `#ifndef`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/ConditionalSegmentLines.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate macroLines(File f, int line) {\n  exists(MacroInvocation mi |\n    mi.getFile() = f and\n    mi.getLocation().getStartLine() = line\n  )\n}\n\npredicate macroLineCount(File f, int num) { num = count(int line | macroLines(f, line)) }\n\nfrom MetricFile f, int macroLines, int loc\nwhere\n  f.fromSource() and\n  loc = f.getNumberOfLinesOfCode() and\n  loc > 0 and\n  macroLineCount(f, macroLines)\nselect f, 100.0 * (macroLines.(float) / loc.(float)) as ratio order by ratio desc",
        "description": "The percentage of source lines in each file that contain use of macros.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FMacroRatio.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate preprocessorOpenCondition(PreprocessorDirective d) {\n  d instanceof PreprocessorIf or\n  d instanceof PreprocessorIfdef or\n  d instanceof PreprocessorIfndef\n}\n\npredicate headerGuard(PreprocessorIfndef notdef) {\n  notdef.getHead().regexpMatch(\".*_H_.*\")\n  or\n  notdef.getHead().regexpMatch(\".*_H\")\n}\n\nfrom File f\nwhere f.fromSource()\nselect f,\n  count(string s |\n    exists(PreprocessorDirective open |\n      preprocessorOpenCondition(open) and\n      not headerGuard(open) and\n      open.getFile() = f and\n      s = open.getHead()\n    )\n  )",
        "description": "For each file, the number of unique conditions used by `#if`, `#ifdef`, and `#ifndef`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/ConditionalSegmentConditions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFile mc\nwhere mc.fromSource()\nselect mc, mc.getHalsteadEffort()",
        "description": "Measures the effort to implement the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FHalsteadEffort.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFile mc\nwhere mc.fromSource()\nselect mc, mc.getHalsteadVolume()",
        "description": "The information contents of the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FHalsteadVolume.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f, f.getMetrics().getAfferentCoupling() as n order by n desc",
        "description": "The number of files that depend on a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FAfferentCoupling.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f, int n\nwhere\n  f.fromSource() and\n  n = count(Include i | i.getFile() = f)\nselect f, n",
        "description": "The number of files directly included by this file using `#include`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FDirectIncludes.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f,\n  count(Function fn |\n    fn.getFile() = f and\n    not fn instanceof MemberFunction and\n    not fn.isStatic()\n  )",
        "description": "The total number of public (non-static) functions in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/NumberOfPublicFunctions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f, f.getMetrics().getEfferentCoupling() as n order by n desc",
        "description": "The number of files that a file depends on.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FEfferentCoupling.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere f.fromSource()\nselect f,\n  avg(MetricFunction fn |\n    fn.getFile() = f and\n    not fn instanceof MemberFunction\n  |\n    fn.getNumberOfLinesOfCode()\n  )",
        "description": "The average number of lines in functions in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Files/FunctionLength.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere strictcount(f.getEntryPoint()) = 1\nselect f, f.getMetrics().getCyclomaticComplexity()",
        "description": "The Cyclomatic complexity (an indication of how many tests are necessary, based on the number of branching statements) per function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunCyclomaticComplexity.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFunction f, int depth\nwhere\n  depth = f.getNestingDepth() and\n  strictcount(f.getEntryPoint()) = 1\nselect f, depth order by depth desc",
        "description": "The maximum number of nested statements (for example, `if`, `for`, `while`, etc.). Blocks are not counted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/StatementNestingDepth.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere strictcount(f.getEntryPoint()) = 1\nselect f, f.getMetrics().getNumberOfLinesOfCode()",
        "description": "Measures the number of lines in a function that contain code (rather than lines that only contain comments or are blank).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunLinesOfCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate callToOperator(FunctionCall fc) {\n  fc.getTarget() instanceof Operator or\n  fc.getTarget() instanceof ConversionOperator\n}\n\nfrom Function f, int n, int o\nwhere\n  strictcount(f.getEntryPoint()) = 1 and\n  o =\n    count(FunctionCall c |\n      c.getEnclosingFunction() = f and\n      not c.isInMacroExpansion() and\n      not c.isCompilerGenerated() and\n      not callToOperator(c)\n    ) and\n  n = o / count(f.getBlock())\nselect f, n",
        "description": "The number of C/C++ function calls per function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunNumberOfCalls.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFunction f\nwhere f.getNumberOfLines() > 0 and strictcount(f.getEntryPoint()) = 1\nselect f, 100.0 * (f.getNumberOfLinesOfComments().(float) / f.getNumberOfLines().(float))",
        "description": "The ratio of comment lines to the total number of lines in a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunPercentageOfComments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f, int n\nwhere\n  strictcount(f.getEntryPoint()) = 1 and\n  n = count(Stmt s | s.getEnclosingFunction() = f)\nselect f, n",
        "description": "The number of C/C++ statements per function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunNumberOfStatements.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nint iterationDepth(Stmt l) { result = count(Loop other | l.getParent*() = other) }\n\nfrom Function f, int depth\nwhere\n  depth = max(Stmt s | s.getEnclosingFunction() = f | iterationDepth(s)) and\n  strictcount(f.getEntryPoint()) = 1\nselect f, depth order by depth desc",
        "description": "The maximum number of nested loops in each function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunIterationNestingDepth.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere strictcount(f.getEntryPoint()) = 1\nselect f, f.getMetrics().getNumberOfParameters()",
        "description": "The number of formal parameters for each function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunNumberOfParameters.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere strictcount(f.getEntryPoint()) = 1\nselect f, f.getMetrics().getNumberOfLinesOfComments()",
        "description": "Measures the number of lines in a function that contain a comment or part of a comment (that is, which are part of a multi-line comment).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/Functions/FunLinesOfComments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Compilation c, int i\nselect c.toString() + \":\" + i.toString(), c.getFileCompiled(i)",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/External/FileCompilationSourceLinks.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Compilation c, int i\nselect c.toString() + \":\" + i.toString(),\n  c.toString() + \":\" + i.toString() + \":\" + c.getFileCompiled(i)",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Metrics/External/FileCompilationDisplayStrings.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nclass DangerousBitOperations extends BinaryBitwiseOperation {\n  FunctionCall bfc;\n\n  /**\n   * The assignment indicates the conscious use of the bit operator.\n   * Use in comparison, conversion, or return value indicates conscious use of the bit operator.\n   * The use of shifts and bitwise operations on any element of an expression indicates a conscious use of the bitwise operator.\n   */\n  DangerousBitOperations() {\n    bfc = this.getRightOperand() and\n    not this.getParent*() instanceof Assignment and\n    not this.getParent*() instanceof Initializer and\n    not this.getParent*() instanceof ReturnStmt and\n    not this.getParent*() instanceof EqualityOperation and\n    not this.getParent*() instanceof UnaryLogicalOperation and\n    not this.getParent*() instanceof BinaryLogicalOperation and\n    not this.getAChild*() instanceof BitwiseXorExpr and\n    not this.getAChild*() instanceof LShiftExpr and\n    not this.getAChild*() instanceof RShiftExpr\n  }\n\n  /** Holds when part of a bit expression is used in a logical operation. */\n  predicate useInLogicalOperations() {\n    exists(BinaryLogicalOperation blop, Expr exp |\n      blop.getAChild*() = exp and\n      exp.(FunctionCall).getTarget() = bfc.getTarget() and\n      not exp.getParent() instanceof ComparisonOperation and\n      not exp.getParent() instanceof BinaryBitwiseOperation\n    )\n  }\n\n  /** Holds when part of a bit expression is used as part of another supply. For example, as an argument to another function. */\n  predicate useInOtherCalls() {\n    bfc.hasQualifier() or\n    bfc.getTarget() instanceof Operator or\n    exists(FunctionCall fc | fc.getAnArgument().getAChild*() = this) or\n    bfc.getTarget() instanceof BuiltInFunction\n  }\n\n  /** Holds when the bit expression contains both arguments and a function call. */\n  predicate dangerousArgumentChecking() {\n    not this.getLeftOperand() instanceof Call and\n    globalValueNumber(this.getLeftOperand().getAChild*()) = globalValueNumber(bfc.getAnArgument())\n  }\n\n  /** Holds when function calls are present in the bit expression. */\n  predicate functionCallsInBitsExpression() {\n    this.getLeftOperand().getAChild*() instanceof FunctionCall\n  }\n}\n\nfrom DangerousBitOperations dbo\nwhere\n  not dbo.useInOtherCalls() and\n  dbo.useInLogicalOperations() and\n  (not dbo.functionCallsInBitsExpression() or dbo.dangerousArgumentChecking())\nselect dbo, \"This bitwise operation appears in a context where a Boolean operation is expected.\"",
        "description": "Unlike the binary operations `||` and `&&`, there is no sequence point after evaluating an operand of a bitwise operation like `|` or `&`. If left-to-right evaluation is expected this may be confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-691/InsufficientControlFlowManagementWhenUsingBitOperations.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.HashCons\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nclass UsingWhileAfterWhile extends WhileStmt {\n  /**\n   * Using a loop call after another loop has finished running can result in an eternal loop.\n   * For example, perhaps as a result of refactoring, the `do ... while ()` loop was incorrectly corrected.\n   * Even in the case of deliberate use of such an expression, it is better to correct it.\n   */\n  UsingWhileAfterWhile() {\n    exists(WhileStmt wh1 |\n      wh1.getStmt().getAChild*().(BreakStmt).(ControlFlowNode).getASuccessor().getASuccessor() =\n        this and\n      hashCons(wh1.getCondition()) = hashCons(this.getCondition()) and\n      this.getStmt() instanceof EmptyStmt\n    )\n    or\n    exists(ForStmt fr1 |\n      fr1.getStmt().getAChild*().(BreakStmt).(ControlFlowNode).getASuccessor().getASuccessor() =\n        this and\n      hashCons(fr1.getCondition()) = hashCons(this.getCondition()) and\n      this.getStmt() instanceof EmptyStmt\n    )\n  }\n}\n\nclass UsingArithmeticInComparison extends BinaryArithmeticOperation {\n  /**\n   * Using arithmetic operations in a comparison operation can be dangerous.\n   * For example, part of the comparison may have been lost as a result of refactoring.\n   * Even if you deliberately use such an expression, it is better to add an explicit comparison.\n   */\n  UsingArithmeticInComparison() {\n    this.getParent*() instanceof IfStmt and\n    not this.getAChild*().isConstant() and\n    not this.getParent*() instanceof Call and\n    not this.getParent*() instanceof AssignExpr and\n    not this.getParent*() instanceof ArrayExpr and\n    not this.getParent*() instanceof RemExpr and\n    not this.getParent*() instanceof AssignBitwiseOperation and\n    not this.getParent*() instanceof AssignArithmeticOperation and\n    not this.getParent*() instanceof EqualityOperation and\n    not this.getParent*() instanceof RelationalOperation\n  }\n\n  /** Holds when the expression is inside the loop body. */\n  predicate insideTheLoop() { exists(Loop lp | lp.getStmt().getAChild*() = this.getParent*()) }\n\n  /** Holds when the expression is used in binary operations. */\n  predicate workingWithValue() {\n    this.getParent*() instanceof BinaryBitwiseOperation or\n    this.getParent*() instanceof NotExpr\n  }\n\n  /** Holds when the expression contains a pointer. */\n  predicate workingWithPointer() {\n    this.getAChild*().getFullyConverted().getType() instanceof DerivedType\n  }\n\n  /** Holds when a null comparison expression exists. */\n  predicate compareWithZero() {\n    exists(Expr exp |\n      exp instanceof ComparisonOperation and\n      (\n        globalValueNumber(exp.getAChild*()) = globalValueNumber(this) or\n        hashCons(exp.getAChild*()) = hashCons(this)\n      ) and\n      (\n        exp.(ComparisonOperation).getLeftOperand().getValue() = \"0\" or\n        exp.(ComparisonOperation).getRightOperand().getValue() = \"0\"\n      )\n    )\n  }\n\n  /** Holds when a comparison expression exists. */\n  predicate compareWithOutZero() {\n    exists(Expr exp |\n      exp instanceof ComparisonOperation and\n      (\n        globalValueNumber(exp.getAChild*()) = globalValueNumber(this) or\n        hashCons(exp.getAChild*()) = hashCons(this)\n      )\n    )\n  }\n}\n\nfrom Expr exp\nwhere\n  exp instanceof UsingArithmeticInComparison and\n  not exp.(UsingArithmeticInComparison).workingWithValue() and\n  not exp.(UsingArithmeticInComparison).workingWithPointer() and\n  not exp.(UsingArithmeticInComparison).insideTheLoop() and\n  not exp.(UsingArithmeticInComparison).compareWithZero() and\n  exp.(UsingArithmeticInComparison).compareWithOutZero()\n  or\n  exists(WhileStmt wst | wst instanceof UsingWhileAfterWhile and exp = wst.getCondition())\nselect exp, \"This expression needs your attention.\"",
        "description": "--In some situations, after code refactoring, parts of the old constructs may remain. --They are correctly accepted by the compiler, but can critically affect program execution. --For example, if you switch from `do {...} while ();` to `while () {...}` with errors, you run the risk of running out of resources. --These code snippets look suspicious and require the developer's attention.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-691/InsufficientControlFlowManagementAfterRefactoringTheCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.commons.Assertions\n\nclass CallUsedToHandleErrors extends FunctionCall {\n  CallUsedToHandleErrors() {\n    // call that is known to not return\n    not exists(this.(ControlFlowNode).getASuccessor())\n    or\n    // call throwing an exception\n    this.(ControlFlowNode).getASuccessor() instanceof ThrowExpr\n    or\n    // call logging a message, possibly an error\n    this.(ControlFlowNode).getASuccessor() instanceof FormattingFunction\n    or\n    // enabling recursive search\n    exists(CallUsedToHandleErrors fr | this.getTarget() = fr.getEnclosingFunction())\n  }\n}\n\npredicate conditionsOutsideWrapper(FunctionCall fcp) {\n  fcp.getNumberOfArguments() > 0 and\n  not fcp.getEnclosingStmt().getParentStmt*() instanceof ConditionalStmt and\n  not fcp.getEnclosingStmt().getParentStmt*() instanceof Loop and\n  not fcp.getEnclosingStmt().getParentStmt*() instanceof ReturnStmt and\n  not exists(FunctionCall fctmp2 | fcp = fctmp2.getAnArgument().getAChild*()) and\n  not exists(Assignment astmp | fcp = astmp.getRValue().getAChild*()) and\n  not exists(Initializer intmp | fcp = intmp.getExpr().getAChild*()) and\n  not exists(Assertion astmp | fcp = astmp.getAsserted().getAChild*()) and\n  not exists(Operation optmp | fcp = optmp.getAChild*()) and\n  not exists(ArrayExpr aetmp | fcp = aetmp.getAChild*()) and\n  not exists(ExprCall ectmp | fcp = ectmp.getAnArgument().getAChild*())\n}\n\npragma[inline]\npredicate conditionsInsideWrapper(FunctionCall fcp, Function fnp) {\n  not exists(FunctionCall fctmp2 |\n    fctmp2.getEnclosingFunction() = fnp and fcp = fctmp2.getAnArgument().getAChild*()\n  ) and\n  not fcp instanceof CallUsedToHandleErrors and\n  not fcp.getAnArgument().isConstant() and\n  fcp.getEnclosingFunction() = fnp and\n  fnp.getNumberOfParameters() > 0 and\n  // the call arguments must be passed through the arguments of the wrapper function\n  forall(int i | i in [0 .. fcp.getNumberOfArguments() - 1] |\n    globalValueNumber(fcp.getArgument(i)) = globalValueNumber(fnp.getAParameter().getAnAccess())\n  ) and\n  // there should be no more than one required call inside the wrapper function\n  not exists(FunctionCall fctmp |\n    fctmp.getTarget() = fcp.getTarget() and\n    fctmp.getFile() = fcp.getFile() and\n    fctmp != fcp and\n    fctmp.getEnclosingFunction() = fnp\n  ) and\n  // inside the wrapper function there should be no calls without paths to the desired function\n  not exists(FunctionCall fctmp |\n    fctmp.getEnclosingFunction() = fnp and\n    fctmp.getFile() = fcp.getFile() and\n    fctmp != fcp and\n    (\n      fctmp = fcp.getAPredecessor+()\n      or\n      not exists(FunctionCall fctmp1 |\n        fctmp1 = fcp and\n        (\n          fctmp.getASuccessor+() = fctmp1 or\n          fctmp.getAPredecessor+() = fctmp1\n        )\n      )\n    )\n  )\n}\n\npragma[inline]\npredicate conditionsForWrapper(FunctionCall fcp, Function fnp) {\n  not exists(ExprCall ectmp | fnp = ectmp.getEnclosingFunction()) and\n  not exists(Loop lp | lp.getEnclosingFunction() = fnp) and\n  not exists(SwitchStmt sw | sw.getEnclosingFunction() = fnp) and\n  not fnp instanceof Operator and\n  // inside the wrapper function there should be checks of arguments or the result,\n  // perhaps by means of passing the latter as an argument to some function\n  (\n    exists(IfStmt ifs |\n      ifs.getEnclosingFunction() = fnp and\n      (\n        globalValueNumber(ifs.getCondition().getAChild*()) = globalValueNumber(fcp.getAnArgument()) and\n        ifs.getASuccessor*() = fcp\n        or\n        ifs.getCondition().getAChild() = fcp\n      )\n    )\n    or\n    exists(FunctionCall fctmp |\n      fctmp.getEnclosingFunction() = fnp and\n      globalValueNumber(fctmp.getAnArgument().getAChild*()) = globalValueNumber(fcp)\n    )\n  ) and\n  // inside the wrapper function there must be a function call to handle the error\n  exists(CallUsedToHandleErrors fctmp |\n    fctmp.getEnclosingFunction() = fnp and\n    forall(int i | i in [0 .. fnp.getNumberOfParameters() - 1] |\n      fnp.getParameter(i).getAnAccess().getTarget() =\n        fcp.getAnArgument().(VariableAccess).getTarget() or\n      fnp.getParameter(i).getUnspecifiedType() instanceof Class or\n      fnp.getParameter(i).getUnspecifiedType().(ReferenceType).getBaseType() instanceof Class or\n      fnp.getParameter(i).getAnAccess().getTarget() =\n        fctmp.getAnArgument().(VariableAccess).getTarget()\n    )\n  )\n}\n\nfrom FunctionCall fc, Function fn\nwhere\n  exists(FunctionCall fctmp |\n    conditionsInsideWrapper(fctmp, fn) and\n    conditionsForWrapper(fctmp, fn) and\n    conditionsOutsideWrapper(fc) and\n    fctmp.getTarget() = fc.getTarget() and\n    fc.getEnclosingFunction() != fn and\n    fc.getEnclosingFunction().getMetrics().getNumberOfCalls() > fn.getMetrics().getNumberOfCalls()\n  )\nselect fc, \"Consider changing the call to $@.\", fn, fn.getName()",
        "description": "If a wrapper function is defined for a given function, any call to the given function should be via the wrapper function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-1041/FindWrapperFunctions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\npredicate numberArgumentRead(Function f, int apos) {\n  f.hasGlobalOrStdName(\"fgets\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"fread\") and apos = 3\n  or\n  f.hasGlobalOrStdName(\"read\") and apos = 0\n  or\n  f.hasGlobalOrStdName(\"fscanf\") and apos = 0\n}\n\npredicate numberArgumentWrite(Function f, int apos) {\n  f.hasGlobalOrStdName(\"fprintf\") and apos = 0\n  or\n  f.hasGlobalOrStdName(\"fputs\") and apos = 1\n  or\n  f.hasGlobalOrStdName(\"write\") and apos = 0\n  or\n  f.hasGlobalOrStdName(\"fwrite\") and apos = 3\n  or\n  f.hasGlobalOrStdName(\"fflush\") and apos = 0\n}\n\nfrom FunctionCall fc\nwhere\n  // a file is opened\n  (\n    fc.getTarget().hasGlobalOrStdName(\"fopen\") or\n    fc.getTarget().hasGlobalOrStdName(\"open\")\n  ) and\n  fc.getNumberOfArguments() = 2 and\n  // the file is used for writing (but not reading)\n  exists(FunctionCall fctmp, int i |\n    numberArgumentWrite(fctmp.getTarget(), i) and\n    globalValueNumber(fc) = globalValueNumber(fctmp.getArgument(i))\n  ) and\n  not exists(FunctionCall fctmp, int i |\n    numberArgumentRead(fctmp.getTarget(), i) and\n    globalValueNumber(fc) = globalValueNumber(fctmp.getArgument(i))\n  ) and\n  // a file creation mode is not set globally by `umask` anywhere in the program\n  not exists(FunctionCall fctmp |\n    fctmp.getTarget().hasGlobalOrStdName(\"umask\") or\n    fctmp.getTarget().hasGlobalOrStdName(\"fchmod\") or\n    fctmp.getTarget().hasGlobalOrStdName(\"chmod\")\n  )\nselect fc, \"You may have forgotten to restrict access rights when working with a file.\"",
        "description": "Lack of restriction on file access rights can be unsafe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-200/ExposureSensitiveInformationUnauthorizedActor.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.security.Overflow\n\nfrom FunctionCall call, Function f, Parameter p, DataFlow::Node sink, PointerArithmeticOperation pao\nwhere\n  f = call.getTarget() and\n  p = f.getAParameter() and\n  p.getUnspecifiedType().(IntegralType).isSigned() and\n  call.getArgument(p.getIndex()).getUnspecifiedType().(IntegralType).isUnsigned() and\n  pao.getAnOperand() = sink.asExpr() and\n  not guardedLesser(_, sink.asExpr()) and\n  not guardedGreater(_, call.getArgument(p.getIndex())) and\n  not call.getArgument(p.getIndex()).isConstant() and\n  DataFlow::localFlow(DataFlow::parameterNode(p), sink) and\n  p.getUnspecifiedType().getSize() < 8\nselect call,\n  \"This call passes an unsigned int to a function that requires a signed int: $@. It's then used in pointer arithmetic: $@.\",\n  f, f.toString(), sink, sink.toString()",
        "description": "finds unsigned to signed conversions used in pointer arithmetic, potentially causing an out-of-bound access",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-787/UnsignedToSignedPointerArith.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\npredicate exprMayBeString(Expr exp) {\n  (\n    exists(StringLiteral sl | globalValueNumber(exp) = globalValueNumber(sl))\n    or\n    exists(FunctionCall fctmp |\n      (\n        fctmp.getAnArgument().(VariableAccess).getTarget() = exp.(VariableAccess).getTarget() or\n        globalValueNumber(fctmp.getAnArgument()) = globalValueNumber(exp)\n      ) and\n      fctmp.getTarget().hasName([\"strlen\", \"strcat\", \"strncat\", \"strcpy\", \"sprintf\", \"printf\"])\n    )\n    or\n    exists(AssignExpr astmp |\n      astmp.getRValue().getValue() = \"0\" and\n      astmp.getLValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() =\n        exp.(VariableAccess).getTarget()\n    )\n    or\n    exists(ComparisonOperation cotmp, Expr exptmp1, Expr exptmp2 |\n      exptmp1.getValue() = \"0\" and\n      (\n        exptmp2.(PointerDereferenceExpr).getOperand().(VariableAccess).getTarget() =\n          exp.(VariableAccess).getTarget() or\n        exptmp2.(ArrayExpr).getArrayBase().(VariableAccess).getTarget() =\n          exp.getAChild().(VariableAccess).getTarget()\n      ) and\n      cotmp.hasOperands(exptmp1, exptmp2)\n    )\n  )\n}\n\npredicate argConstOrSizeof(Expr exp) {\n  exp.getValue().toInt() > 1 or\n  exp.(SizeofTypeOperator).getTypeOperand().getSize() > 1\n}\n\npredicate argMacro(Expr exp) {\n  exists(MacroInvocation matmp |\n    exp = matmp.getExpr() and\n    (\n      matmp.getMacroName() = \"MB_LEN_MAX\" or\n      matmp.getMacroName() = \"MB_CUR_MAX\"\n    )\n  )\n}\n\npredicate findUseCharacterConversion(Expr exp, string msg) {\n  exists(FunctionCall fc |\n    fc = exp and\n    (\n      fc.getEnclosingStmt().getParentStmt*() instanceof Loop and\n      fc.getTarget().hasName([\"mbtowc\", \"mbrtowc\", \"_mbtowc_l\"]) and\n      not fc.getArgument(0).isConstant() and\n      not fc.getArgument(1).isConstant() and\n      (\n        exprMayBeString(fc.getArgument(1)) and\n        argConstOrSizeof(fc.getArgument(2)) and\n        fc.getArgument(2).getValue().toInt() < 5 and\n        not argMacro(fc.getArgument(2)) and\n        msg = \"Size can be less than maximum character length, use macro MB_CUR_MAX.\"\n        or\n        not exprMayBeString(fc.getArgument(1)) and\n        (\n          argConstOrSizeof(fc.getArgument(2))\n          or\n          argMacro(fc.getArgument(2))\n          or\n          exists(DecrementOperation dotmp |\n            globalValueNumber(dotmp.getAnOperand()) = globalValueNumber(fc.getArgument(2)) and\n            not exists(AssignSubExpr aetmp |\n              (\n                aetmp.getLValue().(VariableAccess).getTarget() =\n                  fc.getArgument(2).(VariableAccess).getTarget() or\n                globalValueNumber(aetmp.getLValue()) = globalValueNumber(fc.getArgument(2))\n              ) and\n              globalValueNumber(aetmp.getRValue()) = globalValueNumber(fc)\n            )\n          )\n        ) and\n        msg =\n          \"Access beyond the allocated memory is possible, the length can change without changing the pointer.\"\n        or\n        exists(AssignPointerAddExpr aetmp |\n          (\n            aetmp.getLValue().(VariableAccess).getTarget() =\n              fc.getArgument(0).(VariableAccess).getTarget() or\n            globalValueNumber(aetmp.getLValue()) = globalValueNumber(fc.getArgument(0))\n          ) and\n          globalValueNumber(aetmp.getRValue()) = globalValueNumber(fc)\n        ) and\n        msg = \"Maybe you're using the function's return value incorrectly.\"\n      )\n    )\n  )\n}\n\npredicate findUseMultibyteCharacter(Expr exp, string msg) {\n  exists(ArrayType arrayType, ArrayExpr arrayExpr |\n    arrayExpr = exp and\n    arrayExpr.getArrayBase().getType() = arrayType and\n    (\n      exists(AssignExpr assZero, SizeofExprOperator sizeofArray, Expr oneValue |\n        oneValue.getValue() = \"1\" and\n        sizeofArray.getExprOperand().getType() = arrayType and\n        assZero.getLValue() = arrayExpr and\n        arrayExpr.getArrayOffset().(SubExpr).hasOperands(sizeofArray, oneValue) and\n        assZero.getRValue().getValue() = \"0\"\n      ) and\n      arrayType.getArraySize() != arrayType.getByteSize() and\n      msg =\n        \"The size of the array element is greater than one byte, so the offset will point outside the array.\"\n      or\n      exists(FunctionCall mbFunction |\n        (\n          mbFunction.getTarget().getName().matches(\"_mbs%\") or\n          mbFunction.getTarget().getName().matches(\"mbs%\") or\n          mbFunction.getTarget().getName().matches(\"_mbc%\") or\n          mbFunction.getTarget().getName().matches(\"mbc%\")\n        ) and\n        mbFunction.getAnArgument().(VariableAccess).getTarget().getADeclarationEntry().getType() =\n          arrayType\n      ) and\n      exists(Loop loop, SizeofExprOperator sizeofArray, AssignExpr assignExpr |\n        arrayExpr.getEnclosingStmt().getParentStmt*() = loop and\n        sizeofArray.getExprOperand().getType() = arrayType and\n        assignExpr.getLValue() = arrayExpr and\n        loop.getCondition().(LTExpr).getLeftOperand().(VariableAccess).getTarget() =\n          arrayExpr.getArrayOffset().getAChild*().(VariableAccess).getTarget() and\n        loop.getCondition().(LTExpr).getRightOperand() = sizeofArray\n      ) and\n      msg =\n        \"This buffer may contain multibyte characters, so attempting to copy may result in part of the last character being lost.\"\n    )\n  )\n  or\n  exists(FunctionCall mbccpy, Loop loop, SizeofExprOperator sizeofOp |\n    mbccpy.getTarget().hasName(\"_mbccpy\") and\n    mbccpy.getArgument(0) = exp and\n    exp.getEnclosingStmt().getParentStmt*() = loop and\n    sizeofOp.getExprOperand().getType() =\n      exp.getAChild*().(VariableAccess).getTarget().getADeclarationEntry().getType() and\n    loop.getCondition().(LTExpr).getLeftOperand().(VariableAccess).getTarget() =\n      exp.getAChild*().(VariableAccess).getTarget() and\n    loop.getCondition().(LTExpr).getRightOperand() = sizeofOp and\n    msg =\n      \"This buffer may contain multibyte characters, so an attempt to copy may result in an overflow.\"\n  )\n}\n\npredicate findUseStringConversion(\n  Expr exp, string msg, int posBufSrc, int posBufDst, int posSizeDst, string nameCalls\n) {\n  exists(FunctionCall fc |\n    fc = exp and\n    posBufSrc in [0 .. fc.getNumberOfArguments() - 1] and\n    posSizeDst in [0 .. fc.getNumberOfArguments() - 1] and\n    (\n      fc.getTarget().hasName(nameCalls) and\n      (\n        globalValueNumber(fc.getArgument(posBufDst)) = globalValueNumber(fc.getArgument(posBufSrc)) and\n        msg =\n          \"According to the definition of the functions, if the source buffer and the destination buffer are the same, undefined behavior is possible.\"\n        or\n        exists(ArrayType arrayDst |\n          fc.getArgument(posBufDst).(VariableAccess).getTarget().getADeclarationEntry().getType() =\n            arrayDst and\n          fc.getArgument(posSizeDst).getValue().toInt() >= arrayDst.getArraySize() and\n          not exists(AssignExpr assZero |\n            assZero.getLValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() =\n              fc.getArgument(posBufDst).(VariableAccess).getTarget() and\n            assZero.getRValue().getValue() = \"0\"\n          ) and\n          not exists(Expr someExp, FunctionCall checkSize |\n            checkSize.getASuccessor*() = fc and\n            checkSize.getTarget().hasName(nameCalls) and\n            checkSize.getArgument(posSizeDst).getValue() = \"0\" and\n            globalValueNumber(checkSize) = globalValueNumber(someExp) and\n            someExp.getEnclosingStmt().getParentStmt*() instanceof IfStmt\n          ) and\n          exprMayBeString(fc.getArgument(posBufDst)) and\n          msg =\n            \"According to the definition of the functions, it is not guaranteed to write a null character at the end of the string, so access beyond the bounds of the destination buffer is possible.\"\n        )\n        or\n        exists(FunctionCall allocMem |\n          allocMem.getTarget().hasName([\"calloc\", \"malloc\"]) and\n          globalValueNumber(fc.getArgument(posBufDst)) = globalValueNumber(allocMem) and\n          (\n            allocMem.getArgument(allocMem.getNumberOfArguments() - 1).getValue() = \"1\" or\n            not exists(SizeofOperator sizeofOperator |\n              globalValueNumber(allocMem\n                    .getArgument(allocMem.getNumberOfArguments() - 1)\n                    .getAChild*()) = globalValueNumber(sizeofOperator)\n            )\n          ) and\n          msg =\n            \"The buffer destination has a type other than char, you need to take this into account when allocating memory.\"\n        )\n        or\n        fc.getArgument(posBufDst).getValue() = \"0\" and\n        fc.getArgument(posSizeDst).getValue() != \"0\" and\n        msg =\n          \"If the destination buffer is NULL and its size is not 0, then undefined behavior is possible.\"\n      )\n    )\n  )\n}\n\nfrom Expr exp, string msg\nwhere\n  findUseCharacterConversion(exp, msg) or\n  findUseMultibyteCharacter(exp, msg) or\n  findUseStringConversion(exp, msg, 1, 0, 2, [\"mbstowcs\", \"_mbstowcs_l\", \"mbsrtowcs\"]) or\n  findUseStringConversion(exp, msg, 2, 4, 5, [\"MultiByteToWideChar\", \"WideCharToMultiByte\"])\nselect exp, msg",
        "description": "Using convert function with an invalid length argument can result in an out-of-bounds access error or unexpected result.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-125/DangerousWorksWithMultibyteOrWideCharacters.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\nfrom StrlenCall fc, AssignExpr expr, ArrayExpr exprarr\nwhere\n  exprarr = expr.getLValue() and\n  expr.getRValue().getValue().toInt() = 0 and\n  globalValueNumber(exprarr.getArrayOffset()) = globalValueNumber(fc) and\n  not exists(Expr exptmp |\n    (\n      DataFlow::localExprFlow(fc, exptmp) or\n      exptmp.getAChild*() = fc.getArgument(0).(VariableAccess).getTarget().getAnAccess()\n    ) and\n    dominates(exptmp, expr) and\n    postDominates(exptmp, fc) and\n    not exptmp.getEnclosingStmt() = fc.getEnclosingStmt() and\n    not exptmp.getEnclosingStmt() = expr.getEnclosingStmt()\n  ) and\n  globalValueNumber(fc.getArgument(0)) = globalValueNumber(exprarr.getArrayBase())\nselect expr, \"Potential unsafe or redundant assignment.\"",
        "description": "The expression `buffer [strlen (buffer)] = 0` is potentially dangerous, if the variable `buffer` does not have a terminal zero, then access beyond the bounds of the allocated memory is possible, which will lead to undefined behavior. If terminal zero is present, then the specified expression is meaningless.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-788/AccessOfMemoryLocationAfterEndOfBufferUsingStrlen.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nint argumentPosition(FunctionCall fc, Expr exp, int n) {\n  n in [0 .. fc.getNumberOfArguments() - 1] and\n  fc.getArgument(n) = exp and\n  result = n\n}\n\npredicate conversionDoneLate(MulExpr mexp) {\n  exists(Expr e1, Expr e2 |\n    mexp.hasOperands(e1, e2) and\n    not e1.isConstant() and\n    not e1.hasConversion() and\n    not e1.hasConversion() and\n    (\n      e2.isConstant() or\n      not e2.hasConversion()\n    ) and\n    mexp.getConversion().hasExplicitConversion() and\n    mexp.getConversion() instanceof ParenthesisExpr and\n    mexp.getConversion().getConversion() instanceof CStyleCast and\n    mexp.getConversion().getConversion().getType().getSize() > mexp.getType().getSize() and\n    mexp.getConversion().getConversion().getType().getSize() > e2.getType().getSize() and\n    mexp.getConversion().getConversion().getType().getSize() > e1.getType().getSize() and\n    exists(Expr e0 |\n      e0.(AssignExpr).getRValue() = mexp.getParent*() and\n      e0.(AssignExpr).getLValue().getType().getSize() =\n        mexp.getConversion().getConversion().getType().getSize()\n      or\n      mexp.getEnclosingElement().(ComparisonOperation).hasOperands(mexp, e0) and\n      e0.getType().getSize() = mexp.getConversion().getConversion().getType().getSize()\n      or\n      e0.(FunctionCall).getTarget().getParameter(argumentPosition(e0, mexp, _)).getType().getSize() =\n        mexp.getConversion().getConversion().getType().getSize()\n    )\n  )\n}\n\npredicate signSmallerWithEqualSizes(MulExpr mexp) {\n  exists(Expr e1, Expr e2 |\n    mexp.hasOperands(e1, e2) and\n    not e1.isConstant() and\n    not e1.hasConversion() and\n    not e1.hasConversion() and\n    (\n      e2.isConstant() or\n      not e2.hasConversion()\n    ) and\n    mexp.getConversion+().getUnderlyingType().getSize() = e1.getUnderlyingType().getSize() and\n    (\n      e2.isConstant() or\n      mexp.getConversion+().getUnderlyingType().getSize() = e2.getUnderlyingType().getSize()\n    ) and\n    mexp.getConversion+().getUnderlyingType().getSize() = e1.getUnderlyingType().getSize() and\n    exists(AssignExpr ae |\n      ae.getRValue() = mexp.getParent*() and\n      ae.getRValue().getUnderlyingType().(IntegralType).isUnsigned() and\n      ae.getLValue().getUnderlyingType().(IntegralType).isSigned() and\n      (\n        not mexp.getParent*() instanceof DivExpr\n        or\n        exists(DivExpr de, Expr ec |\n          e2.isConstant() and\n          de.hasOperands(mexp.getParent*(), ec) and\n          ec.isConstant() and\n          e2.getValue().toInt() > ec.getValue().toInt()\n        )\n      ) and\n      exists(PointerAddExpr pa |\n        ae.getASuccessor+() = pa and\n        pa.getAnOperand().(VariableAccess).getTarget() = ae.getLValue().(VariableAccess).getTarget()\n      )\n    )\n  )\n}\n\nfrom MulExpr mexp, string msg\nwhere\n  conversionDoneLate(mexp) and\n  msg = \"This transformation is applied after multiplication.\"\n  or\n  signSmallerWithEqualSizes(mexp) and\n  msg = \"Possible signed overflow followed by offset of the pointer out of bounds.\"\nselect mexp, msg",
        "description": "By using the transformation after the operation, you are doing a pointless and dangerous action.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-190/DangerousUseOfTransformationAfterOperation.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.models.interfaces.Allocation\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport MultToAlloc::PathGraph\n\nmodule MultToAllocConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) {\n    // a multiplication of two non-constant expressions\n    exists(MulExpr me |\n      me = node.asExpr() and\n      forall(Expr e | e = me.getAnOperand() | not exists(e.getValue()))\n    )\n  }\n\n  predicate isSink(DataFlow::Node node) {\n    // something that affects an allocation size\n    node.asExpr() = any(HeuristicAllocationExpr ae).getSizeExpr().getAChild*()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule MultToAlloc = DataFlow::Global<MultToAllocConfig>;\n\nfrom MultToAlloc::PathNode source, MultToAlloc::PathNode sink\nwhere MultToAlloc::flowPath(source, sink)\nselect sink, source, sink,\n  \"Potentially overflowing value from $@ is used in the size of this allocation.\", source,\n  \"multiplication\"",
        "description": "Using a multiplication result that may overflow in the size of an allocation may lead to buffer overflows when the allocated memory is used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-190/AllocMultiplicationOverflow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.valuenumbering.HashCons\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport semmle.code.cpp.controlflow.Guards\n\nfrom\n  GuardCondition guard, Expr expr, ExprStmt exprstmt, BasicBlock block, AssignExpr assignexpr,\n  AddExpr addexpr, SubExpr subexpr\nwhere\n  (guard.ensuresLt(expr, addexpr, 0, block, _) or guard.ensuresLt(addexpr, expr, 0, block, _)) and\n  addexpr.getUnspecifiedType() instanceof IntegralType and\n  exprMightOverflowPositively(addexpr) and\n  block.getANode() = exprstmt and\n  exprstmt.getExpr() = assignexpr and\n  assignexpr.getRValue() = subexpr and\n  (\n    hashCons(addexpr.getLeftOperand()) = hashCons(assignexpr.getLValue()) and\n    globalValueNumber(addexpr.getRightOperand()) = globalValueNumber(subexpr.getRightOperand())\n    or\n    hashCons(addexpr.getRightOperand()) = hashCons(assignexpr.getLValue()) and\n    globalValueNumber(addexpr.getLeftOperand()) = globalValueNumber(subexpr.getRightOperand())\n  ) and\n  globalValueNumber(expr) = globalValueNumber(subexpr.getLeftOperand())\nselect guard,\n  \"\\\"if (a+b>c) a=c-b\\\" was detected where the $@ may potentially overflow/wraparound. The code can be rewritten as \\\"if (a>c-b) a=c-b\\\" which avoids the overflow.\",\n  addexpr, \"addition\"",
        "description": "Writing 'if (a+b>c) a=c-b' incorrectly implements 'a = min(a,c-b)' if 'a+b' overflows. This integer overflow is the root cause of the buffer overflow in the SHA-3 reference implementation (CVE-2022-37454).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-190/IfStatementAdditionOverflow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.controlflow.Guards\n\npredicate mayBeReturnValue(Function fn, float val) {\n  exists(Expr tmpExp, ReturnStmt rs |\n    tmpExp.getValue().toFloat() = val and\n    rs.getEnclosingFunction() = fn and\n    (\n      globalValueNumber(rs.getExpr()) = globalValueNumber(tmpExp)\n      or\n      exists(AssignExpr ae |\n        ae.getLValue().(VariableAccess).getTarget() =\n          globalValueNumber(rs.getExpr()).getAnExpr().(VariableAccess).getTarget() and\n        globalValueNumber(ae.getRValue()) = globalValueNumber(tmpExp)\n      )\n      or\n      exists(Initializer it |\n        globalValueNumber(it.getExpr()) = globalValueNumber(tmpExp) and\n        it.getDeclaration().(Variable).getAnAccess().getTarget() =\n          globalValueNumber(rs.getExpr()).getAnExpr().(VariableAccess).getTarget()\n      )\n    )\n  )\n}\n\npredicate mayBeReturnZero(Function fn) {\n  mayBeReturnValue(fn, 0)\n  or\n  fn.hasName([\n      \"iswalpha\", \"iswlower\", \"iswprint\", \"iswspace\", \"iswblank\", \"iswupper\", \"iswcntrl\",\n      \"iswctype\", \"iswalnum\", \"iswgraph\", \"iswxdigit\", \"iswdigit\", \"iswpunct\", \"isblank\", \"isupper\",\n      \"isgraph\", \"isalnum\", \"ispunct\", \"islower\", \"isspace\", \"isprint\", \"isxdigit\", \"iscntrl\",\n      \"isdigit\", \"isalpha\", \"timespec_get\", \"feof\", \"atomic_is_lock_free\",\n      \"atomic_compare_exchange\", \"thrd_equal\", \"isfinite\", \"islessequal\", \"isnan\", \"isgreater\",\n      \"signbit\", \"isinf\", \"islessgreater\", \"isnormal\", \"isless\", \"isgreaterequal\", \"isunordered\",\n      \"ferror\"\n    ])\n  or\n  fn.hasName([\n      \"thrd_sleep\", \"feenv\", \"feholdexcept\", \"feclearexcept\", \"feexceptflag\", \"feupdateenv\",\n      \"remove\", \"fflush\", \"setvbuf\", \"fgetpos\", \"fsetpos\", \"fclose\", \"rename\", \"fseek\", \"raise\"\n    ])\n  or\n  fn.hasName([\"tss_get\", \"gets\"])\n  or\n  fn.hasName([\"getc\", \"atoi\"])\n}\n\npragma[inline]\nGuardCondition checkByValue(Expr bound, Expr val) {\n  exists(GuardCondition gc |\n    (\n      gc.ensuresEq(bound, val, _, _, _) or\n      gc.ensuresEq(val, bound, _, _, _) or\n      gc.ensuresLt(bound, val, _, _, _) or\n      gc.ensuresLt(val, bound, _, _, _) or\n      gc = globalValueNumber(bound).getAnExpr()\n    ) and\n    result = gc\n  )\n}\n\npragma[inline]\npredicate compareFunctionWithValue(Expr guardExp, Function compArg, Expr valArg) {\n  not exists(Expr exp |\n    exp.getAChild*() = globalValueNumber(compArg.getACallToThisFunction()).getAnExpr() and\n    checkByValue(exp, valArg).controls(guardExp.getBasicBlock(), _)\n  )\n  or\n  exists(GuardCondition gc |\n    (\n      gc.ensuresEq(globalValueNumber(compArg.getACallToThisFunction()).getAnExpr(), valArg, 0,\n        guardExp.getBasicBlock(), true)\n      or\n      gc.ensuresEq(valArg, globalValueNumber(compArg.getACallToThisFunction()).getAnExpr(), 0,\n        guardExp.getBasicBlock(), true)\n      or\n      gc.ensuresLt(globalValueNumber(compArg.getACallToThisFunction()).getAnExpr(), valArg, 0,\n        guardExp.getBasicBlock(), false)\n      or\n      gc.ensuresLt(valArg, globalValueNumber(compArg.getACallToThisFunction()).getAnExpr(), 0,\n        guardExp.getBasicBlock(), false)\n    )\n    or\n    exists(Expr exp |\n      exp.getValue().toFloat() > valArg.getValue().toFloat() and\n      gc.ensuresLt(globalValueNumber(compArg.getACallToThisFunction()).getAnExpr(), exp, 0,\n        guardExp.getBasicBlock(), true)\n      or\n      exp.getValue().toFloat() < valArg.getValue().toFloat() and\n      gc.ensuresLt(exp, globalValueNumber(compArg.getACallToThisFunction()).getAnExpr(), 0,\n        guardExp.getBasicBlock(), true)\n    )\n  )\n  or\n  valArg.getValue().toFloat() = 0 and\n  exists(NotExpr ne, IfStmt ifne |\n    ne.getOperand() = globalValueNumber(compArg.getACallToThisFunction()).getAnExpr() and\n    ifne.getCondition() = ne and\n    ifne.getThen().getAChild*() = guardExp\n  )\n}\n\npragma[inline]\npredicate checkConditions1(Expr div, Function fn, float changeInt) {\n  exists(Expr val |\n    val.getEnclosingFunction() = fn and\n    val.getValue().toFloat() = changeInt and\n    compareFunctionWithValue(div, fn, val)\n  )\n}\n\npragma[inline]\npredicate compareExprWithValue(Expr guardExp, Expr compArg, Expr valArg) {\n  not exists(Expr exp |\n    exp.getAChild*() = globalValueNumber(compArg).getAnExpr() and\n    checkByValue(exp, valArg).controls(guardExp.getBasicBlock(), _)\n  )\n  or\n  exists(GuardCondition gc |\n    (\n      gc.ensuresEq(globalValueNumber(compArg).getAnExpr(), valArg, 0, guardExp.getBasicBlock(), true)\n      or\n      gc.ensuresEq(valArg, globalValueNumber(compArg).getAnExpr(), 0, guardExp.getBasicBlock(), true)\n      or\n      gc.ensuresLt(globalValueNumber(compArg).getAnExpr(), valArg, 0, guardExp.getBasicBlock(),\n        false)\n      or\n      gc.ensuresLt(valArg, globalValueNumber(compArg).getAnExpr(), 0, guardExp.getBasicBlock(),\n        false)\n    )\n    or\n    exists(Expr exp |\n      exp.getValue().toFloat() > valArg.getValue().toFloat() and\n      gc.ensuresLt(globalValueNumber(compArg).getAnExpr(), exp, 0, guardExp.getBasicBlock(), true)\n      or\n      exp.getValue().toFloat() < valArg.getValue().toFloat() and\n      gc.ensuresLt(exp, globalValueNumber(compArg).getAnExpr(), 0, guardExp.getBasicBlock(), true)\n    )\n  )\n  or\n  valArg.getValue().toFloat() = 0 and\n  exists(NotExpr ne, IfStmt ifne |\n    ne.getOperand() = globalValueNumber(compArg).getAnExpr() and\n    ifne.getCondition() = ne and\n    ifne.getThen().getAChild*() = guardExp\n  )\n}\n\npragma[inline]\npredicate checkConditions2(Expr div, Expr divVal, float changeInt2) {\n  exists(Expr val |\n    (\n      val.getEnclosingFunction() =\n        div.getEnclosingFunction().getACallToThisFunction().getEnclosingFunction() or\n      val.getEnclosingFunction() = div.getEnclosingFunction()\n    ) and\n    val.getValue().toFloat() = changeInt2 and\n    compareExprWithValue(div, divVal, val)\n  )\n}\n\nfloat getValueOperand(Expr src, Expr e1, Expr e2) {\n  src.(SubExpr).hasOperands(e1, e2) and\n  result = e2.getValue().toFloat()\n  or\n  src.(AddExpr).hasOperands(e1, e2) and\n  result = -e2.getValue().toFloat()\n}\n\nExpr getMulDivOperand(Expr e1) {\n  result = e1 or\n  result = e1.(MulExpr).getAnOperand() or\n  result = e1.(DivExpr).getLeftOperand()\n}\n\nclass MyDiv extends Expr {\n  MyDiv() {\n    this instanceof DivExpr or\n    this instanceof RemExpr or\n    this instanceof AssignDivExpr or\n    this instanceof AssignRemExpr\n  }\n\n  Expr getRV() {\n    result = this.(AssignArithmeticOperation).getRValue() or\n    result = this.(BinaryArithmeticOperation).getRightOperand()\n  }\n}\n\nfrom Expr exp, string msg, Function fn, GVN findVal, float changeInt, MyDiv div\nwhere\n  findVal = globalValueNumber(fn.getACallToThisFunction()) and\n  (\n    // Look for divide-by-zero operations possible due to the return value of the function `fn`.\n    checkConditions1(div, fn, changeInt) and\n    (\n      // Function return value can be zero.\n      mayBeReturnZero(fn) and\n      getMulDivOperand(globalValueNumber(div.getRV()).getAnExpr()) = findVal.getAnExpr() and\n      changeInt = 0\n      or\n      // Denominator can be sum or difference.\n      changeInt = getValueOperand(div.getRV(), findVal.getAnExpr(), _) and\n      mayBeReturnValue(fn, changeInt)\n    ) and\n    exp = div and\n    msg =\n      \"Can lead to division by 0, since the function \" + fn.getName() + \" can return a value \" +\n        changeInt.toString() + \".\"\n    or\n    // Search for situations where division by zero is possible inside the `divFn` function if the passed argument can be equal to a certain value.\n    exists(int posArg, Expr divVal, FunctionCall divFc, float changeInt2 |\n      // Division is associated with the function argument.\n      exists(Function divFn |\n        divFn.getParameter(posArg).getAnAccess() = divVal and\n        divVal.getEnclosingStmt() = div.getEnclosingStmt() and\n        divFc = divFn.getACallToThisFunction()\n      ) and\n      (\n        divVal = div.getRV() and\n        divFc.getArgument(posArg) != findVal.getAnExpr() and\n        (\n          // Function return value can be zero.\n          mayBeReturnZero(fn) and\n          getMulDivOperand(globalValueNumber(divFc.getArgument(posArg)).getAnExpr()) =\n            findVal.getAnExpr() and\n          changeInt = 0 and\n          changeInt2 = 0\n          or\n          // Denominator can be sum or difference.\n          changeInt = getValueOperand(divFc.getArgument(posArg), findVal.getAnExpr(), _) and\n          mayBeReturnValue(fn, changeInt) and\n          changeInt2 = 0\n        )\n        or\n        // Look for a situation where the difference or subtraction is considered as an argument, and it can be used in the same way.\n        changeInt = getValueOperand(div.getRV(), divVal, _) and\n        changeInt2 = changeInt and\n        mayBeReturnValue(fn, changeInt) and\n        divFc.getArgument(posArg) = findVal.getAnExpr()\n      ) and\n      checkConditions2(div, divVal, changeInt2) and\n      checkConditions1(divFc, fn, changeInt) and\n      exp = divFc and\n      msg =\n        \"Can lead to division by 0, since the function \" + fn.getName() + \" can return a value \" +\n          changeInt.toString() + \".\"\n    )\n  )\nselect exp, msg",
        "description": "Possible cases of division by zero when using the return value from functions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-369/DivideByZeroUsingReturnValue.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom FunctionCall fc, string msg\nwhere\n  exists(ThrowExpr texp |\n    texp.getEnclosingFunction() = fc.getTarget() and\n    (\n      fc.getTarget().hasGlobalOrStdName(\"DllMain\") and\n      not exists(TryStmt ts |\n        texp.getEnclosingStmt().getParentStmt*() = ts.getStmt() and\n        not ts.getACatchClause().isEmpty()\n      ) and\n      msg = \"DllMain contains an exception not wrapped in a try..catch block.\"\n      or\n      texp.getExpr().isParenthesised() and\n      texp.getExpr().(CommaExpr).getLeftOperand().isConstant() and\n      texp.getExpr().(CommaExpr).getRightOperand().isConstant() and\n      msg = \"There is an exception in the function that requires your attention.\"\n    )\n  )\n  or\n  fc.getTarget() instanceof Constructor and\n  (\n    fc.getTargetType().(Class).getABaseClass+().hasGlobalOrStdName(\"exception\") or\n    fc.getTargetType().(Class).getABaseClass+().hasGlobalOrStdName(\"CException\")\n  ) and\n  fc instanceof ExprInVoidContext and\n  not fc.isInMacroExpansion() and\n  msg = \"Object creation of exception type on stack. Did you forget the throw keyword?\"\nselect fc, msg",
        "description": "--Finding places for the dangerous use of exceptions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-703/FindIncorrectlyUsedExceptions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.semmle.code.cpp.security.PrivateCleartextWrite\nimport experimental.semmle.code.cpp.security.PrivateCleartextWrite::PrivateCleartextWrite\nimport WriteFlow::PathGraph\n\nfrom WriteFlow::PathNode source, WriteFlow::PathNode sink\nwhere WriteFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This write into the external location '\" + sink.getNode() +\n    \"' may contain unencrypted data from $@.\", source, \"this source of private data.\"",
        "description": "If private information is written to an external location, it may be accessible by unauthorized persons.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-359/PrivateCleartextWrite.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.HashCons\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nclass ExpressionsOfTheSameLevel extends Expr {\n  Expr exp2;\n\n  ExpressionsOfTheSameLevel() {\n    this != exp2 and\n    this.getParent() = exp2.getParent()\n  }\n\n  /** Holds if the underlying expression is a function call. */\n  predicate expressionCall() {\n    this instanceof FunctionCall and\n    exp2.getAChild*() instanceof FunctionCall and\n    not this.getParent() instanceof Operator and\n    not this.(FunctionCall).hasQualifier()\n  }\n\n  /** Holds if the underlying expression is a call to a function to free resources. */\n  predicate existsCloseOrFreeCall() {\n    (\n      globalValueNumber(this.(FunctionCall).getAnArgument()) =\n        globalValueNumber(exp2.getAChild*().(FunctionCall).getAnArgument()) or\n      hashCons(this.(FunctionCall).getAnArgument()) =\n        hashCons(exp2.getAChild*().(FunctionCall).getAnArgument())\n    ) and\n    (\n      this.(FunctionCall).getTarget().hasGlobalOrStdName(\"close\") or\n      this.(FunctionCall).getTarget().hasGlobalOrStdName(\"free\") or\n      this.(FunctionCall).getTarget().hasGlobalOrStdName(\"fclose\")\n    )\n  }\n\n  /** Holds if the arguments in the function can be changed. */\n  predicate generalArgumentDerivedType() {\n    exists(Parameter prt1, Parameter prt2, AssignExpr aet1, AssignExpr aet2, int i, int j |\n      not this.(FunctionCall).getArgument(i).isConstant() and\n      hashCons(this.(FunctionCall).getArgument(i)) =\n        hashCons(exp2.getAChild*().(FunctionCall).getArgument(j)) and\n      prt1 = this.(FunctionCall).getTarget().getParameter(i) and\n      prt2 = exp2.getAChild*().(FunctionCall).getTarget().getParameter(j) and\n      prt1.getType() instanceof DerivedType and\n      (\n        aet1 = this.(FunctionCall).getTarget().getEntryPoint().getASuccessor*() and\n        (\n          aet1.getLValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() =\n            prt1.getAnAccess().getTarget() or\n          aet1.getLValue().(VariableAccess).getTarget() = prt1.getAnAccess().getTarget()\n        )\n        or\n        exists(FunctionCall fc1 |\n          fc1.getTarget().hasGlobalName(\"memcpy\") and\n          fc1.getArgument(0).(VariableAccess).getTarget() = prt1.getAnAccess().getTarget() and\n          fc1 = this.(FunctionCall).getTarget().getEntryPoint().getASuccessor*()\n        )\n      ) and\n      (\n        aet2 = exp2.getAChild*().(FunctionCall).getTarget().getEntryPoint().getASuccessor*() and\n        (\n          aet2.getLValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() =\n            prt2.getAnAccess().getTarget() or\n          aet2.getLValue().(VariableAccess).getTarget() = prt2.getAnAccess().getTarget()\n        )\n        or\n        exists(FunctionCall fc1 |\n          fc1.getTarget().hasGlobalName(\"memcpy\") and\n          fc1.getArgument(0).(VariableAccess).getTarget() = prt2.getAnAccess().getTarget() and\n          fc1 = exp2.(FunctionCall).getTarget().getEntryPoint().getASuccessor*()\n        )\n      )\n    )\n  }\n\n  /** Holds if functions have a common global argument. */\n  predicate generalGlobalArgument() {\n    exists(Declaration dl, AssignExpr aet1, AssignExpr aet2 |\n      dl instanceof GlobalVariable and\n      (\n        (\n          aet1.getLValue().(Access).getTarget() = dl or\n          aet1.getLValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() = dl\n        ) and\n        aet1 = this.(FunctionCall).getTarget().getEntryPoint().getASuccessor*() and\n        not aet1.getRValue().isConstant()\n        or\n        exists(FunctionCall fc1 |\n          fc1.getTarget().hasGlobalName(\"memcpy\") and\n          fc1.getArgument(0).(VariableAccess).getTarget() = dl and\n          fc1 = this.(FunctionCall).getTarget().getEntryPoint().getASuccessor*()\n        )\n      ) and\n      (\n        (\n          aet2.getLValue().(Access).getTarget() = dl or\n          aet2.getLValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() = dl\n        ) and\n        aet2 = exp2.(FunctionCall).getTarget().getEntryPoint().getASuccessor*()\n        or\n        exists(FunctionCall fc1 |\n          fc1.getTarget().hasGlobalName(\"memcpy\") and\n          fc1.getArgument(0).(VariableAccess).getTarget() = dl and\n          fc1 = exp2.(FunctionCall).getTarget().getEntryPoint().getASuccessor*()\n        )\n      )\n    )\n  }\n\n  /** Holds if sequence point is not present in expression. */\n  predicate orderOfActionExpressions() {\n    not this.getParent() instanceof BinaryLogicalOperation and\n    not this.getParent() instanceof ConditionalExpr and\n    not this.getParent() instanceof Loop and\n    not this.getParent() instanceof CommaExpr\n  }\n\n  /** Holds if expression is crement. */\n  predicate dangerousCrementChanges() {\n    hashCons(this.(CrementOperation).getOperand()) = hashCons(exp2.(CrementOperation).getOperand())\n    or\n    hashCons(this.(CrementOperation).getOperand()) = hashCons(exp2)\n    or\n    hashCons(this.(CrementOperation).getOperand()) = hashCons(exp2.(ArrayExpr).getArrayOffset())\n    or\n    hashCons(this.(Assignment).getLValue()) = hashCons(exp2.(Assignment).getLValue())\n    or\n    not this.getAChild*() instanceof Call and\n    (\n      hashCons(this.getAChild*().(CrementOperation).getOperand()) = hashCons(exp2) or\n      hashCons(this.getAChild*().(CrementOperation).getOperand()) =\n        hashCons(exp2.(Assignment).getLValue())\n    )\n  }\n}\n\nfrom ExpressionsOfTheSameLevel eots\nwhere\n  eots.orderOfActionExpressions() and\n  (\n    eots.expressionCall() and\n    (\n      eots.generalArgumentDerivedType() or\n      eots.generalGlobalArgument() or\n      eots.existsCloseOrFreeCall()\n    )\n    or\n    eots.dangerousCrementChanges()\n  )\nselect eots,\n  \"This expression may have undefined behavior, because the order of evaluation is not specified.\"",
        "description": "--In some situations, the code constructs used may be executed in the wrong order in which the developer designed them. --For example, if you call multiple functions as part of a single expression, and the functions have the ability to modify a shared resource, then the sequence in which the resource is changed can be unpredictable. --These code snippets look suspicious and require the developer's attention.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-758/UndefinedOrImplementationDefinedBehavior.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass DangerousWhileLoop extends WhileStmt {\n  Declaration dl;\n\n  DangerousWhileLoop() {\n    this = dl.getParentScope().(BlockStmt).getParent*() and\n    exists(Expr exp |\n      exp = this.getCondition().getAChild*() and\n      not exp instanceof PointerFieldAccess and\n      not exp instanceof ValueFieldAccess and\n      exp.(VariableAccess).getTarget().getName() = dl.getName() and\n      not exp.getParent*() instanceof FunctionCall\n    )\n  }\n\n  Declaration getDeclaration() { result = dl }\n\n  /** Holds when there are changes to the variables involved in the condition. */\n  predicate isUseThisVariable() {\n    exists(Variable v |\n      this.getCondition().getAChild*().(VariableAccess).getTarget() = v and\n      (\n        exists(Assignment aexp |\n          this = aexp.getEnclosingStmt().getParentStmt*() and\n          (\n            aexp.getLValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() = v\n            or\n            aexp.getLValue().(VariableAccess).getTarget() = v\n          )\n        )\n        or\n        exists(CrementOperation crm |\n          this = crm.getEnclosingStmt().getParentStmt*() and\n          crm.getOperand().(VariableAccess).getTarget() = v\n        )\n      )\n    )\n  }\n}\n\nfrom DangerousWhileLoop lp\nwhere not lp.isUseThisVariable()\nselect lp.getDeclaration(), \"A variable with this name is used in the $@ condition.\", lp, \"loop\"",
        "description": "Using variables with the same name is dangerous. However, such a situation inside the while loop can create an infinite loop exhausting resources. Requires the attention of developers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-1126/DeclarationOfVariableWithUnnecessarilyWideScope.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.Nullness\n\nclass StarOperator extends Operator {\n  StarOperator() {\n    this.hasName(\"operator*\") and\n    this.getNumberOfParameters() = 0\n  }\n}\n\nclass IncrementOperator extends Operator {\n  IncrementOperator() {\n    this.hasName(\"operator++\") and\n    this.getNumberOfParameters() = 0\n  }\n}\n\nclass StructureDerefOperator extends Operator {\n  StructureDerefOperator() {\n    this.hasName(\"operator->\") and\n    this.getNumberOfParameters() = 0\n  }\n}\n\nclass SubscriptOperator extends Operator {\n  SubscriptOperator() {\n    this.hasName(\"operator[]\") and\n    this.getNumberOfParameters() = 1\n  }\n}\n\nabstract class LifetimeIndirectionType extends Type {\n  /**\n   * Gets the `DerefType` of this indirection type.\n   *\n   * This corresponds to the owned or pointed to type.\n   */\n  Type getDerefType() {\n    result = this.(PointerType).getBaseType()\n    or\n    result = this.(ReferenceType).getBaseType()\n    or\n    exists(MemberFunction mf | mf.getDeclaringType() = this |\n      result = mf.(StarOperator).getType().getUnspecifiedType().(ReferenceType).getBaseType()\n      or\n      result = mf.(SubscriptOperator).getType().getUnspecifiedType().(ReferenceType).getBaseType()\n      or\n      result =\n        mf.(StructureDerefOperator).getType().getUnspecifiedType().(PointerType).getBaseType()\n      or\n      mf.getName() = \"begin\" and\n      result = mf.getType().(LifetimePointerType).getDerefType()\n    )\n  }\n}\n\nclass LifetimeOwnerType extends LifetimeIndirectionType {\n  LifetimeOwnerType() {\n    // Any shared owner types are also owner types\n    this instanceof LifetimeSharedOwnerType\n    or\n    // This is a container type, or a type with a star operator and..\n    (\n      this instanceof ContainerType\n      or\n      exists(StarOperator mf | mf.getDeclaringType() = this)\n    ) and\n    // .. has a \"user\" provided destructor\n    exists(Destructor d |\n      d.getDeclaringType() = this and\n      not d.isCompilerGenerated()\n    )\n    or\n    // Any specified version of an owner type is also an owner type\n    this.getUnspecifiedType() instanceof LifetimeOwnerType\n    or\n    // Has a field which is a lifetime owner type\n    this.(Class).getAField().getType() instanceof LifetimeOwnerType\n    or\n    // Derived from a public base class which is a owner type\n    exists(ClassDerivation cd |\n      cd = this.(Class).getADerivation() and\n      cd.getBaseClass() instanceof LifetimeOwnerType and\n      cd.getASpecifier().hasName(\"public\")\n    )\n    or\n    // Lifetime profile treats the following types as owner types, even though they don't fully\n    // adhere to the requirements above\n    this.(Class)\n        .hasQualifiedName(\"std\",\n          [\"stack\", \"queue\", \"priority_queue\", \"optional\", \"variant\", \"any\", \"regex\"])\n    or\n    // Explicit annotation on the type\n    this.getAnAttribute().getName().matches(\"gsl::Owner%\")\n  }\n}\n\nclass ContainerType extends Class {\n  ContainerType() {\n    // We use a simpler set of heuristics than the `[container.requirements]`, requiring only\n    // `begin()`/`end()`/`size()` as the minimum API for something to be considered a \"container\"\n    // type\n    this.getAMemberFunction().getName() = \"begin\" and\n    this.getAMemberFunction().getName() = \"end\" and\n    this.getAMemberFunction().getName() = \"size\"\n    or\n    // This class is a `ContainerType` if it is constructed from a `ContainerType`. This is\n    // important, because templates may not have instantiated all the required member functions\n    exists(TemplateClass tc |\n      this.isConstructedFrom(tc) and\n      tc instanceof ContainerType\n    )\n  }\n}\n\nclass LifetimeSharedOwnerType extends Type {\n  LifetimeSharedOwnerType() {\n    /*\n     * Find all types which can be dereferenced (i.e. have unary * operator), and are therefore\n     * likely to be \"owner\"s or \"pointer\"s to other objects. We then consider these classes to be\n     * shared owners if:\n     *  - They can be copied (a unique \"owner\" type would not be copyable)\n     *  - They can destroyed\n     */\n\n    // unary * (i.e. can be dereferenced)\n    exists(StarOperator mf | mf.getDeclaringType() = this) and\n    // \"User\" provided destructor\n    exists(Destructor d |\n      d.getDeclaringType() = this and\n      not d.isCompilerGenerated()\n    ) and\n    // A copy constructor and copy assignment operator\n    exists(CopyConstructor cc | cc.getDeclaringType() = this and not cc.isDeleted()) and\n    exists(CopyAssignmentOperator cc | cc.getDeclaringType() = this and not cc.isDeleted())\n    or\n    // This class is a `SharedOwnerType` if it is constructed from a `SharedOwnerType`. This is\n    // important, because templates may not have instantiated all the required member functions\n    exists(TemplateClass tc |\n      this.(Class).isConstructedFrom(tc) and\n      tc instanceof LifetimeSharedOwnerType\n    )\n    or\n    // Any specified version of a shared owner type is also a shared owner type\n    this.getUnspecifiedType() instanceof LifetimeSharedOwnerType\n    or\n    // Has a field which is a lifetime shared owner type\n    this.(Class).getAField().getType() instanceof LifetimeSharedOwnerType\n    or\n    // Derived from a public base class which is a shared owner type\n    exists(ClassDerivation cd |\n      cd = this.(Class).getADerivation() and\n      cd.getBaseClass() instanceof LifetimeSharedOwnerType and\n      cd.getASpecifier().hasName(\"public\")\n    )\n    or\n    // Lifetime profile treats the following types as shared owner types, even though they don't\n    // fully adhere to the requirements above\n    this.(Class).hasQualifiedName(\"std\", \"shared_future\")\n    or\n    // Explicit annotation on the type\n    this.getAnAttribute().getName().matches(\"gsl::SharedOwner%\")\n  }\n}\n\nclass IteratorType extends Type {\n  IteratorType() {\n    // We consider anything with an increment and * operator to be sufficient to be an iterator type\n    exists(StarOperator mf |\n      mf.getDeclaringType() = this and mf.getType().getUnspecifiedType() instanceof ReferenceType\n    ) and\n    exists(IncrementOperator op |\n      op.getDeclaringType() = this and op.getType().(ReferenceType).getBaseType() = this\n    )\n    or\n    // Along with unspecified versions of the types above\n    this.getUnspecifiedType() instanceof IteratorType\n  }\n}\n\nclass LifetimePointerType extends LifetimeIndirectionType {\n  LifetimePointerType() {\n    this instanceof IteratorType\n    or\n    this instanceof PointerType\n    or\n    this instanceof ReferenceType\n    or\n    // A shared owner type is a pointer type, but an owner type is not.\n    this instanceof LifetimeSharedOwnerType and\n    not this instanceof LifetimeOwnerType\n    or\n    this.(Class).hasQualifiedName(\"std\", \"reference_wrapper\")\n    or\n    exists(Class vectorBool, UserType reference |\n      vectorBool.hasQualifiedName(\"std\", \"vector\") and\n      vectorBool.getATemplateArgument() instanceof BoolType and\n      reference.hasName(\"reference\") and\n      reference.getDeclaringType() = vectorBool and\n      this = reference.getUnderlyingType()\n    )\n    or\n    // Any specified version of a pointer type is also an owner type\n    this.getUnspecifiedType() instanceof LifetimePointerType\n    or\n    // Has a field which is a lifetime pointer type\n    this.(Class).getAField().getType() instanceof LifetimePointerType\n    or\n    // Derived from a public base class which is a pointer type\n    exists(ClassDerivation cd |\n      cd = this.(Class).getADerivation() and\n      cd.getBaseClass() instanceof LifetimePointerType and\n      cd.getASpecifier().hasName(\"public\")\n    )\n    or\n    // Explicit annotation on the type\n    this.getAnAttribute().getName().matches(\"gsl::Pointer%\")\n  }\n}\n\nclass FullExpr extends Expr {\n  FullExpr() {\n    // A full-expression is not a subexpression\n    not this.getParent() instanceof Expr\n    or\n    // A sub-expression that is an unevaluated operand\n    this.isUnevaluated()\n  }\n}\n\nFullExpr getTemporaryObjectExprScope(TemporaryObjectExpr toe) {\n  result = toe.getUnconverted().getParent*()\n}\n\nprivate newtype TLifetimeLocalVariable =\n  TLocalScopeVariable(LocalScopeVariable lsv) { not lsv.isStatic() } or\n  TTemporaryObject(TemporaryObjectExpr toe)\n\n\nclass LifetimeLocalVariable extends TLifetimeLocalVariable {\n  string toString() { none() } // specified in sub-classes\n\n  Type getType() { none() }\n}\n\nclass LifetimeLocalScopeVariable extends TLocalScopeVariable, LifetimeLocalVariable {\n  LocalScopeVariable getVariable() { this = TLocalScopeVariable(result) }\n\n  override Type getType() { result = this.getVariable().getType() }\n\n  override string toString() { result = this.getVariable().toString() }\n}\n\nclass LifetimeTemporaryObject extends TTemporaryObject, LifetimeLocalVariable {\n  TemporaryObjectExpr getTemporaryObjectExpr() { this = TTemporaryObject(result) }\n\n  override Type getType() { result = this.getTemporaryObjectExpr().getType() }\n\n  override string toString() { result = this.getTemporaryObjectExpr().toString() }\n}\n\nnewtype TInvalidReason =\n  /** LifetimeLocalVariable is invalid because it hasn't been initialized. */\n  TUninitialized(DeclStmt ds, Variable v) { ds.getADeclaration() = v } or\n  /** LifetimeLocalVariable is invalid because it points to a variable which has gone out of scope. */\n  TVariableOutOfScope(LocalScopeVariable v, ControlFlowNode cfn) { goesOutOfScopeAt(v, cfn) } or\n  /** LifetimeLocalVariable is invalid because it points to a temporary object expression which has gone out of scope. */\n  TTemporaryOutOfScope(TemporaryObjectExpr toe) or\n  /** LifetimeLocalVariable is invalid because it points to data held by an owner which has since been invalidated. */\n  TOwnerModified(FunctionCall fc)\n\nclass InvalidReason extends TInvalidReason {\n  /** Holds if this reason indicates the pointer is accessed before the lifetime of an object began. */\n  predicate isBeforeLifetime() { this instanceof TUninitialized }\n\n  /** Holds if this reason indicates the pointer is accessed after the lifetime of an object has finished. */\n  predicate isAfterLifetime() { not this.isBeforeLifetime() }\n\n  /** Gets a description of the reason why this pointer may be invalid. */\n  string getDescription() {\n    exists(DeclStmt ds, Variable v |\n      this = TUninitialized(ds, v) and\n      result = \"variable \" + v.getName() + \" was never initialized\"\n    )\n    or\n    exists(LocalScopeVariable v, ControlFlowNode cfn |\n      this = TVariableOutOfScope(v, cfn) and\n      result = \"variable \" + v.getName() + \" went out of scope\"\n    )\n    or\n    exists(TemporaryObjectExpr toe |\n      this = TTemporaryOutOfScope(toe) and\n      result = \"temporary object went out of scope\"\n    )\n    or\n    exists(FunctionCall fc |\n      this = TOwnerModified(fc) and\n      result = \"owner type was modified\"\n    )\n  }\n\n  string toString() { result = this.getDescription() }\n\n  /** Get an element that explains the reason for the invalid determination. */\n  private Element getExplanatoryElement() {\n    exists(DeclStmt ds |\n      this = TUninitialized(ds, _) and\n      result = ds\n    )\n    or\n    exists(ControlFlowNode cfn |\n      this = TVariableOutOfScope(_, cfn) and\n      result = cfn\n    )\n    or\n    exists(TemporaryObjectExpr toe |\n      this = TTemporaryOutOfScope(toe) and\n      result = getTemporaryObjectExprScope(toe)\n    )\n    or\n    exists(FunctionCall fc |\n      this = TOwnerModified(fc) and\n      result = fc\n    )\n  }\n\n  /**\n   * Provides a `message` for use in alert messages.\n   *\n   * The message will contain a `$@` placeholder, for which `explanation` and `explanationDesc` are\n   * the placeholder components which should be added as extra columns.\n   */\n  predicate hasMessage(string message, Element explanation, string explanationDesc) {\n    message = \"because the \" + this.getDescription() + \" $@.\" and\n    explanation = this.getExplanatoryElement() and\n    explanationDesc = \"here\"\n  }\n}\n\nnewtype TNullReason =\n  // Null because the `NullValue` was assigned\n  TNullAssignment(NullValue e)\n\nclass NullReason extends TNullReason {\n  /** Gets a description of the reason why this pointer may be null. */\n  string getDescription() {\n    exists(NullValue nv |\n      this = TNullAssignment(nv) and\n      result = \"null value was assigned\"\n    )\n  }\n\n  string toString() { result = this.getDescription() }\n}\n\nnewtype TPSetEntry =\n  /** Points to a lifetime local variable. */\n  PSetVar(LifetimeLocalVariable lv) or\n  /** Points to a lifetime local variable that represents an owner type. */\n  PSetOwner(LifetimeLocalVariable lv, int level) {\n    level = [0 .. 2] and lv.getType() instanceof LifetimeOwnerType\n  } or\n  /** Points to a global variable. */\n  PSetGlobal() or\n  /** A null pointer. */\n  PSetNull(NullReason nr) or\n  /** An invalid pointer, for the given reason. */\n  PSetInvalid(InvalidReason ir) or\n  /** An unknown pointer. */\n  PSetUnknown()\n\nclass PSetEntry extends TPSetEntry {\n  string toString() {\n    exists(LifetimeLocalVariable lv |\n      this = PSetVar(lv) and\n      result = \"Var(\" + lv.toString() + \")\"\n    )\n    or\n    this = PSetGlobal() and result = \"global\"\n    or\n    exists(LifetimeLocalVariable lv, int level |\n      this = PSetOwner(lv, level) and\n      result = \"Owner(\" + lv.toString() + \",\" + level + \")\"\n    )\n    or\n    exists(NullReason nr | this = PSetNull(nr) and result = \"null because\" + nr)\n    or\n    exists(InvalidReason ir | this = PSetInvalid(ir) and result = \"invalid because \" + ir)\n    or\n    this = PSetUnknown() and result = \"unknown\"\n  }\n}\n\npredicate pointsToMap(ControlFlowNode cfn, LifetimeLocalVariable lv, PSetEntry ps) {\n  if isPSetReassigned(cfn, lv)\n  then ps = getAnAssignedPSetEntry(cfn, lv)\n  else\n    // Exclude unknown for now\n    exists(ControlFlowNode pred, PSetEntry prevPSet |\n      pred = cfn.getAPredecessor() and\n      pointsToMap(pred, lv, prevPSet) and\n      // Not PSetNull() and a non-null successor of a null check\n      not exists(AnalysedExpr ae |\n        ps = PSetNull(_) and\n        cfn = ae.getNonNullSuccessor(lv.(LifetimeLocalScopeVariable).getVariable())\n      ) and\n      // lv is not out of scope at this node\n      not goesOutOfScopeAt(lv.(LifetimeLocalScopeVariable).getVariable(), cfn)\n    |\n      // Propagate a PSetEntry from the predecessor node, so long as the\n      // PSetEntry is not invalidated at this node\n      ps = prevPSet and\n      not exists(getAnInvalidation(prevPSet, cfn))\n      or\n      // Replace prevPSet with an invalidation reason at this node\n      ps = getAnInvalidation(prevPSet, cfn)\n    )\n}\n\nprivate predicate isPSetReassigned(ControlFlowNode cfn, LifetimeLocalVariable lv) {\n  exists(DeclStmt ds |\n    cfn = ds and\n    ds.getADeclaration() = lv.(LifetimeLocalScopeVariable).getVariable() and\n    lv.getType() instanceof PointerType\n  )\n  or\n  exists(TemporaryObjectExpr toe |\n    toe = lv.(LifetimeTemporaryObject).getTemporaryObjectExpr() and\n    cfn = toe\n  )\n  or\n  // Assigned a value\n  cfn = lv.(LifetimeLocalScopeVariable).getVariable().getAnAssignedValue()\n  or\n  // If the address of a local var is passed to a function, then assume it initializes it\n  exists(Call fc, AddressOfExpr aoe |\n    cfn = aoe and\n    fc.getAnArgument() = aoe and\n    lv.(LifetimeLocalScopeVariable).getVariable() = aoe.getOperand().(VariableAccess).getTarget()\n  )\n}\n\nprivate PSetEntry getAnAssignedPSetEntry(ControlFlowNode cfn, LifetimeLocalVariable lv) {\n  exists(DeclStmt ds |\n    cfn = ds and\n    ds.getADeclaration() = lv.(LifetimeLocalScopeVariable).getVariable()\n  |\n    lv.getType() instanceof PointerType and\n    result = PSetInvalid(TUninitialized(ds, lv.(LifetimeLocalScopeVariable).getVariable()))\n  )\n  or\n  exists(TemporaryObjectExpr toe |\n    toe = lv.(LifetimeTemporaryObject).getTemporaryObjectExpr() and\n    cfn = toe and\n    result = PSetVar(lv)\n  )\n  or\n  // Assigned a value\n  exists(Expr assign |\n    assign = lv.(LifetimeLocalScopeVariable).getVariable().getAnAssignedValue() and\n    cfn = assign\n  |\n    if isKnownAssignmentType(assign)\n    then knownAssignmentType(assign, result)\n    else result = PSetUnknown()\n  )\n  or\n  // If the address of a local var is passed to a function, then assume it initializes it\n  exists(Call fc, AddressOfExpr aoe |\n    cfn = aoe and\n    fc.getAnArgument() = aoe and\n    lv.(LifetimeLocalScopeVariable).getVariable() = aoe.getOperand().(VariableAccess).getTarget() and\n    result = PSetUnknown()\n  )\n}\n\npredicate isKnownAssignmentType(Expr assign) {\n  assign = any(LocalScopeVariable lv).getAnAssignedValue() and\n  (\n    exists(Variable v | v = assign.(AddressOfExpr).getOperand().(VariableAccess).getTarget() |\n      v instanceof LocalScopeVariable\n      or\n      v instanceof GlobalVariable\n    )\n    or\n    // Assignment of a previous variable\n    exists(VariableAccess va |\n      va = assign and\n      va.getTarget().(LocalScopeVariable).getType() instanceof LifetimePointerType\n    )\n    or\n    assign instanceof NullValue\n    or\n    exists(FunctionCall fc |\n      assign = fc and\n      fc.getNumberOfArguments() = 0 and\n      fc.getType() instanceof LifetimePointerType\n    |\n      // A function call is a product of its inputs (just handle qualifiers at the moment)\n      exists(LifetimeLocalVariable lv |\n        lv = TTemporaryObject(fc.getQualifier().getConversion())\n        or\n        lv = TLocalScopeVariable(fc.getQualifier().(VariableAccess).getTarget())\n      |\n        lv.getType() instanceof LifetimePointerType\n        or\n        lv.getType() instanceof LifetimeOwnerType\n      )\n    )\n  )\n}\n\npredicate knownAssignmentType(Expr assign, PSetEntry ps) {\n  assign = any(LocalScopeVariable lv).getAnAssignedValue() and\n  (\n    // The assigned value is `&v`\n    exists(Variable v | v = assign.(AddressOfExpr).getOperand().(VariableAccess).getTarget() |\n      v instanceof LocalScopeVariable and\n      (\n        // If the variable we are taking the address of is a reference type, then we are really\n        // taking the address of whatever the reference type \"points-to\". Use the `pointsToMap`\n        // to determine viable `LifetimeLocalScopeVariable`s this could point to.\n        if v.getType() instanceof ReferenceType\n        then\n          pointsToMap(assign.getAPredecessor(),\n            any(LifetimeLocalScopeVariable lv | lv.getVariable() = v), ps)\n        else\n          // This assignment points-to `v` itself.\n          ps = PSetVar(TLocalScopeVariable(v))\n      )\n      or\n      // If the variable we are taking the address of is a reference variable, then this points-to\n      // a global. If the variable we taking the address of is a reference type, we need to consider\n      // that it might point-to a global, even if it is a LocalScopeVariable (this case is required\n      // so that we still produce a result even if the pointsToMap is empty for `lv`).\n      (v instanceof GlobalVariable or v.getType() instanceof ReferenceType) and\n      ps = PSetGlobal()\n    )\n    or\n    // Assignment of a previous variable\n    exists(VariableAccess va |\n      va = assign and\n      va.getTarget().(LocalScopeVariable).getType() instanceof LifetimePointerType and\n      // PSet of that become PSet of this\n      pointsToMap(assign.getAPredecessor(),\n        any(LifetimeLocalScopeVariable lv | lv.getVariable() = va.getTarget()), ps)\n    )\n    or\n    // The `NullValue` class covers all types of null equivalent expressions. This case also handles\n    // default and value initialization, where an \"implicit\" null value expression is added by the\n    // extractor\n    assign instanceof NullValue and ps = PSetNull(TNullAssignment(assign))\n    or\n    exists(FunctionCall fc |\n      assign = fc and\n      // If the assignment is being converted via a ReferenceDereferenceExpr, then\n      // we are essentially copying the original object\n      not assign.getFullyConverted() instanceof ReferenceDereferenceExpr and\n      fc.getNumberOfArguments() = 0 and\n      fc.getType() instanceof LifetimePointerType\n    |\n      // A function call is a product of its inputs (just handle qualifiers at the moment)\n      exists(LifetimeLocalVariable lv |\n        lv = TTemporaryObject(fc.getQualifier().getConversion())\n        or\n        lv = TLocalScopeVariable(fc.getQualifier().(VariableAccess).getTarget())\n      |\n        ps = PSetVar(lv) and lv.getType() instanceof LifetimePointerType\n        or\n        ps = PSetOwner(lv, 0) and lv.getType() instanceof LifetimeOwnerType\n      )\n    )\n  )\n}\n\npredicate goesOutOfScopeAt(LocalScopeVariable lv, ControlFlowNode cfn) {\n  exists(BlockStmt scope |\n    scope = lv.getParentScope() and\n    scope.getAChild+() = cfn.getAPredecessor().getEnclosingStmt() and\n    not scope.getAChild+() = cfn.getEnclosingStmt()\n  )\n}\n\nPSetInvalid getAnInvalidation(PSetEntry ps, ControlFlowNode cfn) {\n  exists(LifetimeLocalScopeVariable lv | ps = PSetVar(lv) |\n    result = PSetInvalid(TVariableOutOfScope(lv.getVariable(), cfn))\n  )\n  or\n  exists(LifetimeLocalScopeVariable lv | ps = PSetOwner(lv, _) |\n    result = PSetInvalid(TVariableOutOfScope(lv.getVariable(), cfn))\n    or\n    exists(FunctionCall fc |\n      fc = cfn and\n      fc.getQualifier() = lv.getVariable().getAnAccess() and\n      not fc.getTarget() instanceof ConstMemberFunction and\n      // non-const versions of begin and end should nevertheless be considered const\n      not fc.getTarget().hasName([\"begin\", \"end\"]) and\n      result = PSetInvalid(TOwnerModified(fc))\n    )\n  )\n  or\n  // temporary objects end after the full expression\n  exists(LifetimeTemporaryObject lto |\n    ps = PSetVar(lto)\n    or\n    ps = PSetOwner(lto, _)\n  |\n    cfn = lto.getTemporaryObjectExpr().getUnconverted().getParent*().(FullExpr).getASuccessor() and\n    result = PSetInvalid(TTemporaryOutOfScope(lto.getTemporaryObjectExpr()))\n  )\n}\n\nclass InvalidDereference extends VariableAccess {\n  InvalidReason ir;\n\n  InvalidDereference() {\n    // The local points to map suggests this points to an invalid set\n    exists(LocalScopeVariable lv |\n      lv = this.getTarget() and\n      pointsToMap(this, TLocalScopeVariable(lv), PSetInvalid(ir))\n    )\n  }\n\n  /** Gets a reason why this dereference could point to an invalid value. */\n  InvalidReason getAnInvalidReason() { result = ir }\n}\n\nfrom\n  InvalidDereference e, Element explanation, string explanationDesc, InvalidReason ir,\n  string invalidMessage\nwhere\n  ir = e.getAnInvalidReason() and\n  ir.isAfterLifetime() and\n  ir.hasMessage(invalidMessage, explanation, explanationDesc)\nselect e,\n  e.(VariableAccess).getTarget().getName() + \" is dereferenced here but accesses invalid memory \" +\n    invalidMessage, explanation, explanationDesc",
        "description": "Accessing an object after its lifetime has ended can result in security vulnerabilities and undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-416/UseAfterExpiredLifetime.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nprivate class PamAuthCall extends FunctionCall {\n  PamAuthCall() {\n    exists(Function f | f.hasName(\"pam_authenticate\") | f.getACallToThisFunction() = this)\n  }\n}\n\nprivate class PamActMgmtCall extends FunctionCall {\n  PamActMgmtCall() {\n    exists(Function f | f.hasName(\"pam_acct_mgmt\") | f.getACallToThisFunction() = this)\n  }\n}\n\nfrom PamAuthCall pa, Expr handle\nwhere\n  pa.getArgument(0) = handle and\n  not exists(PamActMgmtCall pac |\n    globalValueNumber(handle) = globalValueNumber(pac.getArgument(0)) or\n    DataFlow::localExprFlow(handle, pac.getArgument(0))\n  )\nselect pa, \"This PAM authentication call may be lead to an authorization bypass.\"",
        "description": "Only using `pam_authenticate` call to authenticate users can lead to authorization vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-285/PamAuthorization.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Exclusions\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nfrom FunctionCall fc, FunctionCall fc1\nwhere\n  fc != fc1 and\n  fc.getASuccessor+() = fc1 and\n  fc.getTarget().hasName(\"SSL_shutdown\") and\n  fc1.getTarget().hasName(\"SSL_shutdown\") and\n  fc1 instanceof ExprInVoidContext and\n  (\n    globalValueNumber(fc.getArgument(0)) = globalValueNumber(fc1.getArgument(0)) or\n    fc.getArgument(0).(VariableAccess).getTarget() = fc1.getArgument(0).(VariableAccess).getTarget()\n  ) and\n  not exists(FunctionCall fctmp |\n    fctmp.getTarget().hasName(\"SSL_free\") and\n    fc.getASuccessor+() = fctmp and\n    fctmp.getASuccessor+() = fc1\n  )\nselect fc, \"You need to handle the return value 'SSL_shutdown'.\"",
        "description": "Incorrect closing of the connection leads to the creation of different states for the server and client, which can be exploited by an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-670/DangerousUseSSL_shutdown.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\nclass SystemCallFunction extends Function {\n  SystemCallFunction() {\n    exists(MacroInvocation m |\n      m.getMacro().getName().matches(\"SYSCALL\\\\_DEFINE%\") and\n      this = m.getEnclosingFunction()\n    )\n  }\n}\n\nclass SystemCallSource extends DataFlow::Node {\n  SystemCallSource() {\n    exists(FunctionCall fc |\n      fc.getTarget() instanceof SystemCallFunction and\n      (\n        this.asDefiningArgument() = fc.getAnArgument().getAChild*() or\n        this.asExpr() = fc\n      )\n    )\n  }\n}\n\nclass WriteAccessCheckMacro extends Macro {\n  VariableAccess va;\n\n  WriteAccessCheckMacro() {\n    this.getName() = [\"user_write_access_begin\", \"user_access_begin\", \"access_ok\"] and\n    va.getEnclosingElement() = this.getAnInvocation().getAnExpandedElement()\n  }\n\n  VariableAccess getArgument() { result = va }\n}\n\nclass UnSafePutUserMacro extends Macro {\n  PointerDereferenceExpr writeUserPtr;\n\n  UnSafePutUserMacro() {\n    this.getName() = \"unsafe_put_user\" and\n    writeUserPtr.getEnclosingElement() = this.getAnInvocation().getAnExpandedElement()\n  }\n\n  Expr getUserModePtr() {\n    result = writeUserPtr.getOperand().(AddressOfExpr).getOperand().(FieldAccess).getQualifier() or\n    result = writeUserPtr.getOperand()\n  }\n}\n\nclass ExploitableUserModePtrParam extends SystemCallSource {\n  ExploitableUserModePtrParam() {\n    exists(UnSafePutUserMacro unsafePutUser |\n      DataFlow::localFlow(this, DataFlow::exprNode(unsafePutUser.getUserModePtr()))\n    ) and\n    not exists(WriteAccessCheckMacro writeAccessCheck |\n      DataFlow::localFlow(this, DataFlow::exprNode(writeAccessCheck.getArgument()))\n    )\n  }\n}\n\nfrom ExploitableUserModePtrParam p\nselect p, \"This 'unsafe_put_user' writes a user-mode pointer without a security check.\"",
        "description": "unsafe_put_user which is used to write data to user-mode memory is widely used in Linux kernel codebase,  but if there is no security check for user-mode pointer used as parameter of unsafe_put_user, attacker can exploit the issue to obtain root privilege. CVE-2017-5123 is quite a good example for your information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-020/NoCheckBeforeUnsafePutUser.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\npredicate numberArgument(Function f, int apos) {\n  f.hasGlobalOrStdName(\"write\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"read\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"lseek\") and apos = 1\n  or\n  f.hasGlobalOrStdName(\"memmove\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"memset\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"memcpy\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"memcmp\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"strncat\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"strncpy\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"strncmp\") and apos = 2\n  or\n  f.hasGlobalOrStdName(\"snprintf\") and apos = 1\n  or\n  f.hasGlobalOrStdName(\"strndup\") and apos = 2\n}\n\nclass IfCompareWithZero extends IfStmt {\n  IfCompareWithZero() { this.getCondition().(RelationalOperation).getAChild().getValue() = \"0\" }\n\n  Expr noZerroOperand() {\n    if this.getCondition().(RelationalOperation).getGreaterOperand().getValue() = \"0\"\n    then result = this.getCondition().(RelationalOperation).getLesserOperand()\n    else result = this.getCondition().(RelationalOperation).getGreaterOperand()\n  }\n}\n\nfrom FunctionCall fc, IfCompareWithZero ifc, int na\nwhere\n  numberArgument(fc.getTarget(), na) and\n  globalValueNumber(fc.getArgument(na)) = globalValueNumber(ifc.noZerroOperand()) and\n  dominates(fc, ifc) and\n  not exists(IfStmt ifc1 |\n    dominates(ifc1, fc) and\n    globalValueNumber(fc.getArgument(na)) = globalValueNumber(ifc1.getCondition().getAChild*())\n  )\nselect fc, \"The value of argument $@ appears to be checked after the call, rather than before it.\",\n  fc.getArgument(na), fc.getArgument(na).toString()",
        "description": "--Checking the function argument after calling the function itself. --This situation looks suspicious and requires the attention of the developer. --It may be necessary to add validation before calling the function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-020/LateCheckOfFunctionArgument.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.FlowSources\nimport DecompressionBomb\n\npredicate isSink(FunctionCall fc, DataFlow::Node sink) {\n  exists(DecompressionFunction f | fc.getTarget() = f |\n    fc.getArgument(f.getArchiveParameterIndex()) = [sink.asExpr(), sink.asIndirectExpr()]\n  )\n}\n\nmodule DecompressionTaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof FlowSource }\n\n  predicate isSink(DataFlow::Node sink) { isSink(_, sink) }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    any(DecompressionFlowStep s).isAdditionalFlowStep(node1, node2)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(FunctionCall fc | result = [sink.getLocation(), fc.getLocation()] | isSink(fc, sink))\n  }\n}\n\nmodule DecompressionTaint = TaintTracking::Global<DecompressionTaintConfig>;\n\nimport DecompressionTaint::PathGraph\n\nfrom DecompressionTaint::PathNode source, DecompressionTaint::PathNode sink, FunctionCall fc\nwhere DecompressionTaint::flowPath(source, sink) and isSink(fc, sink.getNode())\nselect sink.getNode(), source, sink, \"The decompression output of $@ is not limited\", fc,\n  fc.getTarget().getName()",
        "description": "User-controlled data that flows into decompression library APIs without checking the compression rate is dangerous",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-409/DecompressionBombs.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate numberArgument(Function f, int bpos, int spos) {\n  f.hasGlobalOrStdName([\n      \"X509_NAME_oneline\", \"SSL_CIPHER_description\", \"SSL_get_shared_ciphers\",\n      \"SSL_export_keying_material_early\", \"SSL_export_keying_material\", \"SSL_set_alpn_protos\",\n      \"SSL_CTX_set_alpn_protos\", \"SSL_read\", \"SSL_read_ex\", \"SSL_read_early_data\",\n      \"SSL_bytes_to_cipher_list\", \"SSL_write\", \"SSL_SESSION_set1_master_key\",\n      \"SSL_CTX_set_session_id_context\", \"BIO_gets\", \"BIO_read\", \"BIO_read_ex\", \"BIO_write\",\n      \"BIO_write_ex\", \"BIO_ctrl\", \"BN_bn2binpad\", \"BN_signed_bn2bin\", \"BN_signed_bn2lebin\",\n      \"EVP_PKEY_get_default_digest_name\", \"EVP_DigestUpdate\", \"EVP_PKEY_CTX_set1_tls1_prf_secret\",\n      \"EVP_KDF_derive\", \"EVP_CIPHER_CTX_get_updated_iv\", \"EVP_PKEY_get_group_name\", \"EVP_MAC_init\",\n      \"write\", \"read\", \"send\", \"sendto\", \"recv\", \"recvfrom\", \"strerror_r\"\n    ]) and\n  bpos = 1 and\n  spos = 2\n  or\n  f.hasGlobalOrStdName([\"X509_NAME_get_text_by_NID\", \"EVP_PKEY_get_utf8_string_param\"]) and\n  bpos = 2 and\n  spos = 3\n  or\n  f.hasGlobalOrStdName([\n      \"BIO_snprintf\", \"BN_signed_lebin2bn\", \"BIO_new_mem_buf\", \"BN_lebin2bn\", \"BN_bin2bn\",\n      \"EVP_read_pw_string\", \"EVP_read_pw_string\", \"strftime\", \"strnlen\", \"fgets\", \"snprintf\",\n      \"vsnprintf\"\n    ]) and\n  bpos = 0 and\n  spos = 1\n  or\n  f.hasGlobalOrStdName([\"AES_ige_encrypt\", \"memchr\"]) and bpos = 0 and spos = 2\n  or\n  f.hasGlobalOrStdName(\"EVP_MAC_final\") and bpos = 1 and spos = 3\n  or\n  f.hasGlobalOrStdName(\"OBJ_obj2txt\") and bpos = 2 and spos = 1\n  or\n  f.hasGlobalOrStdName(\"EVP_CIPHER_CTX_ctrl\") and bpos = 3 and spos = 2\n  or\n  f.hasGlobalOrStdName([\"EVP_PKEY_get_octet_string_param\", \"getnameinfo\"]) and bpos = 2 and spos = 3\n  or\n  f.hasGlobalOrStdName([\n      \"EVP_DecryptUpdate\", \"EVP_EncryptUpdate\", \"EVP_PKEY_encrypt\", \"EVP_PKEY_sign\",\n      \"EVP_CipherUpdate\"\n    ]) and\n  bpos = 3 and\n  spos = 4\n  or\n  f.hasGlobalOrStdName(\"getnameinfo\") and bpos = 4 and spos = 5\n}\n\nfrom FunctionCall fc\nwhere\n  exists(ArrayType array, int bufArgPos, int sizeArgPos |\n    numberArgument(fc.getTarget(), bufArgPos, sizeArgPos) and\n    fc.getArgument(pragma[only_bind_into](sizeArgPos)).getValue().toInt() > array.getByteSize() and\n    fc.getArgument(pragma[only_bind_into](bufArgPos))\n        .(VariableAccess)\n        .getTarget()\n        .getADeclarationEntry()\n        .getType() = array\n  )\nselect fc,\n  \"Access beyond the bounds of the allocated memory is possible, the size argument used is greater than the size of the buffer.\"",
        "description": "Incorrect use of the length argument in some functions will result in out-of-memory accesses.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-805/BufferAccessWithIncorrectLengthValue.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.Guards\nimport semmle.code.cpp.valuenumbering.HashCons\n\nclass CallMayNotReturn extends FunctionCall {\n  CallMayNotReturn() {\n    // call that is known to not return\n    not exists(this.(ControlFlowNode).getASuccessor())\n    or\n    // call to another function that may not return\n    exists(CallMayNotReturn exit | this.getTarget() = exit.getEnclosingFunction())\n  }\n}\n\nclass ReallocCallLeak extends FunctionCall {\n  Variable v;\n\n  ReallocCallLeak() {\n    exists(AssignExpr ex |\n      this.getTarget().hasGlobalOrStdName(\"realloc\") and\n      this = ex.getRValue() and\n      hashCons(ex.getLValue()) = hashCons(this.getArgument(0)) and\n      v.getAnAccess() = this.getArgument(0)\n    )\n  }\n\n  /**\n   * Holds if failure of this allocation may be handled by termination, for\n   * example a call to `exit()`.\n   */\n  predicate mayHandleByTermination() {\n    exists(GuardCondition guard, CallMayNotReturn exit |\n      this.(ControlFlowNode).getASuccessor*() = guard and\n      guard.getAChild*() = v.getAnAccess() and\n      guard.controls(exit.getBasicBlock(), _)\n    )\n  }\n}\n\nfrom ReallocCallLeak rcl\nwhere not rcl.mayHandleByTermination()\nselect rcl, \"Possible loss of original pointer on unsuccessful call to 'realloc'.\"",
        "description": "The expression mem = realloc (mem, size) is potentially dangerous, if the call fails, we will lose the pointer to the memory block. We recommend storing the result in a temporary variable and eliminating memory leak.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-401/MemoryLeakOnFailedCallToRealloc.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nstring encryptionWord() {\n  exists(string word |\n    // `(?<!P)` is negative lookbehind, i.e. the match is not preceded by `P`.\n    // `(?!P)` is negative lookahead, i.e. the match is not followed by `P`.\n    word =\n      [\n        \"Crypt\", \"Cipher\", \"Aes\", \"Rijndael\",\n        //\"(?<!Wi|Co|No)Des(?!truct)\",\n        \"(?<!C)Rc[0-9]\", \"(?<!Cha|Unive)Rsa\", \"Blowfish\", \"Twofish\", \"Idea\", \"Kyber\", \"(?<!V)Aria\",\n        //\"Asn[0-9]\",\n        \"Camellia\",\n        //\"(?<!Bit|Type)Cast\",\n        \"Chacha\", \"ChaCha\", \"Poly[0-9]\", \"Ripemd\", \"Whirlpool\", \"Sbox\", \"SBox\", \"Cblock\", \"CBlock\",\n        \"Sub.?Bytes?\", \"Mix.?Columns?\", \"ECDH\", \"ECDSA\", \"EdDSA\", \"ECMQV\", \"ECQV\", \"Curve[0-9][0-9]\"\n      ] and\n    (\n      result = word or\n      result = word.toLowerCase() + \"(?![a-z])\" or // avoid matching middles of words\n      result = word.toUpperCase() + \"(?![A-Z])\" // avoid matching middles of words\n    )\n  )\n}\n\npredicate likelyEncryptionFunction(Function f) {\n  exists(string fName | fName = f.getName() |\n    fName.regexpMatch(\".*(\" + concat(encryptionWord(), \"|\") + \").*\")\n  )\n}\n\npredicate computeHeuristicType(Type t) {\n  t instanceof IntegralType or\n  computeHeuristicType(t.(ArrayType).getBaseType().getUnspecifiedType())\n}\n\npredicate computeHeuristic(Expr e) {\n  (\n    e instanceof BitwiseXorExpr or\n    e instanceof AssignXorExpr or\n    e instanceof LShiftExpr or\n    e instanceof AssignLShiftExpr or\n    e instanceof RShiftExpr or\n    e instanceof AssignRShiftExpr or\n    e instanceof ArrayExpr\n  ) and\n  computeHeuristicType(e.getUnspecifiedType())\n}\n\nstring encryptionLibraryName() {\n  result =\n    [\n      \"libssh\", \"openssl\", \"boringssl\", \"mbed\", \"libsodium\", \"libsrtp\", \"third.?party\", \"library\",\n      \"deps\"\n    ]\n}\n\npredicate isLibrary(File f) {\n  f.getAbsolutePath().regexpMatch(\"(?i).*(\" + concat(encryptionLibraryName(), \"|\") + \").*\")\n  or\n  // assume that any result that would be found outside the source location is in a crypto library\n  not exists(f.getFile().getRelativePath())\n}\n\nfrom Function f, int amount\nwhere\n  likelyEncryptionFunction(f) and\n  amount = strictcount(Expr e | computeHeuristic(e) and e.getEnclosingFunction() = f) and\n  amount >= 8 and\n  not isLibrary(f.getFile())\nselect f,\n  \"This function, \\\"\" + f.getName() +\n    \"\\\", may be a custom implementation of a cryptographic primitive.\"",
        "description": "Writing your own cryptographic primitives is prone to errors and omissions that weaken cryptographic protection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-1240/CustomCryptographicPrimitive.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nclass ContainsArithmetic extends Expr {\n  ContainsArithmetic() {\n    this instanceof BinaryArithmeticOperation\n    or\n    // recursive search into `Operation`s\n    this.(BinaryBitwiseOperation).getAnOperand() instanceof ContainsArithmetic\n  }\n}\n\npredicate numberArgumentModFunctions(Function f, int apos) {\n  f.hasGlobalOrStdName(\"umask\") and apos = 0\n  or\n  f.hasGlobalOrStdName(\"fchmod\") and apos = 1\n  or\n  f.hasGlobalOrStdName(\"chmod\") and apos = 1\n}\n\nfrom FunctionCall fc, string msg, FunctionCall fcsnd\nwhere\n  fc.getTarget().hasGlobalOrStdName(\"umask\") and\n  fc.getArgument(0).getValue() = \"0\" and\n  not exists(FunctionCall fctmp |\n    fctmp.getTarget().hasGlobalOrStdName(\"umask\") and\n    not fctmp.getArgument(0).getValue() = \"0\"\n  ) and\n  exists(FunctionCall fctmp |\n    (\n      fctmp.getTarget().hasGlobalOrStdName(\"fopen\") or\n      fctmp.getTarget().hasGlobalOrStdName(\"open\")\n    ) and\n    (\n      fctmp.getArgument(1).getValue().matches(\"%a%\") or\n      fctmp.getArgument(1).getValue().matches(\"%w%\") or\n      // unfortunately cannot use numeric value here because // O_CREAT is defined differently on different OSes:\n      // https://github.com/red/red/blob/92feb0c0d5f91e087ab35fface6906afbf99b603/runtime/definitions.reds#L477-L491\n      // this may introduce false negatives\n      fctmp.getArgument(1).(BitwiseOrExpr).getAChild*().getValueText() = \"O_CREAT\" or\n      fctmp.getArgument(1).getValueText().matches(\"%O_CREAT%\")\n    ) and\n    fctmp.getNumberOfArguments() = 2 and\n    not fctmp.getArgument(0).getValue() = \"/dev/null\" and\n    fcsnd = fctmp\n  ) and\n  not exists(FunctionCall fctmp |\n    fctmp.getTarget().hasGlobalOrStdName(\"chmod\") or\n    fctmp.getTarget().hasGlobalOrStdName(\"fchmod\")\n  ) and\n  msg = \"Using umask(0) may not be safe with call $@.\"\n  or\n  fc.getTarget().hasGlobalOrStdName(\"umask\") and\n  exists(FunctionCall fctmp |\n    (\n      fctmp.getTarget().hasGlobalOrStdName(\"chmod\") or\n      fctmp.getTarget().hasGlobalOrStdName(\"fchmod\")\n    ) and\n    (\n      globalValueNumber(fc.getArgument(0)) = globalValueNumber(fctmp.getArgument(1)) and\n      fc.getArgument(0).getValue() != \"0\"\n    ) and\n    msg = \"Not use equal argument in umask and $@ functions.\" and\n    fcsnd = fctmp\n  )\n  or\n  exists(ContainsArithmetic exptmp, int i |\n    numberArgumentModFunctions(fc.getTarget(), i) and\n    globalValueNumber(exptmp) = globalValueNumber(fc.getArgument(i)) and\n    msg = \"Using arithmetic to compute the mask in $@ may not be safe.\" and\n    fcsnd = fc\n  )\nselect fc, msg, fcsnd, fcsnd.getTarget().getName()",
        "description": "Incorrectly evaluated argument to the umask function may have security implications.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-266/IncorrectPrivilegeAssignment.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.new.TaintTracking\n\nprivate class CurlSetOptCall extends FunctionCall {\n  CurlSetOptCall() {\n    exists(FunctionCall fc, Function f |\n      f.hasGlobalOrStdName(\"curl_easy_setopt\") and\n      fc.getTarget() = f\n    |\n      this = fc\n    )\n  }\n}\n\nprivate class CurlVerificationConstant extends EnumConstantAccess {\n  CurlVerificationConstant() {\n    exists(EnumConstant e | e.getName() = [\"CURLOPT_SSL_VERIFYHOST\", \"CURLOPT_SSL_VERIFYPEER\"] |\n      e.getAnAccess() = this\n    )\n  }\n}\n\nfrom CurlSetOptCall c\nwhere\n  c.getArgument(1) = any(CurlVerificationConstant v) and\n  c.getArgument(2).getValue() = \"0\"\nselect c, \"This call disables Secure Socket Layer and could potentially lead to MITM attacks\"",
        "description": "Disabling SSL certificate verification of host or peer could expose the communication to man-in-the-middle(MITM) attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-295/CurlSSL.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.HashCons\n\npredicate incrementBoolType(IncrementOperation exp) {\n  exp.getOperand().getType() instanceof BoolType\n}\n\npredicate revertSignBoolType(UnaryMinusExpr exp) {\n  exp.getAnOperand().getType() instanceof BoolType and\n  exp.getFullyConverted().getType() instanceof BoolType\n}\n\npredicate assignBoolType(Expr exp) {\n  exists(ComparisonOperation co |\n    exp.(AssignExpr).getRValue() = co and\n    exp.isCondition() and\n    not co.isParenthesised() and\n    not exp.(AssignExpr).getLValue().getType() instanceof BoolType and\n    not exists(Expr exbl |\n      hashCons(exbl.(AssignExpr).getLValue()) = hashCons(exp.(AssignExpr).getLValue()) and\n      not exbl.isCondition() and\n      exbl.(AssignExpr).getRValue().getType() instanceof BoolType and\n      exbl.(AssignExpr).getLValue().getType() = exp.(AssignExpr).getLValue().getType()\n    ) and\n    co.getLeftOperand() instanceof FunctionCall and\n    not co.getRightOperand().getType() instanceof BoolType and\n    not co.getRightOperand().getValue() = \"0\" and\n    not co.getRightOperand().getValue() = \"1\"\n  )\n}\n\nfrom Expr exp\nwhere\n  incrementBoolType(exp) or\n  revertSignBoolType(exp) or\n  assignBoolType(exp)\nselect exp, \"This expression needs attention.\"",
        "description": "--Finding places of confusing use of boolean type. --For example, a unary minus does not work before a boolean type and an increment always gives true.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-783/OperatorPrecedenceLogicErrorWhenUseBoolType.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\n\npredicate isLogicalOrAndExpr(LogicalOrExpr exptmp) {\n  not exptmp.getLeftOperand() instanceof BinaryOperation and\n  not exptmp.getRightOperand().isParenthesised() and\n  exptmp.getRightOperand() instanceof LogicalAndExpr\n}\n\npredicate isLogicalOrandBitwise(Expr exptmp) {\n  not exptmp.(LogicalOrExpr).getLeftOperand() instanceof BinaryOperation and\n  not exptmp.(LogicalOrExpr).getRightOperand().isParenthesised() and\n  (\n    exptmp.(LogicalOrExpr).getRightOperand().(BinaryBitwiseOperation).getLeftOperand().getType()\n      instanceof BoolType and\n    // The essence of these lines is to improve the quality of detection by eliminating the situation\n    // of processing a logical type by bit operations. In fact, the predicate looks for a situation\n    // when the left operand of a bit operation has a boolean type, which already suggests that the priority is not correct.\n    // But if the right-hand operand is 0 or 1, then there is a possibility that the author intended so.\n    not exptmp\n        .(LogicalOrExpr)\n        .getRightOperand()\n        .(BinaryBitwiseOperation)\n        .getRightOperand()\n        .getValue() = \"0\" and\n    not exptmp\n        .(LogicalOrExpr)\n        .getRightOperand()\n        .(BinaryBitwiseOperation)\n        .getRightOperand()\n        .getValue() = \"1\"\n  )\n  or\n  not exptmp.(LogicalAndExpr).getLeftOperand() instanceof BinaryOperation and\n  not exptmp.(LogicalAndExpr).getRightOperand().isParenthesised() and\n  (\n    exptmp.(LogicalAndExpr).getRightOperand().(BinaryBitwiseOperation).getLeftOperand().getType()\n      instanceof BoolType and\n    // Looking for a situation in which the right-hand operand of a bit operation is not limited to 0 or 1.\n    // In this case, the logical operation will be performed with the result of a binary operation that is not a Boolean type.\n    // In my opinion this indicates a priority error. after all, it will be quite difficult for a developer\n    // to evaluate the conversion of the results of a bit operation to a boolean type.\n    not exptmp\n        .(LogicalAndExpr)\n        .getRightOperand()\n        .(BinaryBitwiseOperation)\n        .getRightOperand()\n        .getValue() = \"0\" and\n    not exptmp\n        .(LogicalAndExpr)\n        .getRightOperand()\n        .(BinaryBitwiseOperation)\n        .getRightOperand()\n        .getValue() = \"1\"\n  )\n}\n\npredicate isBitwiseandBitwise(Expr exptmp) {\n  not exptmp.(BitwiseOrExpr).getLeftOperand() instanceof BinaryOperation and\n  not exptmp.(BitwiseOrExpr).getRightOperand().isParenthesised() and\n  (\n    exptmp.(BitwiseOrExpr).getRightOperand() instanceof BitwiseAndExpr or\n    exptmp.(BitwiseOrExpr).getRightOperand() instanceof BitwiseXorExpr\n  )\n  or\n  not exptmp.(BitwiseXorExpr).getLeftOperand() instanceof BinaryOperation and\n  not exptmp.(BitwiseXorExpr).getRightOperand().isParenthesised() and\n  exptmp.(BitwiseXorExpr).getRightOperand() instanceof BitwiseAndExpr\n}\n\npredicate isRealRange(Expr exp) {\n  upperBound(exp).toString() != \"18446744073709551616\" and\n  upperBound(exp).toString() != \"9223372036854775807\" and\n  upperBound(exp).toString() != \"4294967295\" and\n  upperBound(exp).toString() != \"Infinity\" and\n  upperBound(exp).toString() != \"NaN\" and\n  lowerBound(exp).toString() != \"-9223372036854775808\" and\n  lowerBound(exp).toString() != \"-4294967296\" and\n  lowerBound(exp).toString() != \"-Infinity\" and\n  lowerBound(exp).toString() != \"NaN\" and\n  upperBound(exp) != 2147483647 and\n  upperBound(exp) != 268435455 and\n  upperBound(exp) != 33554431 and\n  upperBound(exp) != 8388607 and\n  upperBound(exp) != 65535 and\n  upperBound(exp) != 32767 and\n  upperBound(exp) != 255 and\n  upperBound(exp) != 127 and\n  lowerBound(exp) != -2147483648 and\n  lowerBound(exp) != -268435456 and\n  lowerBound(exp) != -33554432 and\n  lowerBound(exp) != -8388608 and\n  lowerBound(exp) != -65536 and\n  lowerBound(exp) != -32768 and\n  lowerBound(exp) != -128\n  or\n  lowerBound(exp) = 0 and\n  upperBound(exp) = 1\n}\n\npragma[inline]\npredicate isDifferentSize(Expr exp1, Expr exp2, Expr exp3) {\n  exp1.getType().getSize() = exp2.getType().getSize() and\n  exp1.getType().getSize() != exp3.getType().getSize()\n  or\n  (\n    isRealRange(exp1) and\n    isRealRange(exp2) and\n    isRealRange(exp3)\n  ) and\n  upperBound(exp1).maximum(upperBound(exp2)) - upperBound(exp1).minimum(upperBound(exp2)) < 16 and\n  lowerBound(exp1).maximum(lowerBound(exp2)) - lowerBound(exp1).minimum(lowerBound(exp2)) < 16 and\n  (\n    upperBound(exp1).maximum(upperBound(exp3)) - upperBound(exp1).minimum(upperBound(exp3)) > 256 or\n    lowerBound(exp1).maximum(lowerBound(exp2)) - lowerBound(exp1).minimum(lowerBound(exp2)) > 256\n  )\n}\n\npragma[inline]\npredicate isDifferentResults(\n  Expr exp1, Expr exp2, Expr exp3, BinaryBitwiseOperation op1, BinaryBitwiseOperation op2\n) {\n  (\n    isRealRange(exp1) and\n    isRealRange(exp2) and\n    isRealRange(exp3)\n  ) and\n  exists(int i1, int i2, int i3 |\n    i1 in [lowerBound(exp1).floor() .. upperBound(exp1).floor()] and\n    i2 in [lowerBound(exp2).floor() .. upperBound(exp2).floor()] and\n    i3 in [lowerBound(exp3).floor() .. upperBound(exp3).floor()] and\n    (\n      op1 instanceof BitwiseOrExpr and\n      op2 instanceof BitwiseAndExpr and\n      i1.bitOr(i2).bitAnd(i3) != i2.bitAnd(i3).bitOr(i1)\n      or\n      op1 instanceof BitwiseOrExpr and\n      op2 instanceof BitwiseXorExpr and\n      i1.bitOr(i2).bitXor(i3) != i2.bitXor(i3).bitOr(i1)\n      or\n      op1 instanceof BitwiseXorExpr and\n      op2 instanceof BitwiseAndExpr and\n      i1.bitXor(i2).bitAnd(i3) != i2.bitAnd(i3).bitXor(i1)\n    )\n  )\n}\n\nfrom Expr exp, string msg\nwhere\n  isLogicalOrAndExpr(exp) and\n  msg = \"Logical AND has a higher priority.\"\n  or\n  isLogicalOrandBitwise(exp) and\n  msg = \"Binary operations have higher priority.\"\n  or\n  // Looking for a situation where the equality of the sizes of the first operands\n  // might indicate that the developer planned to perform an operation between them.\n  // However, the absence of parentheses means that the rightmost operation will be performed initially.\n  isBitwiseandBitwise(exp) and\n  isDifferentSize(exp.(BinaryBitwiseOperation).getLeftOperand(),\n    exp.(BinaryBitwiseOperation).getRightOperand().(BinaryBitwiseOperation).getLeftOperand(),\n    exp.(BinaryBitwiseOperation).getRightOperand().(BinaryBitwiseOperation).getRightOperand()) and\n  msg = \"Expression ranges do not match operation precedence.\"\n  or\n  // Looking for a out those expressions that, as a result of identifying the priority with parentheses,\n  // will give different values. As a consequence, this piece of code was supposed to find errors associated\n  // with possible outcomes of operations.\n  isBitwiseandBitwise(exp) and\n  isDifferentResults(exp.(BinaryBitwiseOperation).getLeftOperand(),\n    exp.(BinaryBitwiseOperation).getRightOperand().(BinaryBitwiseOperation).getLeftOperand(),\n    exp.(BinaryBitwiseOperation).getRightOperand().(BinaryBitwiseOperation).getRightOperand(), exp,\n    exp.(BinaryBitwiseOperation).getRightOperand()) and\n  msg = \"Specify the priority with parentheses.\"\nselect exp, msg",
        "description": "--Finding places to use bit and logical operations, without explicit priority allocation. --For example, `a || b ^ c` and `(a || b) ^ c` give different results when `b` is zero.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-783/OperatorPrecedenceLogicErrorWhenUseBitwiseOrLogicalOperations.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nfrom FunctionCall fc, string msg\nwhere\n  // search for functions for generating a name, without a guarantee of the absence of a file during the period of work with it.\n  (\n    fc.getTarget().hasGlobalOrStdName(\"tmpnam\") or\n    fc.getTarget().hasGlobalOrStdName(\"tmpnam_s\") or\n    fc.getTarget().hasGlobalOrStdName(\"tmpnam_r\")\n  ) and\n  not exists(FunctionCall fctmp |\n    (\n      fctmp.getTarget().hasGlobalOrStdName(\"mktemp\") or\n      fctmp.getTarget().hasGlobalOrStdName(\"mkstemp\") or\n      fctmp.getTarget().hasGlobalOrStdName(\"mkstemps\") or\n      fctmp.getTarget().hasGlobalOrStdName(\"mkdtemp\")\n    ) and\n    (\n      fc.getBasicBlock().getASuccessor*() = fctmp.getBasicBlock() or\n      fctmp.getBasicBlock().getASuccessor*() = fc.getBasicBlock()\n    )\n  ) and\n  msg =\n    \"Finding the name of a file that does not exist does not mean that it will not be exist at the next operation.\"\nselect fc, msg",
        "description": "Using a predictable filename when creating a temporary file can lead to an attacker-controlled input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-377/InsecureTemporaryFile.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Scanf\n\nfrom FunctionCall call, ScanfFunction sff\nwhere\n  call.getTarget() = sff and\n  call.getArgument(sff.getFormatParameterIndex()).getValue().regexpMatch(\".*%l?s.*\")\nselect call, \"Dangerous use of one of the scanf functions.\"",
        "description": "Use of one of the scanf functions without a specified length.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-120/MemoryUnsafeFunctionScan.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Exclusions\n\nint posArgumentInFunctionCall(FunctionCall fc) {\n  (\n    fc.getTarget().hasGlobalOrStdName([\"scanf\", \"scanf_s\"]) and\n    result = 1\n    or\n    fc.getTarget().hasGlobalOrStdName([\"fscanf\", \"sscanf\", \"fscanf_s\", \"sscanf_s\"]) and\n    result = 2\n  )\n}\n\npredicate argumentIsNotInitializedAndIsUsed(Variable vt, FunctionCall fc) {\n  // Fillable argument was not initialized.\n  vt instanceof LocalScopeVariable and\n  not vt.getAnAssignment().getASuccessor+() = fc and\n  (\n    not vt.hasInitializer()\n    or\n    exists(Expr e, Variable v |\n      e = vt.getInitializer().getExpr() and\n      v = e.(AddressOfExpr).getOperand().(VariableAccess).getTarget() and\n      (\n        not v.hasInitializer() and\n        not v.getAnAssignment().getASuccessor+() = fc\n      )\n    )\n  ) and\n  not exists(AssignExpr ae |\n    ae.getLValue() = vt.getAnAccess().getParent() and\n    ae.getASuccessor+() = fc\n  ) and\n  not exists(FunctionCall f0 |\n    f0.getAnArgument().getAChild() = vt.getAnAccess() and\n    f0.getASuccessor+() = fc\n  ) and\n  exists(Expr e0 |\n    // After the call, the completed arguments are assigned or returned as the result of the operation of the upper function.\n    fc.getASuccessor+() = e0 and\n    (\n      (\n        e0.(Assignment).getRValue().(VariableAccess).getTarget() = vt or\n        e0.(Assignment).getRValue().(ArrayExpr).getArrayBase().(VariableAccess).getTarget() = vt\n      )\n      or\n      e0.getEnclosingStmt() instanceof ReturnStmt and\n      e0.(VariableAccess).getTarget() = vt\n      or\n      not exists(Expr e1 |\n        fc.getASuccessor+() = e1 and\n        e1.(VariableAccess).getTarget() = vt\n      )\n    )\n  )\n}\n\nfrom FunctionCall fc, int i\nwhere\n  // Function return value is not evaluated.\n  fc instanceof ExprInVoidContext and\n  not isFromMacroDefinition(fc) and\n  i in [posArgumentInFunctionCall(fc) .. fc.getNumberOfArguments() - 1] and\n  (\n    argumentIsNotInitializedAndIsUsed(fc.getArgument(i).(VariableAccess).getTarget(), fc) or\n    argumentIsNotInitializedAndIsUsed(fc.getArgument(i)\n          .(AddressOfExpr)\n          .getOperand()\n          .(VariableAccess)\n          .getTarget(), fc) or\n    argumentIsNotInitializedAndIsUsed(fc.getArgument(i)\n          .(ArrayExpr)\n          .getArrayBase()\n          .(VariableAccess)\n          .getTarget(), fc)\n  ) and\n  // After the call, filled arguments are not evaluated.\n  not exists(Expr e0, int i1 |\n    i1 in [posArgumentInFunctionCall(fc) .. fc.getNumberOfArguments() - 1] and\n    fc.getASuccessor+() = e0 and\n    e0.getEnclosingElement() instanceof ComparisonOperation and\n    (\n      e0.(VariableAccess).getTarget() = fc.getArgument(i1).(VariableAccess).getTarget() or\n      e0.(VariableAccess).getTarget() =\n        fc.getArgument(i1).(AddressOfExpr).getOperand().(VariableAccess).getTarget()\n    )\n  )\nselect fc, \"Unchecked return value for call to $@.\", fc.getTarget() as target, target.getName()",
        "description": "Not checking the return value of scanf and related functions may lead to undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-754/ImproperCheckReturnValueScanf.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\n\npredicate isRealRange(Expr exp) {\n  upperBound(exp).toString() != \"18446744073709551616\" and\n  upperBound(exp).toString() != \"9223372036854775807\" and\n  upperBound(exp).toString() != \"4294967295\" and\n  upperBound(exp).toString() != \"Infinity\" and\n  upperBound(exp).toString() != \"NaN\" and\n  lowerBound(exp).toString() != \"-9223372036854775808\" and\n  lowerBound(exp).toString() != \"-4294967296\" and\n  lowerBound(exp).toString() != \"-Infinity\" and\n  lowerBound(exp).toString() != \"NaN\" and\n  upperBound(exp) != 2147483647 and\n  upperBound(exp) != 268435455 and\n  upperBound(exp) != 33554431 and\n  upperBound(exp) != 8388607 and\n  upperBound(exp) != 65535 and\n  upperBound(exp) != 32767 and\n  upperBound(exp) != 255 and\n  upperBound(exp) != 127 and\n  upperBound(exp) != 63 and\n  upperBound(exp) != 31 and\n  upperBound(exp) != 15 and\n  upperBound(exp) != 7 and\n  lowerBound(exp) != -2147483648 and\n  lowerBound(exp) != -268435456 and\n  lowerBound(exp) != -33554432 and\n  lowerBound(exp) != -8388608 and\n  lowerBound(exp) != -65536 and\n  lowerBound(exp) != -32768 and\n  lowerBound(exp) != -128\n}\n\npredicate isNotAllSelected(SwitchStmt swtmp) {\n  not swtmp.getExpr().isConstant() and\n  exists(int i |\n    i != 0 and\n    (\n      i = lowerBound(swtmp.getASwitchCase().getExpr()) and\n      upperBound(swtmp.getExpr()) < i\n      or\n      (\n        i = upperBound(swtmp.getASwitchCase().getExpr()) or\n        i = upperBound(swtmp.getASwitchCase().getEndExpr())\n      ) and\n      lowerBound(swtmp.getExpr()) > i\n    )\n  )\n}\n\npredicate isConditionBig(SwitchStmt swtmp) {\n  not swtmp.hasDefaultCase() and\n  not exists(int iu, int il |\n    (\n      iu = upperBound(swtmp.getASwitchCase().getExpr()) or\n      iu = upperBound(swtmp.getASwitchCase().getEndExpr())\n    ) and\n    upperBound(swtmp.getExpr()) = iu and\n    (\n      il = lowerBound(swtmp.getASwitchCase().getExpr()) or\n      il = lowerBound(swtmp.getASwitchCase().getEndExpr())\n    ) and\n    lowerBound(swtmp.getExpr()) = il\n  )\n}\n\npredicate isWrongLabelName(SwitchStmt swtmp) {\n  not swtmp.hasDefaultCase() and\n  exists(LabelStmt lb |\n    (\n      (\n        lb.getName().charAt(0) = \"d\" or\n        lb.getName().charAt(0) = \"c\"\n      ) and\n      (\n        lb.getName().charAt(1) = \"e\" or\n        lb.getName().charAt(1) = \"a\"\n      ) and\n      (\n        lb.getName().charAt(2) = \"f\" or\n        lb.getName().charAt(2) = \"s\"\n      )\n    ) and\n    lb.getEnclosingStmt().getParentStmt*() = swtmp.getStmt() and\n    not exists(GotoStmt gs | gs.getName() = lb.getName())\n  )\n}\n\npredicate isCodeBeforeCase(SwitchStmt swtmp) {\n  exists(Expr exp |\n    exp.getEnclosingStmt().getParentStmt*() = swtmp.getStmt() and\n    not exists(Loop lp |\n      exp.getEnclosingStmt().getParentStmt*() = lp and\n      lp.getEnclosingStmt().getParentStmt*() = swtmp.getStmt()\n    ) and\n    not exists(Stmt sttmp, SwitchCase sctmp |\n      sttmp = swtmp.getASwitchCase().getAStmt() and\n      sctmp = swtmp.getASwitchCase() and\n      (\n        exp.getEnclosingStmt().getParentStmt*() = sttmp or\n        exp.getEnclosingStmt() = sctmp\n      )\n    )\n  )\n}\n\nfrom SwitchStmt sw, string msg\nwhere\n  isRealRange(sw.getExpr()) and\n  lowerBound(sw.getExpr()) != upperBound(sw.getExpr()) and\n  lowerBound(sw.getExpr()) != 0 and\n  not exists(Expr cexp |\n    cexp = sw.getASwitchCase().getExpr() and not isRealRange(cexp)\n    or\n    cexp = sw.getASwitchCase().getEndExpr() and not isRealRange(cexp)\n  ) and\n  not exists(Expr exptmp |\n    exptmp = sw.getExpr().getAChild*() and\n    not exptmp.isConstant() and\n    not isRealRange(exptmp)\n  ) and\n  (sw.getASwitchCase().terminatesInBreakStmt() or sw.getASwitchCase().terminatesInReturnStmt()) and\n  (\n    isNotAllSelected(sw) and msg = \"The range of condition values is less than the selection.\"\n    or\n    isConditionBig(sw) and msg = \"The range of condition values is wider than the choices.\"\n  )\n  or\n  isWrongLabelName(sw) and msg = \"Possibly erroneous label name.\"\n  or\n  isCodeBeforeCase(sw) and msg = \"Code before case will not be executed.\"\nselect sw, msg",
        "description": "--Finding places the dangerous use of a switch. --For example, when the range of values for a condition does not cover all of the selection values..",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-561/FindIncorrectlyUsedSwitch.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.rangeanalysis.new.internal.semantic.analysis.RangeAnalysis\nimport semmle.code.cpp.rangeanalysis.new.internal.semantic.SemanticExprSpecific\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport ArrayAddressToDerefFlow::PathGraph\n\npragma[nomagic]\nInstruction getABoundIn(SemBound b, IRFunction func) {\n  getSemanticExpr(result) = b.getExpr(0) and\n  result.getEnclosingIRFunction() = func\n}\n\npragma[inline]\npredicate boundedImpl(Instruction i, Instruction b, int delta) {\n  exists(SemBound bound, IRFunction func |\n    semBounded(getSemanticExpr(i), bound, delta, true, _) and\n    b = getABoundIn(bound, func) and\n    pragma[only_bind_out](i.getEnclosingIRFunction()) = func\n  )\n}\n\nbindingset[i]\npragma[inline_late]\npredicate bounded1(Instruction i, Instruction b, int delta) { boundedImpl(i, b, delta) }\n\nbindingset[b]\npragma[inline_late]\npredicate bounded2(Instruction i, Instruction b, int delta) { boundedImpl(i, b, delta) }\n\nbindingset[delta]\npredicate isInvalidPointerDerefSinkImpl(\n  int delta, Instruction i, AddressOperand addr, string operation\n) {\n  delta >= 0 and\n  i.getAnOperand() = addr and\n  (\n    i instanceof StoreInstruction and\n    operation = \"write\"\n    or\n    i instanceof LoadInstruction and\n    operation = \"read\"\n  )\n}\n\npragma[inline]\npredicate isInvalidPointerDerefSink1(DataFlow::Node sink, Instruction i, string operation) {\n  exists(AddressOperand addr, int delta |\n    bounded1(addr.getDef(), sink.asInstruction(), delta) and\n    isInvalidPointerDerefSinkImpl(delta, i, addr, operation)\n  )\n}\n\npragma[inline]\npredicate isInvalidPointerDerefSink2(DataFlow::Node sink, Instruction i, string operation) {\n  exists(AddressOperand addr, int delta |\n    bounded2(addr.getDef(), sink.asInstruction(), delta) and\n    isInvalidPointerDerefSinkImpl(delta, i, addr, operation)\n  )\n}\n\npredicate arrayTypeCand(ArrayType arrayType) {\n  any(Variable v).getUnspecifiedType() = arrayType and\n  exists(arrayType.getByteSize())\n}\n\nbindingset[baseTypeSize]\npragma[inline_late]\npredicate arrayTypeHasSizes(ArrayType arr, int baseTypeSize, int size) {\n  arrayTypeCand(arr) and\n  arr.getByteSize() / baseTypeSize = size\n}\n\nbindingset[pai]\npragma[inline_late]\npredicate constantUpperBounded(PointerArithmeticInstruction pai, int delta) {\n  semBounded(getSemanticExpr(pai.getRight()), any(SemZeroBound b), delta, true, _)\n}\n\nbindingset[pai, size]\npredicate pointerArithOverflow0Impl(PointerArithmeticInstruction pai, int size, int delta) {\n  exists(int bound |\n    constantUpperBounded(pai, bound) and\n    delta = bound - size and\n    delta >= 0 and\n    size != 0 and\n    size != 1\n  )\n}\n\npragma[nomagic]\npredicate pointerArithOverflow0(PointerArithmeticInstruction pai, int delta) {\n  exists(int size |\n    arrayTypeHasSizes(_, pai.getElementSize(), size) and\n    pointerArithOverflow0Impl(pai, size, delta)\n  )\n}\n\nmodule PointerArithmeticToDerefConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { pointerArithOverflow0(source.asInstruction(), _) }\n\n  predicate isBarrierIn(DataFlow::Node node) { isSource(node) }\n\n  predicate isBarrierOut(DataFlow::Node node) { isSink(node) }\n\n  predicate isSink(DataFlow::Node sink) { isInvalidPointerDerefSink1(sink, _, _) }\n}\n\nmodule PointerArithmeticToDerefFlow = DataFlow::Global<PointerArithmeticToDerefConfig>;\n\npredicate pointerArithOverflow(PointerArithmeticInstruction pai, int delta) {\n  pointerArithOverflow0(pai, delta) and\n  PointerArithmeticToDerefFlow::flow(DataFlow::instructionNode(pai), _)\n}\n\nbindingset[v]\npredicate finalPointerArithOverflow(Variable v, PointerArithmeticInstruction pai, int delta) {\n  exists(int size |\n    arrayTypeHasSizes(pragma[only_bind_out](v.getUnspecifiedType()), pai.getElementSize(), size) and\n    pointerArithOverflow0Impl(pai, size, delta)\n  )\n}\n\npredicate isSourceImpl(DataFlow::Node source, Variable v) {\n  (\n    source.asInstruction().(FieldAddressInstruction).getField() = v\n    or\n    source.asInstruction().(VariableAddressInstruction).getAstVariable() = v\n  ) and\n  arrayTypeCand(v.getUnspecifiedType())\n}\n\nmodule ArrayAddressToDerefConfig implements DataFlow::StateConfigSig {\n  newtype FlowState =\n    additional TArray() or\n    additional TOverflowArithmetic(PointerArithmeticInstruction pai) {\n      pointerArithOverflow(pai, _)\n    }\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    isSourceImpl(source, _) and\n    state = TArray()\n  }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    exists(DataFlow::Node pai |\n      state = TOverflowArithmetic(pai.asInstruction()) and\n      PointerArithmeticToDerefFlow::flow(pai, sink)\n    )\n  }\n\n  predicate isBarrierIn(DataFlow::Node node) { isSource(node, _) }\n\n  predicate isBarrierOut(DataFlow::Node node) { isSink(node, _) }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    exists(PointerArithmeticInstruction pai |\n      state1 = TArray() and\n      state2 = TOverflowArithmetic(pai) and\n      pai.getLeft() = node1.asInstruction() and\n      node2.asInstruction() = pai and\n      pointerArithOverflow(pai, _)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    exists(Variable v | result = v.getLocation() | isSourceImpl(source, v))\n  }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(PointerArithmeticInstruction pai, Instruction deref |\n      result = [pai, deref].getLocation() and\n      isInvalidPointerDerefSink2(sink, deref, _) and\n      isSink(sink, ArrayAddressToDerefConfig::TOverflowArithmetic(pai))\n    )\n  }\n}\n\nmodule ArrayAddressToDerefFlow = DataFlow::GlobalWithState<ArrayAddressToDerefConfig>;\n\nfrom\n  Variable v, ArrayAddressToDerefFlow::PathNode source, PointerArithmeticInstruction pai,\n  ArrayAddressToDerefFlow::PathNode sink, Instruction deref, string operation, int delta\nwhere\n  ArrayAddressToDerefFlow::flowPath(pragma[only_bind_into](source), pragma[only_bind_into](sink)) and\n  isInvalidPointerDerefSink2(sink.getNode(), deref, operation) and\n  pragma[only_bind_out](sink.getState()) = ArrayAddressToDerefConfig::TOverflowArithmetic(pai) and\n  isSourceImpl(source.getNode(), v) and\n  finalPointerArithOverflow(v, pai, delta)\nselect pai, source, sink,\n  \"This pointer arithmetic may have an off-by-\" + (delta + 1) +\n    \" error allowing it to overrun $@ at this $@.\", v, v.getName(), deref, operation",
        "description": "Dereferencing a pointer that points past a statically-sized array is undefined behavior and may lead to security vulnerabilities",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-193/ConstantSizeArrayOffByOne.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\nclass CopyFromUserFunctionCall extends FunctionCall {\n  CopyFromUserFunctionCall() {\n    this.getTarget().getName() = \"copy_from_user\" and\n    not this.getArgument(1) instanceof AddressOfExpr\n  }\n\n  //root cause of double-fetech issue is read from\n  //the same user mode memory twice, so it makes\n  //sense that only check user mode pointer\n  predicate readFromSameUserModePointer(CopyFromUserFunctionCall another) {\n    globalValueNumber(this.getArgument(1)) = globalValueNumber(another.getArgument(1))\n  }\n}\n\nfrom CopyFromUserFunctionCall p1, CopyFromUserFunctionCall p2\nwhere\n  not p1 = p2 and\n  p1.readFromSameUserModePointer(p2) and\n  exists(IfStmt ifStmt |\n    p1.getBasicBlock().getAFalseSuccessor*() = ifStmt.getBasicBlock() and\n    ifStmt.getBasicBlock().getAFalseSuccessor*() = p2.getBasicBlock()\n  ) and\n  not exists(AssignPointerAddExpr assignPtrAdd |\n    globalValueNumber(p1.getArgument(1)) = globalValueNumber(assignPtrAdd.getLValue()) and\n    p1.getBasicBlock().getAFalseSuccessor*() = assignPtrAdd.getBasicBlock()\n  )\nselect p2, \"Double fetch vulnerability. First fetch was $@.\", p1, p1.toString()",
        "description": "Double-fetch is a very common vulnerability pattern in linux kernel, attacker can exploit double-fetch issues to obtain root privilege. Double-fetch is caused by fetching data from user mode by calling copy_from_user twice, CVE-2016-6480 is quite a good example for your information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-362/double-fetch.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom FunctionCall fc, FunctionCall fc2, LocalScopeVariable v\nwhere\n  fc.(DeallocationExpr).getFreedExpr() = v.getAnAccess() and\n  fc2.(DeallocationExpr).getFreedExpr() = v.getAnAccess() and\n  fc != fc2 and\n  fc.getASuccessor*() = fc2 and\n  not exists(Expr exptmp |\n    (exptmp = v.getAnAssignedValue() or exptmp.(AddressOfExpr).getOperand() = v.getAnAccess()) and\n    exptmp = fc.getASuccessor*() and\n    exptmp = fc2.getAPredecessor*()\n  ) and\n  not exists(FunctionCall fctmp |\n    not fctmp instanceof DeallocationExpr and\n    fctmp = fc.getASuccessor*() and\n    fctmp = fc2.getAPredecessor*() and\n    fctmp.getAnArgument().(VariableAccess).getTarget() = v\n  ) and\n  (\n    fc.getTarget().hasGlobalOrStdName(\"realloc\") and\n    (\n      not fc.getParent*() instanceof IfStmt and\n      not exists(IfStmt iftmp |\n        iftmp.getCondition().getAChild*().(VariableAccess).getTarget().getAnAssignedValue() = fc\n      )\n    )\n    or\n    not fc.getTarget().hasGlobalOrStdName(\"realloc\")\n  )\nselect fc2.getArgument(0),\n  \"This pointer may have already been cleared in the line \" + fc.getLocation().getStartLine() + \".\"",
        "description": "Freeing a previously allocated resource twice can lead to various vulnerabilities in the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-415/DoubleFree.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Exclusions\n\npredicate inExistsChdir(FunctionCall fcp) {\n  exists(FunctionCall fctmp |\n    (\n      fctmp.getTarget().hasGlobalOrStdName(\"chdir\") or\n      fctmp.getTarget().hasGlobalOrStdName(\"fchdir\")\n    ) and\n    (\n      fcp.getBasicBlock().getASuccessor*() = fctmp.getBasicBlock() or\n      fctmp.getBasicBlock().getASuccessor*() = fcp.getBasicBlock()\n    )\n  )\n}\n\npredicate outExistsChdir(FunctionCall fcp) {\n  exists(FunctionCall fctmp |\n    exists(FunctionCall fctmp2 |\n      (\n        fctmp2.getTarget().hasGlobalOrStdName(\"chdir\") or\n        fctmp2.getTarget().hasGlobalOrStdName(\"fchdir\")\n      ) and\n      // we are looking for a call containing calls chdir and fchdir\n      fctmp2.getEnclosingStmt().getParentStmt*() = fctmp.getTarget().getEntryPoint().getChildStmt*()\n    ) and\n    (\n      fcp.getBasicBlock().getASuccessor*() = fctmp.getBasicBlock() or\n      fctmp.getBasicBlock().getASuccessor*() = fcp.getBasicBlock()\n    )\n  )\n}\n\nfrom FunctionCall fc, string msg\nwhere\n  fc.getTarget().hasGlobalOrStdName(\"chroot\") and\n  not inExistsChdir(fc) and\n  not outExistsChdir(fc) and\n  // in this section I want to exclude calls to functions containing chroot that have a direct path to chdir, or to a function containing chdir\n  exists(FunctionCall fctmp |\n    fc.getEnclosingStmt().getParentStmt*() = fctmp.getTarget().getEntryPoint().getChildStmt*() and\n    not inExistsChdir(fctmp) and\n    not outExistsChdir(fctmp)\n  ) and\n  msg = \"Creation of 'chroot' jail without changing the working directory\"\n  or\n  (\n    fc.getTarget().hasGlobalOrStdName(\"chdir\") or\n    fc.getTarget().hasGlobalOrStdName(\"fchdir\")\n  ) and\n  fc instanceof ExprInVoidContext and\n  not isFromMacroDefinition(fc) and\n  msg = \"Unchecked return value for call to '\" + fc.getTarget().getName() + \"'.\"\nselect fc, msg",
        "description": "Not validating the return value or pinning the directory can be unsafe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-243/IncorrectChangingWorkingDirectory.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.security.FlowSources\nimport WordexpTaint::PathGraph\n\nprivate class WordexpFunction extends Function {\n  WordexpFunction() { this.hasGlobalName(\"wordexp\") }\n}\n\nprivate predicate isCommandSubstitutionDisabled(FunctionCall fc) {\n  fc.getArgument(2).getValue().toInt().bitAnd(4) = 4\n  /* 4 = WRDE_NOCMD. Check whether the flag is set.  */\n}\n\nmodule WordexpTaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof FlowSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(FunctionCall fc | fc.getTarget() instanceof WordexpFunction |\n      fc.getArgument(0) = sink.asIndirectArgument(1) and\n      not isCommandSubstitutionDisabled(fc)\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n}\n\nmodule WordexpTaint = TaintTracking::Global<WordexpTaintConfig>;\n\nfrom WordexpTaint::PathNode sourceNode, WordexpTaint::PathNode sinkNode\nwhere WordexpTaint::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"Using user-supplied data in a `wordexp` command, without disabling command substitution, can make code vulnerable to command injection.\"",
        "description": "Using user-supplied data in a `wordexp` command, without disabling command substitution, can make code vulnerable to command injection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-078/WordexpTainted.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.File\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.valuenumbering.HashCons\n\nclass CallMayNotReturn extends FunctionCall {\n  CallMayNotReturn() {\n    // call that is known to not return\n    not exists(this.(ControlFlowNode).getASuccessor())\n    or\n    // call to another function that may not return\n    exists(CallMayNotReturn exit | this.getTarget() = exit.getEnclosingFunction())\n    or\n    this.(ControlFlowNode).getASuccessor() instanceof ThrowExpr\n  }\n}\n\npragma[inline]\npredicate checkChangeVariable(FunctionCall fc0, ControlFlowNode fc1, ControlFlowNode fc2) {\n  not exists(Expr exptmp |\n    (\n      exptmp = fc0.getArgument(0).(VariableAccess).getTarget().getAnAssignedValue() or\n      exptmp.(AddressOfExpr).getOperand() =\n        fc0.getArgument(0).(VariableAccess).getTarget().getAnAccess()\n    ) and\n    exptmp = fc1.getASuccessor*() and\n    exptmp = fc2.getAPredecessor*()\n  ) and\n  (\n    (\n      not fc0.getArgument(0) instanceof PointerFieldAccess and\n      not fc0.getArgument(0) instanceof ValueFieldAccess\n      or\n      fc0.getArgument(0).(VariableAccess).getQualifier() instanceof ThisExpr\n    )\n    or\n    not exists(Expr exptmp |\n      (\n        exptmp =\n          fc0.getArgument(0)\n              .(VariableAccess)\n              .getQualifier()\n              .(VariableAccess)\n              .getTarget()\n              .getAnAssignedValue() or\n        exptmp.(AddressOfExpr).getOperand() =\n          fc0.getArgument(0)\n              .(VariableAccess)\n              .getQualifier()\n              .(VariableAccess)\n              .getTarget()\n              .getAnAccess()\n      ) and\n      exptmp = fc1.getASuccessor*() and\n      exptmp = fc2.getAPredecessor*()\n    )\n  )\n}\n\npredicate closeReturn(FunctionCall fc) {\n  fcloseCall(fc, _) and\n  checkChangeVariable(fc, fc, fc.getEnclosingFunction())\n}\n\npredicate closeWithoutChangeBefore(FunctionCall fc) {\n  fcloseCall(fc, _) and\n  checkChangeVariable(fc, fc.getEnclosingFunction().getEntryPoint(), fc)\n}\n\npredicate callInOtherFunctions(FunctionCall fc, FunctionCall fc1) {\n  exists(FunctionCall fec1, FunctionCall fec2 |\n    fc.getEnclosingFunction() != fc1.getEnclosingFunction() and\n    fec1 = fc.getEnclosingFunction().getACallToThisFunction() and\n    fec2 = fc1.getEnclosingFunction().getACallToThisFunction() and\n    fec1.getASuccessor*() = fec2 and\n    checkChangeVariable(fc, fec1, fec2)\n  )\n}\n\npredicate interDoubleCloseFunctions(FunctionCall fc, FunctionCall fc1) {\n  fcloseCall(fc, _) and\n  fcloseCall(fc1, _) and\n  fc != fc1 and\n  fc.getASuccessor*() = fc1 and\n  checkChangeVariable(fc, fc, fc1)\n}\n\npredicate similarArguments(FunctionCall fc, FunctionCall fc1) {\n  globalValueNumber(fc.getArgument(0)) = globalValueNumber(fc1.getArgument(0))\n  or\n  fc.getArgument(0).(VariableAccess).getTarget() = fc1.getArgument(0).(VariableAccess).getTarget() and\n  (\n    not fc.getArgument(0) instanceof PointerFieldAccess and\n    not fc.getArgument(0) instanceof ValueFieldAccess\n    or\n    fc.getArgument(0).(VariableAccess).getQualifier() instanceof ThisExpr\n  )\n  or\n  fc.getArgument(0).(VariableAccess).getTarget() = fc1.getArgument(0).(VariableAccess).getTarget() and\n  (\n    fc.getArgument(0) instanceof PointerFieldAccess or\n    fc.getArgument(0) instanceof ValueFieldAccess\n  ) and\n  hashCons(fc.getArgument(0)) = hashCons(fc1.getArgument(0))\n}\n\nfrom FunctionCall fc, FunctionCall fc1\nwhere\n  not fc.getASuccessor*() instanceof CallMayNotReturn and\n  not exists(IfStmt ifs | ifs.getCondition().getAChild*() = fc) and\n  (\n    // detecting a repeated call situation within one function\n    closeReturn(fc) and\n    closeWithoutChangeBefore(fc1) and\n    callInOtherFunctions(fc, fc1)\n    or\n    // detection of repeated call in different functions\n    interDoubleCloseFunctions(fc, fc1)\n  ) and\n  similarArguments(fc, fc1)\nselect fc, \"Second call to the $@ function is possible.\", fc1, fc1.getTarget().getName()",
        "description": "Double release of the descriptor can lead to a crash of the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-675/DoubleRelease.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npragma[inline]\npredicate doubleCallDelete(BlockStmt b, CatchAnyBlock cb, Variable vr) {\n  // Search for exceptions after freeing memory.\n  exists(Expr e1 |\n    // `e1` is a delete of `vr`\n    (\n      e1 = vr.getAnAccess().getEnclosingStmt().(ExprStmt).getExpr().(DeleteArrayExpr) or\n      e1 = vr.getAnAccess().getEnclosingStmt().(ExprStmt).getExpr().(DeleteExpr)\n    ) and\n    e1.getEnclosingFunction() = cb.getEnclosingFunction() and\n    // there is no assignment `vr = 0` in the `try` block after `e1`\n    not exists(AssignExpr ae |\n      ae.getLValue().(VariableAccess).getTarget() = vr and\n      ae.getRValue().getValue() = \"0\" and\n      e1.getASuccessor+() = ae and\n      ae.getEnclosingStmt().getParentStmt*() = b\n    ) and\n    // `e2` is a `throw` (or a function call that may throw) that occurs in the `try` or `catch` block after `e1`\n    exists(Expr e2, ThrowExpr th |\n      (\n        e2 = th or\n        e2 = th.getEnclosingFunction().getACallToThisFunction()\n      ) and\n      e2.getEnclosingStmt().getParentStmt*() = b and\n      e1.getASuccessor+() = e2\n    ) and\n    e1.getEnclosingStmt().getParentStmt*() = b and\n    (\n      // Search for a situation where there is a release in the block of `try`.\n      b = cb.getTryStmt().getStmt()\n      or\n      // Search for a situation when there is a higher catch block that also frees memory.\n      exists(b.(CatchBlock).getParameter())\n    ) and\n    // Exclude the presence of a check in catch block.\n    not exists(IfStmt ifst | ifst.getEnclosingStmt().getParentStmt*() = cb.getAStmt())\n  )\n}\n\npragma[inline]\npredicate pointerDereference(CatchAnyBlock cb, Variable vr, Variable vro) {\n  // Search exceptions before allocating memory.\n  exists(Expr e0, Expr e1 |\n    (\n      // `e0` is a `new` expression (or equivalent function call) assigned to `vro`\n      exists(AssignExpr ase |\n        ase = vro.getAnAccess().getEnclosingStmt().(ExprStmt).getExpr() and\n        (\n          e0 = ase.getRValue().(NewOrNewArrayExpr) or\n          e0 = ase.getRValue().(NewOrNewArrayExpr).getEnclosingFunction().getACallToThisFunction()\n        ) and\n        vro = ase.getLValue().(VariableAccess).getTarget()\n      )\n      or\n      // `e0` is a `new` expression (or equivalent function call) assigned to the array element `vro`\n      exists(AssignExpr ase |\n        ase = vro.getAnAccess().(Qualifier).getEnclosingStmt().(ExprStmt).getExpr() and\n        (\n          e0 = ase.getRValue().(NewOrNewArrayExpr) or\n          e0 = ase.getRValue().(NewOrNewArrayExpr).getEnclosingFunction().getACallToThisFunction()\n        ) and\n        not ase.getLValue() instanceof VariableAccess and\n        vro = ase.getLValue().getAPredecessor().(VariableAccess).getTarget()\n      )\n    ) and\n    // `e1` is a `new` expression (or equivalent function call) assigned to `vr`\n    exists(AssignExpr ase |\n      ase = vr.getAnAccess().getEnclosingStmt().(ExprStmt).getExpr() and\n      (\n        e1 = ase.getRValue().(NewOrNewArrayExpr) or\n        e1 = ase.getRValue().(NewOrNewArrayExpr).getEnclosingFunction().getACallToThisFunction()\n      ) and\n      vr = ase.getLValue().(VariableAccess).getTarget()\n    ) and\n    e0.getASuccessor*() = e1 and\n    e0.getEnclosingStmt().getParentStmt*() = cb.getTryStmt().getStmt() and\n    e1.getEnclosingStmt().getParentStmt*() = cb.getTryStmt().getStmt() and\n    // `e2` is a `throw` (or a function call that may throw) that occurs in the `try` block before `e0`\n    exists(Expr e2, ThrowExpr th |\n      (\n        e2 = th or\n        e2 = th.getEnclosingFunction().getACallToThisFunction()\n      ) and\n      e2.getEnclosingStmt().getParentStmt*() = cb.getTryStmt().getStmt() and\n      e2.getASuccessor+() = e0\n    )\n  ) and\n  // We exclude checking the value of a variable or its parent in the catch block.\n  not exists(IfStmt ifst |\n    ifst.getEnclosingStmt().getParentStmt*() = cb.getAStmt() and\n    (\n      ifst.getCondition().getAChild*().(VariableAccess).getTarget() = vr or\n      ifst.getCondition().getAChild*().(VariableAccess).getTarget() = vro\n    )\n  )\n}\n\npragma[inline]\npredicate newThrowDelete(CatchAnyBlock cb, Variable vro) {\n  exists(Expr e0, AssignExpr ase, NewOrNewArrayExpr nae |\n    ase = vro.getAnAccess().getEnclosingStmt().(ExprStmt).getExpr() and\n    nae = ase.getRValue() and\n    not nae.getAChild*().toString() = \"nothrow\" and\n    (\n      e0 = nae or\n      e0 = nae.getEnclosingFunction().getACallToThisFunction()\n    ) and\n    vro = ase.getLValue().(VariableAccess).getTarget() and\n    e0.getEnclosingStmt().getParentStmt*() = cb.getTryStmt().getStmt() and\n    not exists(AssignExpr ase1 |\n      vro = ase1.getLValue().(VariableAccess).getTarget() and\n      ase1.getRValue().getValue() = \"0\" and\n      ase1.getASuccessor*() = e0\n    )\n  ) and\n  not exists(Initializer it |\n    vro.getInitializer() = it and\n    it.getExpr().getValue() = \"0\"\n  ) and\n  not exists(ConstructorFieldInit ci | vro = ci.getTarget())\n}\n\nfrom CatchAnyBlock cb, string msg\nwhere\n  exists(Variable vr, Variable vro, Expr exp |\n    exp.getEnclosingStmt().getParentStmt*() = cb and\n    exists(VariableAccess va |\n      (\n        (\n          va = exp.(DeleteArrayExpr).getExpr().getAPredecessor+().(Qualifier) or\n          va = exp.(DeleteArrayExpr).getExpr().getAPredecessor+()\n        ) and\n        vr = exp.(DeleteArrayExpr).getExpr().(VariableAccess).getTarget()\n        or\n        (\n          va = exp.(DeleteExpr).getExpr().getAPredecessor+().(Qualifier) or\n          va = exp.(DeleteExpr).getExpr().getAPredecessor+()\n        ) and\n        vr = exp.(DeleteExpr).getExpr().(VariableAccess).getTarget()\n      ) and\n      va.getEnclosingStmt() = exp.getEnclosingStmt() and\n      vro = va.getTarget() and\n      vr != vro\n    ) and\n    pointerDereference(cb, vr, vro) and\n    msg =\n      \"it is possible to dereference a pointer when accessing a \" + vr.getName() +\n        \", since it is possible to throw an exception before the memory for the \" + vro.getName() +\n        \" is allocated\"\n  )\n  or\n  exists(Expr exp, Variable vr |\n    (\n      exp.(DeleteExpr).getEnclosingStmt().getParentStmt*() = cb and\n      vr = exp.(DeleteExpr).getExpr().(VariableAccess).getTarget()\n      or\n      exp.(DeleteArrayExpr).getEnclosingStmt().getParentStmt*() = cb and\n      vr = exp.(DeleteArrayExpr).getExpr().(VariableAccess).getTarget()\n    ) and\n    doubleCallDelete(_, cb, vr) and\n    msg =\n      \"This allocation may have been released in the try block or a previous catch block.\" +\n        vr.getName()\n  )\n  or\n  exists(Variable vro, Expr exp |\n    exp.getEnclosingStmt().getParentStmt*() = cb and\n    exists(VariableAccess va |\n      (\n        va = exp.(DeleteArrayExpr).getExpr() or\n        va = exp.(DeleteExpr).getExpr()\n      ) and\n      va.getEnclosingStmt() = exp.getEnclosingStmt() and\n      vro = va.getTarget()\n    ) and\n    newThrowDelete(cb, vro) and\n    msg =\n      \"If the allocation in the try block fails, then an unallocated pointer \" + vro.getName() +\n        \" will be freed in the catch block.\"\n  )\nselect cb, msg",
        "description": "When clearing the data in the catch block, you must be sure that the memory was allocated before the exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-476/DangerousUseOfExceptionBlocks.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate argumentMayBeRoot(Expr e) {\n  e.getValue() = \"0\" or\n  e.(VariableAccess).getTarget().getName().toLowerCase().matches(\"%root%\")\n}\n\nclass SetuidLikeFunctionCall extends FunctionCall {\n  SetuidLikeFunctionCall() {\n    (this.getTarget().hasGlobalName(\"setuid\") or this.getTarget().hasGlobalName(\"setresuid\")) and\n    // setuid/setresuid with the root user are false positives.\n    not argumentMayBeRoot(this.getArgument(0))\n  }\n}\n\nclass SetuidLikeWrapperCall extends FunctionCall {\n  SetuidLikeFunctionCall baseCall;\n\n  SetuidLikeWrapperCall() {\n    this = baseCall\n    or\n    exists(SetuidLikeWrapperCall fc |\n      this.getTarget() = fc.getEnclosingFunction() and\n      baseCall = fc.getBaseCall()\n    )\n  }\n\n  SetuidLikeFunctionCall getBaseCall() { result = baseCall }\n}\n\nclass CallBeforeSetuidFunctionCall extends FunctionCall {\n  CallBeforeSetuidFunctionCall() {\n    this.getTarget()\n        .hasGlobalName([\n            \"setgid\", \"setresgid\",\n            // Compatibility may require skipping initgroups and setgroups return checks.\n            // A stricter best practice is to check the result and errnor for EPERM.\n            \"initgroups\", \"setgroups\"\n          ]) and\n    // setgid/setresgid/etc with the root group are false positives.\n    not argumentMayBeRoot(this.getArgument(0))\n  }\n}\n\nclass CallBeforeSetuidWrapperCall extends FunctionCall {\n  CallBeforeSetuidFunctionCall baseCall;\n\n  CallBeforeSetuidWrapperCall() {\n    this = baseCall\n    or\n    exists(CallBeforeSetuidWrapperCall fc |\n      this.getTarget() = fc.getEnclosingFunction() and\n      baseCall = fc.getBaseCall()\n    )\n  }\n\n  CallBeforeSetuidFunctionCall getBaseCall() { result = baseCall }\n}\n\npredicate setuidBeforeSetgid(\n  SetuidLikeWrapperCall setuidWrapper, CallBeforeSetuidWrapperCall setgidWrapper\n) {\n  setgidWrapper.getAPredecessor+() = setuidWrapper\n}\n\npredicate isAccessed(FunctionCall fc) {\n  exists(Variable v | v.getAnAssignedValue() = fc)\n  or\n  exists(Operation c | fc = c.getAChild() | c.isCondition())\n  or\n  // ignore pattern where result is intentionally ignored by a cast to void.\n  fc.hasExplicitConversion()\n}\n\nfrom Function func, CallBeforeSetuidFunctionCall fc, SetuidLikeFunctionCall setuid\nwhere\n  setuidBeforeSetgid(setuid, fc) and\n  // Require the call return code to be used in a condition or assigned.\n  // This introduces false negatives where the return is checked but then\n  // errno == EPERM allows execution to continue.\n  not isAccessed(fc) and\n  func = fc.getEnclosingFunction()\nselect fc,\n  \"This function is called within \" + func + \", and potentially after \" +\n    \"$@, and may not succeed. Be sure to check the return code and errno, otherwise permissions \" +\n    \"may not be dropped.\", setuid, setuid.getTarget().getName()",
        "description": "A syscall commonly associated with privilege dropping is being called out of order. Normally a process drops group ID and sets supplemental groups for the target user before setting the target user ID. This can have security impact if the return code from these methods is not checked.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Security/CWE/CWE-273/PrivilegeDroppingOutoforder.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom BlockModeAlgorithm alg, string name, string msg, Expr confSink\nwhere\n  exists(string tmpMsg |\n    (\n      name = alg.getBlockModeName() and\n      name = unknownAlgorithm() and\n      tmpMsg = \"Use of unrecognized block mode algorithm.\"\n      or\n      name != unknownAlgorithm() and\n      name = alg.getBlockModeName() and\n      not name = [\"CBC\", \"CTS\", \"XTS\"] and\n      tmpMsg = \"Use of weak block mode algorithm \" + name + \".\"\n    ) and\n    if alg.hasConfigurationSink() and alg.configurationSink() != alg\n    then (\n      confSink = alg.configurationSink() and msg = tmpMsg + \" Algorithm used at sink: $@.\"\n    ) else (\n      confSink = alg and msg = tmpMsg\n    )\n  )\nselect alg, msg, confSink, confSink.toString()",
        "description": "Finds uses of symmetric encryption block modes that are weak, obsolete, or otherwise unaccepted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/example_alerts/WeakBlockMode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm alg, string name, string msg, Expr confSink\nwhere\n  exists(string tmpMsg |\n    (\n      name = alg.getCurveName() and\n      name = unknownAlgorithm() and\n      tmpMsg = \"Use of unrecognized curve algorithm.\"\n      or\n      name != unknownAlgorithm() and\n      name = alg.getCurveName() and\n      not name =\n        [\n          \"SECP256R1\", \"PRIME256V1\", //P-256\n          \"SECP384R1\", //P-384\n          \"SECP521R1\", //P-521\n          \"ED25519\", \"X25519\"\n        ] and\n      tmpMsg = \"Use of weak curve algorithm \" + name + \".\"\n    ) and\n    if alg.hasConfigurationSink() and alg.configurationSink() != alg\n    then (\n      confSink = alg.configurationSink() and msg = tmpMsg + \" Algorithm used at sink: $@.\"\n    ) else (\n      confSink = alg and msg = tmpMsg\n    )\n  )\nselect alg, msg, confSink, confSink.toString()",
        "description": "Finds uses of weak, unknown, or otherwise unaccepted elliptic curve algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/example_alerts/WeakEllipticCurve.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm alg, Expr confSink, string msg\nwhere\n  exists(string resMsg |\n    (\n      if alg.getEncryptionName() = unknownAlgorithm()\n      then (\n        alg instanceof Literal and\n        resMsg =\n          \"Use of unrecognized symmetric encryption algorithm: \" +\n            alg.(Literal).getValueText().toString() + \".\"\n        or\n        not alg instanceof Literal and\n        resMsg = \"Use of unrecognized symmetric encryption algorithm.\"\n      ) else (\n        not alg.getEncryptionName().matches(\"AES%\") and\n        resMsg = \"Use of banned symmetric encryption algorithm: \" + alg.getEncryptionName() + \".\"\n      )\n    ) and\n    (\n      if alg.hasConfigurationSink() and alg.configurationSink() != alg\n      then (\n        confSink = alg.configurationSink() and msg = resMsg + \" Algorithm used at sink: $@.\"\n      ) else (\n        confSink = alg and msg = resMsg\n      )\n    )\n  )\nselect alg, msg, confSink, confSink.toString()",
        "description": "Finds explicit uses of symmetric encryption algorithms that are weak, unknown, or otherwise unaccepted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/example_alerts/WeakEncryption.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricKeyGeneration op, AsymmetricAlgorithm alg\nwhere\n  alg = op.getAlgorithm() and\n  not alg instanceof EllipticCurveAlgorithm and\n  not exists(op.getKeySizeInBits(alg))\nselect op, \"Use of unknown asymmetric key size for algorithm $@\", alg, alg.getName().toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/example_alerts/UnknownAsymmetricKeyGen.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom HashAlgorithm alg, Expr confSink, string msg\nwhere\n  exists(string name, string msgTmp | name = alg.getHashName() |\n    not name = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n    (\n      if name = unknownAlgorithm()\n      then\n        not alg instanceof Literal and msgTmp = \"Use of unrecognized hash algorithm.\"\n        or\n        alg instanceof Literal and\n        msgTmp =\n          \"Use of unrecognized hash algorithm: \" + alg.(Literal).getValueText().toString() + \".\"\n      else msgTmp = \"Use of banned hash algorithm \" + name + \".\"\n    ) and\n    if alg.hasConfigurationSink() and alg.configurationSink() != alg\n    then (\n      confSink = alg.configurationSink() and msg = msgTmp + \" Algorithm used at sink: $@.\"\n    ) else (\n      confSink = alg and msg = msgTmp\n    )\n  )\nselect alg, msg, confSink, confSink.toString()",
        "description": "Finds explicit uses of cryptographic hash algorithms that are weak and obsolete.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/example_alerts/WeakHashes.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricKeyGeneration op, AsymmetricAlgorithm alg, Expr configSrc, int size\nwhere\n  alg = op.getAlgorithm() and\n  not alg instanceof EllipticCurveAlgorithm and\n  configSrc = op.getKeyConfigurationSource(alg) and\n  size = configSrc.getValue().toInt() and\n  size < 2048\nselect op,\n  \"Use of weak asymmetric key size (in bits) \" + size + \" configured at $@ for algorithm $@\",\n  configSrc, configSrc.toString(), alg, alg.getName().toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/example_alerts/WeakAsymmetricKeyGen.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricEncryptionAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getEncryptionName()",
        "description": "Finds all potential usage of asymmeric keys for encryption or key exchange using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/AsymmetricEncryptionAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\n// TODO: currently not modeled for any API\nfrom BlockModeAlgorithm alg\nwhere not alg.hasIVorNonce()\nselect alg, \"Block mode with unknown IV or Nonce configuration\"",
        "description": "Finds all potentially unknown sources for initialization vectors (IV) or nonce used in block ciphers while using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/BlockModeUnknownIVsOrNonces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\n// TODO: currently not modeled for any API\nfrom SymmetricPadding alg\nselect alg, \"Use of algorithm \" + alg.getPaddingName()",
        "description": "Finds all potential usage of padding schemes used with symmeric algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/SymmetricPaddingAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricKeyGeneration op, CryptographicAlgorithm alg, Expr configSrc\nwhere\n  alg = op.getAlgorithm() and\n  configSrc = op.getKeyConfigurationSource(alg)\nselect op, \"Key generator for algorithm $@ with key configuration $@\", alg, alg.getName(),\n  configSrc, configSrc.toString()",
        "description": "Finds all known potential sources for asymmetric key generation while using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/KnownAsymmetricKeyGeneration.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\n// TODO: currently not modeled for any API\nfrom AsymmetricPadding alg\nselect alg, \"Use of algorithm \" + alg.getPaddingName()",
        "description": "Finds all potential usage of padding schemes used with asymmeric algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/AsymmetricPaddingAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\n// TODO: currently not modeled for any API\nfrom BlockModeAlgorithm alg\nselect alg.getIVorNonce(), \"Block mode IV/Nonce source\"",
        "description": "Finds all potential sources for initialization vectors (IV) or nonce used in block ciphers while using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/BlockModeKnownIVsOrNonces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\n// TODO: currently not modeled for any API\nfrom SigningAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of signing algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/SigningAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom KeyExchangeAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of key exchange using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/KeyExchangeAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm alg, string size\nwhere\n  if not exists(alg.getCurveBitSize())\n  then size = \"UNKNOWN SIZE\"\n  else size = alg.getCurveBitSize().toString()\nselect alg, \"Use of algorithm \" + alg.getCurveName() + \" with key size (in bits) \" + size",
        "description": "Finds all potential key lengths for elliptic curve algorithms usage.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/EllipticCurveAlgorithmSize.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getCurveName()",
        "description": "Finds all potential usage of elliptic curve algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/EllipticCurveAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getEncryptionName()",
        "description": "Finds all potential usage of symmetric encryption algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/SymmetricEncryptionAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of asymmeric keys (RSA & ECC) using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/AllAsymmetricAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom BlockModeAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getBlockModeName()",
        "description": "Finds all potential block cipher modes of operations using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/BlockModeAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom CryptographicAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of cryptographic algorithms usage using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/AllCryptoAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom AuthenticatedEncryptionAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getAuthticatedEncryptionName()",
        "description": "Finds all potential usage of authenticated encryption schemes using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/AuthenticatedEncryptionAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricKeyGeneration op, CryptographicAlgorithm alg\nwhere\n  alg = op.getAlgorithm() and\n  not op.hasKeyConfigurationSource(alg)\nselect op, \"Key generator for algorithm $@ with unknown configuration source\", alg, alg.getName()",
        "description": "Finds all unknown potential sources for asymmetric key generation while using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/UnknownAsymmetricKeyGeneration.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport experimental.cryptography.Concepts\n\nfrom HashAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of cryptographic hash algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/cryptography/inventory/new_models/HashingAlgorithms.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\npredicate sameExpr(Expr e1, Expr e2) { globalValueNumber(e1).getAnExpr() = e2 }\n\nElement nearestParent(Expr e) {\n  if\n    e.getParent().(Expr).getConversion*() instanceof ParenthesisExpr or\n    e.getParent() instanceof IfStmt or\n    e.getParent() instanceof WhileStmt\n  then result = e.getParent()\n  else result = nearestParent(e.getParent())\n}\n\nfrom LogicalAndExpr b, EQExpr eq, NEExpr ne\nwhere\n  (\n    b.getAChild*() = eq and\n    b.getAChild*() = ne and\n    eq.getParent() instanceof LogicalAndExpr and\n    ne.getParent() instanceof LogicalAndExpr\n  ) and\n  (\n    eq.getLeftOperand() instanceof VariableAccess and ne.getLeftOperand() instanceof VariableAccess\n    or\n    eq.getLeftOperand() instanceof PointerDereferenceExpr and\n    ne.getLeftOperand() instanceof PointerDereferenceExpr\n  ) and\n  eq.getRightOperand() instanceof Literal and\n  ne.getRightOperand() instanceof Literal and\n  eq.getLeftOperand().getFullyConverted().getUnspecifiedType() =\n    ne.getLeftOperand().getFullyConverted().getUnspecifiedType() and\n  nearestParent(eq) = nearestParent(ne) and\n  sameExpr(eq.getLeftOperand(), ne.getLeftOperand())\nselect ne, \"This boolean condition is never evaluated and can be deleted.\"",
        "description": "A boolean condition that is guaranteed to never be evaluated should be deleted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Best Practices/UselessTest.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Variable var, ArrayExpr useExpr, ArrayType defLine, VariableAccess use\nwhere\n  var.getUnspecifiedType() = defLine and\n  use = useExpr.getArrayBase() and\n  var = use.getTarget() and\n  (\n    useExpr.getArrayOffset().getType() instanceof UInt16_t or\n    useExpr.getArrayOffset().getType() instanceof UInt32_t or\n    useExpr.getArrayOffset().getType() instanceof UInt64_t\n  ) and\n  defLine.getArraySize() <= 256\nselect useExpr,\n  \"Using a \" + useExpr.getArrayOffset().getType() + \" to access the array $@ of size \" +\n    defLine.getArraySize() + \".\", var, var.getName()",
        "description": "Access an array of size lower than 256 with a uint16.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Best Practices/WrongUintAccess.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.new.DataFlow\n\nfrom Function nuller, Parameter pd, FunctionCall fc, Variable v\nwhere\n  mayReturnNull(nuller) and\n  functionDereferences(pd.getFunction(), pd.getIndex()) and\n  // there is a function call which will deref parameter pd\n  fc.getTarget() = pd.getFunction() and\n  // the parameter pd comes from a variable v\n  DataFlow::localFlow(DataFlow::exprNode(v.getAnAccess()),\n    DataFlow::exprNode(fc.getArgument(pd.getIndex()))) and\n  // this variable v was assigned by a call to the nuller function\n  unique( | | v.getAnAssignedValue()) = nuller.getACallToThisFunction() and\n  // this variable v is not accessed for an operation (check for NULLness)\n  not exists(VariableAccess vc |\n    vc.getTarget() = v and\n    (vc.getParent() instanceof Operation or vc.getParent() instanceof IfStmt)\n  )\nselect fc, \"This function call may deref $@ when it can be NULL from $@\", v, v.getName(), nuller,\n  nuller.getName()",
        "description": "A function parameter is dereferenced, while it comes from a function that may return NULL, and is not checked for nullness by the caller.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Likely Bugs/DerefNullResult.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.internal.ProductFlow\nimport semmle.code.cpp.rangeanalysis.new.internal.semantic.analysis.RangeAnalysis\nimport semmle.code.cpp.rangeanalysis.new.internal.semantic.SemanticExprSpecific\nimport semmle.code.cpp.rangeanalysis.new.internal.semantic.analysis.Bound\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.models.interfaces.Allocation\nimport semmle.code.cpp.ir.IRConfiguration\nimport ArraySizeFlow::PathGraph1\n\n// temporary - custom allocator for ffmpeg\nclass AvBufferAlloc extends AllocationFunction {\n  AvBufferAlloc() { this.hasGlobalName([\"av_mallocz\", \"av_malloc\"]) }\n\n  override int getSizeArg() { result = 0 }\n}\n\n// temporary - custom allocator for php\nclass PhpEmalloc extends AllocationFunction {\n  PhpEmalloc() { this.hasGlobalName([\"_emalloc\"]) }\n\n  override int getSizeArg() { result = 0 }\n}\n\npredicate bounded(Instruction i, Bound b, int delta, boolean upper) {\n  // TODO: reason\n  semBounded(getSemanticExpr(i), b, delta, upper, _)\n}\n\nmodule ArraySizeConfig implements ProductFlow::ConfigSig {\n  predicate isSourcePair(DataFlow::Node source1, DataFlow::Node source2) {\n    source1.asConvertedExpr().(AllocationExpr).getSizeExpr() = source2.asConvertedExpr()\n  }\n\n  predicate isSinkPair(DataFlow::Node sink1, DataFlow::Node sink2) {\n    exists(PointerAddInstruction pai, int delta |\n      isSinkPair1(sink1, sink2, pai, delta) and\n      (\n        delta = 0 and\n        exists(DataFlow::Node paiNode, DataFlow::Node derefNode |\n          DataFlow::localFlow(paiNode, derefNode) and\n          paiNode.asInstruction() = pai and\n          derefNode.asOperand() instanceof AddressOperand\n        )\n        or\n        delta >= 1\n      )\n    )\n  }\n}\n\nmodule ArraySizeFlow = ProductFlow::Global<ArraySizeConfig>;\n\npragma[nomagic]\npredicate isSinkPair1(\n  DataFlow::Node sink1, DataFlow::Node sink2, PointerAddInstruction pai, int delta\n) {\n  exists(Instruction index, ValueNumberBound b |\n    pai.getRight() = index and\n    pai.getLeft() = sink1.asInstruction() and\n    bounded(index, b, delta, true) and\n    sink2.asInstruction() = b.getInstruction()\n  )\n}\n\nfrom\n  ArraySizeFlow::PathNode1 source1, ArraySizeFlow::PathNode2 source2,\n  ArraySizeFlow::PathNode1 sink1, ArraySizeFlow::PathNode2 sink2\nwhere ArraySizeFlow::flowPath(source1, source2, sink1, sink2)\n// TODO: pull delta out and display it\nselect sink1.getNode(), source1, sink1, \"Off-by one error allocated at $@ bounded by $@.\", source1,\n  source1.toString(), sink2, sink2.toString()",
        "description": "TODO",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Likely Bugs/ArrayAccessProductFlow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate blockDominates(BlockStmt check, BlockStmt access) {\n  check.getLocation().getStartLine() <= access.getLocation().getStartLine() and\n  check.getLocation().getEndLine() >= access.getLocation().getEndLine()\n}\n\npredicate isCheckedInstruction(VariableAccess unchecked, VariableAccess checked) {\n  checked = any(VariableAccess va | va.getTarget() = unchecked.getTarget()) and\n  //Simple test if the first access in this code path is dereferenced\n  not dereferenced(checked) and\n  blockDominates(checked.getEnclosingBlock(), unchecked.getEnclosingBlock())\n}\n\npredicate candidateResultUnchecked(VariableAccess unchecked) {\n  not isCheckedInstruction(unchecked, _)\n}\n\npredicate candidateResultChecked(VariableAccess check, EqualityOperation eqop) {\n  //not dereferenced to check against pointer, not its pointed value\n  not dereferenced(check) and\n  //assert macros are not taken into account\n  not check.isInMacroExpansion() and\n  // is part of a comparison against some constant NULL\n  eqop.getAnOperand() = check and\n  eqop.getAnOperand() instanceof NullValue\n}\n\nfrom VariableAccess unchecked, VariableAccess check, EqualityOperation eqop, Parameter param\nwhere\n  // a dereference\n  dereferenced(unchecked) and\n  // for a function parameter\n  unchecked.getTarget() = param and\n  // this function parameter is not overwritten\n  not exists(param.getAnAssignment()) and\n  check.getTarget() = param and\n  // which is once checked\n  candidateResultChecked(check, eqop) and\n  // and which has not been checked before in this code path\n  candidateResultUnchecked(unchecked)\nselect check, \"This null check is redundant or there is a missing null check before $@.\", unchecked,\n  \"where dereferencing happens\"",
        "description": "Checking a parameter for nullness in one path, and not in another is likely to be a sign that either the check can be removed, or added in the other case.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/Likely Bugs/RedundantNullCheckParam.ql",
        "language": "cpp"
    },
    {
        "query": "import experimental.quantum.Language\n\nquery predicate nodes(Crypto::NodeBase node, string key, string value) {\n  Crypto::nodes_graph_impl(node, key, value)\n}\n\nquery predicate edges(Crypto::NodeBase source, Crypto::NodeBase target, string key, string value) {\n  Crypto::edges_graph_impl(source, target, key, value)\n}\n\nquery predicate graphProperties(string key, string value) {\n  key = \"semmle.graphKind\" and value = \"graph\"\n}",
        "description": "Outputs a graph representation of the cryptographic bill of materials. This query only supports DGML output, as CodeQL DOT output omits properties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/experimental/quantum/PrintCBOMGraph.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricFunction f, int n\nwhere\n  n = f.getNumberOfLines() and\n  n > 100 and\n  f.getCommentRatio() <= 0.02 and\n  not f.isMultiplyDefined()\nselect f,\n  \"Poorly documented function: fewer than 2% comments for a function of \" + n.toString() + \" lines.\"",
        "description": "Large functions that have no or almost no comments are likely to be too complex to understand and maintain. The larger a function is, the more problematic the lack of comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Documentation/UncommentedFunction.ql",
        "language": "cpp"
    },
    {
        "query": "import CommentedOutCode\n\nfrom CommentedOutCode comment\nselect comment, \"This comment appears to contain commented-out code.\"",
        "description": "Commented-out code makes the remaining code more difficult to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Documentation/CommentedOutCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate isCommented(FunctionDeclarationEntry f) {\n  exists(Comment c | c.getCommentedElement() = f)\n}\n\n// Uses of 'f' in 'other'\nCall uses(File other, Function f) { result.getTarget() = f and result.getFile() = other }\n\nfrom File callerFile, Function f, Call use, int numCalls\nwhere\n  numCalls = strictcount(File other | exists(uses(other, f)) and other != f.getFile()) and\n  not isCommented(f.getADeclarationEntry()) and\n  not f instanceof Constructor and\n  not f instanceof Destructor and\n  not f.hasName(\"operator=\") and\n  f.getMetrics().getNumberOfLinesOfCode() >= 5 and\n  numCalls > 1 and\n  use = uses(callerFile, f) and\n  callerFile != f.getFile()\nselect f, \"Functions called from other files should be documented (called from $@).\", use,\n  use.getFile().getRelativePath()",
        "description": "Functions used from outside the file they are declared in should be documented, as they are part of a public API. Without comments, modifying such functions is dangerous because callers easily come to rely on their exact implementation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Documentation/DocumentApi.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Documentation.CaptionedComments\n\nfrom Comment c, string message\nwhere message = getCommentTextCaptioned(c, \"TODO\")\nselect c, message",
        "description": "Comments containing 'TODO' indicate that the code may be in an incomplete state.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Documentation/TodoComments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Documentation.CaptionedComments\n\nfrom Comment c, string message\nwhere message = getCommentTextCaptioned(c, \"FIXME\")\nselect c, message",
        "description": "Comments containing 'FIXME' indicate that the code has known bugs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Documentation/FixmeComments.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.pointsto.PointsTo\n\nselect count(int set, Element location | setlocations(set, unresolveElement(location))),\n  count(int set, Element element | pointstosets(set, unresolveElement(element)))",
        "description": "Query to force evaluation of staged points-to predicates",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/PointsTo/PreparedStagedPointsTo.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.pointsto.PointsTo\n\npredicate inc(int set, int cnt) {\n  (setflow(set, _) or setflow(_, set)) and\n  cnt = count(int i | setflow(i, set) and i != set)\n}\n\nselect count(int set | inc(set, _)) as total, count(int set | inc(set, 0)) as nullary,\n  count(int set | inc(set, 1)) as unary, total - nullary - unary as rest",
        "description": "Count the number points-to sets with 0 or 1 incoming flow edges, and the total number of points-to sets",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/PointsTo/Stats.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.pointsto.PointsTo\n\nclass FieldAccessPT extends PointsToExpr {\n  override predicate interesting() { this instanceof FieldAccess }\n}\n\nfrom Function outer, FieldAccessPT fa\nwhere\n  outer.hasName(\"rtLnDeliverableMayContainDividends\") and\n  fa.(FieldAccess).getTarget().hasName(\"pfFunction\") and\n  fa.getEnclosingFunction() = outer\nselect fa, fa.pointsTo()",
        "description": "Query to help investigate mysterious results with ReturnStackAllocatedObject",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/PointsTo/Debug.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.pointsto.PointsTo\nimport semmle.code.cpp.pointsto.CallGraph\n\npredicate inputArgument(string function, int arg) {\n  function = \"read\" and arg = 1\n  or\n  function = \"fread\" and arg = 0\n  or\n  function = \"fgets\" and arg = 0\n  // ... add more\n}\n\npredicate inputBuffer(Expr e) {\n  exists(FunctionCall fc, string fname, int i |\n    fc.getTarget().getName() = fname and\n    inputArgument(fname, i) and\n    e = fc.getArgument(i)\n  )\n}\n\nclass InputBuffer extends PointsToExpr {\n  InputBuffer() { inputBuffer(this) }\n\n  override predicate interesting() { inputBuffer(this) }\n}\n\npredicate formatArgument(string function, int i) {\n  function = \"printf\" and i = 0\n  or\n  function = \"fprintf\" and i = 1\n  or\n  function = \"sprintf\" and i = 1\n  or\n  function = \"snprintf\" and i = 2\n  or\n  function = \"d_printf\" and i = 0\n  or\n  function = \"talloc_asprintf\" and i = 1\n  or\n  function = \"fstr_sprintf\" and i = 1\n  or\n  function = \"talloc_asprintf_append\" and i = 1\n  or\n  function = \"d_fprintf\" and i = 1\n  or\n  function = \"asprintf\" and i = 1\n  or\n  function = \"talloc_asprintf_append_buffer\" and i = 1\n  or\n  function = \"fdprintf\" and i = 1\n  or\n  function = \"d_vfprintf\" and i = 1\n  or\n  function = \"smb_xvasprintf\" and i = 1\n  or\n  function = \"asprintf_strupper_m\" and i = 1\n  or\n  function = \"talloc_asprintf_strupper_m\" and i = 1\n  or\n  function = \"sprintf_append\" and i = 4\n  or\n  function = \"x_vfprintf\" and i = 1\n  or\n  function = \"x_fprintf\" and i = 1\n  or\n  function = \"vasprintf\" and i = 1\n  or\n  function = \"ldb_asprintf_errstring\" and i = 1\n  or\n  function = \"talloc_vasprintf\" and i = 1\n  or\n  function = \"talloc_vasprintf\" and i = 1\n  or\n  function = \"fprintf_file\" and i = 1\n  or\n  function = \"vsnprintf\" and i = 2\n  or\n  function = \"talloc_vasprintf_append\" and i = 1\n  or\n  function = \"__talloc_vaslenprintf_append\" and i = 2\n  or\n  function = \"talloc_vasprintf_append_buffer\" and i = 1\n  or\n  function = \"fprintf_attr\" and i = 2\n  or\n  function = \"vprintf\" and i = 0\n  or\n  function = \"vsprintf\" and i = 1\n}\n\npredicate formatBuffer(Expr e) {\n  exists(FunctionCall fc, string fname, int i |\n    fc.getTarget().getName() = fname and\n    formatArgument(fname, i) and\n    fc.getArgument(i) = e\n  )\n}\n\nclass FormatBuffer extends PointsToExpr {\n  FormatBuffer() { formatBuffer(this) }\n\n  override predicate interesting() { formatBuffer(this) }\n}\n\npredicate potentialViolation(InputBuffer source, FormatBuffer dest) {\n  source.pointsTo() = dest.pointsTo() and\n  not exists(FunctionCall fc |\n    fc = dest and fc.getTarget().hasName(\"lang_msg_rotate\") and fc.getArgument(1) instanceof Literal\n  )\n}\n\nfrom InputBuffer source, FormatBuffer dest\nwhere potentialViolation(source, dest)\nselect dest.getFile() as file, dest as formatString",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/PointsTo/TaintedFormatStrings.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate permissibleConversion(Type t) {\n  t instanceof IntegralType or\n  t instanceof FunctionPointerType or\n  permissibleConversion(t.getUnspecifiedType()) or\n  permissibleConversion(t.(TypedefType).getBaseType()) or\n  permissibleConversion(t.(ReferenceType).getBaseType())\n}\n\nfrom Expr e, Type converted\nwhere\n  e.getType() instanceof FunctionPointerType and\n  e.getFullyConverted().getType() = converted and\n  not permissibleConversion(converted)\nselect e,\n  \"Function pointer converted to \" + converted.getName() + \", which is not an integral type.\"",
        "description": "Conversions shall not be performed between a pointer to a function and any type other than an integral type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 30/FunctionPointerConversions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nint firstCodeLine(File f) {\n  result =\n    min(Declaration d, Location l, int toMin |\n      (\n        l = d.getLocation() and\n        l.getFile() = f and\n        not d.isInMacroExpansion()\n      ) and\n      toMin = l.getStartLine()\n    |\n      toMin\n    )\n}\n\nint badIncludeLine(File f, Include i) {\n  result = i.getLocation().getStartLine() and\n  result > firstCodeLine(f) and\n  f = i.getFile()\n}\n\nfrom File f, Include i, int line\nwhere\n  line = badIncludeLine(f, i) and\n  line = min(badIncludeLine(f, _))\nselect i,\n  \"'\" + i.toString() + \"' is preceded by code -- it should be moved above line \" + firstCodeLine(f) +\n    \" in \" + f.getBaseName() + \".\"",
        "description": "#include directives in a file shall only be preceded by other preprocessor directives or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 31/IncludesFirst.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nstring lengthWarning(Function f) {\n  exists(int lines | lines = f.getMetrics().getNumberOfLines() |\n    lines > 60 and\n    result = f.getName() + \" has too many lines (\" + lines + \", while 60 are allowed).\"\n  )\n}\n\nstring paramWarning(Function f) {\n  exists(int params | params = f.getMetrics().getNumberOfParameters() |\n    params > 6 and\n    result = f.getName() + \" has too many parameters (\" + params + \", while 6 are allowed).\"\n  )\n}\n\nfrom Function f, string msg\nwhere\n  msg = lengthWarning(f) or\n  msg = paramWarning(f)\nselect f, msg",
        "description": "Function length should be limited to what can be printed on a single sheet of paper (60 lines). Number of parameters is limited to 6 or fewer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 25/FunctionSizeLimits.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PreprocessorUndef u\nselect u, \"The #undef directive shall not be used.\"",
        "description": "#undef shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 22/UseOfUndef.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass FileWithDirectives extends File {\n  FileWithDirectives() { exists(Directive d | d.getFile() = this) }\n\n  int getDirectiveLine(Directive d) {\n    d.getFile() = this and d.getLocation().getStartLine() = result\n  }\n\n  int getDirectiveIndex(Directive d) {\n    exists(int line | line = this.getDirectiveLine(d) |\n      line = rank[result](this.getDirectiveLine(_))\n    )\n  }\n\n  int depth(Directive d) {\n    exists(int index | index = this.getDirectiveIndex(d) |\n      index = 1 and result = d.depthChange()\n      or\n      exists(Directive prev | this.getDirectiveIndex(prev) = index - 1 |\n        result = d.depthChange() + this.depth(prev)\n      )\n    )\n  }\n\n  Directive lastDirective() { this.getDirectiveIndex(result) = max(this.getDirectiveIndex(_)) }\n}\n\nabstract class Directive extends PreprocessorDirective {\n  abstract int depthChange();\n\n  abstract predicate mismatched();\n\n  int depth() { exists(FileWithDirectives f | f.depth(this) = result) }\n}\n\nclass IfDirective extends Directive {\n  IfDirective() {\n    this instanceof PreprocessorIf or\n    this instanceof PreprocessorIfdef or\n    this instanceof PreprocessorIfndef\n  }\n\n  override int depthChange() { result = 1 }\n\n  override predicate mismatched() { none() }\n}\n\nclass ElseDirective extends Directive {\n  ElseDirective() {\n    this instanceof PreprocessorElif or\n    this instanceof PreprocessorElse\n  }\n\n  override int depthChange() { result = 0 }\n\n  override predicate mismatched() { this.depth() < 1 }\n}\n\nclass EndifDirective extends Directive instanceof PreprocessorEndif {\n  override int depthChange() { result = -1 }\n\n  override predicate mismatched() { this.depth() < 0 }\n}\n\nfrom FileWithDirectives f, Directive d, string msg\nwhere\n  d.getFile() = f and\n  if d.mismatched()\n  then msg = \"'\" + d + \"' has no matching #if in file \" + f.getBaseName() + \".\"\n  else (\n    d = f.lastDirective() and\n    d.depth() > 0 and\n    msg = \"File \" + f.getBaseName() + \" ends with \" + d.depth() + \" unterminated #if directives.\"\n  )\nselect d, msg",
        "description": "All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 23/MismatchedIfdefs.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom DeclStmt d\nwhere\n  exists(Variable v1, Variable v2 | v1 = d.getADeclaration() and v2 = d.getADeclaration() |\n    v1 != v2 and\n    v1.getLocation().getStartLine() = v2.getLocation().getStartLine()\n  )\nselect d, \"Multiple variable declarations on the same line.\"",
        "description": "There should be no more than one variable declaration per line.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 24/MultipleVarDeclsPerLine.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass OneLineStmt extends Stmt {\n  OneLineStmt() {\n    this.getLocation().getStartLine() = this.getLocation().getEndLine() and\n    not exists(ForStmt for | this = for.getInitialization())\n  }\n\n  predicate onLine(File f, int line) {\n    f = this.getFile() and line = this.getLocation().getStartLine()\n  }\n}\n\nint numStmt(File f, int line) { result = strictcount(OneLineStmt o | o.onLine(f, line)) }\n\nfrom File f, int line, OneLineStmt o, int cnt\nwhere\n  numStmt(f, line) = cnt and\n  cnt > 1 and\n  o.onLine(f, line) and\n  o.getLocation().getStartColumn() =\n    min(OneLineStmt other, int toMin |\n      other.onLine(f, line) and toMin = other.getLocation().getStartColumn()\n    |\n      toMin\n    )\nselect o, \"This line contains \" + cnt + \" statements; only one is allowed.\"",
        "description": "Putting more than one statement on a single line hinders program understanding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 24/MultipleStmtsPerLine.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nint lineInBlock(File f) {\n  exists(BlockStmt block, Location blockLocation |\n    block.getFile() = f and blockLocation = block.getLocation()\n  |\n    result in [blockLocation.getStartLine() .. blockLocation.getEndLine()]\n  )\n}\n\nfrom Macro m\nwhere m.getLocation().getStartLine() = lineInBlock(m.getFile())\nselect m, \"The macro \" + m.getHead() + \" is defined in a block.\"",
        "description": "Macros shall not be #define'd within a function or a block.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 21/MacroInBlock.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nstring var(Variable v) {\n  exists(int level | level = v.getType().getPointerIndirectionLevel() |\n    level > 2 and\n    result =\n      \"The type of \" + v.getName() + \" uses \" + level +\n        \" levels of pointer indirection -- maximum allowed is 2.\"\n  )\n}\n\nstring fun(Function f) {\n  exists(int level | level = f.getType().getPointerIndirectionLevel() |\n    level > 2 and\n    result =\n      \"The return type of \" + f.getName() + \" uses \" + level +\n        \" levels of pointer indirection -- maximum allowed is 2.\"\n  )\n}\n\nfrom Declaration d, string msg\nwhere msg = var(d) or msg = fun(d)\nselect d, msg",
        "description": "The declaration of an object should contain no more than two levels of indirection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 26/DeclarationPointerNesting.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Macro m\nwhere\n  forex(MacroInvocation mi | mi.getMacro() = m |\n    exists(PointerDereferenceExpr e, Location miLoc, Location eLoc | e = mi.getAGeneratedElement() |\n      miLoc = mi.getLocation() and\n      eLoc = e.getLocation() and\n      eLoc.getStartColumn() = miLoc.getStartColumn() and\n      eLoc.getStartLine() = miLoc.getStartLine()\n    )\n  )\nselect m, \"The macro \" + m.getHead() + \" hides pointer dereference operations.\"",
        "description": "Pointer dereference operations should not be hidden in macro definitions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 28/HiddenPointerDereferenceMacro.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom TypedefType t\nwhere t.getBaseType().getPointerIndirectionLevel() > 0\nselect t, \"The typedef \" + t.getName() + \" hides pointer indirection.\"",
        "description": "Pointer indirection may not be hidden by typedefs -- \"typedef int* IntPtr;\" is not allowed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 28/HiddenPointerIndirectionTypedef.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom ExprCall c\nwhere not c.getExpr().getType().isConst()\nselect c, \"This call does not go through a const function pointer.\"",
        "description": "Non-constant pointers to functions should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 29/NonConstFunctionPointer.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PointerDereferenceExpr e, int n\nwhere\n  not e.getParent+() instanceof PointerDereferenceExpr and\n  n = strictcount(PointerDereferenceExpr child | child.getParent+() = e) and\n  n > 1\nselect e, \"This expression involves \" + n + \" levels of pointer dereference; 2 are allowed.\"",
        "description": "Statements should contain no more than two levels of dereferencing per object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 27/PointerDereferenceInStmt.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PreprocessorDirective i\nwhere\n  (i instanceof PreprocessorIf or i instanceof PreprocessorIfdef or i instanceof PreprocessorIfndef) and\n  not i.getFile() instanceof HeaderFile\nselect i, \"Use of conditional compilation must be kept to a minimum.\"",
        "description": "The use of conditional compilation directives must be kept to a minimum -- e.g. for header guards only.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 20/PreprocessorUseIfdef.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate incomplete(Macro m) {\n  exists(string body | body = m.getBody() and not m.getBody().matches(\"%\\\\\") |\n    body.regexpMatch(\"[^(]*\\\\).*\") or\n    body.regexpMatch(\"[^\\\\[]*].*\") or\n    body.regexpMatch(\"[^{]*}.*\") or\n    body.regexpMatch(\".*\\\\([^)]*\") or\n    body.regexpMatch(\".*\\\\[[^\\\\]]*\") or\n    body.regexpMatch(\".*\\\\{[^}]*\") or\n    count(body.indexOf(\"(\")) != count(body.indexOf(\")\")) or\n    count(body.indexOf(\"[\")) != count(body.indexOf(\"]\")) or\n    count(body.indexOf(\"{\")) != count(body.indexOf(\"}\"))\n  )\n}\n\nfrom Macro m\nwhere incomplete(m)\nselect m, \"The macro \" + m.getHead() + \" will not expand into a syntactic unit.\"",
        "description": "Macros must expand to complete syntactic units -- \"#define MY_IF if(\" is not legal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 20/PreprocessorUsePartial.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Macro m, string msg\nwhere\n  m.getHead().matches(\"%...%\") and\n  msg = \"The macro \" + m.getHead() + \" is variadic, and hence not allowed.\"\n  or\n  m.getBody().matches(\"%##%\") and\n  msg = \"The macro \" + m.getHead() + \" uses token pasting and is not allowed.\"\nselect m, msg",
        "description": "Macros are not allowed to use complex preprocessor features like variable argument lists and token pasting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 20/PreprocessorUseUndisciplined.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PreprocessorDirective p\nwhere\n  not p instanceof Include and\n  not p instanceof Macro and\n  not p instanceof PreprocessorIf and\n  not p instanceof PreprocessorElif and\n  not p instanceof PreprocessorElse and\n  not p instanceof PreprocessorIfdef and\n  not p instanceof PreprocessorIfndef and\n  not p instanceof PreprocessorEndif\nselect p, \"This preprocessor directive is not allowed.\"",
        "description": "The use of the preprocessor must be limited to inclusion of header files and simple macro definitions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-4/Rule 20/PreprocessorUse.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate whitelist(Function f) {\n  // Example:\n  // f.hasName(\"printf\") or f.hasName(\"close\") or // ...\n  none()\n}\n\nfrom FunctionCall c, string msg\nwhere\n  not c.getTarget().getType() instanceof VoidType and\n  not whitelist(c.getTarget()) and\n  (\n    c instanceof ExprInVoidContext and\n    msg = \"The return value of non-void function $@ is not checked.\"\n    or\n    definition(_, c.getParent()) and\n    not definitionUsePair(_, c.getParent(), _) and\n    msg = \"$@'s return value is stored but not checked.\"\n  )\nselect c, msg, c.getTarget() as f, f.getName()",
        "description": "The return value of each non-void function call should be checked for error conditions, or cast to (void) if irrelevant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 14/CheckingReturnValues.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass LocalVariableOrParameter extends Variable {\n  LocalVariableOrParameter() {\n    this instanceof LocalVariable\n    or\n    // A function declaration (i.e. \"int foo(int bar);\") doesn't usefully\n    // shadow globals; the parameter should be on the version of the function\n    // that has a body.\n    exists(Parameter p | p = this |\n      p.getFunction().getDefinitionLocation().getFile() = this.getFile() and\n      exists(p.getFunction().getBlock())\n    )\n  }\n\n  string type() {\n    if this instanceof Parameter then result = \"Parameter \" else result = \"Local variable \"\n  }\n}\n\nfrom LocalVariableOrParameter lv, GlobalVariable gv\nwhere\n  lv.getName() = gv.getName() and\n  lv.getFile() = gv.getFile()\nselect lv, lv.type() + lv.getName() + \" hides the global variable $@.\", gv, gv.getName()",
        "description": "A local variable or parameter that hides a global variable of the same name.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 13/LimitedScopeLocalHidesGlobal.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom VariableDeclarationEntry v\nwhere\n  v.getVariable() instanceof GlobalVariable and\n  v.hasSpecifier(\"extern\") and\n  not v.getFile() instanceof HeaderFile\nselect v, v.getName() + \" should be declared only in a header file that is included as needed.\"",
        "description": "All \"extern\" declarations should be placed in a header file that is included in every file referring to the corresponding data object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 13/ExternDeclsInHeader.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom GlobalVariable v, Function f\nwhere\n  v.getAnAccess().getEnclosingFunction() = f and\n  strictcount(v.getAnAccess().getEnclosingFunction()) = 1 and\n  forall(VariableAccess a | a = v.getAnAccess() | exists(a.getEnclosingFunction())) and\n  not v.getADeclarationEntry().getFile() instanceof HeaderFile // intended to be accessed elsewhere\nselect v,\n  \"The variable \" + v.getName() + \" is only accessed in $@ and should be scoped accordingly.\", f,\n  f.getName()",
        "description": "Global and file-scope variables that are accessed by only one function should be scoped within that function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 13/LimitedScopeFunction.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom GlobalVariable v\nwhere\n  forex(VariableAccess va | va.getTarget() = v | va.getFile() = v.getDefinitionLocation().getFile()) and\n  not v.hasSpecifier(\"static\") and\n  strictcount(v.getAnAccess().getEnclosingFunction()) > 1 and // If = 1, variable should be function-scope.\n  not v.getADeclarationEntry().getFile() instanceof HeaderFile // intended to be accessed elsewhere\nselect v,\n  \"The global variable \" + v.getName() + \" is not accessed outside of \" + v.getFile().getBaseName() +\n    \" and could be made static.\"",
        "description": "Global variables that are not accessed outside their own file should be made static to promote information hiding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 13/LimitedScopeFile.ql",
        "language": "cpp"
    },
    {
        "query": "import JPL_C.Tasks\n\npredicate flow(Parameter p, ControlFlowNode n) {\n  exists(p.getAnAccess()) and n = p.getFunction().getBlock()\n  or\n  exists(ControlFlowNode mid |\n    flow(p, mid) and not mid = p.getAnAccess() and n = mid.getASuccessor()\n  )\n}\n\nVariableAccess firstAccess(Parameter p) { flow(p, result) and result = p.getAnAccess() }\n\nfrom Parameter p, VariableAccess va\nwhere\n  va = firstAccess(p) and\n  p.getFunction() instanceof PublicFunction and\n  not exists(Expr e | e.isCondition() | e.getAChild*() = va)\nselect va, \"This use of parameter \" + p.getName() + \" has not been checked.\"",
        "description": "Functions should check their arguments before their first use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 15/CheckingParameterValues.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate safeFunctionWhitelist(Function f) {\n  exists(string name | name = f.getName() |\n    // List functions by name which are not correctly identified\n    // as side-effect free. For example, for strlen, one might do:\n    // name = \"strlen\" or\n    none()\n  )\n}\n\nPointerType getAPointerType(Type t) {\n  result = t or\n  result = getAPointerType(t.getUnderlyingType()) or\n  result = getAPointerType(t.(DerivedType).getBaseType()) or\n  result = getAPointerType(t.(Class).getAMemberVariable().getType())\n}\n\npredicate inherentlyUnsafe(Function f) {\n  exists(Variable v | v.getAnAssignedValue().getEnclosingFunction() = f |\n    v instanceof GlobalVariable or\n    v.isStatic()\n  )\n  or\n  exists(FunctionCall c | c.getEnclosingFunction() = f | inherentlyUnsafe(c.getTarget()))\n}\n\npredicate safeToCall(Function f) {\n  forall(PointerType paramPointerType |\n    paramPointerType = getAPointerType(f.getAParameter().getType())\n  |\n    paramPointerType.getBaseType().isConst()\n  ) and\n  not inherentlyUnsafe(f)\n}\n\nclass BooleanExpression extends Expr {\n  BooleanExpression() {\n    exists(Loop l | l.getControllingExpr() = this) or\n    exists(IfStmt i | i.getCondition() = this) or\n    exists(ConditionalExpr e | e.getCondition() = this)\n  }\n}\n\npredicate hasSideEffect(Expr e) {\n  e instanceof Assignment\n  or\n  e instanceof CrementOperation\n  or\n  e instanceof ExprCall\n  or\n  exists(Function f | f = e.(FunctionCall).getTarget() and not safeFunctionWhitelist(f) |\n    inherentlyUnsafe(f) or not safeToCall(f)\n  )\n  or\n  hasSideEffect(e.getAChild())\n}\n\nfrom BooleanExpression b\nwhere hasSideEffect(b)\nselect b, \"This Boolean expression is not side-effect free.\"",
        "description": "The evaluation of a Boolean expression shall have no side effects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 19/NoBooleanSideEffects.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate allowedTypedefs(TypedefType t) {\n  t.getName() =\n    [\n      \"I64\", \"U64\", \"I32\", \"U32\", \"I16\", \"U16\", \"I8\", \"U8\", \"F64\", \"F32\", \"int64_t\", \"uint64_t\",\n      \"int32_t\", \"uint32_t\", \"int16_t\", \"uint16_t\", \"int8_t\", \"uint8_t\"\n    ]\n}\n\nType getAnImmediateUsedType(Declaration d) {\n  d.hasDefinition() and\n  (\n    result = d.(Function).getType() or\n    result = d.(Variable).getType()\n  )\n}\n\nType getAUsedType(Type t) {\n  not allowedTypedefs(t) and\n  (\n    result = t.(TypedefType).getBaseType() or\n    result = t.(DerivedType).getBaseType()\n  )\n}\n\npredicate problematic(IntegralType t) {\n  // List any exceptions that should be allowed.\n  any()\n}\n\nfrom Declaration d, Type usedType\nwhere\n  usedType = getAUsedType*(getAnImmediateUsedType(d)) and\n  problematic(usedType) and\n  // Allow uses of boolean types where defined by the language.\n  not usedType instanceof BoolType and\n  // Ignore violations for which we do not have a valid location.\n  not d.getLocation() instanceof UnknownLocation\nselect d,\n  d.getName() + \" uses the basic integral type \" + usedType.getName() +\n    \" rather than a typedef with size and signedness.\"",
        "description": "Typedefs that indicate size and signedness should be used in place of the basic types.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 17/BasicIntTypes.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nfrom Assertion a\nwhere not a.getAsserted().isPure()\nselect a.getAsserted(), \"Assertions should not have side effects.\"",
        "description": "Assertions should not have side-effects -- they may be disabled completely, changing program behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 16/UseOfAssertionsSideEffect.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nfrom Assertion a, string value, string msg\nwhere\n  value = a.getAsserted().getValue() and\n  if value.toInt() = 0\n  then msg = \"This assertion is always false.\"\n  else msg = \"This assertion is always true.\"\nselect a.getAsserted(), msg",
        "description": "Assertions should check dynamic properties of pre-/post-conditions and invariants. Assertions that either always succeed or always fail are an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 16/UseOfAssertionsConstant.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nfrom Assertion a\nwhere a.getAsserted().getType() instanceof PointerType\nselect a.getAsserted(), \"Assertions should be defined as Boolean tests.\"",
        "description": "Assertions should be defined as Boolean tests, meaning \"assert(p != NULL)\" rather than \"assert(p)\".",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 16/UseOfAssertionsNonBoolean.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nfrom Function f\nwhere\n  f.getMetrics().getNumberOfLinesOfCode() > 10 and\n  not exists(Assertion a | a.getAsserted().getEnclosingFunction() = f)\nselect f, \"All functions of more than 10 lines should have at least one assertion.\"",
        "description": "All functions of more than 10 lines should have at least one assertion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 16/UseOfAssertionsDensity.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom BinaryOperation parent, BinaryOperation child\nwhere\n  parent.getAnOperand() = child and\n  not child.isParenthesised() and\n  (parent instanceof BinaryBitwiseOperation or child instanceof BinaryBitwiseOperation) and\n  // Some benign cases...\n  not (parent instanceof BitwiseAndExpr and child instanceof BitwiseAndExpr) and\n  not (parent instanceof BitwiseOrExpr and child instanceof BitwiseOrExpr) and\n  not (parent instanceof BitwiseXorExpr and child instanceof BitwiseXorExpr)\nselect parent, \"This expression involving bitwise operations should be bracketed.\"",
        "description": "In compound expressions with multiple sub-expressions the intended order of evaluation shall be made explicit with parentheses.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-3/Rule 18/CompoundExpressions.ql",
        "language": "cpp"
    },
    {
        "query": "import Semaphores\n\nLockOperation maybeLocked(Function f) {\n  result.getEnclosingFunction() = f\n  or\n  exists(Function g | f.calls(g) | result = maybeLocked(g))\n}\n\npredicate intraproc(LockOperation inner, string msg, LockOperation outer) {\n  inner = outer.getAReachedNode() and\n  outer.getLocked() != inner.getLocked() and\n  msg = \"This lock operation is nested in a $@.\"\n}\n\npredicate interproc(FunctionCall inner, string msg, LockOperation outer) {\n  inner = outer.getAReachedNode() and\n  exists(LockOperation lock |\n    lock = maybeLocked(inner.getTarget()) and lock.getLocked() != outer.getLocked()\n  |\n    msg = \"This call may perform a \" + lock.say() + \" while under the effect of a $@.\"\n  )\n}\n\nfrom LockOperation outer, FunctionCall inner, string msg\nwhere intraproc(inner, msg, outer) or interproc(inner, msg, outer)\nselect inner, msg, outer, outer.say()",
        "description": "Nested use of semaphores or locks should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 09/AvoidNestedSemaphores.ql",
        "language": "cpp"
    },
    {
        "query": "import Semaphores\n\nfrom FunctionCall call, string kind\nwhere\n  call instanceof SemaphoreCreation and kind = \"semaphores\"\n  or\n  call instanceof LockingPrimitive and kind = \"locking primitives\"\nselect call, \"Use of \" + kind + \" should be avoided.\"",
        "description": "The use of semaphores or locks to access shared data should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 09/AvoidSemaphores.ql",
        "language": "cpp"
    },
    {
        "query": "import Semaphores\n\nfrom LockOperation lock\nwhere lock.getAReachedNode() = lock.getEnclosingFunction()\nselect lock, \"This lock operation may escape the function without a matching unlock.\"",
        "description": "Unlock operations shall always appear within the body of the same function that performs the matching lock operation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 09/ReleaseLocksWhenAcquired.ql",
        "language": "cpp"
    },
    {
        "query": "import Semaphores\n\npredicate lockOrder(LockOperation outer, LockOperation inner) {\n  outer.getAReachedNode() = inner and\n  inner.getLocked() != outer.getLocked()\n}\n\nint orderCount(Declaration outerLock, Declaration innerLock) {\n  result =\n    strictcount(LockOperation outer, LockOperation inner |\n      outer.getLocked() = outerLock and\n      inner.getLocked() = innerLock and\n      lockOrder(outer, inner)\n    )\n}\n\nfrom LockOperation outer, LockOperation inner\nwhere\n  lockOrder(outer, inner) and\n  orderCount(outer.getLocked(), inner.getLocked()) <=\n    orderCount(inner.getLocked(), outer.getLocked())\nselect inner, \"Out-of-order locks: A \" + inner.say() + \" usually precedes a $@.\", outer, outer.say()",
        "description": "Where nested locks are inevitable, they should always be taken in the same order.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 09/OutOfOrderLocks.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass ForbiddenCall extends FunctionCall {\n  ForbiddenCall() {\n    this.getTarget().getName() =\n      [\"task_delay\", \"taskDelay\", \"sleep\", \"nanosleep\", \"clock_nanosleep\"]\n  }\n}\n\nfrom ForbiddenCall call\nselect call, \"Task synchronization shall not be performed through task delays.\"",
        "description": "Task synchronization shall not be performed through the use of task delays.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 07/ThreadSafety.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate hasInitializer(EnumConstant c) { c.getInitializer().fromSource() }\n\npredicate hasNonReferenceInitializer(EnumConstant c) {\n  exists(Initializer init |\n    init = c.getInitializer() and\n    init.fromSource() and\n    not init.getExpr().(EnumConstantAccess).getTarget().getDeclaringEnum() = c.getDeclaringEnum()\n  )\n}\n\npredicate hasReferenceInitializer(EnumConstant c) {\n  exists(Initializer init |\n    init = c.getInitializer() and\n    init.fromSource() and\n    init.getExpr().(EnumConstantAccess).getTarget().getDeclaringEnum() = c.getDeclaringEnum()\n  )\n}\n\n// There exists another constant whose value is implicit, but it's\n// not the last one: the last value is okay to use to get the highest\n// enum value automatically. It can be followed by aliases though.\npredicate enumThatHasConstantWithImplicitValue(Enum e) {\n  exists(EnumConstant ec, int pos |\n    ec = e.getEnumConstant(pos) and\n    not hasInitializer(ec) and\n    exists(EnumConstant ec2, int pos2 |\n      ec2 = e.getEnumConstant(pos2) and\n      pos2 > pos and\n      not hasReferenceInitializer(ec2)\n    )\n  )\n}\n\nfrom Enum e, int i\nwhere\n  // e is at position i, and has an explicit value in the source - but\n  // not just a reference to another enum constant\n  hasNonReferenceInitializer(e.getEnumConstant(i)) and\n  // but e is not the first or the last constant of the enum\n  i != 0 and\n  exists(e.getEnumConstant(i + 1)) and\n  // and there exists another constant whose value is implicit, but it's\n  // not the last one: the last value is okay to use to get the highest\n  // enum value automatically. It can be followed by aliases though.\n  enumThatHasConstantWithImplicitValue(e)\nselect e,\n  \"In an enumerator list, the = construct should not be used to explicitly initialize members other than the first, unless all items are explicitly initialized.\"",
        "description": "In an enumerator list, the = construct should not be used to explicitly initialize members other than the first, unless all items are explicitly initialized. An exception is the pattern to use the last element of an enumerator list to get the number of possible values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 12/EnumInitialization.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass Initialization extends Function {\n  Initialization() {\n    // TODO: This could be refined to match precisely what functions count\n    // as \"initialization\", and are, hence, allowed to perform dynamic\n    // memory allocation.\n    this.getName().toLowerCase().matches(\"init%\") or\n    this.getName().toLowerCase().matches(\"%\\\\_init\")\n  }\n}\n\nclass Allocation extends FunctionCall {\n  Allocation() { this.getTarget().getName() = [\"malloc\", \"calloc\", \"alloca\", \"sbrk\", \"valloc\"] }\n}\n\nfrom Function f, Allocation a\nwhere\n  not f instanceof Initialization and\n  a.getEnclosingFunction() = f\nselect a, \"Dynamic memory allocation is only allowed during initialization.\"",
        "description": "Dynamic memory allocation (using malloc() or calloc()) should be confined to the initialization routines of a program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 05/HeapMemory.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass RecursiveCall extends FunctionCall {\n  RecursiveCall() { this.getTarget().calls*(this.getEnclosingFunction()) }\n}\n\nfrom RecursiveCall call, string msg\nwhere\n  if call.getTarget() = call.getEnclosingFunction()\n  then msg = \"This call directly invokes its containing function $@.\"\n  else\n    msg =\n      \"The function \" + call.getEnclosingFunction() +\n        \" is indirectly recursive via this call to $@.\"\nselect call, msg, call.getTarget(), call.getTarget().getName()",
        "description": "Avoiding recursion allows tools and people to better analyze the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 04/Recursion.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate validVarForBound(Loop loop, Variable var) {\n  // The variable is read in the loop controlling expression\n  var.getAnAccess().getParent*() = loop.getControllingExpr() and\n  // The variable is not assigned in the loop body\n  not inScope(loop, var.getAnAssignment().getEnclosingStmt()) and\n  // The variable is not incremented/decremented in the loop body\n  not inScope(loop, var.getAnAccess().getParent().(CrementOperation).getEnclosingStmt())\n}\n\npredicate upperBoundCheck(Loop loop, VariableAccess checked) {\n  exists(RelationalOperation rop | loop.getControllingExpr().getAChild*() = rop |\n    checked = rop.getLesserOperand() and\n    // The RHS is something \"valid\", i.e. a constant or\n    // a variable that isn't assigned in the loop body\n    (\n      exists(rop.getGreaterOperand().getValue()) or\n      rop.getGreaterOperand().(VariableAccess).getTarget().isConst() or\n      validVarForBound(loop, rop.getGreaterOperand().(VariableAccess).getTarget())\n    ) and\n    not rop.getGreaterOperand() instanceof CharLiteral\n  )\n}\n\npredicate lowerBoundCheck(Loop loop, VariableAccess checked) {\n  exists(RelationalOperation rop | loop.getControllingExpr().getAChild*() = rop |\n    checked = rop.getGreaterOperand() and\n    // The RHS is something \"valid\", i.e. a constant or\n    // a variable that isn't assigned in the loop body\n    (\n      exists(rop.getLesserOperand().getValue()) or\n      rop.getLesserOperand().(VariableAccess).getTarget().isConst() or\n      validVarForBound(loop, rop.getLesserOperand().(VariableAccess).getTarget())\n    ) and\n    not rop.getLesserOperand() instanceof CharLiteral\n  )\n}\n\nVariableAccess getAnIncrement(Variable var) {\n  result.getTarget() = var and\n  (\n    result.getParent() instanceof IncrementOperation\n    or\n    exists(AssignAddExpr a | a.getLValue() = result and a.getRValue().getValue().toInt() > 0)\n    or\n    exists(AssignExpr a | a.getLValue() = result |\n      a.getRValue() =\n        any(AddExpr ae |\n          ae.getAnOperand() = var.getAnAccess() and\n          ae.getAnOperand().getValue().toInt() > 0\n        )\n    )\n  )\n}\n\nVariableAccess getADecrement(Variable var) {\n  result.getTarget() = var and\n  (\n    result.getParent() instanceof DecrementOperation\n    or\n    exists(AssignSubExpr a | a.getLValue() = result and a.getRValue().getValue().toInt() > 0)\n    or\n    exists(AssignExpr a | a.getLValue() = result |\n      a.getRValue() =\n        any(SubExpr ae |\n          ae.getLeftOperand() = var.getAnAccess() and\n          ae.getRightOperand().getValue().toInt() > 0\n        )\n    )\n  )\n}\n\npredicate inScope(Loop l, Stmt s) { l.getAChild*() = s }\n\npredicate reachesNoInc(VariableAccess source, ControlFlowNode target) {\n  upperBoundCheck(_, source) and source.getASuccessor() = target\n  or\n  exists(ControlFlowNode mid |\n    reachesNoInc(source, mid) and not mid = getAnIncrement(source.getTarget())\n  |\n    target = mid.getASuccessor() and\n    inScope(source.getEnclosingStmt(), target.getEnclosingStmt())\n  )\n}\n\npredicate reachesNoDec(VariableAccess source, ControlFlowNode target) {\n  lowerBoundCheck(_, source) and source.getASuccessor() = target\n  or\n  exists(ControlFlowNode mid |\n    reachesNoDec(source, mid) and not mid = getADecrement(source.getTarget())\n  |\n    target = mid.getASuccessor() and\n    inScope(source.getEnclosingStmt(), target.getEnclosingStmt())\n  )\n}\n\npredicate hasSafeBound(Loop l) {\n  exists(VariableAccess bound | upperBoundCheck(l, bound) | not reachesNoInc(bound, bound))\n  or\n  exists(VariableAccess bound | lowerBoundCheck(l, bound) | not reachesNoDec(bound, bound))\n  or\n  exists(l.getControllingExpr().getValue())\n}\n\npredicate markedAsNonterminating(Loop l) {\n  exists(Comment c | c.getContents().matches(\"%@non-terminating@%\") | c.getCommentedElement() = l)\n}\n\nfrom Loop loop, string msg\nwhere\n  not hasSafeBound(loop) and\n  not markedAsNonterminating(loop) and\n  (\n    not upperBoundCheck(loop, _) and\n    not lowerBoundCheck(loop, _) and\n    msg = \"This loop does not have a fixed bound.\"\n    or\n    exists(VariableAccess bound |\n      upperBoundCheck(loop, bound) and\n      reachesNoInc(bound, bound) and\n      msg =\n        \"The loop counter \" + bound.getTarget().getName() +\n          \" is not always incremented in the loop body.\"\n    )\n    or\n    exists(VariableAccess bound |\n      lowerBoundCheck(loop, bound) and\n      reachesNoDec(bound, bound) and\n      msg =\n        \"The loop counter \" + bound.getTarget().getName() +\n          \" is not always decremented in the loop body.\"\n    )\n  )\nselect loop, msg",
        "description": "All loops should have a fixed upper bound; the counter should also be incremented along all paths within the loop. This check excludes loops that are meant to be nonterminating (like schedulers).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 03/LoopBounds.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate markedAsNonterminating(Loop l) {\n  exists(Comment c | c.getContents().matches(\"%@non-terminating@%\") | c.getCommentedElement() = l)\n}\n\nStmt exitFrom(Loop l) {\n  l.getAChild+() = result and\n  (\n    result instanceof ReturnStmt\n    or\n    exists(BreakStmt break | break = result | not l.getAChild*() = break.getTarget())\n  )\n}\n\nfrom Loop l, Stmt exit\nwhere\n  markedAsNonterminating(l) and\n  exit = exitFrom(l)\nselect exit, \"$@ should not be exited.\", l, \"This permanent loop\"",
        "description": "Permanent loops (like \"while(1) {..}\") are typically meant to be non-terminating and should not be terminated by other means.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 03/ExitNonterminatingLoop.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom GotoStmt goto\nselect goto, \"The goto statement should not be used.\"",
        "description": "Using the goto statement complicates function control flow and hinders program understanding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 11/SimpleControlFlowGoto.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass ForbiddenFunction extends Function {\n  ForbiddenFunction() { this.getName() = [\"setjmp\", \"longjmp\", \"sigsetjmp\", \"siglongjmp\"] }\n}\n\nfrom FunctionCall call\nwhere call.getTarget() instanceof ForbiddenFunction\nselect call, \"The \" + call.getTarget().getName() + \" function should not be used.\"",
        "description": "Using the setjmp and longjmp functions complicates control flow and hinders program understanding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/JPL_C/LOC-2/Rule 11/SimpleControlFlowJmp.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.SSA\nprivate import UninitializedVariables\n\nfrom\n  ConditionallyInitializedVariable v, ConditionalInitializationFunction f,\n  ConditionalInitializationCall call, string defined, Evidence e\nwhere\n  exists(v.getARiskyAccess(f, call, e)) and\n  (\n    if e = DefinitionInSnapshot()\n    then defined = \"\"\n    else\n      if e = SuggestiveSalAnnotation()\n      then defined = \"externally defined (SAL) \"\n      else defined = \"externally defined (CSV) \"\n  )\nselect call,\n  \"The status of this call to \" + defined +\n    \"$@ is not checked, potentially leaving $@ uninitialized.\", f, f.getName(), v, v.getName()",
        "description": "An initialization function is used to initialize a local variable, but the returned status code is not checked. The variable may be left in an uninitialized state, and reading the variable may result in undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-457/ConditionallyUninitializedVariable.ql",
        "language": "cpp"
    },
    {
        "query": "import IncorrectPointerScalingCommon\n\nfrom Expr dest, Type destType, Type sourceType, Type sourceBase, Type destBase, Location sourceLoc\nwhere\n  exists(pointerArithmeticParent(dest)) and\n  exprSourceType(dest, sourceType, sourceLoc) and\n  sourceBase = baseType(sourceType) and\n  destType = dest.getFullyConverted().getType() and\n  destBase = baseType(destType) and\n  destBase.getSize() != sourceBase.getSize() and\n  not dest.isInMacroExpansion() and\n  // If the source type is a `char*` or `void*` then don't\n  // produce a result, because it is likely to be a false\n  // positive.\n  not sourceBase instanceof CharType and\n  not sourceBase instanceof VoidType and\n  // Don't produce an alert if the dest type is `char *` but the\n  // expression contains a `sizeof`, which is probably correct.  For\n  // example:\n  // ```\n  //   int x[3] = {1,2,3};\n  //   char* p = (char*)x;\n  //   return *(int*)(p + (2 * sizeof(int)))\n  // ```\n  not (\n    destBase instanceof CharType and\n    dest.getParent().(Expr).getAChild*() instanceof SizeofOperator\n  ) and\n  // Don't produce an alert if the root expression computes\n  // an offset, rather than a pointer. For example:\n  // ```\n  //     (p + 1) - q\n  // ```\n  forall(Expr parent | parent = pointerArithmeticParent+(dest) |\n    parent.getFullyConverted().getUnspecifiedType() instanceof PointerType\n  ) and\n  // Only produce alerts that are not produced by `IncorrectPointerScaling.ql`.\n  destBase instanceof CharType\nselect dest,\n  \"This pointer might have type $@ (size \" + sourceBase.getSize() +\n    \"), but this pointer arithmetic is done with type \" + destType + \" (size \" + destBase.getSize() +\n    \").\", sourceLoc, sourceBase.toString()",
        "description": "Implicit scaling of pointer arithmetic expressions can cause buffer overflow conditions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-468/IncorrectPointerScalingChar.ql",
        "language": "cpp"
    },
    {
        "query": "import IncorrectPointerScalingCommon\n\nfrom Expr dest, Type destType, Type sourceType, Type sourceBase, Type destBase, Location sourceLoc\nwhere\n  exists(pointerArithmeticParent(dest)) and\n  exprSourceType(dest, sourceType, sourceLoc) and\n  sourceBase = baseType(sourceType) and\n  destType = dest.getFullyConverted().getType() and\n  destBase = baseType(destType) and\n  destBase.getSize() != sourceBase.getSize() and\n  not dest.isInMacroExpansion() and\n  // Only produce alerts that are not produced by `IncorrectPointerScaling.ql`.\n  destBase instanceof VoidType\nselect dest,\n  \"This pointer might have type $@ (size \" + sourceBase.getSize() +\n    \"), but this pointer arithmetic is done with type void.\", sourceLoc, sourceBase.toString()",
        "description": "Implicit scaling of pointer arithmetic expressions can cause buffer overflow conditions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-468/IncorrectPointerScalingVoid.ql",
        "language": "cpp"
    },
    {
        "query": "import IncorrectPointerScalingCommon\n\nfrom Expr dest, Type destType, Type sourceType, Type sourceBase, Type destBase, Location sourceLoc\nwhere\n  exists(pointerArithmeticParent(dest)) and\n  exprSourceType(dest, sourceType, sourceLoc) and\n  sourceBase = baseType(sourceType) and\n  destType = dest.getFullyConverted().getType() and\n  destBase = baseType(destType) and\n  destBase.getSize() != sourceBase.getSize() and\n  not dest.isInMacroExpansion() and\n  // If the source type is a `char*` or `void*` then don't\n  // produce a result, because it is likely to be a false\n  // positive.\n  not sourceBase instanceof CharType and\n  not sourceBase instanceof VoidType and\n  // Low-level pointer tricks often involve casting a struct pointer to a\n  // char pointer, then accessing it at byte offsets. For example, this can\n  // be necessary in order to resume an interrupted `write(2)`.\n  not destBase instanceof CharType and\n  // Similarly, gcc and compilers emulating it will allow void pointer\n  // arithmetic as if void were a 1-byte type\n  not destBase instanceof VoidType and\n  // Don't produce an alert if the root expression computes\n  // an offset, rather than a pointer. For example:\n  // ```\n  //     (p + 1) - q\n  // ```\n  forall(Expr parent | parent = pointerArithmeticParent+(dest) |\n    parent.getFullyConverted().getUnspecifiedType() instanceof PointerType\n  )\nselect dest,\n  \"This pointer might have type $@ (size \" + sourceBase.getSize() +\n    \"), but this pointer arithmetic is done with type \" + destType + \" (size \" + destBase.getSize() +\n    \").\", sourceLoc, sourceBase.toString()",
        "description": "Implicit scaling of pointer arithmetic expressions can cause buffer overflow conditions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-468/IncorrectPointerScaling.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport IncorrectPointerScalingCommon\n\nprivate predicate isCharSzPtrExpr(Expr e) {\n  exists(PointerType pt | pt = e.getFullyConverted().getUnspecifiedType() |\n    pt.getBaseType() instanceof CharType or\n    pt.getBaseType() instanceof VoidType\n  )\n}\n\nfrom Expr sizeofExpr, Expr e\nwhere\n  // If we see an addWithSizeof then we expect the type of\n  // the pointer expression to be `char*` or `void*`. Otherwise it\n  // is probably a mistake.\n  addWithSizeof(e, sizeofExpr, _) and\n  not isCharSzPtrExpr(e)\nselect sizeofExpr,\n  \"Suspicious sizeof offset in a pointer arithmetic expression. The type of the pointer is $@.\",\n  e.getFullyConverted().getType() as t, t.toString()",
        "description": "Explicitly scaled pointer arithmetic expressions can cause buffer overflow conditions if the offset is also implicitly scaled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-468/SuspiciousAddWithSizeof.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.security.FlowSources as FS\nimport Flow::PathGraph\n\nstring getATopLevelDomain() {\n  result =\n    [\n      \"com\", \"ru\", \"net\", \"org\", \"de\", \"jp\", \"uk\", \"br\", \"pl\", \"in\", \"it\", \"fr\", \"au\", \"info\", \"nl\",\n      \"cn\", \"ir\", \"es\", \"cz\", \"biz\", \"ca\", \"eu\", \"ua\", \"kr\", \"za\", \"co\", \"gr\", \"ro\", \"se\", \"tw\",\n      \"vn\", \"mx\", \"ch\", \"tr\", \"at\", \"be\", \"hu\", \"tv\", \"dk\", \"me\", \"ar\", \"us\", \"no\", \"sk\", \"fi\",\n      \"id\", \"cl\", \"nz\", \"by\", \"xyz\", \"pt\", \"ie\", \"il\", \"kz\", \"my\", \"hk\", \"lt\", \"cc\", \"sg\", \"io\",\n      \"edu\", \"gov\"\n    ]\n}\n\npredicate hardCodedAddressOrIP(StringLiteral txt) {\n  exists(string s | s = txt.getValueText() |\n    // Hard-coded ip addresses, such as 127.0.0.1\n    s.regexpMatch(\"\\\"[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+\\\"\") or\n    // Hard-coded addresses such as www.mycompany.com\n    s.regexpMatch(\"\\\"(www\\\\.|http:|https:).*\\\"\") or\n    s.regexpMatch(\"\\\".*\\\\.(\" + strictconcat(getATopLevelDomain(), \"|\") + \")\\\"\")\n  )\n}\n\npredicate useOfHardCodedAddressOrIP(Expr use) {\n  hardCodedAddressOrIP(use)\n  or\n  exists(Expr def, Expr src, Variable v |\n    useOfHardCodedAddressOrIP(src) and\n    exprDefinition(v, def, src) and\n    definitionUsePair(v, def, use)\n  )\n}\n\npredicate hardCodedAddressInCondition(Expr subexpression, Expr condition) {\n  subexpression = condition.getAChild+() and\n  // One of the sub-expressions of the condition is a hard-coded\n  // IP or web-address.\n  exists(Expr use | use = condition.getAChild+() | useOfHardCodedAddressOrIP(use)) and\n  condition = any(IfStmt ifStmt).getCondition()\n}\n\npredicate isSource(FS::FlowSource source, string sourceType) { source.getSourceType() = sourceType }\n\npredicate isSink(DataFlow::Node sink, Expr condition) {\n  hardCodedAddressInCondition([sink.asExpr(), sink.asIndirectExpr()], condition)\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(Expr condition | result = condition.getLocation() | isSink(sink, condition))\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom\n  Expr subexpression, Expr condition, Flow::PathNode source, Flow::PathNode sink, string sourceType\nwhere\n  hardCodedAddressInCondition(subexpression, condition) and\n  isSource(source.getNode(), sourceType) and\n  Flow::flowPath(source, sink) and\n  isSink(sink.getNode(), condition)\nselect condition, source, sink, \"Untrusted input $@ might be vulnerable to a spoofing attack.\",\n  source, sourceType",
        "description": "Authentication by checking that the peer's address matches a known IP or web address is unsafe as it is vulnerable to spoofing attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-290/AuthenticationBypass.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Security\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.ir.IR\nimport Flow::PathGraph\n\npredicate sensitiveCondition(Expr condition, Expr raise) {\n  raisesPrivilege(raise) and\n  exists(IfStmt ifstmt |\n    ifstmt.getCondition() = condition and\n    raise.getEnclosingStmt().getParentStmt*() = ifstmt\n  )\n}\n\nprivate predicate constantInstruction(Instruction instr) {\n  instr instanceof ConstantInstruction\n  or\n  instr instanceof StringConstantInstruction\n  or\n  constantInstruction(instr.(UnaryInstruction).getUnary())\n}\n\npredicate isSource(FlowSource source, string sourceType) { sourceType = source.getSourceType() }\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { isSource(node, _) }\n\n  predicate isSink(DataFlow::Node node) {\n    sensitiveCondition([node.asExpr(), node.asIndirectExpr()], _)\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // Block flow into binary instructions if both operands are non-constant\n    exists(BinaryInstruction iTo |\n      iTo = node.asInstruction() and\n      not constantInstruction(iTo.getLeft()) and\n      not constantInstruction(iTo.getRight()) and\n      // propagate taint from either the pointer or the offset, regardless of constant-ness\n      not iTo instanceof PointerArithmeticInstruction\n    )\n    or\n    // Block flow through calls to pure functions if two or more operands are non-constant\n    exists(Instruction iFrom1, Instruction iFrom2, CallInstruction iTo |\n      iTo = node.asInstruction() and\n      isPureFunction(iTo.getStaticCallTarget().getName()) and\n      iFrom1 = iTo.getAnArgument() and\n      iFrom2 = iTo.getAnArgument() and\n      not constantInstruction(iFrom1) and\n      not constantInstruction(iFrom2) and\n      iFrom1 != iFrom2\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    result = sink.getLocation()\n    or\n    exists(Expr raise | result = raise.getLocation() |\n      sensitiveCondition([sink.asExpr(), sink.asIndirectExpr()], raise)\n    )\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\n\nfrom\n  Expr raise, string sourceType, DataFlow::Node source, DataFlow::Node sink,\n  Flow::PathNode sourceNode, Flow::PathNode sinkNode\nwhere\n  source = sourceNode.getNode() and\n  sink = sinkNode.getNode() and\n  isSource(source, sourceType) and\n  sensitiveCondition([sink.asExpr(), sink.asIndirectExpr()], raise) and\n  Flow::flowPath(sourceNode, sinkNode)\nselect sink, sourceNode, sinkNode, \"Reliance on $@ to raise privilege at $@.\", source, sourceType,\n  raise, raise.toString()",
        "description": "Using untrusted inputs in a statement that makes a security decision makes code vulnerable to attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-807/TaintedCondition.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate isHresultBooleanConverted(Expr e1, Cast e2) {\n  exists(Type t1, Type t2 |\n    t1 = e1.getType() and\n    t2 = e2.getType() and\n    (\n      (t1.hasName(\"bool\") or t1.hasName(\"BOOL\") or t1.hasName(\"_Bool\")) and\n      t2.hasName(\"HRESULT\")\n      or\n      (t2.hasName(\"bool\") or t2.hasName(\"BOOL\") or t2.hasName(\"_Bool\")) and\n      t1.hasName(\"HRESULT\")\n    )\n  )\n}\n\npredicate isHresultBooleanConverted(Expr e1) {\n  exists(Cast e2 |\n    e2 = e1.getConversion() and\n    isHresultBooleanConverted(e1, e2)\n  )\n}\n\nfrom Expr e1, string msg\nwhere\n  exists(Cast e2 | e2 = e1.getConversion() |\n    isHresultBooleanConverted(e1, e2) and\n    if e2.isImplicit()\n    then\n      msg =\n        \"Implicit conversion from \" + e1.getType().toString() + \" to \" + e2.getType().toString() +\n          \".\"\n    else\n      msg =\n        \"Explicit conversion from \" + e1.getType().toString() + \" to \" + e2.getType().toString() +\n          \".\"\n  )\n  or\n  exists(ControlStructure ctls |\n    ctls.getControllingExpr() = e1 and\n    e1.getType().(TypedefType).hasName(\"HRESULT\") and\n    not isHresultBooleanConverted(e1) and\n    not ctls instanceof SwitchStmt and // not controlled by a boolean condition\n    msg = \"Direct usage of a type \" + e1.getType().toString() + \" as a conditional expression.\"\n  )\n  or\n  (\n    exists(BinaryLogicalOperation blop | blop.getAnOperand() = e1 |\n      e1.getType().(TypedefType).hasName(\"HRESULT\") and\n      msg =\n        \"Usage of a type \" + e1.getType().toString() +\n          \" as an argument of a binary logical operation.\"\n    )\n    or\n    exists(UnaryLogicalOperation ulop | ulop.getAnOperand() = e1 |\n      e1.getType().(TypedefType).hasName(\"HRESULT\") and\n      msg =\n        \"Usage of a type \" + e1.getType().toString() +\n          \" as an argument of a unary logical operation.\"\n    ) and\n    not isHresultBooleanConverted(e1)\n  )\nselect e1, msg",
        "description": "Casting an HRESULT to/from a Boolean type and then using it in a test expression will yield an incorrect result because success (S_OK) in HRESULT is indicated by a value of 0.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-253/HResultBooleanConversion.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.ir.IR\nimport KeyStrengthFlow::PathGraph\n\n// Gets the recommended minimum key size (in bits) of `func`, the name of an encryption function that accepts a key size as parameter `paramIndex`\nint getMinimumKeyStrength(string func, int paramIndex) {\n  func =\n    [\n      \"EVP_PKEY_CTX_set_dsa_paramgen_bits\", \"DSA_generate_parameters_ex\",\n      \"EVP_PKEY_CTX_set_rsa_keygen_bits\", \"RSA_generate_key_ex\", \"RSA_generate_key_fips\",\n      \"EVP_PKEY_CTX_set_dh_paramgen_prime_len\", \"DH_generate_parameters_ex\"\n    ] and\n  paramIndex = 1 and\n  result = 2048\n}\n\nmodule KeyStrengthFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) {\n    exists(int bits |\n      node.asInstruction().(IntegerConstantInstruction).getValue().toInt() = bits and\n      bits < getMinimumKeyStrength(_, _) and\n      bits > 0 // exclude sentinel values\n    )\n  }\n\n  predicate isSink(DataFlow::Node node) {\n    exists(FunctionCall fc, string name, int param |\n      node.asExpr() = fc.getArgument(param) and\n      fc.getTarget().hasGlobalName(name) and\n      exists(getMinimumKeyStrength(name, param))\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(FunctionCall fc | result = fc.getLocation() | sink.asExpr() = fc.getArgument(_))\n  }\n}\n\nmodule KeyStrengthFlow = DataFlow::Global<KeyStrengthFlowConfig>;\n\nfrom\n  KeyStrengthFlow::PathNode source, KeyStrengthFlow::PathNode sink, FunctionCall fc, int param,\n  string name, int minimumBits, int bits\nwhere\n  KeyStrengthFlow::flowPath(source, sink) and\n  sink.getNode().asExpr() = fc.getArgument(param) and\n  fc.getTarget().hasGlobalName(name) and\n  minimumBits = getMinimumKeyStrength(name, param) and\n  bits = source.getNode().asInstruction().(ConstantValueInstruction).getValue().toInt() and\n  bits < minimumBits and\n  bits != 0\nselect fc, source, sink,\n  \"The key size $@ is less than the recommended key size of \" + minimumBits.toString() + \" bits.\",\n  source, bits.toString()",
        "description": "Using cryptographic algorithms with too small a key size can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-326/InsufficientKeySize.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Security\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.ir.IR\nimport Flow::PathGraph\n\npredicate isProcessOperationExplanation(DataFlow::Node arg, string processOperation) {\n  exists(int processOperationArg, FunctionCall call |\n    isProcessOperationArgument(processOperation, processOperationArg) and\n    call.getTarget().getName() = processOperation and\n    call.getArgument(processOperationArg) = arg.asIndirectExpr()\n  )\n}\n\npredicate isSource(FlowSource source, string sourceType) { sourceType = source.getSourceType() }\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { isSource(node, _) }\n\n  predicate isSink(DataFlow::Node node) { isProcessOperationExplanation(node, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    isSink(node) and node.asExpr().getUnspecifiedType() instanceof ArithmeticType\n    or\n    node.asCertainDefinition().getUnspecifiedType() instanceof ArithmeticType\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom\n  string processOperation, string sourceType, DataFlow::Node source, DataFlow::Node sink,\n  Flow::PathNode sourceNode, Flow::PathNode sinkNode\nwhere\n  source = sourceNode.getNode() and\n  sink = sinkNode.getNode() and\n  isSource(source, sourceType) and\n  isProcessOperationExplanation(sink, processOperation) and\n  Flow::flowPath(sourceNode, sinkNode)\nselect sink, sourceNode, sinkNode,\n  \"The value of this argument may come from $@ and is being passed to \" + processOperation + \".\",\n  source, sourceType",
        "description": "Using externally controlled strings in a process operation can allow an attacker to execute malicious commands.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-114/UncontrolledProcessOperation.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.controlflow.Guards\nimport semmle.code.cpp.models.implementations.NoexceptFunction\n\nConstructor getConstructorForAllocation(NewOrNewArrayExpr newExpr) {\n  result.getACallToThisFunction() = newExpr.getInitializer()\n}\n\nDestructor getDestructorForDeallocation(DeleteOrDeleteArrayExpr deleteExpr) {\n  result = deleteExpr.getDestructor()\n}\n\npredicate newMayThrow(NewOrNewArrayExpr newExpr) {\n  functionMayThrow(newExpr.getAllocator()) or\n  functionMayThrow(getConstructorForAllocation(newExpr))\n}\n\npredicate deleteMayThrow(DeleteOrDeleteArrayExpr deleteExpr) {\n  functionMayThrow(deleteExpr.getDeallocator()) or\n  functionMayThrow(getDestructorForDeallocation(deleteExpr))\n}\n\npredicate functionMayThrow(Function f) {\n  not f instanceof NonCppThrowingFunction and\n  (not exists(f.getBlock()) or stmtMayThrow(f.getBlock()))\n}\n\npredicate stmtMayThrow(Stmt stmt) {\n  stmtMayThrow(stmt.(BlockStmt).getAStmt())\n  or\n  convertedExprMayThrow(stmt.(ExprStmt).getExpr())\n  or\n  convertedExprMayThrow(stmt.(DeclStmt).getADeclaration().(Variable).getInitializer().getExpr())\n  or\n  exists(IfStmt ifStmt | ifStmt = stmt |\n    convertedExprMayThrow(ifStmt.getCondition()) or\n    stmtMayThrow([ifStmt.getThen(), ifStmt.getElse()])\n  )\n  or\n  exists(ConstexprIfStmt constIfStmt | constIfStmt = stmt |\n    stmtMayThrow([constIfStmt.getThen(), constIfStmt.getElse()])\n  )\n  or\n  exists(Loop loop | loop = stmt |\n    convertedExprMayThrow(loop.getCondition()) or\n    stmtMayThrow(loop.getStmt())\n  )\n  or\n  // The case for `Loop` already checked the condition and the statement.\n  convertedExprMayThrow(stmt.(RangeBasedForStmt).getUpdate())\n  or\n  // The case for `Loop` already checked the condition and the statement.\n  exists(ForStmt forStmt | forStmt = stmt |\n    stmtMayThrow(forStmt.getInitialization())\n    or\n    convertedExprMayThrow(forStmt.getUpdate())\n  )\n  or\n  exists(SwitchStmt switchStmt | switchStmt = stmt |\n    convertedExprMayThrow(switchStmt.getExpr()) or\n    stmtMayThrow(switchStmt.getStmt())\n  )\n  or\n  // NOTE: We don't include `TryStmt` as those exceptions are not \"observable\" outside the function.\n  stmtMayThrow(stmt.(Handler).getBlock())\n  or\n  convertedExprMayThrow(stmt.(CoReturnStmt).getExpr())\n  or\n  convertedExprMayThrow(stmt.(ReturnStmt).getExpr())\n}\n\npredicate convertedExprMayThrow(Expr e) {\n  exprMayThrow(e)\n  or\n  convertedExprMayThrow(e.getConversion())\n}\n\npredicate exprMayThrow(Expr e) {\n  e instanceof DynamicCast\n  or\n  e instanceof TypeidOperator\n  or\n  e instanceof ThrowExpr\n  or\n  newMayThrow(e)\n  or\n  deleteMayThrow(e)\n  or\n  convertedExprMayThrow(e.(UnaryOperation).getOperand())\n  or\n  exists(BinaryOperation binOp | binOp = e |\n    convertedExprMayThrow([binOp.getLeftOperand(), binOp.getRightOperand()])\n  )\n  or\n  exists(Assignment assign | assign = e |\n    convertedExprMayThrow([assign.getLValue(), assign.getRValue()])\n  )\n  or\n  exists(CommaExpr comma | comma = e |\n    convertedExprMayThrow([comma.getLeftOperand(), comma.getRightOperand()])\n  )\n  or\n  exists(StmtExpr stmtExpr | stmtExpr = e |\n    convertedExprMayThrow(stmtExpr.getResultExpr()) or\n    stmtMayThrow(stmtExpr.getStmt())\n  )\n  or\n  convertedExprMayThrow(e.(Conversion).getExpr())\n  or\n  exists(FunctionCall fc | fc = e |\n    not exists(fc.getTarget()) or\n    functionMayThrow(fc.getTarget()) or\n    convertedExprMayThrow(fc.getAnArgument())\n  )\n}\n\nclass NoThrowType extends Struct {\n  NoThrowType() { this.hasGlobalOrStdOrBslName(\"nothrow_t\") }\n}\n\nclass ThrowingAllocator extends Function {\n  ThrowingAllocator() {\n    exists(NewOrNewArrayExpr newExpr |\n      newExpr.getAllocator() = this and\n      // Exclude custom overloads of `operator new`.\n      // What we really want here is to only include the functions that satisfy `functionMayThrow`, but\n      // there seems to be examples where `throw()` isn't extracted (which causes false positives).\n      //\n      // As noted in the QLDoc for `Function.getAllocatorCall`:\n      //\n      // \"As a rule of thumb, there will be an allocator call precisely when the type\n      // being allocated has a custom `operator new`, or when an argument list appears\n      // after the `new` keyword and before the name of the type being allocated.\n      //\n      // In particular note that uses of placement-new and nothrow-new will have an\n      // allocator call.\"\n      //\n      // So we say an allocator might throw if:\n      // 1. It doesn't have a body\n      // 2. there isn't a parameter with type `nothrow_t`\n      // 3. the allocator isn't marked with `throw()` or `noexcept`.\n      not exists(this.getBlock()) and\n      not exists(Parameter p | p = this.getAParameter() |\n        p.getUnspecifiedType().stripType() instanceof NoThrowType\n      ) and\n      not this instanceof NoexceptFunction\n    )\n  }\n}\n\nclass BadAllocType extends Class {\n  BadAllocType() { this.hasGlobalOrStdOrBslName(\"bad_alloc\") }\n}\n\nclass BadAllocCatchBlock extends CatchBlock {\n  BadAllocCatchBlock() {\n    this.getParameter().getUnspecifiedType().stripType() =\n      any(BadAllocType badAlloc).getABaseClass*()\n    or\n    not exists(this.getParameter())\n  }\n}\n\npredicate noThrowInTryBlock(NewOrNewArrayExpr newExpr, BadAllocCatchBlock catchBlock) {\n  exists(TryStmt try |\n    not stmtMayThrow(try.getStmt()) and\n    try.getACatchClause() = catchBlock and\n    newExpr.getEnclosingBlock().getEnclosingBlock*() = try.getStmt()\n  )\n}\n\npredicate nullCheckInThrowingNew(NewOrNewArrayExpr newExpr, GuardCondition guard) {\n  newExpr.getAllocator() instanceof ThrowingAllocator and\n  // There can be many guard conditions that compares `newExpr` againgst 0.\n  // For example, for `if(!p)` both `p` and `!p` are guard conditions. To not\n  // produce duplicates results we pick the \"first\" guard condition according\n  // to some arbitrary ordering (i.e., location information). This means `!p` is the\n  // element that we use to construct the alert.\n  guard =\n    min(GuardCondition gc, int startline, int startcolumn, int endline, int endcolumn |\n      gc.comparesEq(globalValueNumber(newExpr).getAnExpr(), 0, _, _) and\n      gc.getLocation().hasLocationInfo(_, startline, startcolumn, endline, endcolumn)\n    |\n      gc order by startline, startcolumn, endline, endcolumn\n    )\n}\n\nfrom NewOrNewArrayExpr newExpr, Element element, string msg, string elementString\nwhere\n  not newExpr.isFromUninstantiatedTemplate(_) and\n  not newExpr.isFromTemplateInstantiation(_) and\n  (\n    noThrowInTryBlock(newExpr, element) and\n    msg = \"This allocation cannot throw. $@ is unnecessary.\" and\n    elementString = \"This catch block\"\n    or\n    nullCheckInThrowingNew(newExpr, element) and\n    msg = \"This allocation cannot return null. $@ is unnecessary.\" and\n    elementString = \"This check\"\n  )\nselect newExpr, msg, element, elementString",
        "description": "Mixing up the failure conditions of 'operator new' and 'operator new(std::nothrow)' can result in unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-570/IncorrectAllocationErrorHandling.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport HttpStringToUrlOpen::PathGraph\n\nclass PrivateHostName extends string {\n  bindingset[this]\n  PrivateHostName() {\n    this.regexpMatch(\"(?i)localhost(?:[:/?#].*)?|127\\\\.0\\\\.0\\\\.1(?:[:/?#].*)?|10(?:\\\\.[0-9]+){3}(?:[:/?#].*)?|172\\\\.16(?:\\\\.[0-9]+){2}(?:[:/?#].*)?|192.168(?:\\\\.[0-9]+){2}(?:[:/?#].*)?|\\\\[?0:0:0:0:0:0:0:1\\\\]?(?:[:/?#].*)?|\\\\[?::1\\\\]?(?:[:/?#].*)?\")\n  }\n}\n\npragma[nomagic]\npredicate privateHostNameFlowsToExpr(Expr e) {\n  TaintTracking::localExprTaint(any(StringLiteral p | p.getValue() instanceof PrivateHostName), e)\n}\n\nclass HttpStringLiteral extends StringLiteral {\n  HttpStringLiteral() {\n    exists(string s | this.getValue() = s |\n      s = \"http\"\n      or\n      exists(string tail |\n        tail = s.regexpCapture(\"http://(.*)\", 1) and not tail instanceof PrivateHostName\n      )\n    ) and\n    not privateHostNameFlowsToExpr(this.getParent*())\n  }\n}\n\nmodule HttpStringToUrlOpenConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node src) {\n    // Sources are strings containing an HTTP URL not in a private domain.\n    src.asIndirectExpr() instanceof HttpStringLiteral and\n    // block taint starting at `strstr`, which is likely testing an existing URL, rather than constructing an HTTP URL.\n    not exists(FunctionCall fc |\n      fc.getTarget().getName() = [\"strstr\", \"strcasestr\"] and\n      fc.getArgument(1) = globalValueNumber(src.asIndirectExpr()).getAnExpr()\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    // Sinks can be anything that demonstrates the string is likely to be\n    // accessed as a URL, for example using it in a network access. Some\n    // URLs are only ever displayed or used for data processing.\n    exists(FunctionCall fc |\n      fc.getTarget()\n          .hasGlobalOrStdName([\n              \"system\", \"gethostbyname\", \"gethostbyname2\", \"gethostbyname_r\", \"getaddrinfo\",\n              \"X509_load_http\", \"X509_CRL_load_http\"\n            ]) and\n      sink.asIndirectExpr() = fc.getArgument(0)\n      or\n      fc.getTarget().hasGlobalOrStdName([\"send\", \"URLDownloadToFile\", \"URLDownloadToCacheFile\"]) and\n      sink.asIndirectExpr() = fc.getArgument(1)\n      or\n      fc.getTarget().hasGlobalOrStdName([\"curl_easy_setopt\", \"getnameinfo\"]) and\n      sink.asIndirectExpr() = fc.getArgument(2)\n      or\n      fc.getTarget().hasGlobalOrStdName([\"ShellExecute\", \"ShellExecuteA\", \"ShellExecuteW\"]) and\n      sink.asIndirectExpr() = fc.getArgument(3)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    result = source.asIndirectExpr().getLocation()\n  }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) { none() }\n}\n\nmodule HttpStringToUrlOpen = TaintTracking::Global<HttpStringToUrlOpenConfig>;\n\nfrom HttpStringToUrlOpen::PathNode source, HttpStringToUrlOpen::PathNode sink, HttpStringLiteral str\nwhere\n  HttpStringToUrlOpen::flowPath(source, sink) and\n  str = source.getNode().asIndirectExpr()\nselect str, source, sink, \"This URL may be constructed with the HTTP protocol.\"",
        "description": "Non-HTTPS connections can be intercepted by third parties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-319/UseOfHttp.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Encryption\n\nFunction getAnInsecureEncryptionFunction() {\n  (\n    isInsecureEncryption(result.getName()) or\n    isInsecureEncryption(result.getAParameter().getName()) or\n    isInsecureEncryption(result.getDeclaringType().getName())\n  ) and\n  exists(result.getACallToThisFunction())\n}\n\nFunction getAnAdditionalEvidenceFunction() {\n  (\n    isEncryptionAdditionalEvidence(result.getName()) or\n    isEncryptionAdditionalEvidence(result.getAParameter().getName())\n  ) and\n  exists(result.getACallToThisFunction())\n}\n\nMacro getAnInsecureEncryptionMacro() {\n  isInsecureEncryption(result.getName()) and\n  exists(result.getAnInvocation())\n}\n\nMacro getAnAdditionalEvidenceMacro() {\n  isEncryptionAdditionalEvidence(result.getName()) and\n  exists(result.getAnInvocation())\n}\n\nEnumConstant getAnInsecureEncryptionEnumConst() { isInsecureEncryption(result.getName()) }\n\nEnumConstant getAdditionalEvidenceEnumConst() { isEncryptionAdditionalEvidence(result.getName()) }\n\npredicate getInsecureEncryptionEvidence(FunctionCall fc, Element blame, string description) {\n  // find use of an insecure algorithm name\n  (\n    exists(FunctionCall fc2 |\n      fc.getAChild*() = fc2 and\n      fc2.getTarget() = getAnInsecureEncryptionFunction() and\n      blame = fc2 and\n      description = \"call to \" + fc.getTarget().getName()\n    )\n    or\n    exists(MacroInvocation mi |\n      (\n        mi.getAnExpandedElement() = fc or\n        mi.getAnExpandedElement() = fc.getAnArgument()\n      ) and\n      mi.getMacro() = getAnInsecureEncryptionMacro() and\n      blame = mi and\n      description = \"invocation of macro \" + mi.getMacro().getName()\n    )\n    or\n    exists(EnumConstantAccess ec |\n      ec = fc.getAnArgument() and\n      ec.getTarget() = getAnInsecureEncryptionEnumConst() and\n      blame = ec and\n      description = \"access of enum constant \" + ec.getTarget().getName()\n    )\n  ) and\n  // find additional evidence that this function is related to encryption.\n  (\n    exists(FunctionCall fc2 |\n      fc.getAChild*() = fc2 and\n      fc2.getTarget() = getAnAdditionalEvidenceFunction()\n    )\n    or\n    exists(MacroInvocation mi |\n      (\n        mi.getAnExpandedElement() = fc or\n        mi.getAnExpandedElement() = fc.getAnArgument()\n      ) and\n      mi.getMacro() = getAnAdditionalEvidenceMacro()\n    )\n    or\n    exists(EnumConstantAccess ec |\n      ec = fc.getAnArgument() and\n      ec.getTarget() = getAdditionalEvidenceEnumConst()\n    )\n  ) and\n  // exclude calls from templates as this is rarely the right place to flag an\n  // issue\n  not fc.isFromTemplateInstantiation(_) and\n  (\n    // the function should have an input that looks like a non-constant buffer\n    exists(Expr e |\n      fc.getAnArgument() = e and\n      (\n        e.getUnspecifiedType() instanceof PointerType or\n        e.getUnspecifiedType() instanceof ReferenceType or\n        e.getUnspecifiedType() instanceof ArrayType\n      ) and\n      not e.getType().isDeeplyConstBelow() and\n      not e.isConstant()\n    )\n    or\n    // or be a non-const member function of an object\n    fc.getTarget() instanceof MemberFunction and\n    not fc.getTarget() instanceof ConstMemberFunction and\n    not fc.getTarget().isStatic()\n  )\n}\n\nclass BlamedElement extends Element {\n  string description;\n\n  BlamedElement() { getInsecureEncryptionEvidence(_, this, description) }\n\n  /**\n   * Holds if this is the `num`-th `BlamedElement` in `f`.\n   */\n  predicate hasFileRank(File f, int num) {\n    exists(int loc |\n      this.getLocation().charLoc(f, loc, _) and\n      loc =\n        rank[num](BlamedElement other, int loc2 | other.getLocation().charLoc(f, loc2, _) | loc2)\n    )\n  }\n\n  string getDescription() { result = description }\n}\n\nfrom File f, BlamedElement firstResult, BlamedElement thisResult\nwhere\n  firstResult.hasFileRank(f, 1) and\n  thisResult.hasFileRank(f, _)\nselect firstResult,\n  \"This file makes use of a broken or weak cryptographic algorithm (specified by $@).\", thisResult,\n  thisResult.getDescription()",
        "description": "Using broken or weak cryptographic algorithms can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-327/BrokenCryptoAlgorithm.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate comparedTo(Variable v, Variable w) {\n  v.getAnAssignedValue() = w.getAnAccess()\n  or\n  exists(ComparisonOperation comp |\n    comp = v.getAnAccess().getParent+() and\n    comp = w.getAnAccess().getParent+()\n  )\n}\n\nclass DataVariable extends Variable {\n  DataVariable() {\n    exists(Struct ssl3_record_st |\n      ssl3_record_st.hasName(\"ssl3_record_st\") and\n      this = ssl3_record_st.getAField() and\n      this.hasName(\"data\")\n    )\n  }\n}\n\npredicate pointsInto(Expr e, DataVariable v) {\n  e = v.getAnAccess() or\n  e.(AddressOfExpr).getOperand().(ArrayExpr).getArrayBase() = v.getAnAccess() or\n  varPointsInto(e.(VariableAccess).getTarget(), v)\n}\n\npragma[nomagic]\npredicate varPointsInto(Variable tainted, DataVariable src) {\n  pointsInto(tainted.getAnAssignedValue(), src)\n}\n\nfrom FunctionCall fc, Struct ssl3_record_st, Field data, Field length\nwhere\n  fc.getTarget().getName().matches(\"%memcpy%\") and\n  ssl3_record_st.hasName(\"ssl3_record_st\") and\n  data = ssl3_record_st.getAField() and\n  data.hasName(\"data\") and\n  length = ssl3_record_st.getAField() and\n  length.hasName(\"length\") and\n  pointsInto(fc.getArgument(1), data) and\n  not comparedTo(fc.getArgument(2).(VariableAccess).getTarget(), length)\nselect fc, \"This call to memcpy is insecure (Heartbleed vulnerability).\"",
        "description": "Using an old version of OpenSSL can allow remote attackers to retrieve portions of memory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-327/OpenSslHeartbleed.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.SensitiveExprs\nimport semmle.code.cpp.security.PrivateData\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.models.interfaces.FlowSource\nimport semmle.code.cpp.commons.File\nimport FromSensitiveFlow::PathGraph\n\nclass SourceVariable extends Variable {\n  SourceVariable() {\n    this instanceof SensitiveVariable or\n    this instanceof PrivateDataVariable\n  }\n}\n\nclass SourceFunction extends Function {\n  SourceFunction() {\n    this instanceof SensitiveFunction or\n    this instanceof PrivateDataFunction\n  }\n}\n\nabstract class SendRecv extends Function {\n  /**\n   * Gets the expression for the socket or similar object used for sending or\n   * receiving data through the function call `call` (if any).\n   */\n  abstract Expr getSocketExpr(Call call);\n\n  /**\n   * Gets the expression for the buffer to be sent from / received into through\n   * the function call `call`.\n   */\n  abstract Expr getDataExpr(Call call);\n}\n\nclass Send extends SendRecv instanceof RemoteFlowSinkFunction {\n  override Expr getSocketExpr(Call call) {\n    call.getTarget() = this and\n    exists(FunctionInput input, int arg |\n      super.hasSocketInput(input) and\n      (\n        input.isParameter(arg) or\n        input.isParameterDeref(arg)\n      ) and\n      result = call.getArgument(arg)\n    )\n  }\n\n  override Expr getDataExpr(Call call) {\n    call.getTarget() = this and\n    exists(FunctionInput input, int arg |\n      super.hasRemoteFlowSink(input, _) and\n      input.isParameterDeref(arg) and\n      result = call.getArgument(arg)\n    )\n  }\n}\n\nclass Recv extends SendRecv instanceof RemoteFlowSourceFunction {\n  override Expr getSocketExpr(Call call) {\n    call.getTarget() = this and\n    exists(FunctionInput input, int arg |\n      super.hasSocketInput(input) and\n      (\n        input.isParameter(arg) or\n        input.isParameterDeref(arg)\n      ) and\n      result = call.getArgument(arg)\n    )\n  }\n\n  override Expr getDataExpr(Call call) {\n    call.getTarget() = this and\n    exists(FunctionOutput output, int arg |\n      super.hasRemoteFlowSource(output, _) and\n      output.isParameterDeref(arg) and\n      result = call.getArgument(arg)\n    )\n  }\n}\n\nabstract class NetworkSendRecv extends FunctionCall {\n  SendRecv target;\n\n  NetworkSendRecv() {\n    this.getTarget() = target and\n    // exclude calls based on the socket...\n    not exists(DataFlow::Node src, DataFlow::Node dest |\n      DataFlow::localFlow(src, dest) and\n      dest.asExpr() = target.getSocketExpr(this) and\n      (\n        // literal constant\n        src.asExpr() instanceof Literal\n        or\n        // variable (such as a global) initialized to a literal constant\n        exists(Variable v |\n          v.getInitializer().getExpr() instanceof Literal and\n          src.asExpr() = v.getAnAccess()\n        )\n        or\n        // result of a function call with literal inputs (likely constant)\n        forex(Expr arg | arg = src.asExpr().(FunctionCall).getAnArgument() | arg instanceof Literal)\n        or\n        // variable called `stdin`, `stdout` or `stderr`\n        src.asExpr().(VariableAccess).getTarget().getName() = [\"stdin\", \"stdout\", \"stderr\"]\n        or\n        // open of `\"/dev/tty\"`\n        exists(FunctionCall fc |\n          fopenCall(fc) and\n          fc.getAnArgument().getValue() = \"/dev/tty\" and\n          src.asExpr() = fc\n        )\n        // (this is not exhaustive)\n      )\n    )\n  }\n\n  final Expr getDataExpr() { result = target.getDataExpr(this) }\n}\n\nclass NetworkSend extends NetworkSendRecv {\n  override Send target;\n}\n\nclass NetworkRecv extends NetworkSendRecv {\n  override Recv target;\n}\n\npragma[noinline]\npredicate encryptionFunction(Function f) {\n  f.getName().toLowerCase().regexpMatch(\".*(crypt|encode|decode|hash|securezero).*\")\n}\n\npragma[noinline]\npredicate encryptionType(UserType t) {\n  t.getName().toLowerCase().regexpMatch(\".*(crypt|encode|decode|hash|securezero).*\")\n}\n\nclass Encrypted extends Expr {\n  Encrypted() {\n    exists(FunctionCall fc |\n      encryptionFunction(fc.getTarget()) and\n      (\n        this = fc or\n        this = fc.getAnArgument()\n      )\n    )\n    or\n    exists(Type t |\n      this.getType().refersTo(t) and\n      encryptionType(t)\n    )\n  }\n}\n\npredicate isSinkSendRecv(DataFlow::Node sink, NetworkSendRecv nsr) {\n  [sink.asIndirectExpr(), sink.asExpr()] = nsr.getDataExpr()\n}\n\npredicate isSinkEncrypt(DataFlow::Node sink, Encrypted enc) { sink.asExpr() = enc }\n\npredicate isSourceImpl(DataFlow::Node source) {\n  exists(VariableAccess e |\n    e = source.asExpr() and\n    e.getTarget() instanceof SourceVariable\n  )\n  or\n  source.asExpr().(FunctionCall).getTarget() instanceof SourceFunction\n}\n\nmodule FromSensitiveConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSourceImpl(source) }\n\n  predicate isSink(DataFlow::Node sink) { isSinkSendRecv(sink, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate isBarrierIn(DataFlow::Node node) {\n    // As any use of a sensitive variable is a potential source, we need to block flow into\n    // sources to not get path duplication.\n    isSource(node)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(NetworkSendRecv networkSendRecv | result = networkSendRecv.getLocation() |\n      isSinkSendRecv(sink, networkSendRecv)\n    )\n  }\n}\n\nmodule FromSensitiveFlow = TaintTracking::Global<FromSensitiveConfig>;\n\nmodule ToEncryptionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { FromSensitiveFlow::flow(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSinkEncrypt(sink, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate isBarrierIn(DataFlow::Node node) {\n    // As any use of a sensitive variable is a potential source, we need to block flow into\n    // sources to not get path duplication.\n    isSource(node)\n  }\n\n  predicate observeDiffInformedIncrementalMode() {\n    none() // only used negatively\n  }\n}\n\nmodule ToEncryptionFlow = TaintTracking::Global<ToEncryptionConfig>;\n\nmodule FromEncryptionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSinkEncrypt(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { FromSensitiveFlow::flowTo(sink) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate observeDiffInformedIncrementalMode() {\n    none() // only used negatively\n  }\n}\n\nmodule FromEncryptionFlow = TaintTracking::Global<FromEncryptionConfig>;\n\nfrom\n  FromSensitiveFlow::PathNode source, FromSensitiveFlow::PathNode sink,\n  NetworkSendRecv networkSendRecv, string msg\nwhere\n  // flow from sensitive -> network data\n  FromSensitiveFlow::flowPath(source, sink) and\n  isSinkSendRecv(sink.getNode(), networkSendRecv) and\n  // no flow from sensitive -> evidence of encryption\n  not ToEncryptionFlow::flow(source.getNode(), _) and\n  not FromEncryptionFlow::flowTo(sink.getNode()) and\n  // construct result\n  if networkSendRecv instanceof NetworkSend\n  then\n    msg =\n      \"This operation transmits '\" + sink.toString() +\n        \"', which may contain unencrypted sensitive data from $@.\"\n  else\n    msg =\n      \"This operation receives into '\" + sink.toString() +\n        \"', which may put unencrypted sensitive data into $@.\"\nselect networkSendRecv, source, sink, msg, source.getNode(), source.getNode().toString()",
        "description": "Transmitting sensitive information across a network in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-311/CleartextTransmission.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.SensitiveExprs\nimport semmle.code.cpp.security.FileWrite\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport FromSensitiveFlow::PathGraph\n\nmodule FromSensitiveConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSourceImpl(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSinkImpl(sink, _, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node sourceNode) {\n    exists(SensitiveExpr source | result = source.getLocation() | isSourceImpl(sourceNode, source))\n  }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(FileWrite w | result = w.getLocation() | isSinkImpl(sink, w, _))\n  }\n}\n\nmodule FromSensitiveFlow = TaintTracking::Global<FromSensitiveConfig>;\n\npredicate isSinkImpl(DataFlow::Node sink, FileWrite w, Expr dest) {\n  exists(Expr e |\n    e = [sink.asExpr(), sink.asIndirectExpr()] and\n    w.getASource() = e and\n    dest = w.getDest() and\n    // ignore things written with other conversion characters\n    not exists(string convChar | convChar = w.getSourceConvChar(e) | not convChar = [\"s\", \"S\"]) and\n    // exclude calls with standard streams\n    not dest.(VariableAccess).getTarget().getName() = [\"stdin\", \"stdout\", \"stderr\"]\n  )\n}\n\npredicate isSourceImpl(DataFlow::Node source, SensitiveExpr sensitive) {\n  not isFileName(globalValueNumber(sensitive)) and // file names are not passwords\n  source.asExpr() = sensitive\n}\n\npredicate filenameOperation(FunctionCall op, Expr path) {\n  exists(string name | name = op.getTarget().getName() |\n    name =\n      [\n        \"remove\", \"unlink\", \"rmdir\", \"rename\", \"fopen\", \"open\", \"freopen\", \"_open\", \"_wopen\",\n        \"_wfopen\", \"_fsopen\", \"_wfsopen\", \"chmod\", \"chown\", \"stat\", \"lstat\", \"fstat\", \"access\",\n        \"_access\", \"_waccess\", \"_access_s\", \"_waccess_s\"\n      ] and\n    path = op.getArgument(0)\n    or\n    name = [\"fopen_s\", \"wfopen_s\", \"rename\"] and\n    path = op.getArgument(1)\n  )\n}\n\npredicate isFileName(GVN gvn) {\n  exists(Expr path |\n    filenameOperation(_, path) and\n    gvn = globalValueNumber(path)\n  )\n}\n\nfrom\n  SensitiveExpr source, FromSensitiveFlow::PathNode sourceNode, FromSensitiveFlow::PathNode midNode,\n  FileWrite w, Expr dest\nwhere\n  FromSensitiveFlow::flowPath(sourceNode, midNode) and\n  isSourceImpl(sourceNode.getNode(), source) and\n  isSinkImpl(midNode.getNode(), w, dest)\nselect w, sourceNode, midNode,\n  \"This write into file '\" + dest.toString() + \"' may contain unencrypted data from $@.\", source,\n  \"this source.\"",
        "description": "Storing sensitive information in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-311/CleartextFileWrite.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.BufferWrite as BufferWrite\nimport semmle.code.cpp.security.SensitiveExprs\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport ToBufferFlow::PathGraph\n\nclass SensitiveBufferWrite extends Expr instanceof BufferWrite::BufferWrite {\n  SensitiveBufferWrite() { super.getDest() instanceof SensitiveExpr }\n\n  /**\n   * Gets a data source of this operation.\n   */\n  Expr getASource() { result = super.getASource() }\n\n  /**\n   * Gets the destination buffer of this operation.\n   */\n  Expr getDest() { result = super.getDest() }\n}\n\nmodule ToBufferConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof FlowSource }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSinkImpl(sink, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(SensitiveBufferWrite w | result = w.getLocation() | isSinkImpl(sink, w))\n  }\n}\n\nmodule ToBufferFlow = TaintTracking::Global<ToBufferConfig>;\n\npredicate isSinkImpl(DataFlow::Node sink, SensitiveBufferWrite w) {\n  w.getASource() = sink.asIndirectExpr()\n}\n\nfrom\n  SensitiveBufferWrite w, ToBufferFlow::PathNode sourceNode, ToBufferFlow::PathNode sinkNode,\n  FlowSource source\nwhere\n  ToBufferFlow::flowPath(sourceNode, sinkNode) and\n  sourceNode.getNode() = source and\n  isSinkImpl(sinkNode.getNode(), w)\nselect w, sourceNode, sinkNode,\n  \"This write into buffer '\" + w.getDest().toString() + \"' may contain unencrypted data from $@.\",\n  source, \"user input (\" + source.getSourceType() + \")\"",
        "description": "Storing sensitive information in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-311/CleartextBufferWrite.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.NullTermination\nimport semmle.code.cpp.security.FlowSources as FS\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.ir.IR\n\npredicate isSource(FS::FlowSource source, string sourceType) {\n  sourceType = source.getSourceType() and\n  exists(VariableAccess va, Call call |\n    va = source.asDefiningArgument() and\n    call.getAnArgument() = va and\n    va.getTarget() instanceof SemanticStackVariable and\n    call.getTarget().hasGlobalName([\"read\", \"fread\", \"recv\", \"recvfrom\", \"recvmsg\"])\n  )\n}\n\npredicate isSink(DataFlow::Node sink, VariableAccess va) {\n  va = [sink.asExpr(), sink.asIndirectExpr()] and\n  variableMustBeNullTerminated(va)\n}\n\nprivate module Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSource(source, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    isSink(node) and node.asExpr().getUnspecifiedType() instanceof ArithmeticType\n    or\n    node.asCertainDefinition().getUnspecifiedType() instanceof ArithmeticType\n    or\n    mayAddNullTerminator(_, node.asIndirectExpr())\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(VariableAccess va | result = va.getLocation() | isSink(sink, va))\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom DataFlow::Node source, DataFlow::Node sink, VariableAccess va, string sourceType\nwhere\n  Flow::flow(source, sink) and\n  isSource(source, sourceType) and\n  isSink(sink, va)\nselect va, \"String operation depends on $@ that may not be null terminated.\", source, sourceType",
        "description": "String operations on user-controlled strings can result in buffer overflow or buffer over-read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-170/ImproperNullTerminationTainted.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\nclass SetSecurityDescriptorDaclFunctionCall extends FunctionCall {\n  SetSecurityDescriptorDaclFunctionCall() {\n    this.getTarget().hasGlobalName(\"SetSecurityDescriptorDacl\") and\n    this.getArgument(1).getValue().toInt() != 0\n  }\n}\n\nmodule NullDaclConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.asExpr() instanceof NullValue }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(SetSecurityDescriptorDaclFunctionCall call, VariableAccess val | val = sink.asExpr() |\n      val = call.getArgument(2)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(SetSecurityDescriptorDaclFunctionCall call | result = call.getLocation() |\n      sink.asExpr() = call.getArgument(2)\n    )\n  }\n}\n\nmodule NullDaclFlow = DataFlow::Global<NullDaclConfig>;\n\nmodule NonNullDaclConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source.getType().getUnspecifiedType().(PointerType).getBaseType() =\n      any(Type t | t.getName() = \"ACL\").getUnspecifiedType() and\n    (\n      // If the value comes from a function whose body we can't see, assume\n      // it's not null.\n      exists(Call call |\n        not exists(call.getTarget().getBlock()) and\n        source.asExpr() = call\n      )\n      or\n      // If the value is assigned by reference, assume it's not null. The data\n      // flow library cannot currently follow flow from the body of a function to\n      // an assignment by reference, so this rule applies whether we see the\n      // body or not.\n      exists(Call call | call.getAnArgument() = source.asDefiningArgument())\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(SetSecurityDescriptorDaclFunctionCall call | sink.asExpr() = call.getArgument(2))\n  }\n\n  predicate observeDiffInformedIncrementalMode() {\n    none() // only used negatively\n  }\n}\n\nmodule NonNullDaclFlow = DataFlow::Global<NonNullDaclConfig>;\n\nfrom SetSecurityDescriptorDaclFunctionCall call, string message\nwhere\n  exists(NullValue nullExpr |\n    message =\n      \"Setting a DACL to NULL in a SECURITY_DESCRIPTOR will result in an unprotected object.\"\n  |\n    call.getArgument(1).getValue().toInt() != 0 and\n    call.getArgument(2) = nullExpr\n  )\n  or\n  exists(VariableAccess var |\n    message =\n      \"Setting a DACL to NULL in a SECURITY_DESCRIPTOR using variable \" + var +\n        \" that is set to NULL will result in an unprotected object.\"\n  |\n    var = call.getArgument(2) and\n    NullDaclFlow::flowToExpr(var) and\n    not NonNullDaclFlow::flowToExpr(var)\n  )\nselect call, message",
        "description": "Setting a DACL to NULL in a SECURITY_DESCRIPTOR will result in an unprotected object. If the DACL that belongs to the security descriptor of an object is set to NULL, a null DACL is created. A null DACL grants full access to any user who requests it; normal security checking is not performed with respect to the object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-732/UnsafeDaclSecurityDescriptor.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport FilePermissions\n\nfrom FileCreationWithOptionalModeExpr fc\nwhere not fc.hasModeArgument()\nselect fc,\n  \"This creates a file without providing a mode argument, which may leak bits from the stack.\"",
        "description": "Opening a file with the O_CREAT flag but without mode argument reads arbitrary bytes from the stack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-732/OpenCallMissingModeArgument.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport FilePermissions\nimport semmle.code.cpp.ConfigurationTestFile\n\npredicate worldWritableCreation(FileCreationExpr fc, int mode) {\n  mode = localUmask(fc).mask(fc.getMode()) and\n  setsAnyBits(mode, UnixConstants::s_iwoth())\n}\n\npredicate setWorldWritable(FunctionCall fc, int mode) {\n  fc.getTarget().getName() = [\"chmod\", \"fchmod\", \"_chmod\", \"_wchmod\"] and\n  mode = fc.getArgument(1).getValue().toInt() and\n  setsAnyBits(mode, UnixConstants::s_iwoth())\n}\n\nfrom Expr fc, int mode, string message\nwhere\n  worldWritableCreation(fc, mode) and\n  not fc.getFile() instanceof ConfigurationTestFile and // expressions in files generated during configuration are likely false positives\n  message =\n    \"A file may be created here with mode \" + octalFileMode(mode) +\n      \", which would make it world-writable.\"\n  or\n  setWorldWritable(fc, mode) and\n  message =\n    \"This sets a file's permissions to \" + octalFileMode(mode) +\n      \", which would make it world-writable.\"\nselect fc, message",
        "description": "Creating a file that is world-writable can allow an attacker to write to the file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-732/DoNotCreateWorldWritable.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport semmle.code.cpp.dataflow.new.DataFlow\nimport semmle.code.cpp.security.FlowSources as FS\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.controlflow.IRGuards as IRGuards\n\npredicate outOfBoundsExpr(Expr expr, string kind) {\n  if convertedExprMightOverflowPositively(expr)\n  then kind = \"overflow\"\n  else (\n    convertedExprMightOverflowNegatively(expr) and\n    kind = \"overflow negatively\"\n  )\n}\n\npredicate isSource(FS::FlowSource source, string sourceType) { sourceType = source.getSourceType() }\n\npredicate isSink(DataFlow::Node sink, string kind) {\n  exists(Expr use |\n    not use.getUnspecifiedType() instanceof PointerType and\n    outOfBoundsExpr(use, kind) and\n    not inSystemMacroExpansion(use) and\n    use = sink.asExpr()\n  )\n}\n\npredicate hasUpperBoundsCheck(Variable var) {\n  exists(RelationalOperation oper, VariableAccess access |\n    oper.getAnOperand() = access and\n    access.getTarget() = var and\n    // Comparing to 0 is not an upper bound check\n    not oper.getAnOperand().getValue() = \"0\"\n  )\n}\n\npredicate constantInstruction(Instruction instr) {\n  instr instanceof ConstantInstruction or\n  constantInstruction(instr.(UnaryInstruction).getUnary())\n}\n\npredicate readsVariable(LoadInstruction load, Variable var) {\n  load.getSourceAddress().(VariableAddressInstruction).getAstVariable() = var\n}\n\npredicate nodeIsBarrierEqualityCandidate(DataFlow::Node node, Operand access, Variable checkedVar) {\n  exists(Instruction instr | instr = node.asInstruction() |\n    readsVariable(instr, checkedVar) and\n    any(IRGuards::IRGuardCondition guard).ensuresEq(access, _, _, instr.getBlock(), true)\n  )\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // Block flow if there's an upper bound check of the variable anywhere in the program\n    exists(Variable checkedVar, Instruction instr | instr = node.asInstruction() |\n      readsVariable(instr, checkedVar) and\n      hasUpperBoundsCheck(checkedVar)\n    )\n    or\n    // Block flow if the node is guarded by an equality check\n    exists(Variable checkedVar, Operand access |\n      nodeIsBarrierEqualityCandidate(node, access, checkedVar) and\n      readsVariable(access.getDef(), checkedVar)\n    )\n    or\n    // Block flow to any binary instruction whose operands are both non-constants.\n    exists(BinaryInstruction iTo |\n      iTo = node.asInstruction() and\n      not constantInstruction(iTo.getLeft()) and\n      not constantInstruction(iTo.getRight()) and\n      // propagate taint from either the pointer or the offset, regardless of constantness\n      not iTo instanceof PointerArithmeticInstruction\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom DataFlow::Node source, DataFlow::Node sink, string kind, string sourceType\nwhere\n  Flow::flow(source, sink) and\n  isSource(source, sourceType) and\n  isSink(sink, kind)\nselect sink, \"$@ flows an expression which might \" + kind + \".\", source, sourceType",
        "description": "A user-controlled integer arithmetic expression that is not validated can cause overflows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-190/IntegerOverflowTainted.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Overflow\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.controlflow.IRGuards as IRGuards\n\npredicate isMaxValue(Expr mie) {\n  exists(MacroInvocation mi |\n    mi.getExpr() = mie and\n    mi.getMacroName() = [\"CHAR_MAX\", \"LLONG_MAX\", \"INT_MAX\", \"SHRT_MAX\", \"UINT_MAX\"]\n  )\n}\n\npredicate isMinValue(Expr mie) {\n  exists(MacroInvocation mi |\n    mi.getExpr() = mie and\n    mi.getMacroName() = [\"CHAR_MIN\", \"LLONG_MIN\", \"INT_MIN\", \"SHRT_MIN\"]\n  )\n}\n\npredicate isSource(DataFlow::Node source, string cause) {\n  exists(Expr expr | expr = source.asExpr() |\n    isMaxValue(expr) and cause = \"max value\"\n    or\n    isMinValue(expr) and cause = \"min value\"\n  )\n}\n\npredicate causeEffectCorrespond(string cause, string effect) {\n  cause = \"max value\" and\n  effect = \"overflow\"\n  or\n  cause = \"min value\" and\n  effect = \"underflow\"\n}\n\npredicate isSink(DataFlow::Node sink, VariableAccess va, string effect) {\n  exists(Operation op |\n    sink.asExpr() = va and\n    op.getAnOperand() = va\n  |\n    missingGuardAgainstUnderflow(op, va) and effect = \"underflow\"\n    or\n    missingGuardAgainstOverflow(op, va) and effect = \"overflow\"\n  )\n}\n\npredicate hasUpperBoundsCheck(Variable var) {\n  exists(RelationalOperation oper, VariableAccess access |\n    oper.getAnOperand() = access and\n    access.getTarget() = var and\n    // Comparing to 0 is not an upper bound check\n    not oper.getAnOperand().getValue() = \"0\"\n  )\n}\n\npredicate constantInstruction(Instruction instr) {\n  instr instanceof ConstantInstruction or\n  constantInstruction(instr.(UnaryInstruction).getUnary())\n}\n\npredicate readsVariable(LoadInstruction load, Variable var) {\n  load.getSourceAddress().(VariableAddressInstruction).getAstVariable() = var\n}\n\npredicate nodeIsBarrierEqualityCandidate(DataFlow::Node node, Operand access, Variable checkedVar) {\n  exists(Instruction instr | instr = node.asInstruction() |\n    readsVariable(instr, checkedVar) and\n    any(IRGuards::IRGuardCondition guard).ensuresEq(access, _, _, instr.getBlock(), true)\n  )\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // Block flow if there's an upper bound check of the variable anywhere in the program\n    exists(Variable checkedVar, Instruction instr | instr = node.asInstruction() |\n      readsVariable(instr, checkedVar) and\n      hasUpperBoundsCheck(checkedVar)\n    )\n    or\n    // Block flow if the node is guarded by an equality check\n    exists(Variable checkedVar, Operand access |\n      nodeIsBarrierEqualityCandidate(node, access, checkedVar) and\n      readsVariable(access.getDef(), checkedVar)\n    )\n    or\n    // Block flow to any binary instruction whose operands are both non-constants.\n    exists(BinaryInstruction iTo |\n      iTo = node.asInstruction() and\n      not constantInstruction(iTo.getLeft()) and\n      not constantInstruction(iTo.getRight()) and\n      // propagate taint from either the pointer or the offset, regardless of constantness\n      not iTo instanceof PointerArithmeticInstruction\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(VariableAccess va | result = va.getLocation() | isSink(sink, va, _))\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom DataFlow::Node source, DataFlow::Node sink, VariableAccess va, string cause, string effect\nwhere\n  Flow::flow(source, sink) and\n  isSource(source, cause) and\n  causeEffectCorrespond(cause, effect) and\n  isSink(sink, va, effect)\nselect va,\n  \"$@ flows to an operand of an arithmetic expression, potentially causing an \" + effect + \".\",\n  source, \"Extreme value\"",
        "description": "If a variable is assigned the maximum or minimum value for that variable's type and is then used in an arithmetic expression, this may result in an overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-190/ArithmeticWithExtremeValues.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.controlflow.IRGuards\nimport semmle.code.cpp.security.FlowSources\nimport TaintedAllocationSize::PathGraph\nimport Bounded\n\npredicate allocSink(HeuristicAllocationExpr alloc, DataFlow::Node sink) {\n  exists(Expr e | e = sink.asExpr() |\n    e = alloc.getAChild() and\n    e.getUnspecifiedType() instanceof IntegralType\n  )\n}\n\npredicate readsVariable(LoadInstruction load, Variable var, IRBlock bb) {\n  load.getSourceAddress().(VariableAddressInstruction).getAstVariable() = var and\n  bb = load.getBlock()\n}\n\npredicate hasUpperBoundsCheck(Variable var) {\n  exists(RelationalOperation oper, VariableAccess access |\n    oper.getAnOperand() = access and\n    access.getTarget() = var and\n    // Comparing to 0 is not an upper bound check\n    not oper.getAnOperand().getValue() = \"0\"\n  )\n}\n\npredicate variableEqualityCheckedInBlock(Variable checkedVar, IRBlock bb) {\n  exists(Operand access |\n    readsVariable(access.getDef(), checkedVar, _) and\n    any(IRGuardCondition guard).ensuresEq(access, _, _, bb, true)\n  )\n}\n\npredicate nodeIsBarrierEquality(DataFlow::Node node) {\n  exists(Variable checkedVar, Instruction instr, IRBlock bb |\n    instr = node.asOperand().getDef() and\n    readsVariable(instr, checkedVar, bb) and\n    variableEqualityCheckedInBlock(checkedVar, bb)\n  )\n}\n\npredicate isFlowSource(FlowSource source, string sourceType) { sourceType = source.getSourceType() }\n\nmodule TaintedAllocationSizeConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isFlowSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { allocSink(_, sink) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    exists(Expr e | e = node.asExpr() |\n      bounded(e)\n      or\n      // Subtracting two pointers is either well-defined (and the result will likely be small), or\n      // terribly undefined and dangerous. Here, we assume that the programmer has ensured that the\n      // result is well-defined (i.e., the two pointers point to the same object), and thus the result\n      // will likely be small.\n      e = any(PointerDiffExpr diff).getAnOperand()\n    )\n    or\n    exists(Variable checkedVar, Instruction instr | instr = node.asOperand().getDef() |\n      readsVariable(instr, checkedVar, _) and\n      hasUpperBoundsCheck(checkedVar)\n    )\n    or\n    nodeIsBarrierEquality(node)\n    or\n    // block flow to inside of identified allocation functions (this flow leads\n    // to duplicate results)\n    any(HeuristicAllocationFunction f).getAParameter() = node.asParameter()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(Expr alloc | result = alloc.getLocation() | allocSink(alloc, sink))\n  }\n}\n\nmodule TaintedAllocationSize = TaintTracking::Global<TaintedAllocationSizeConfig>;\n\nfrom\n  Expr alloc, TaintedAllocationSize::PathNode source, TaintedAllocationSize::PathNode sink,\n  string taintCause\nwhere\n  isFlowSource(source.getNode(), taintCause) and\n  TaintedAllocationSize::flowPath(source, sink) and\n  allocSink(alloc, sink.getNode())\nselect alloc, source, sink,\n  \"This allocation size is derived from $@ and could allocate arbitrary amounts of memory.\",\n  source.getNode(), \"user input (\" + taintCause + \")\"",
        "description": "Allocating memory with a size controlled by an external user can result in arbitrary amounts of memory being allocated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-190/TaintedAllocationSize.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Overflow\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.dataflow.new.DataFlow\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.controlflow.IRGuards as IRGuards\nimport semmle.code.cpp.security.FlowSources as FS\nimport Bounded\nimport Flow::PathGraph\n\nbindingset[op]\npredicate missingGuard(Operation op, Expr e, string effect) {\n  missingGuardAgainstUnderflow(op, e) and effect = \"underflow\"\n  or\n  missingGuardAgainstOverflow(op, e) and effect = \"overflow\"\n  or\n  not e instanceof VariableAccess and effect = \"overflow\"\n}\n\npredicate isSource(FS::FlowSource source, string sourceType) { sourceType = source.getSourceType() }\n\npredicate isSink(DataFlow::Node sink, Operation op, Expr e) {\n  e = sink.asExpr() and\n  missingGuard(op, e, _) and\n  op.getAnOperand() = e and\n  (\n    op instanceof UnaryArithmeticOperation or\n    op instanceof BinaryArithmeticOperation or\n    op instanceof AssignArithmeticOperation\n  )\n}\n\npredicate hasUpperBoundsCheck(Variable var) {\n  exists(RelationalOperation oper, VariableAccess access |\n    oper.getAnOperand() = access and\n    access.getTarget() = var and\n    // Comparing to 0 is not an upper bound check\n    not oper.getAnOperand().getValue() = \"0\"\n  )\n}\n\npredicate constantInstruction(Instruction instr) {\n  instr instanceof ConstantInstruction or\n  constantInstruction(instr.(UnaryInstruction).getUnary())\n}\n\npredicate readsVariable(LoadInstruction load, Variable var) {\n  load.getSourceAddress().(VariableAddressInstruction).getAstVariable() = var\n}\n\npredicate nodeIsBarrierEqualityCandidate(DataFlow::Node node, Operand access, Variable checkedVar) {\n  exists(Instruction instr | instr = node.asInstruction() |\n    readsVariable(instr, checkedVar) and\n    any(IRGuards::IRGuardCondition guard).ensuresEq(access, _, _, instr.getBlock(), true)\n  )\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    exists(StoreInstruction store, Expr e |\n      store = node.asInstruction() and e = node.asCertainDefinition()\n    |\n      // Block flow to \"likely small expressions\"\n      bounded(e)\n      or\n      // Block flow to \"small types\"\n      store.getResultType().getUnspecifiedType().(IntegralType).getSize() <= 1\n    )\n    or\n    // Block flow if there's an upper bound check of the variable anywhere in the program\n    exists(Variable checkedVar, Instruction instr | instr = node.asInstruction() |\n      readsVariable(instr, checkedVar) and\n      hasUpperBoundsCheck(checkedVar)\n    )\n    or\n    // Block flow if the node is guarded by an equality check\n    exists(Variable checkedVar, Operand access |\n      nodeIsBarrierEqualityCandidate(node, access, checkedVar) and\n      readsVariable(access.getDef(), checkedVar)\n    )\n    or\n    // Block flow to any binary instruction whose operands are both non-constants.\n    exists(BinaryInstruction iTo |\n      iTo = node.asInstruction() and\n      not constantInstruction(iTo.getLeft()) and\n      not constantInstruction(iTo.getRight()) and\n      // propagate taint from either the pointer or the offset, regardless of constantness\n      not iTo instanceof PointerArithmeticInstruction\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(Expr e | result = e.getLocation() | isSink(sink, _, e))\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom\n  Expr e, string effect, Flow::PathNode source, Flow::PathNode sink, Operation op, string sourceType\nwhere\n  Flow::flowPath(source, sink) and\n  isSource(source.getNode(), sourceType) and\n  isSink(sink.getNode(), op, e) and\n  missingGuard(op, e, effect)\nselect e, source, sink,\n  \"$@ flows to an operand of an arithmetic expression, potentially causing an \" + effect + \".\",\n  source, sourceType",
        "description": "Arithmetic operations on user-controlled data that is not validated can cause overflows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-190/ArithmeticTainted.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.Dominance\nimport semmle.code.cpp.controlflow.SSA\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\n\nint getComparisonSize(Expr e) {\n  if e.getType() instanceof ReferenceType\n  then result = e.getType().(ReferenceType).getBaseType().getSize()\n  else result = e.getType().getSize()\n}\n\npredicate loopVariant(VariableAccess e, Loop loop) {\n  exists(SsaDefinition d | d.getAUse(e.getTarget()) = e |\n    d.getAnUltimateDefiningValue(e.getTarget()) = loop.getCondition().getAChild*() or\n    d.getAnUltimateDefiningValue(e.getTarget()).getEnclosingStmt().getParent*() = loop.getStmt() or\n    d.getAnUltimateDefiningValue(e.getTarget()) = loop.(ForStmt).getUpdate().getAChild*()\n  )\n}\n\nElement friendlyLoc(Expr e) {\n  result = e.(Access).getTarget()\n  or\n  result = e.(Call).getTarget()\n  or\n  not e instanceof Access and not e instanceof Call and result = e\n}\n\nint getComparisonSizeAdjustment(Expr e) {\n  if e.getType().(IntegralType).isSigned() then result = 1 else result = 0\n}\n\nfrom Loop l, RelationalOperation rel, VariableAccess small, Expr large\nwhere\n  small = rel.getLesserOperand() and\n  large = rel.getGreaterOperand() and\n  rel = l.getCondition().getAChild*() and\n  forall(Expr conv | conv = large.getConversion*() |\n    // We adjust the comparison size in the case of a signed integer type.\n    // This is to exclude the sign bit from the comparison that determines if the small type's size is sufficient to hold\n    // the value of the larger type determined with range analysis.\n    upperBound(conv).log2() > (getComparisonSize(small) * 8 - getComparisonSizeAdjustment(small))\n  ) and\n  // Ignore cases where the smaller type is int or larger\n  // These are still bugs, but you should need a very large string or array to\n  // trigger them. We will want to disable this for some applications, but it's\n  // very noisy on codebases that started as 32-bit\n  small.getExplicitlyConverted().getType().getSize() < 4 and\n  // Ignore cases where integer promotion has occurred on /, -, or >> expressions.\n  not getComparisonSize(large.(DivExpr).getLeftOperand().getExplicitlyConverted()) <=\n    getComparisonSize(small) and\n  not getComparisonSize(large.(SubExpr).getLeftOperand().getExplicitlyConverted()) <=\n    getComparisonSize(small) and\n  not getComparisonSize(large.(RShiftExpr).getLeftOperand().getExplicitlyConverted()) <=\n    getComparisonSize(small) and\n  // ignore loop-invariant smaller variables\n  loopVariant(small, l)\nselect rel,\n  \"Comparison between $@ of type \" + small.getType().getName() + \" and $@ of wider type \" +\n    large.getType().getName() + \".\", friendlyLoc(small), small.toString(), friendlyLoc(large),\n  large.toString()",
        "description": "Comparisons between types of different widths in a loop condition can cause the loop to behave unexpectedly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-190/ComparisonWithWiderType.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Overflow\nimport semmle.code.cpp.security.Security\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport UncontrolledArith::PathGraph\nimport Bounded\n\nabstract class RandomFunction extends Function {\n  /**\n   * Gets the `FunctionOutput` that describes how this function returns the random data.\n   */\n  FunctionOutput getFunctionOutput() { result.isReturnValue() }\n}\n\nprivate class StdRand extends RandomFunction {\n  StdRand() {\n    this.hasGlobalOrStdOrBslName(\"rand\") and\n    this.getNumberOfParameters() = 0\n  }\n}\n\nprivate class RandR extends RandomFunction {\n  RandR() {\n    this.hasGlobalName(\"rand_r\") and\n    this.getNumberOfParameters() = 1\n  }\n}\n\nprivate class Random extends RandomFunction {\n  Random() {\n    this.hasGlobalName(\"random\") and\n    this.getNumberOfParameters() = 1\n  }\n}\n\nprivate class RandS extends RandomFunction {\n  RandS() {\n    this.hasGlobalName(\"rand_s\") and\n    this.getNumberOfParameters() = 1\n  }\n\n  override FunctionOutput getFunctionOutput() { result.isParameterDeref(0) }\n}\n\npredicate missingGuard(VariableAccess va, string effect) {\n  exists(Operation op | op.getAnOperand() = va |\n    // underflow - random numbers are usually non-negative, so underflow is\n    // only likely if the type is unsigned. Multiplication is also unlikely to\n    // cause underflow of a non-negative number.\n    missingGuardAgainstUnderflow(op, va) and\n    effect = \"underflow\" and\n    op.getUnspecifiedType().(IntegralType).isUnsigned() and\n    not op instanceof MulExpr\n    or\n    // overflow - only report signed integer overflow since unsigned overflow\n    // is well-defined.\n    op.getUnspecifiedType().(IntegralType).isSigned() and\n    missingGuardAgainstOverflow(op, va) and\n    effect = \"overflow\"\n  )\n}\n\nmodule UncontrolledArithConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(RandomFunction rand, Call call | call.getTarget() = rand |\n      rand.getFunctionOutput().isReturnValue() and\n      source.asExpr() = call\n      or\n      exists(int n |\n        source.asDefiningArgument() = call.getArgument(n) and\n        rand.getFunctionOutput().isParameterDeref(n)\n      )\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { missingGuard(sink.asExpr(), _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    bounded(node.asExpr())\n    or\n    // If this expression is part of bitwise 'and' or 'or' operation it's likely that the value is\n    // only used as a bit pattern.\n    node.asExpr() =\n      any(Operation op |\n        op instanceof BitwiseOrExpr or\n        op instanceof BitwiseAndExpr or\n        op instanceof ComplementExpr\n      ).getAnOperand*()\n    or\n    // block unintended flow to pointers\n    node.asExpr().getUnspecifiedType() instanceof PointerType\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    result = getExpr(source).getLocation()\n  }\n}\n\nmodule UncontrolledArith = TaintTracking::Global<UncontrolledArithConfig>;\n\nExpr getExpr(DataFlow::Node node) { result = [node.asExpr(), node.asDefiningArgument()] }\n\nfrom\n  UncontrolledArith::PathNode source, UncontrolledArith::PathNode sink, VariableAccess va,\n  string effect\nwhere\n  UncontrolledArith::flowPath(source, sink) and\n  sink.getNode().asExpr() = va and\n  missingGuard(va, effect)\nselect sink.getNode(), source, sink,\n  \"This arithmetic expression depends on an $@, potentially causing an \" + effect + \".\",\n  getExpr(source.getNode()), \"uncontrolled value\"",
        "description": "Arithmetic operations on uncontrolled data that is not validated can cause overflows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-190/ArithmeticUncontrolled.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.Guards\n\nFunctionCall filenameOperation(Expr path) {\n  exists(string name | name = result.getTarget().getName() |\n    name =\n      [\n        \"remove\", \"unlink\", \"rmdir\", \"rename\", \"fopen\", \"open\", \"freopen\", \"_open\", \"_wopen\",\n        \"_wfopen\", \"_fsopen\", \"_wfsopen\"\n      ] and\n    result.getArgument(0) = path\n    or\n    name = [\"fopen_s\", \"wfopen_s\", \"rename\"] and\n    result.getArgument(1) = path\n  )\n  or\n  result = sensitiveFilenameOperation(path)\n}\n\nFunctionCall sensitiveFilenameOperation(Expr path) {\n  exists(string name | name = result.getTarget().getName() |\n    name = [\"chmod\", \"chown\"] and\n    result.getArgument(0) = path\n  )\n}\n\nFunctionCall accessCheck(Expr path) {\n  exists(string name | name = result.getTarget().getName() |\n    name = [\"access\", \"_access\", \"_waccess\", \"_access_s\", \"_waccess_s\"]\n  ) and\n  path = result.getArgument(0)\n}\n\nFunctionCall stat(Expr path, Expr buf) {\n  exists(string name | name = result.getTarget().getName() |\n    name = [\"stat\", \"lstat\", \"fstat\"] or\n    name.matches(\"\\\\_stat%\") or\n    name.matches(\"\\\\_wstat%\")\n  ) and\n  path = result.getArgument(0) and\n  buf = result.getArgument(1)\n}\n\npredicate referenceTo(Expr source, Expr use) {\n  source = use\n  or\n  exists(SsaDefinition def, StackVariable v |\n    def.getAnUltimateDefiningValue(v) = source and def.getAUse(v) = use\n  )\n}\n\npragma[noinline]\npredicate statCallWithPointer(Expr checkPath, Expr call, Expr e, Variable v) {\n  call = stat(checkPath, e) and\n  e.getAChild*().(VariableAccess).getTarget() = v\n}\n\npredicate checksPath(Expr check, Expr checkPath) {\n  // either:\n  // an access check\n  check = accessCheck(checkPath)\n  or\n  // a stat\n  check = stat(checkPath, _)\n  or\n  // access to a member variable on the stat buf\n  // (morally, this should be a use-use pair, but it seems unlikely\n  // that this variable will get reused in practice)\n  exists(Expr e, Variable v |\n    statCallWithPointer(checkPath, _, e, v) and\n    check.(VariableAccess).getTarget() = v and\n    not e.getAChild*() = check // the call that writes to the pointer is not where the pointer is checked.\n  )\n}\n\npragma[nomagic]\npredicate checkPathControlsUse(Expr check, Expr checkPath, Expr use) {\n  exists(GuardCondition guard | referenceTo(check, guard.getAChild*()) |\n    guard.controls(use.getBasicBlock(), _)\n  ) and\n  checksPath(pragma[only_bind_into](check), checkPath)\n}\n\npragma[nomagic]\npredicate fileNameOperationControlsUse(Expr check, Expr checkPath, Expr use) {\n  exists(GuardCondition guard | referenceTo(check, guard.getAChild*()) |\n    guard.controls(use.getBasicBlock(), _)\n  ) and\n  pragma[only_bind_into](check) = filenameOperation(checkPath)\n}\n\npredicate checkUse(Expr check, Expr checkPath, FunctionCall use, Expr usePath) {\n  // `check` is part of a guard that controls `use`\n  checkPathControlsUse(check, checkPath, use) and\n  // `check` looks like a check on a filename\n  checksPath(check, checkPath) and\n  // `op` looks like an operation on a filename\n  use = filenameOperation(usePath)\n  or\n  // `check` is part of a guard that controls `use`\n  fileNameOperationControlsUse(check, checkPath, use) and\n  // another filename operation (null pointers can indicate errors)\n  check = filenameOperation(checkPath) and\n  // `op` looks like a sensitive operation on a filename\n  use = sensitiveFilenameOperation(usePath)\n}\n\npragma[noinline]\npredicate isCheckedPath(\n  Expr check, SsaDefinition def, StackVariable v, FunctionCall use, Expr usePath, Expr checkPath\n) {\n  checkUse(check, checkPath, use, usePath) and\n  def.getAUse(v) = checkPath\n}\n\npragma[noinline]\npredicate isUsedPath(\n  Expr check, SsaDefinition def, StackVariable v, FunctionCall use, Expr usePath, Expr checkPath\n) {\n  checkUse(check, checkPath, use, usePath) and\n  def.getAUse(v) = usePath\n}\n\nfrom Expr check, Expr checkPath, FunctionCall use, Expr usePath, SsaDefinition def, StackVariable v\nwhere\n  // `checkPath` and `usePath` refer to the same SSA variable\n  isCheckedPath(check, def, v, use, usePath, checkPath) and\n  isUsedPath(check, def, v, use, usePath, checkPath)\nselect use,\n  \"The $@ being operated upon was previously $@, but the underlying file may have been changed since then.\",\n  usePath, \"filename\", check, \"checked\"",
        "description": "Separately checking the state of a file before operating on it may allow an attacker to modify the file between the two operations.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-367/TOCTOUFilesystemRace.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.Guards\nimport semmle.code.cpp.ir.IR\n\nclass WideCharPointerType extends PointerType {\n  WideCharPointerType() { this.getBaseType() instanceof WideCharType }\n}\n\nType getABaseType(Type t) {\n  result = t\n  or\n  result = getABaseType(t.(DerivedType).getBaseType())\n  or\n  result = getABaseType(t.(TypedefType).getBaseType())\n}\n\nclass UnlikelyToBeAStringType extends Type {\n  UnlikelyToBeAStringType() {\n    exists(Type targ | getABaseType(this) = targ |\n      // NOTE: not using CharType isUnsigned, but rather look for any explicitly declared unsigned\n      // char types. Assuming these are used for buffers, not strings.\n      targ.(CharType).getName().toLowerCase().matches(\"unsigned%\") or\n      targ.getName().toLowerCase().matches([\"uint8_t\", \"%byte%\"])\n    )\n  }\n}\n\n// Types that can be wide depending on the UNICODE macro\n// see https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types\nclass UnicodeMacroDependentWidthType extends Type {\n  UnicodeMacroDependentWidthType() {\n    exists(Type targ | getABaseType(this) = targ |\n      targ.getName() in [\n          \"LPCTSTR\",\n          \"LPTSTR\",\n          \"PCTSTR\",\n          \"PTSTR\",\n          \"TBYTE\",\n          \"TCHAR\"\n        ]\n    )\n  }\n}\n\nclass UnicodeMacro extends Macro {\n  UnicodeMacro() { this.getName().toLowerCase().matches(\"%unicode%\") }\n}\n\nclass UnicodeMacroInvocation extends MacroInvocation {\n  UnicodeMacroInvocation() { this.getMacro() instanceof UnicodeMacro }\n}\n\npredicate isLikelyDynamicallyChecked(Expr e) {\n  e.getType() instanceof UnicodeMacroDependentWidthType and\n  exists(GuardCondition gc, BitwiseAndExpr bai, UnicodeMacroInvocation umi |\n    bai.getAnOperand() = umi.getExpr()\n  |\n    // bai == 0 is false when reaching `e.getBasicBlock()`.\n    // That is, bai != 0 when reaching `e.getBasicBlock()`.\n    gc.ensuresEq(bai, 0, e.getBasicBlock(), false)\n    or\n    // bai == k and k != 0 is true when reaching `e.getBasicBlock()`.\n    gc.ensuresEq(bai, any(int k | k != 0), e.getBasicBlock(), true)\n  )\n}\n\nfrom Expr e1, Cast e2\nwhere\n  e2 = e1.getConversion() and\n  exists(WideCharPointerType w, CharPointerType c |\n    w = e2.getUnspecifiedType().(PointerType) and\n    c = e1.getUnspecifiedType().(PointerType)\n  ) and\n  // Avoid `BYTE`-like casting as they are typically false positives\n  // Example: `BYTE* buffer;` ... `(wchar_t*) buffer;`\n  not e1.getType() instanceof UnlikelyToBeAStringType and\n  // Avoid castings from 'new' expressions as typically these will be safe\n  // Example: `__Type* ret = reinterpret_cast<__Type*>(New(m_pmo) char[num * sizeof(__Type)]);`\n  not exists(NewOrNewArrayExpr newExpr | newExpr.getAChild*() = e1) and\n  // Avoid cases where the cast is guarded by a check to determine if\n  // unicode encoding is enabled in such a way to disallow the dangerous cast\n  // at runtime.\n  not isLikelyDynamicallyChecked(e1) and\n  // Avoid cases in unreachable blocks.\n  any(EnterFunctionInstruction e).getASuccessor+().getAst() = e1\nselect e1,\n  \"Conversion from \" + e1.getType().toString() + \" to \" + e2.getType().toString() +\n    \". Use of invalid string can lead to undefined behavior.\"",
        "description": "Casting a byte string to a wide-character string is likely to yield a string that is incorrectly terminated or aligned. This can lead to undefined behavior, including buffer overruns.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-704/WcharCharConversion.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Exclusions\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport semmle.code.cpp.rangeanalysis.RangeAnalysisUtils\nimport semmle.code.cpp.controlflow.Guards\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\npragma[nomagic]\npredicate isGuarded(SubExpr sub, Expr left, Expr right) {\n  exprIsSubLeftOrLess(pragma[only_bind_into](sub), _) and // Manual magic\n  exists(GuardCondition guard, int k, BasicBlock bb |\n    pragma[only_bind_into](bb) = sub.getBasicBlock() and\n    guard.controls(pragma[only_bind_into](bb), _) and\n    guard.ensuresLt(left, right, k, bb, false) and\n    k >= 0\n  )\n}\n\nExpr exprIsLeftOrLessBase(SubExpr sub) {\n  interestingSubExpr(sub, _) and // Manual magic\n  exists(Expr e | globalValueNumber(e).getAnExpr() = sub.getLeftOperand() |\n    // sub = e - x\n    // result = e\n    // so:\n    // result <= e\n    result = e\n    or\n    // sub = e - x\n    // result = e & y\n    // so:\n    // result = e & y <= e\n    result.(BitwiseAndExpr).getAnOperand() = e\n    or\n    exists(SubExpr s |\n      // sub = e - x\n      // result = s\n      // s = e - y\n      // y >= 0\n      // so:\n      // result = e - y <= e\n      result = s and\n      s.getLeftOperand() = e and\n      lowerBound(s.getRightOperand().getFullyConverted()) >= 0\n    )\n    or\n    exists(Expr other |\n      // sub = e - x\n      // result = a\n      // a = e + y\n      // y <= 0\n      // so:\n      // result = e + y <= e + 0 = e\n      result.(AddExpr).hasOperands(e, other) and\n      upperBound(other.getFullyConverted()) <= 0\n    )\n    or\n    exists(DivExpr d |\n      // sub = e - x\n      // result = d\n      // d = e / y\n      // y >= 1\n      // so:\n      // result = e / y <= e / 1 = e\n      result = d and\n      d.getLeftOperand() = e and\n      lowerBound(d.getRightOperand().getFullyConverted()) >= 1\n    )\n    or\n    exists(RShiftExpr rs |\n      // sub = e - x\n      // result = rs\n      // rs = e >> y\n      // so:\n      // result = e >> y <= e\n      result = rs and\n      rs.getLeftOperand() = e\n    )\n  )\n}\n\npredicate exprIsSubLeftOrLess(SubExpr sub, DataFlow::Node n) {\n  n.asExpr() = exprIsLeftOrLessBase(sub)\n  or\n  exists(DataFlow::Node other |\n    // dataflow\n    exprIsSubLeftOrLess(sub, other) and\n    (\n      DataFlow::localFlowStep(n, other) or\n      DataFlow::localFlowStep(other, n)\n    )\n  )\n  or\n  exists(DataFlow::Node other |\n    // guard constraining `sub`\n    exprIsSubLeftOrLess(sub, other) and\n    isGuarded(sub, other.asExpr(), n.asExpr()) // other >= n\n  )\n  or\n  exists(DataFlow::Node other, float p, float q |\n    // linear access of `other`\n    exprIsSubLeftOrLess(sub, other) and\n    linearAccess(n.asExpr(), other.asExpr(), p, q) and // n = p * other + q\n    p <= 1 and\n    q <= 0\n  )\n  or\n  exists(DataFlow::Node other, float p, float q |\n    // linear access of `n`\n    exprIsSubLeftOrLess(sub, other) and\n    linearAccess(other.asExpr(), n.asExpr(), p, q) and // other = p * n + q\n    p >= 1 and\n    q >= 0\n  )\n}\n\npredicate interestingSubExpr(SubExpr sub, RelationalOperation ro) {\n  not isFromMacroDefinition(sub) and\n  ro.getLesserOperand().getValue().toInt() = 0 and\n  ro.getGreaterOperand() = sub and\n  sub.getFullyConverted().getUnspecifiedType().(IntegralType).isUnsigned() and\n  // generally catches false positives involving constants\n  exprMightOverflowNegatively(sub.getFullyConverted())\n}\n\nfrom RelationalOperation ro, SubExpr sub\nwhere\n  interestingSubExpr(sub, ro) and\n  not isFromMacroDefinition(ro) and\n  // generally catches false positives where there's a relation between the left and right operands\n  not exprIsSubLeftOrLess(sub, DataFlow::exprNode(sub.getRightOperand()))\nselect ro, \"Unsigned subtraction can never be negative.\"",
        "description": "A subtraction with an unsigned result can never be negative. Using such an expression in a relational comparison with `0` is likely to be wrong.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-191/UnsignedDifferenceExpressionComparedZero.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.models.interfaces.ArrayFunction\nimport semmle.code.cpp.models.interfaces.Allocation\nimport semmle.code.cpp.commons.NullTermination\n\npredicate terminationProblem(HeuristicAllocationExpr malloc, string msg) {\n  // malloc(strlen(...))\n  exists(StrlenCall strlen | DataFlow::localExprFlow(strlen, malloc.getSizeExpr())) and\n  // flows to a call that implies this is a null-terminated string\n  exists(ArrayFunction af, FunctionCall fc, int arg |\n    DataFlow::localExprFlow(malloc, fc.getArgument(arg)) and\n    fc.getTarget() = af and\n    (\n      // flows into null terminated string argument\n      af.hasArrayWithNullTerminator(arg)\n      or\n      // flows into likely null terminated string argument (such as `strcpy`, `strcat`)\n      af.hasArrayWithUnknownSize(arg)\n      or\n      // flows into string argument to a formatting function (such as `printf`)\n      formatArgumentMustBeNullTerminated(fc, fc.getArgument(arg))\n    )\n  ) and\n  msg = \"This allocation does not include space to null-terminate the string.\"\n}\n\nfrom Expr problem, string msg\nwhere terminationProblem(problem, msg)\nselect problem, msg",
        "description": "Allocating a buffer using 'malloc' without ensuring that there is always space for the entire string and a zero terminator can cause a buffer overrun.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-131/NoSpaceForZeroTerminator.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.models.implementations.StdString\nimport Temporaries\n\nfrom Call c\nwhere\n  outlivesFullExpr(c) and\n  not c.isFromUninstantiatedTemplate(_) and\n  (c.getTarget() instanceof StdStringCStr or c.getTarget() instanceof StdStringData) and\n  isTemporary(c.getQualifier().getFullyConverted())\nselect c,\n  \"The underlying temporary string object is destroyed after the call to '\" + c.getTarget() +\n    \"' returns.\"",
        "description": "If the value of a call to 'c_str' outlives the underlying object it may lead to unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-416/UseOfStringAfterLifetimeEnds.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.models.interfaces.PointerWrapper\nimport Temporaries\n\npredicate isUniquePointerDerefFunction(Function f) {\n  exists(PointerWrapper wrapper |\n    f = wrapper.getAnUnwrapperFunction() and\n    // We only want unique pointers as the memory behind share pointers may still be\n    // alive after the shared pointer is destroyed.\n    wrapper.(Class).hasQualifiedName([\"std\", \"bsl\"], \"unique_ptr\")\n  )\n}\n\nfrom Call c\nwhere\n  outlivesFullExpr(c) and\n  not c.isFromUninstantiatedTemplate(_) and\n  isUniquePointerDerefFunction(c.getTarget()) and\n  // Exclude cases where the pointer is implicitly converted to a non-pointer type\n  not c.getActualType() instanceof IntegralType and\n  isTemporary(c.getQualifier().getFullyConverted())\nselect c,\n  \"The underlying unique pointer object is destroyed after the call to '\" + c.getTarget() +\n    \"' returns.\"",
        "description": "Referencing the contents of a unique pointer after the underlying object has expired may lead to unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-416/UseOfUniquePointerAfterLifetimeEnds.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.dataflow.new.DataFlow\nimport semmle.code.cpp.models.implementations.StdContainer\nimport semmle.code.cpp.models.implementations.StdMap\nimport semmle.code.cpp.models.implementations.Iterator\n\nprivate predicate tempToDestructorSink(DataFlow::Node sink, CallInstruction call) {\n  call = sink.asOperand().(ThisArgumentOperand).getCall() and\n  call.getStaticCallTarget() instanceof Destructor\n}\n\nprivate predicate isPostUpdateOfQualifier(CallInstruction call, DataFlow::PostUpdateNode pun) {\n  call.getThisArgumentOperand() = pun.getPreUpdateNode().asOperand()\n}\n\nDataFlow::Node getADestroyedNode(DataFlow::Node n) {\n  // Case 1: The pointer that goes into the destructor call is destroyed\n  exists(CallInstruction destructorCall |\n    tempToDestructorSink(n, destructorCall) and\n    isPostUpdateOfQualifier(destructorCall, result)\n  )\n  or\n  // Case 2: Anything that was derived from the temporary that is now destroyed\n  // is also destroyed.\n  exists(CallInstruction call |\n    result.asInstruction() = call and\n    DataFlow::localFlow(DataFlow::operandNode(call.getThisArgumentOperand()), n)\n  |\n    call.getStaticCallTarget() instanceof StdSequenceContainerAt or\n    call.getStaticCallTarget() instanceof StdMapAt\n  )\n}\n\npredicate destroyedToBeginSink(DataFlow::Node sink) {\n  exists(CallInstruction call |\n    call = sink.asOperand().(ThisArgumentOperand).getCall() and\n    call.getStaticCallTarget() instanceof BeginOrEndFunction\n  )\n}\n\nprivate predicate qualifierToDestroyed(DataFlow::Node node1, DataFlow::Node node2) {\n  tempToDestructorSink(node1, _) and\n  node2 = getADestroyedNode(node1)\n}\n\nmodule Config0 implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { qualifierToDestroyed(_, source) }\n\n  predicate isSink(DataFlow::Node sink) { destroyedToBeginSink(sink) }\n}\n\nmodule Flow0 = DataFlow::Global<Config0>;\n\nmodule Config implements DataFlow::StateConfigSig {\n  newtype FlowState =\n    additional TempToDestructor() or\n    additional DestroyedToBegin(DataFlow::Node n) {\n      any(Flow0::PathNode pn | pn.isSource()).getNode() = n\n    }\n\n  /**\n   * Holds if `sink` is a qualifier to a call to `begin`, and `mid` is an\n   * object that is destroyed.\n   */\n  private predicate relevant(DataFlow::Node mid, DataFlow::Node sink) { Flow0::flow(mid, sink) }\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    source.asInstruction().(VariableAddressInstruction).getIRVariable() instanceof IRTempVariable and\n    state = TempToDestructor()\n  }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    state1 = TempToDestructor() and\n    state2 = DestroyedToBegin(node2) and\n    qualifierToDestroyed(node1, node2)\n  }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    exists(DataFlow::Node mid |\n      relevant(mid, sink) and\n      state = DestroyedToBegin(mid)\n    )\n  }\n\n  DataFlow::FlowFeature getAFeature() {\n    // By blocking argument-to-parameter flow we ensure that we don't enter a\n    // function body where the temporary outlives anything inside the function.\n    // This prevents false positives in cases like:\n    // ```cpp\n    // void foo(const std::vector<int>& v) {\n    //   for(auto x : v) { ... } // this is fine since v outlives the loop\n    // }\n    // ...\n    // foo(create_temporary())\n    // ```\n    result instanceof DataFlow::FeatureHasSinkCallContext\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(DataFlow::Node mid, FlowState state | result = mid.getLocation() |\n      destroyedToBeginSink(sink) and\n      isSink(sink, state) and\n      state = Config::DestroyedToBegin(mid)\n    )\n  }\n}\n\nmodule Flow = DataFlow::GlobalWithState<Config>;\n\nfrom Flow::PathNode source, Flow::PathNode sink, DataFlow::Node mid\nwhere\n  Flow::flowPath(source, sink) and\n  destroyedToBeginSink(sink.getNode()) and\n  sink.getState() = Config::DestroyedToBegin(mid)\nselect mid, \"This object is destroyed at the end of the full-expression.\"",
        "description": "Using an iterator owned by a container whose lifetime has expired may lead to unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-416/IteratorToExpiredContainer.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Security\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.security.FunctionWithWrappers\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport SqlTainted::PathGraph\n\nclass SqlLikeFunction extends FunctionWithWrappers {\n  SqlLikeFunction() { sqlArgument(this.getName(), _) }\n\n  override predicate interestingArg(int arg) { sqlArgument(this.getName(), arg) }\n}\n\nExpr asSinkExpr(DataFlow::Node node) {\n  result = node.asIndirectArgument()\n  or\n  // We want the conversion so we only get one node for the expression\n  result = node.asExpr()\n}\n\nmodule SqlTaintedConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof FlowSource }\n\n  predicate isSink(DataFlow::Node node) {\n    exists(SqlLikeFunction runSql | runSql.outermostWrapperFunctionCall(asSinkExpr(node), _))\n    or\n    // sink defined using models-as-data\n    sinkNode(node, \"sql-injection\")\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate isBarrierIn(DataFlow::Node node) {\n    exists(SqlBarrierFunction sql, int arg, FunctionInput input |\n      node.asIndirectArgument() = sql.getACallToThisFunction().getArgument(arg) and\n      input.isParameterDeref(arg) and\n      sql.barrierSqlArgument(input, _)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(Expr taintedArg | result = taintedArg.getLocation() | taintedArg = asSinkExpr(sink))\n  }\n}\n\nmodule SqlTainted = TaintTracking::Global<SqlTaintedConfig>;\n\nfrom\n  Expr taintedArg, FlowSource taintSource, SqlTainted::PathNode sourceNode,\n  SqlTainted::PathNode sinkNode, string extraText\nwhere\n  (\n    exists(SqlLikeFunction runSql, string callChain |\n      runSql.outermostWrapperFunctionCall(taintedArg, callChain) and\n      extraText = \" and then passed to \" + callChain\n    )\n    or\n    sinkNode(sinkNode.getNode(), \"sql-injection\") and\n    extraText = \"\"\n  ) and\n  SqlTainted::flowPath(sourceNode, sinkNode) and\n  taintedArg = asSinkExpr(sinkNode.getNode()) and\n  taintSource = sourceNode.getNode()\nselect taintedArg, sourceNode, sinkNode,\n  \"This argument to a SQL query function is derived from $@\" + extraText + \".\", taintSource,\n  \"user input (\" + taintSource.getSourceType() + \")\"",
        "description": "Including user-supplied data in a SQL query without neutralizing special elements can make code vulnerable to SQL Injection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-089/SqlTainted.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\npredicate isCreateProcessFunction(FunctionCall call, int applicationNameIndex, int commandLineIndex) {\n  call.getTarget().hasGlobalName(\"CreateProcessA\") and\n  applicationNameIndex = 0 and\n  commandLineIndex = 1\n  or\n  call.getTarget().hasGlobalName(\"CreateProcessW\") and\n  applicationNameIndex = 0 and\n  commandLineIndex = 1\n  or\n  call.getTarget().hasGlobalName(\"CreateProcessWithTokenW\") and\n  applicationNameIndex = 2 and\n  commandLineIndex = 3\n  or\n  call.getTarget().hasGlobalName(\"CreateProcessWithLogonW\") and\n  applicationNameIndex = 4 and\n  commandLineIndex = 5\n  or\n  call.getTarget().hasGlobalName(\"CreateProcessAsUserA\") and\n  applicationNameIndex = 1 and\n  commandLineIndex = 2\n  or\n  call.getTarget().hasGlobalName(\"CreateProcessAsUserW\") and\n  applicationNameIndex = 1 and\n  commandLineIndex = 2\n}\n\nclass CreateProcessFunctionCall extends FunctionCall {\n  CreateProcessFunctionCall() { isCreateProcessFunction(this, _, _) }\n\n  int getApplicationNameArgumentId() { isCreateProcessFunction(this, result, _) }\n\n  int getCommandLineArgumentId() { isCreateProcessFunction(this, _, result) }\n}\n\nmodule NullAppNameCreateProcessFunctionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.asExpr() instanceof NullValue }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(CreateProcessFunctionCall call, Expr val | val = sink.asExpr() |\n      val = call.getArgument(call.getApplicationNameArgumentId())\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(CreateProcessFunctionCall call | result = call.getLocation() |\n      sink.asExpr() = call.getArgument(call.getApplicationNameArgumentId())\n    )\n  }\n}\n\nmodule NullAppNameCreateProcessFunction = DataFlow::Global<NullAppNameCreateProcessFunctionConfig>;\n\nmodule QuotedCommandInCreateProcessFunctionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(string s |\n      s = source.asExpr().getValue().toString() and\n      not isQuotedOrNoSpaceApplicationNameOnCmd(s)\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(CreateProcessFunctionCall call, Expr val | val = sink.asExpr() |\n      val = call.getArgument(call.getCommandLineArgumentId())\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(CreateProcessFunctionCall call | result = call.getLocation() |\n      sink.asExpr() = call.getArgument(call.getCommandLineArgumentId())\n    )\n  }\n}\n\nmodule QuotedCommandInCreateProcessFunction =\n  DataFlow::Global<QuotedCommandInCreateProcessFunctionConfig>;\n\nbindingset[s]\npredicate isQuotedOrNoSpaceApplicationNameOnCmd(string s) {\n  s.regexpMatch(\"\\\"([^\\\"])*\\\"[\\\\s\\\\S]*\") // The first element (path) is quoted\n  or\n  s.regexpMatch(\"[^\\\\s]+\") // There are no spaces in the string\n}\n\nfrom CreateProcessFunctionCall call, string msg1, string msg2\nwhere\n  exists(Expr appName |\n    appName = call.getArgument(call.getApplicationNameArgumentId()) and\n    NullAppNameCreateProcessFunction::flowToExpr(appName) and\n    msg1 = call.toString() + \" with lpApplicationName == NULL (\" + appName + \")\"\n  ) and\n  exists(Expr cmd |\n    cmd = call.getArgument(call.getCommandLineArgumentId()) and\n    QuotedCommandInCreateProcessFunction::flowToExpr(cmd) and\n    msg2 =\n      \" and with an unquoted lpCommandLine (\" + cmd +\n        \") introduces a security vulnerability if the path contains spaces.\"\n  )\nselect call, msg1 + \" \" + msg2",
        "description": "Calling a function of the CreateProcess* family of functions, where the path contains spaces, introduces a security vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-428/UnsafeCreateProcessCall.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport ExternalAPIs\n\nfrom ExternalApiUsedWithUntrustedData externalApi\nselect externalApi, count(externalApi.getUntrustedDataNode()) as numberOfUses,\n  externalApi.getNumberOfUntrustedSources() as numberOfUntrustedSources order by\n    numberOfUntrustedSources desc",
        "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-020/CountUntrustedDataToExternalAPI.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport ir.ExternalAPIs\n\nfrom ExternalApiUsedWithUntrustedData externalApi\nselect externalApi, count(externalApi.getUntrustedDataNode()) as numberOfUses,\n  externalApi.getNumberOfUntrustedSources() as numberOfUntrustedSources order by\n    numberOfUntrustedSources desc",
        "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-020/IRCountUntrustedDataToExternalAPI.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom UntrustedDataToExternalApiFlow::PathNode source, UntrustedDataToExternalApiFlow::PathNode sink\nwhere UntrustedDataToExternalApiFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"Call to \" + sink.getNode().(ExternalApiDataNode).getExternalFunction().toString() +\n    \" with untrusted data from $@.\", source, source.toString()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-020/UntrustedDataToExternalAPI.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport ir.ExternalAPIs\nimport semmle.code.cpp.security.FlowSources\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom UntrustedDataToExternalApiFlow::PathNode source, UntrustedDataToExternalApiFlow::PathNode sink\nwhere UntrustedDataToExternalApiFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"Call to \" + sink.getNode().(ExternalApiDataNode).getExternalFunction().toString() +\n    \" with untrusted data from $@.\", source, source.getNode().(RemoteFlowSource).getSourceType()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-020/IRUntrustedDataToExternalAPI.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass AnyCharPointerType extends PointerType {\n  AnyCharPointerType() {\n    this.getBaseType().getUnderlyingType() instanceof CharType or\n    this.getBaseType().getUnderlyingType() instanceof Wchar_t\n  }\n}\n\nclass AnyCharArrayType extends ArrayType {\n  AnyCharArrayType() {\n    this.getBaseType().getUnderlyingType() instanceof CharType or\n    this.getBaseType().getUnderlyingType() instanceof Wchar_t\n  }\n}\n\nclass AnyStdStringType extends Type {\n  AnyStdStringType() {\n    exists(Namespace std |\n      std.getName() = \"std\" and\n      std.getADeclaration() = this\n    ) and\n    this.getName().matches(\"basic\\\\_string<%\")\n  }\n}\n\nclass IFStream extends Type {\n  IFStream() {\n    exists(Namespace std |\n      std.getName() = \"std\" and\n      std.getADeclaration() = this\n    ) and\n    this.getName().matches(\"basic\\\\_ifstream<%\")\n  }\n}\n\nclass CinVariable extends NamespaceVariable {\n  CinVariable() {\n    this.getName() = [\"cin\", \"wcin\"] and\n    this.getNamespace().getName() = \"std\"\n  }\n}\n\nclass OperatorRShiftCall extends FunctionCall {\n  OperatorRShiftCall() {\n    this.getTarget().getNamespace().getName() = \"std\" and\n    this.getTarget().hasName(\"operator>>\")\n  }\n\n  /*\n   * This is complicated by the fact this overload can be made\n   * in two ways:\n   *  - as a member of the `std::istream` class, with one parameter.\n   *  - as an independent function, with two parameters.\n   */\n\n  Expr getSource() {\n    if this.getTarget() instanceof MemberFunction\n    then result = this.getQualifier()\n    else result = this.getArgument(0)\n  }\n\n  Expr getDest() {\n    if this.getTarget() instanceof MemberFunction\n    then result = this.getArgument(0)\n    else result = this.getArgument(1)\n  }\n}\n\nabstract class PotentiallyDangerousInput extends Expr {\n  /**\n   * Gets the variable that is the source of this input stream, if\n   * it can be determined.\n   */\n  abstract Variable getStreamVariable();\n\n  /**\n   * Gets the previous access to the same input stream, if any.\n   */\n  abstract PotentiallyDangerousInput getPreviousAccess();\n\n  /**\n   * Gets the width restriction that applies to the input stream\n   * for this expression, if any.\n   */\n  Expr getWidth() { result = this.getPreviousAccess().getWidthAfter() }\n\n  private Expr getWidthSetHere() {\n    exists(FunctionCall widthCall |\n      // std::istream.width or std::wistream.width\n      widthCall.getQualifier() = this and\n      widthCall.getTarget().getName() = \"width\" and\n      result = widthCall.getArgument(0)\n    )\n    or\n    exists(FunctionCall setwCall, Function setw |\n      // >> std::setw\n      setwCall = this.(OperatorRShiftCall).getDest() and\n      setw = setwCall.getTarget() and\n      setw.getNamespace().getName() = \"std\" and\n      setw.hasName(\"setw\") and\n      result = setwCall.getArgument(0)\n    )\n  }\n\n  private predicate isWidthConsumedHere() {\n    // std::cin >> s, where s is a char*, char[] or std::string type\n    // or wide character equivalent\n    exists(Type t | t = this.(OperatorRShiftCall).getDest().getUnderlyingType() |\n      t instanceof AnyCharPointerType or\n      t instanceof AnyCharArrayType or\n      t instanceof AnyStdStringType\n    )\n  }\n\n  /**\n   * Gets the width restriction that applies to the input stream\n   * after this expression, if any.\n   */\n  Expr getWidthAfter() {\n    result = this.getWidthSetHere()\n    or\n    not exists(this.getWidthSetHere()) and\n    not this.isWidthConsumedHere() and\n    result = this.getWidth()\n  }\n}\n\npredicate nextPotentiallyDangerousInput(\n  ControlFlowNode cfn, PotentiallyDangerousInput next, Variable streamVariable\n) {\n  // this node\n  next = cfn and\n  next.getStreamVariable() = streamVariable\n  or\n  // flow\n  not cfn.(PotentiallyDangerousInput).getStreamVariable() = streamVariable and\n  nextPotentiallyDangerousInput(cfn.getASuccessor(), next, streamVariable)\n}\n\nclass CinAccess extends PotentiallyDangerousInput {\n  CinAccess() { this.(VariableAccess).getTarget() instanceof CinVariable }\n\n  override Variable getStreamVariable() { result = this.(VariableAccess).getTarget() }\n\n  override PotentiallyDangerousInput getPreviousAccess() {\n    nextPotentiallyDangerousInput(result.getASuccessor(), this, result.getStreamVariable())\n  }\n}\n\nclass IFStreamAccess extends PotentiallyDangerousInput {\n  IFStreamAccess() { this.(VariableAccess).getTarget().getUnderlyingType() instanceof IFStream }\n\n  override Variable getStreamVariable() { result = this.(VariableAccess).getTarget() }\n\n  override PotentiallyDangerousInput getPreviousAccess() {\n    nextPotentiallyDangerousInput(result.getASuccessor(), this, result.getStreamVariable())\n  }\n}\n\nclass ChainedInput extends PotentiallyDangerousInput {\n  ChainedInput() { this.(OperatorRShiftCall).getSource() instanceof PotentiallyDangerousInput }\n\n  override Variable getStreamVariable() {\n    result = this.(OperatorRShiftCall).getSource().(PotentiallyDangerousInput).getStreamVariable()\n  }\n\n  override PotentiallyDangerousInput getPreviousAccess() {\n    result = this.(OperatorRShiftCall).getSource()\n  }\n}\n\nfrom PotentiallyDangerousInput input, OperatorRShiftCall rshift, Expr dest\nwhere\n  // a call to operator>> on a potentially dangerous input\n  input = rshift.getSource() and\n  dest = rshift.getDest() and\n  (\n    // destination is char* or wchar_t*\n    dest.getUnderlyingType() instanceof AnyCharPointerType and\n    // assume any width setting makes this safe\n    not exists(input.getWidthAfter())\n    or\n    exists(int arraySize |\n      // destination is char[] or wchar_t* or a wide character equivalent.\n      arraySize = dest.getUnderlyingType().(AnyCharArrayType).getArraySize() and\n      // assume any width setting makes this safe, unless we know\n      // it to be larger than the array.\n      forall(Expr w | w = input.getWidthAfter() | w.getValue().toInt() > arraySize)\n    )\n  )\nselect rshift, \"Use of 'cin' without specifying the length of the input may be dangerous.\"",
        "description": "Using `cin` without specifying the length of the input may be dangerous.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-676/DangerousUseOfCin.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom FunctionCall call, Function target\nwhere\n  call.getTarget() = target and\n  target.hasGlobalOrStdName(\"gets\") and\n  target.getNumberOfParameters() = 1\nselect call, \"'gets' does not guard against buffer overflow.\"",
        "description": "Use of a standard library function that does not guard against buffer overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-676/DangerousFunctionOverflow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate potentiallyDangerousFunction(Function f, string message) {\n  exists(string name | f.hasGlobalName(name) |\n    name = [\"gmtime\", \"localtime\", \"ctime\", \"asctime\"] and\n    message = \"Call to '\" + name + \"' is potentially dangerous.\"\n  )\n}\n\nfrom FunctionCall call, Function target, string message\nwhere\n  call.getTarget() = target and\n  potentiallyDangerousFunction(target, message)\nselect call, message",
        "description": "Use of a standard library function that is not thread-safe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-676/PotentiallyDangerousFunction.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.Guards\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\nclass SslGetVerifyResultCall extends FunctionCall {\n  SslGetVerifyResultCall() { this.getTarget().getName() = \"SSL_get_verify_result\" }\n}\n\nmodule VerifyResultConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.asExpr() instanceof SslGetVerifyResultCall }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(GuardCondition guard | guard.getAChild*() = sink.asExpr())\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(GuardCondition guard | result = guard.getLocation() |\n      guard.comparesEq(sink.asExpr(), _, 0, false, _)\n    )\n  }\n}\n\nmodule VerifyResult = DataFlow::Global<VerifyResultConfig>;\n\nfrom\n  DataFlow::Node source, DataFlow::Node sink1, DataFlow::Node sink2, GuardCondition guard, Expr c1,\n  Expr c2, boolean testIsTrue\nwhere\n  VerifyResult::flow(source, sink1) and\n  VerifyResult::flow(source, sink2) and\n  guard.comparesEq(sink1.asExpr(), c1, 0, false, testIsTrue) and // (value != c1) => testIsTrue\n  guard.comparesEq(sink2.asExpr(), c2, 0, false, testIsTrue) and // (value != c2) => testIsTrue\n  c1.getValue().toInt() = 0 and\n  c2.getValue().toInt() != 0\nselect guard, \"This expression conflates OK and non-OK results from $@.\", source, source.toString()",
        "description": "Only accept SSL certificates that pass certificate verification.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-295/SSLResultConflation.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.controlflow.IRGuards\n\nclass SslGetPeerCertificateCall extends FunctionCall {\n  SslGetPeerCertificateCall() {\n    this.getTarget().getName() = \"SSL_get_peer_certificate\" // SSL_get_peer_certificate(ssl)\n  }\n\n  Expr getSslArgument() { result = this.getArgument(0) }\n}\n\nclass SslGetVerifyResultCall extends FunctionCall {\n  SslGetVerifyResultCall() {\n    this.getTarget().getName() = \"SSL_get_verify_result\" // SSL_get_peer_certificate(ssl)\n  }\n\n  Expr getSslArgument() { result = this.getArgument(0) }\n}\n\npredicate resultIsChecked(SslGetPeerCertificateCall getCertCall, ControlFlowNode node) {\n  exists(Expr ssl, SslGetVerifyResultCall check |\n    ssl = globalValueNumber(getCertCall.getSslArgument()).getAnExpr() and\n    ssl = check.getSslArgument() and\n    node = check\n  )\n}\n\npredicate certIsZero(\n  SslGetPeerCertificateCall getCertCall, ControlFlowNode node1, ControlFlowNode node2\n) {\n  exists(Expr cert |\n    cert = globalValueNumber(getCertCall).getAnExpr() and\n    node1.(GuardCondition).ensuresEqEdge(cert, 0, _, node2.getBasicBlock(), true)\n  )\n}\n\npredicate certNotChecked(SslGetPeerCertificateCall getCertCall, ControlFlowNode node) {\n  // cert is not checked at the call to `SSL_get_peer_certificate`\n  node = getCertCall\n  or\n  exists(BasicBlock bb, int pos |\n    // flow to end of a `BasicBlock`\n    certNotChecked(getCertCall, bb.getNode(pos)) and\n    node = bb.getEnd() and\n    // check for barrier node\n    not exists(int pos2 |\n      pos2 > pos and\n      resultIsChecked(getCertCall, bb.getNode(pos2))\n    )\n  )\n  or\n  exists(BasicBlock pred, BasicBlock bb |\n    // flow from the end of one `BasicBlock` to the beginning of a successor\n    certNotChecked(getCertCall, pred.getEnd()) and\n    bb = pred.getASuccessor() and\n    node = bb.getStart() and\n    // check for barrier bb\n    not certIsZero(getCertCall, pred.getEnd(), bb.getStart())\n  )\n}\n\nfrom SslGetPeerCertificateCall getCertCall, ControlFlowNode node\nwhere\n  certNotChecked(getCertCall, node) and\n  node instanceof Function // (function exit)\nselect getCertCall,\n  \"This \" + getCertCall.toString() + \" is not followed by a call to SSL_get_verify_result.\"",
        "description": "Always check the result of certificate verification after fetching an SSL certificate.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-295/SSLResultNotChecked.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.models.interfaces.FlowSource\nimport semmle.code.cpp.security.OutputWrite\nimport semmle.code.cpp.models.implementations.Memset\nimport PotentiallyExposedSystemData::PathGraph\nimport SystemData\n\nmodule PotentiallyExposedSystemDataConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source = any(SystemData sd | sd.isSensitive()).getAnExpr()\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(OutputWrite ow, Expr child | child = ow.getASource().getAChild*() |\n      // Most sinks receive a pointer as an argument (for example `printf`),\n      // and we use an indirect sink for those.\n      // However, some sinks (for example `puts`) receive a single character\n      // as an argument. For those we have to use a direct sink.\n      if\n        child.getUnspecifiedType() instanceof PointerType or\n        child.getUnspecifiedType() instanceof ArrayType\n      then child = sink.asIndirectExpr()\n      else child = sink.asExpr()\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asIndirectArgument() = any(MemsetFunction func).getACallToThisFunction().getAnArgument()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule PotentiallyExposedSystemData = TaintTracking::Global<PotentiallyExposedSystemDataConfig>;\n\nfrom PotentiallyExposedSystemData::PathNode source, PotentiallyExposedSystemData::PathNode sink\nwhere PotentiallyExposedSystemData::flowPath(source, sink)\nselect sink, source, sink, \"This operation potentially exposes sensitive system data from $@.\",\n  source, source.getNode().toString()",
        "description": "Exposing sensitive system data helps a malicious user learn about the system and form an attack plan.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-497/PotentiallyExposedSystemData.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.models.interfaces.FlowSource\nimport semmle.code.cpp.models.implementations.Memset\nimport semmle.code.cpp.security.FlowSources\nimport ExposedSystemData::PathGraph\nimport SystemData\n\nmodule ExposedSystemDataConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source = any(SystemData sd).getAnExpr() }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink instanceof RemoteFlowSink\n    or\n    // workaround for cases where the sink contains the tainted thing as a child; this could\n    // probably be handled better with taint inheriting content or similar modeling.\n    exists(RemoteFlowSink sinkNode | sinkNode.asIndirectExpr().getAChild*() = sink.asIndirectExpr())\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asIndirectArgument() = any(MemsetFunction func).getACallToThisFunction().getAnArgument()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule ExposedSystemData = TaintTracking::Global<ExposedSystemDataConfig>;\n\nfrom ExposedSystemData::PathNode source, ExposedSystemData::PathNode sink\nwhere ExposedSystemData::flowPath(source, sink)\nselect sink, source, sink, \"This operation exposes system data from $@.\", source,\n  source.getNode().toString()",
        "description": "Exposing system data or debugging information helps a malicious user learn about the system and form an attack plan.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-497/ExposedSystemData.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.BasicBlocks\nprivate import semmle.code.cpp.rangeanalysis.PointlessComparison\nimport semmle.code.cpp.controlflow.internal.ConstantExprs\n\npredicate impossibleEdge(ComparisonOperation cmp, boolean value, BasicBlock src, BasicBlock dst) {\n  cmp = src.getEnd() and\n  reachablePointlessComparison(cmp, _, _, value, _) and\n  if value = true then dst = src.getAFalseSuccessor() else dst = src.getATrueSuccessor()\n}\n\nBasicBlock enhancedSucc(BasicBlock bb) {\n  result = bb.getASuccessor() and not impossibleEdge(_, _, bb, result)\n}\n\npredicate impossibleEdgeCausesNonTermination(ComparisonOperation cmp, boolean value) {\n  exists(BasicBlock src |\n    impossibleEdge(cmp, value, src, _) and\n    src.getASuccessor+() instanceof ExitBasicBlock and\n    not enhancedSucc+(src) instanceof ExitBasicBlock and\n    // Make sure that the source is reachable to reduce\n    // false positives.\n    exists(EntryBasicBlock entry | src = enhancedSucc+(entry))\n  )\n}\n\nfrom ComparisonOperation cmp, boolean value\nwhere impossibleEdgeCausesNonTermination(cmp, value)\nselect cmp,\n  \"Function exit is unreachable because this condition is always \" + value.toString() + \".\"",
        "description": "A loop with an unsatisfiable exit condition could prevent the program from terminating, making it vulnerable to a denial of service attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-835/InfiniteLoopWithUnsatisfiableExitCondition.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nstring normalisedExprValue(Expr e) { result = e.getValue().regexpReplaceAll(\"\\\\.0$\", \"\") }\n\nclass VarargsFunction extends Function {\n  VarargsFunction() {\n    this.isVarargs() and\n    not this instanceof FormattingFunction\n  }\n\n  Expr trailingArgumentIn(FunctionCall fc) {\n    fc = this.getACallToThisFunction() and\n    result = fc.getArgument(fc.getNumberOfArguments() - 1)\n  }\n\n  string trailingArgValue(FunctionCall fc) {\n    result = normalisedExprValue(this.trailingArgumentIn(fc))\n  }\n\n  private int trailingArgValueCount(string value) {\n    result = strictcount(FunctionCall fc | this.trailingArgValue(fc) = value)\n  }\n\n  string nonTrailingVarArgValue(FunctionCall fc, int index) {\n    fc = this.getACallToThisFunction() and\n    index >= this.getNumberOfParameters() and\n    index < fc.getNumberOfArguments() - 1 and\n    result = normalisedExprValue(fc.getArgument(index))\n  }\n\n  private int totalCount() {\n    result = strictcount(FunctionCall fc | fc = this.getACallToThisFunction())\n  }\n\n  string normalTerminator(int cnt, int totalCount) {\n    // the terminator is 0 or -1\n    result = [\"0\", \"-1\"] and\n    // at least 80% of calls have the terminator\n    cnt = this.trailingArgValueCount(result) and\n    totalCount = this.totalCount() and\n    100 * cnt / totalCount >= 80 and\n    // terminator value is not used in a non-terminating position\n    not this.nonTrailingVarArgValue(_, _) = result\n  }\n\n  predicate isWhitelisted() { this.hasGlobalName([\"open\", \"fcntl\", \"ptrace\", \"mremap\"]) }\n}\n\nfrom VarargsFunction f, FunctionCall fc, string terminator, int cnt, int totalCount\nwhere\n  terminator = f.normalTerminator(cnt, totalCount) and\n  fc = f.getACallToThisFunction() and\n  not normalisedExprValue(f.trailingArgumentIn(fc)) = terminator and\n  not f.isWhitelisted()\nselect fc,\n  \"Calls to $@ should use the value \" + terminator + \" as a terminator (\" + cnt + \" of \" +\n    totalCount + \" calls do).\", f, f.getQualifiedName()",
        "description": "Calling a variadic function without a sentinel value may result in a buffer overflow if the function expects a specific value to terminate the argument list.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-121/UnterminatedVarargsCall.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.SensitiveExprs\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport FromSensitiveFlow::PathGraph\n\nabstract class SqliteFunctionCall extends FunctionCall {\n  abstract Expr getASource();\n}\n\nclass SqliteFunctionPrepareCall extends SqliteFunctionCall {\n  SqliteFunctionPrepareCall() { this.getTarget().getName().matches(\"sqlite3\\\\_prepare%\") }\n\n  override Expr getASource() { result = this.getArgument(1) }\n}\n\nclass SqliteFunctionExecCall extends SqliteFunctionCall {\n  SqliteFunctionExecCall() { this.getTarget().hasName(\"sqlite3_exec\") }\n\n  override Expr getASource() { result = this.getArgument(1) }\n}\n\nclass SqliteFunctionAppendfCall extends SqliteFunctionCall {\n  SqliteFunctionAppendfCall() {\n    this.getTarget().hasName([\"sqlite3_str_appendf\", \"sqlite3_str_vappendf\"])\n  }\n\n  override Expr getASource() { result = this.getArgument(any(int n | n > 0)) }\n}\n\nclass SqliteFunctionAppendNonCharCall extends SqliteFunctionCall {\n  SqliteFunctionAppendNonCharCall() {\n    this.getTarget().hasName([\"sqlite3_str_append\", \"sqlite3_str_appendall\"])\n  }\n\n  override Expr getASource() { result = this.getArgument(1) }\n}\n\nclass SqliteFunctionAppendCharCall extends SqliteFunctionCall {\n  SqliteFunctionAppendCharCall() { this.getTarget().hasName(\"sqlite3_str_appendchar\") }\n\n  override Expr getASource() { result = this.getArgument(2) }\n}\n\nclass SqliteFunctionBindCall extends SqliteFunctionCall {\n  SqliteFunctionBindCall() {\n    this.getTarget()\n        .hasName([\n            \"sqlite3_bind_blob\", \"sqlite3_bind_blob64\", \"sqlite3_bind_text\", \"sqlite3_bind_text16\",\n            \"sqlite3_bind_text64\", \"sqlite3_bind_value\", \"sqlite3_bind_pointer\"\n          ])\n  }\n\n  override Expr getASource() { result = this.getArgument(2) }\n}\n\npredicate sqlite_encryption_used() {\n  any(StringLiteral l).getValue().toLowerCase().matches(\"pragma key%\") or\n  any(StringLiteral l).getValue().toLowerCase().matches(\"%attach%database%key%\") or\n  any(FunctionCall fc).getTarget().getName().matches(\"sqlite%\\\\_key\\\\_%\")\n}\n\nField getRecField(Class c) {\n  result = c.getAField() or\n  result = getRecField(c.getAField().getUnspecifiedType().stripType())\n}\n\npredicate isSourceImpl(DataFlow::Node source, SensitiveExpr sensitive) {\n  [source.asExpr(), source.asDefiningArgument()] = sensitive\n}\n\npredicate isSinkImpl(DataFlow::Node sink, SqliteFunctionCall c, Type t) {\n  exists(Expr e |\n    e = c.getASource() and\n    e = [sink.asExpr(), sink.asIndirectExpr()] and\n    t = e.getUnspecifiedType()\n  )\n}\n\nmodule FromSensitiveConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    isSourceImpl(source, _) and not sqlite_encryption_used()\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSinkImpl(sink, _, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().getUnspecifiedType() instanceof IntegralType\n  }\n\n  predicate isBarrierIn(DataFlow::Node node) { isSource(node) }\n\n  predicate isBarrierOut(DataFlow::Node node) { isSink(node) }\n\n  predicate allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet content) {\n    // flow out from fields at the sink (only).\n    // constrain `content` to a field inside the node.\n    exists(Type t |\n      isSinkImpl(node, _, t) and\n      content.(DataFlow::FieldContent).getField() = getRecField(t.stripType())\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    exists(SensitiveExpr sensitive | result = sensitive.getLocation() |\n      isSourceImpl(source, sensitive)\n    )\n  }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(SqliteFunctionCall sqliteCall | result = sqliteCall.getLocation() |\n      isSinkImpl(sink, sqliteCall, _)\n    )\n  }\n}\n\nmodule FromSensitiveFlow = TaintTracking::Global<FromSensitiveConfig>;\n\nfrom\n  SensitiveExpr sensitive, FromSensitiveFlow::PathNode source, FromSensitiveFlow::PathNode sink,\n  SqliteFunctionCall sqliteCall\nwhere\n  FromSensitiveFlow::flowPath(source, sink) and\n  isSourceImpl(source.getNode(), sensitive) and\n  isSinkImpl(sink.getNode(), sqliteCall, _)\nselect sqliteCall, source, sink,\n  \"This SQLite call may store $@ in a non-encrypted SQLite database.\", sensitive,\n  \"sensitive information\"",
        "description": "Storing sensitive information in a non-encrypted database can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-313/CleartextSqliteDatabase.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.security.BufferWrite\nimport semmle.code.cpp.security.BufferAccess\n\nbindingset[num, singular, plural]\nstring plural(int num, string singular, string plural) {\n  if num = 1 then result = num + singular else result = num + plural\n}\n\nfrom\n  BufferAccess ba, string bufferDesc, int accessSize, int accessType, Element bufferAlloc,\n  int bufferSize, string message\nwhere\n  accessType != 4 and\n  accessSize = ba.getSize() and\n  bufferSize = getBufferSize(ba.getBuffer(bufferDesc, accessType), bufferAlloc) and\n  (\n    accessSize > bufferSize\n    or\n    accessSize <= 0 and accessType = 3\n  ) and\n  if accessType = 1\n  then\n    message =\n      \"This '\" + ba.getName() + \"' operation accesses \" + plural(accessSize, \" byte\", \" bytes\") +\n        \" but the $@ is only \" + plural(bufferSize, \" byte\", \" bytes\") + \".\"\n  else\n    if accessType = 2\n    then\n      message =\n        \"This '\" + ba.getName() + \"' operation may access \" + plural(accessSize, \" byte\", \" bytes\") +\n          \" but the $@ is only \" + plural(bufferSize, \" byte\", \" bytes\") + \".\"\n    else (\n      if accessSize > 0\n      then\n        message =\n          \"This array indexing operation accesses byte offset \" + (accessSize - 1) +\n            \" but the $@ is only \" + plural(bufferSize, \" byte\", \" bytes\") + \".\"\n      else\n        message =\n          \"This array indexing operation accesses a negative index \" +\n            ((accessSize / ba.getActualType().getSize()) - 1) + \" on the $@.\"\n    )\nselect ba, message, bufferAlloc, bufferDesc",
        "description": "Incorrect use of a function that accesses a memory buffer may read or write data past the end of that buffer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-119/OverflowBuffer.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.internal.ProductFlow\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.models.interfaces.Allocation\nimport semmle.code.cpp.models.interfaces.ArrayFunction\nimport semmle.code.cpp.rangeanalysis.new.internal.semantic.analysis.RangeAnalysis\nimport semmle.code.cpp.rangeanalysis.new.internal.semantic.SemanticExprSpecific\nimport semmle.code.cpp.security.ProductFlowUtils.ProductFlowUtils\nimport semmle.code.cpp.rangeanalysis.new.RangeAnalysisUtil\nimport StringSizeFlow::PathGraph1\nimport codeql.util.Unit\n\nVariableAccess getAVariableAccess(Expr e) { e.getAChild*() = result }\n\npredicate hasSize(HeuristicAllocationExpr alloc, DataFlow::Node n, int state) {\n  exists(VariableAccess va, Expr size, int delta |\n    size = alloc.getSizeExpr() and\n    // Get the unique variable in a size expression like `x` in `malloc(x + 1)`.\n    va = unique( | | getAVariableAccess(size)) and\n    // Compute `delta` as the constant difference between `x` and `x + 1`.\n    bounded(any(Instruction instr | instr.getUnconvertedResultExpression() = size),\n      any(LoadInstruction load | load.getUnconvertedResultExpression() = va), delta) and\n    n.asExpr() = va and\n    state = delta\n  )\n}\n\npredicate isSinkPairImpl0(\n  CallInstruction c, DataFlow::Node bufSink, DataFlow::Node sizeSink, int delta, Expr eBuf,\n  Instruction sizeBound, Instruction sizeInstr\n) {\n  exists(int bufIndex, int sizeIndex, Instruction bufInstr, ArrayFunction func |\n    bufInstr = bufSink.asInstruction() and\n    c.getArgument(bufIndex) = bufInstr and\n    sizeBound = sizeSink.asInstruction() and\n    c.getArgument(sizeIndex) = sizeInstr and\n    c.getStaticCallTarget() = func and\n    pragma[only_bind_into](func)\n        .hasArrayWithVariableSize(pragma[only_bind_into](bufIndex),\n          pragma[only_bind_into](sizeIndex)) and\n    bounded(sizeInstr, sizeBound, delta) and\n    eBuf = bufInstr.getUnconvertedResultExpression()\n  )\n}\n\nmodule ValidState {\n  /**\n   * In the `StringSizeConfig` configuration we use an integer as the flow state for the second\n   * projection of the dataflow graph. The integer represents an offset that is added to the\n   * size of the allocation. For example, given:\n   * ```cpp\n   * char* p = new char[size + 1];\n   * size += 1;\n   * memset(p, 0, size);\n   * ```\n   * the initial flow state is `1`. This represents the fact that `size + 1` is a valid bound\n   * for the size of the allocation pointed to by `p`. After updating the size using `+=`, the\n   * flow state changes to `0`, which represents the fact that `size + 0` is a valid bound for\n   * the allocation.\n   *\n   * So we need to compute a set of valid integers that represent the offset applied to the\n   * size. We do this in two steps:\n   * 1. We first perform the dataflow traversal that the second projection of the product-flow\n   * library will perform, and visit all the places where the size argument is modified.\n   * 2. Once that dataflow traversal is done, we accumulate the offsets added at each places\n   * where the offset is modified (see `validStateImpl`).\n   */\n  private module ValidStateConfig implements DataFlow::ConfigSig {\n    predicate isSource(DataFlow::Node source) { hasSize(_, source, _) }\n\n    predicate isSink(DataFlow::Node sink) { isSinkPairImpl0(_, _, sink, _, _, _, _) }\n\n    predicate isBarrierOut(DataFlow::Node node) { DataFlow::flowsToBackEdge(node) }\n  }\n\n  private import DataFlow::Global<ValidStateConfig>\n\n  predicate validState(DataFlow::Node source, DataFlow::Node sink, int value) {\n    hasSize(_, source, value) and\n    flow(source, sink)\n  }\n}\n\nimport ValidState\n\nmodule SizeBarrierInput implements SizeBarrierInputSig {\n  int fieldFlowBranchLimit() { result = 2 }\n\n  predicate isSource(DataFlow::Node source) {\n    exists(int state |\n      hasSize(_, source, state) and\n      validState(source, _, state)\n    )\n  }\n}\n\npredicate isSinkPairImpl(\n  CallInstruction c, DataFlow::Node bufSink, DataFlow::Node sizeSink, int delta, Expr eBuf\n) {\n  exists(Instruction sizeBound, Instruction sizeInstr |\n    isSinkPairImpl0(c, bufSink, sizeSink, delta, eBuf, sizeBound, sizeInstr) and\n    not sizeBound = SizeBarrier<SizeBarrierInput>::getABarrierInstruction(delta) and\n    not sizeInstr = SizeBarrier<SizeBarrierInput>::getABarrierInstruction(delta)\n  )\n}\n\nmodule StringSizeConfig implements ProductFlow::StateConfigSig {\n  class FlowState1 = Unit;\n\n  class FlowState2 = int;\n\n  predicate isSourcePair(\n    DataFlow::Node bufSource, FlowState1 state1, DataFlow::Node sizeSource, FlowState2 state2\n  ) {\n    // In the case of an allocation like\n    // ```cpp\n    // malloc(size + 1);\n    // ```\n    // we use `state2` to remember that there was an offset (in this case an offset of `1`) added\n    // to the size of the allocation. This state is then checked in `isSinkPair`.\n    exists(state1) and\n    hasSize(bufSource.asExpr(), sizeSource, state2) and\n    validState(sizeSource, _, state2)\n  }\n\n  predicate isSinkPair(\n    DataFlow::Node bufSink, FlowState1 state1, DataFlow::Node sizeSink, FlowState2 state2\n  ) {\n    exists(state1) and\n    validState(_, sizeSink, state2) and\n    exists(int delta |\n      isSinkPairImpl(_, bufSink, sizeSink, delta, _) and\n      delta > state2\n    )\n  }\n\n  predicate isBarrierOut2(DataFlow::Node node) { DataFlow::flowsToBackEdge(node) }\n\n  predicate isBarrier2(DataFlow::Node node, FlowState2 state) {\n    node = SizeBarrier<SizeBarrierInput>::getABarrierNode(state)\n  }\n}\n\nmodule StringSizeFlow = ProductFlow::GlobalWithState<StringSizeConfig>;\n\nint getOverflow(\n  DataFlow::Node source1, DataFlow::Node source2, DataFlow::Node sink1, DataFlow::Node sink2,\n  CallInstruction c, Expr buffer\n) {\n  result > 0 and\n  exists(\n    StringSizeFlow::PathNode1 pathSource1, StringSizeFlow::PathNode2 pathSource2,\n    StringSizeFlow::PathNode1 pathSink1, StringSizeFlow::PathNode2 pathSink2\n  |\n    StringSizeFlow::flowPath(pathSource1, pathSource2, pathSink1, pathSink2) and\n    source1 = pathSource1.getNode() and\n    source2 = pathSource2.getNode() and\n    sink1 = pathSink1.getNode() and\n    sink2 = pathSink2.getNode() and\n    isSinkPairImpl(c, sink1, sink2, result + pathSink2.getState(), buffer)\n  )\n}\n\nfrom\n  StringSizeFlow::PathNode1 source1, StringSizeFlow::PathNode2 source2,\n  StringSizeFlow::PathNode1 sink1, StringSizeFlow::PathNode2 sink2, int overflow, CallInstruction c,\n  Expr buffer, string element\nwhere\n  StringSizeFlow::flowPath(source1, source2, sink1, sink2) and\n  overflow =\n    max(getOverflow(source1.getNode(), source2.getNode(), sink1.getNode(), sink2.getNode(), c,\n          buffer)\n    ) and\n  if overflow = 1 then element = \" element.\" else element = \" elements.\"\nselect c.getUnconvertedResultExpression(), source1, sink1,\n  \"This write may overflow $@ by \" + overflow + element, buffer, buffer.toString()",
        "description": "Exceeding the size of a static array during write or access operations may result in a buffer overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-119/OverrunWriteProductFlow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.IRGuards\nimport semmle.code.cpp.security.FlowSources as FS\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport ImproperArrayIndexValidation::PathGraph\n\npredicate isFlowSource(FS::FlowSource source, string sourceType) {\n  sourceType = source.getSourceType()\n}\n\npredicate guardChecks(IRGuardCondition g, Expr e, boolean branch) {\n  exists(Operand op | op.getDef().getConvertedResultExpression() = e |\n    // `op < k` is true and `k > 0`\n    g.comparesLt(op, any(int k | k > 0), true, any(BooleanValue bv | bv.getValue() = branch))\n    or\n    // `op < _ + k` is true and `k > 0`.\n    g.comparesLt(op, _, any(int k | k > 0), true, branch)\n    or\n    // op == k\n    g.comparesEq(op, _, true, any(BooleanValue bv | bv.getValue() = branch))\n    or\n    // op == _ + k\n    g.comparesEq(op, _, _, true, branch)\n  )\n}\n\npredicate offsetIsAlwaysInBounds(ArrayExpr arrayExpr, VariableAccess offsetExpr) {\n  exists(ArrayType arrayType |\n    arrayType = arrayExpr.getArrayBase().getUnspecifiedType() and\n    arrayType.getArraySize() > upperBound(offsetExpr.getFullyConverted())\n  )\n}\n\nmodule ImproperArrayIndexValidationConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isFlowSource(source, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node = DataFlow::BarrierGuard<guardChecks/3>::getABarrierNode()\n  }\n\n  predicate isBarrierOut(DataFlow::Node node) { isSink(node) }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(ArrayExpr arrayExpr, VariableAccess offsetExpr |\n      offsetExpr = arrayExpr.getArrayOffset() and\n      sink.asExpr() = offsetExpr and\n      not offsetIsAlwaysInBounds(arrayExpr, offsetExpr)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule ImproperArrayIndexValidation = TaintTracking::Global<ImproperArrayIndexValidationConfig>;\n\nfrom\n  ImproperArrayIndexValidation::PathNode source, ImproperArrayIndexValidation::PathNode sink,\n  string sourceType\nwhere\n  ImproperArrayIndexValidation::flowPath(source, sink) and\n  isFlowSource(source.getNode(), sourceType)\nselect sink.getNode(), source, sink,\n  \"An array indexing expression depends on $@ that might be outside the bounds of the array.\",\n  source.getNode(), sourceType",
        "description": "Accessing an array without first checking that the index is within the bounds of the array can cause undefined behavior and can also be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-129/ImproperArrayIndexValidation.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.security.BufferWrite\n\n\nfrom BufferWrite bw, Expr dest, int destSize, int estimated, ValueFlowAnalysis reason\nwhere\n  not bw.hasExplicitLimit() and // has no explicit size limit\n  dest = bw.getDest() and\n  destSize = getBufferSize(dest, _) and\n  estimated = bw.getMaxDataLimited(reason) and\n  // we can deduce from non-trivial range analysis that too much data may be copied\n  estimated > destSize\nselect bw,\n  \"This '\" + bw.getBWDesc() + \"' operation requires \" + estimated +\n    \" bytes but the destination is only \" + destSize + \" bytes.\"",
        "description": "Buffer write operations that do not control the length of data written may overflow",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-120/VeryLikelyOverrunWrite.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.security.BufferWrite\n\n\nfrom BufferWrite bw, Expr dest, int destSize, int estimated, BufferWriteEstimationReason reason\nwhere\n  not bw.hasExplicitLimit() and // has no explicit size limit\n  dest = bw.getDest() and\n  destSize = getBufferSize(dest, _) and\n  estimated = bw.getMaxDataLimited(reason) and\n  // we exclude ValueFlowAnalysis as it is reported in cpp/very-likely-overrunning-write\n  not reason instanceof ValueFlowAnalysis and\n  // we can deduce that too much data may be copied (even without\n  // long '%f' conversions)\n  estimated > destSize\nselect bw,\n  \"This '\" + bw.getBWDesc() + \"' operation requires \" + estimated +\n    \" bytes but the destination is only \" + destSize + \" bytes.\"",
        "description": "Buffer write operations that do not control the length of data written may overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-120/OverrunWrite.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.security.BufferWrite\nimport semmle.code.cpp.security.FlowSources as FS\nimport semmle.code.cpp.dataflow.new.TaintTracking\nimport semmle.code.cpp.controlflow.IRGuards\nimport Flow::PathGraph\n\n\n\npredicate isUnboundedWrite(BufferWrite bw) {\n  not bw.hasExplicitLimit() and // has no explicit size limit\n  not exists(bw.getMaxData(_)) // and we can't deduce an upper bound to the amount copied\n}\n\npredicate unboundedWriteSource(Expr e, BufferWrite bw, boolean qualifier) {\n  isUnboundedWrite(bw) and e = bw.getASource() and qualifier = false\n  or\n  exists(FieldAccess fa | unboundedWriteSource(fa, bw, _) and e = fa.getQualifier()) and\n  qualifier = true\n}\n\npredicate isSource(FS::FlowSource source, string sourceType) { source.getSourceType() = sourceType }\n\npredicate isSink(DataFlow::Node sink, BufferWrite bw, boolean qualifier) {\n  unboundedWriteSource(sink.asIndirectExpr(), bw, qualifier)\n  or\n  // `gets` and `scanf` reads from stdin so there's no real input.\n  // The `BufferWrite` library models this as the call itself being\n  // the source. In this case we mark the output argument as being\n  // the sink so that we report a path where source = sink (because\n  // the same output argument is also included in `isSource`).\n  bw.getASource() = bw and\n  unboundedWriteSource(sink.asDefiningArgument(), bw, qualifier)\n}\n\nmodule BarrierConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) {\n    comparesEq(sink.asOperand(), _, _, true, _) or\n    comparesLt(sink.asOperand(), _, _, true, _)\n  }\n}\n\nmodule BarrierFlow = TaintTracking::Global<BarrierConfig>;\n\nimport semmle.code.cpp.ir.dataflow.internal.DataFlowImplCommon as DataFlowImplCommon\n\npredicate interestingLessThanOrEqual(Operand left) {\n  exists(DataFlowImplCommon::NodeEx node |\n    node.asNode().asOperand() = left and\n    BarrierFlow::Stages::Stage1::sinkNode(node, _)\n  )\n}\n\npredicate lessThanOrEqual(IRGuardCondition g, Expr e, boolean branch) {\n  exists(Operand left |\n    g.comparesLt(left, _, _, true, branch) or\n    g.comparesEq(left, _, _, true, branch)\n  |\n    interestingLessThanOrEqual(left) and\n    left.getDef().getConvertedResultExpression() = e\n  )\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _, _) }\n\n  predicate isBarrierOut(DataFlow::Node node) { isSink(node, _, false) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // Block flow if the node is guarded by any <, <= or = operations.\n    node = DataFlow::BarrierGuard<lessThanOrEqual/3>::getABarrierNode()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(BufferWrite bw | result = bw.getLocation() | isSink(sink, bw, _))\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\n\nfrom BufferWrite bw, Flow::PathNode source, Flow::PathNode sink, string sourceType\nwhere\n  Flow::flowPath(source, sink) and\n  isSource(source.getNode(), sourceType) and\n  isSink(sink.getNode(), bw, _)\nselect bw, source, sink,\n  \"This '\" + bw.getBWDesc() + \"' with input from $@ may overflow the destination.\",\n  source.getNode(), sourceType",
        "description": "Buffer write operations that do not control the length of data written may overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-120/UnboundedWrite.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.security.BufferWrite\nimport semmle.code.cpp.ConfigurationTestFile\n\n\nfrom BufferWrite bw, int destSize\nwhere\n  bw.hasExplicitLimit() and // has an explicit size limit\n  destSize = max(getBufferSize(bw.getDest(), _)) and\n  bw.getExplicitLimit() > destSize and // but it's larger than the destination\n  not bw.getDest().getType().stripType() instanceof ErroneousType and // destSize may be incorrect\n  not bw.getFile() instanceof ConfigurationTestFile // expressions in files generated during configuration are likely false positives\nselect bw,\n  \"This '\" + bw.getBWDesc() + \"' operation is limited to \" + bw.getExplicitLimit() +\n    \" bytes but the destination is only \" + destSize + \" bytes.\"",
        "description": "Buffer write operations with a length parameter that does not match the size of the destination buffer may overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-120/BadlyBoundedWrite.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.security.BufferWrite\n\n\nfrom BufferWrite bw, int destSize, int estimated, BufferWriteEstimationReason reason\nwhere\n  not bw.hasExplicitLimit() and\n  // has no explicit size limit\n  destSize = getBufferSize(bw.getDest(), _) and\n  estimated = bw.getMaxData(reason) and\n  estimated > destSize and\n  // and we can deduce that too much data may be copied\n  bw.getMaxDataLimited(reason) <= destSize // but it would fit without long '%f' conversions\nselect bw,\n  \"This '\" + bw.getBWDesc() + \"' operation may require \" + estimated +\n    \" bytes because of float conversions, but the target is only \" + destSize + \" bytes.\"",
        "description": "Buffer write operations that do not control the length of data written may overflow when floating point inputs take extreme values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-120/OverrunWriteFloat.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.Security\nimport semmle.code.cpp.security.FunctionWithWrappers\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.ir.IR\nimport Flow::PathGraph\n\npredicate isSource(FlowSource source, string sourceType) { sourceType = source.getSourceType() }\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { isSource(node, _) }\n\n  predicate isSink(DataFlow::Node node) {\n    exists(PrintfLikeFunction printf |\n      printf.outermostWrapperFunctionCall([node.asExpr(), node.asIndirectExpr()], _)\n    )\n  }\n\n  private predicate isArithmeticNonCharType(ArithmeticType type) {\n    not type instanceof CharType and\n    not type instanceof Char8Type and\n    not type instanceof Char16Type and\n    not type instanceof Char32Type\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    isSink(node) and isArithmeticNonCharType(node.asExpr().getUnspecifiedType())\n    or\n    isArithmeticNonCharType(node.asCertainDefinition().getUnspecifiedType())\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom\n  PrintfLikeFunction printf, string printfFunction, string sourceType, DataFlow::Node source,\n  DataFlow::Node sink, Flow::PathNode sourceNode, Flow::PathNode sinkNode\nwhere\n  source = sourceNode.getNode() and\n  sink = sinkNode.getNode() and\n  isSource(source, sourceType) and\n  printf.outermostWrapperFunctionCall([sink.asExpr(), sink.asIndirectExpr()], printfFunction) and\n  Flow::flowPath(sourceNode, sinkNode)\nselect sink, sourceNode, sinkNode,\n  \"The value of this argument may come from $@ and is being used as a formatting argument to \" +\n    printfFunction + \".\", source, sourceType",
        "description": "Using externally-controlled format strings in printf-style functions can lead to buffer overflows or data representation problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-134/UncontrolledFormatString.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.new.DataFlow\nimport semmle.code.cpp.ir.IR\nimport FinalFlow::PathGraph\nimport semmle.code.cpp.security.InvalidPointerDereference.AllocationToInvalidPointer\nimport semmle.code.cpp.security.InvalidPointerDereference.InvalidPointerToDereference\n\nmodule FinalConfig implements DataFlow::StateConfigSig {\n  newtype FlowState =\n    additional TInitial() or\n    additional TPointerArith(PointerArithmeticInstruction pai) {\n      operationIsOffBy(_, pai, _, _, _, _, _)\n    }\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    state = TInitial() and\n    operationIsOffBy(source, _, _, _, _, _, _)\n  }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    exists(PointerArithmeticInstruction pai |\n      operationIsOffBy(_, pai, _, _, _, sink, _) and\n      state = TPointerArith(pai)\n    )\n  }\n\n  int fieldFlowBranchLimit() {\n    result =\n      allocationToInvalidPointerFieldFlowBranchLimit()\n          .maximum(invalidPointerToDereferenceFieldFlowBranchLimit())\n  }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    // A step from the left-hand side of a pointer-arithmetic operation that has been\n    // identified as creating an out-of-bounds pointer to the result of the pointer-arithmetic\n    // operation.\n    exists(PointerArithmeticInstruction pai |\n      pointerAddInstructionHasBounds(_, pai, node1, _) and\n      operationIsOffBy(_, pai, node2, _, _, _, _) and\n      state1 = TInitial() and\n      state2 = TPointerArith(pai)\n    )\n    or\n    // A step from an out-of-bounds address to the operation (which is either a `StoreInstruction`\n    // or a `LoadInstruction`) that dereferences the address.\n    // This step exists purely for aesthetic reasons: we want the alert to be placed at the operation\n    // that causes the dereference, and not at the address that flows into the operation.\n    state1 = state2 and\n    exists(PointerArithmeticInstruction pai |\n      state1 = TPointerArith(pai) and\n      operationIsOffBy(_, pai, _, node1, _, node2, _)\n    )\n  }\n}\n\nmodule FinalFlow = DataFlow::GlobalWithState<FinalConfig>;\n\npredicate hasFlowPath(\n  FinalFlow::PathNode source, FinalFlow::PathNode sink, PointerArithmeticInstruction pai,\n  string operation, int delta\n) {\n  FinalFlow::flowPath(source, sink) and\n  operationIsOffBy(source.getNode(), pai, _, _, operation, sink.getNode(), delta) and\n  sink.getState() = FinalConfig::TPointerArith(pai)\n}\n\nfrom\n  FinalFlow::PathNode source, FinalFlow::PathNode sink, int k, string kstr,\n  PointerArithmeticInstruction pai, string operation, Expr offset, DataFlow::Node n\nwhere\n  k = min(int cand | hasFlowPath(source, sink, pai, operation, cand)) and\n  offset = pai.getRight().getUnconvertedResultExpression() and\n  n = source.getNode() and\n  if k = 0 then kstr = \"\" else kstr = \" + \" + k\nselect sink.getNode(), source, sink,\n  \"This \" + operation + \" might be out of bounds, as the pointer might be equal to $@ + $@\" + kstr +\n    \".\", n, n.toString(), offset, offset.toString()",
        "description": "Dereferencing an out-of-bounds pointer is undefined behavior and may lead to security vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-193/InvalidPointerDeref.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Synchronization\nimport LockFlow\n\ncached\nprivate predicate twiceLocked(FunctionCall call, Variable v, VariableAccess a) {\n  lockedOnEntry(v.getAnAccess(), call) and\n  lockedInCall(a, call)\n}\n\n// When this query finds a result, there are often multiple call sites\n// associated with one instance of the problem. For this reason, we do not\n// include `call` in the result. However, it is sometimes helpful to\n// include `call.getLocation()` in the result, because it can help to find\n// the control flow path which might be responsible.\nfrom FunctionCall call, Variable v, VariableAccess access2\nwhere\n  twiceLocked(call, v, access2) and\n  v = access2.getTarget() and\n  // If the second lock is a `try_lock` then it won't cause a deadlock.\n  // We want to be extra sure that the second lock is not a `try_lock`\n  // to make sure that we don't generate too many false positives, so\n  // we use three heuristics:\n  //\n  //  1. The call is to a function named \"try_lock\".\n  //  2. The result of the call is used in a condition. For example:\n  //       if (pthread_mutex_lock(mtx) != 0) return -1;\n  //  3. The call is a condition. Because the analysis is interprocedural,\n  //     `call` might be an indirect call to `lock`, so this heuristic\n  //     catches some cases which the second heuristic does not.\n  not (\n    trylockCall(access2, _) or\n    tryLockCondition(access2, _, _) or\n    call.isCondition()\n  )\nselect access2, \"Mutex \" + v + \" might be locked already, which could cause a deadlock.\"",
        "description": "Calling the lock method of a mutex twice in succession might cause a deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-764/TwiceLocked.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Synchronization\nimport LockFlow\n\nVariable lockSuccessor(Variable v) {\n  exists(FunctionCall call |\n    lockedOnEntry(v.getAnAccess(), call) and\n    lockedInCall(result.getAnAccess(), call)\n  )\n}\n\nfrom Variable v1, Variable v2\nwhere v1 != v2 and lockSuccessor+(v1) = v2 and lockSuccessor+(v2) = v1\nselect v1, \"Mutex \" + v1 + \" has a cyclic lock order dependency with $@.\", v2, \"mutex \" + v2",
        "description": "Locking mutexes in different orders in different threads can cause deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-764/LockOrderCycle.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Synchronization\n\npredicate lockBlock(MutexType t, BasicBlock b, int locks) {\n  locks = strictcount(int i | b.getNode(i) = t.getLockAccess())\n}\n\npredicate unlockBlock(MutexType t, BasicBlock b, int unlocks) {\n  unlocks = strictcount(int i | b.getNode(i) = t.getUnlockAccess())\n}\n\npredicate failedLock(MutexType t, BasicBlock lockblock, BasicBlock failblock) {\n  exists(ControlFlowNode lock |\n    lock = lockblock.getEnd() and\n    lock = t.getLockAccess() and\n    lock.getAFalseSuccessor() = failblock\n  )\n}\n\npredicate lockUnlockBlock(MutexType t, BasicBlock b, int netlocks) {\n  lockBlock(t, b, netlocks) and not unlockBlock(t, b, _)\n  or\n  exists(int unlocks |\n    not lockBlock(t, b, _) and unlockBlock(t, b, unlocks) and netlocks = -unlocks\n  )\n  or\n  exists(int locks, int unlocks |\n    lockBlock(t, b, locks) and unlockBlock(t, b, unlocks) and netlocks = locks - unlocks\n  )\n}\n\npredicate blockIsLocked(MutexType t, BasicBlock src, BasicBlock b, int locks) {\n  lockUnlockBlock(t, b, locks) and src = b and locks > 0\n  or\n  exists(BasicBlock pred, int predlocks, int curlocks, int failedlock | pred = b.getAPredecessor() |\n    blockIsLocked(t, src, pred, predlocks) and\n    (if failedLock(t, pred, b) then failedlock = 1 else failedlock = 0) and // count a failed lock as an unlock so the net is zero\n    (\n      not lockUnlockBlock(t, b, _) and curlocks = 0\n      or\n      lockUnlockBlock(t, b, curlocks)\n    ) and\n    locks = predlocks + curlocks - failedlock and\n    locks > 0 and\n    locks < 10 // arbitrary bound to fail gracefully in case of locking in a loop\n  )\n}\n\nfrom Function c, MutexType t, BasicBlock src, BasicBlock exit, FunctionCall lock\nwhere\n  // restrict results to those methods that actually attempt to unlock\n  t.getUnlockAccess().getEnclosingFunction() = c and\n  blockIsLocked(t, src, exit, _) and\n  exit.getEnd() = c and\n  lock = src.getANode() and\n  lock = t.getLockAccess()\nselect lock, \"This lock might not be unlocked or might be locked more times than it is unlocked.\"",
        "description": "A lock that is acquired one or more times without a matching number of unlocks may cause a deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-764/UnreleasedLock.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.EscapesTree\nimport semmle.code.cpp.commons.Exclusions\nimport semmle.code.cpp.models.interfaces.Alias\n\nclass MemsetFunction extends Function {\n  MemsetFunction() {\n    this.hasGlobalOrStdOrBslName(\"memset\")\n    or\n    this.hasGlobalOrStdName(\"wmemset\")\n    or\n    this.hasGlobalName([\"bzero\", \"__builtin_memset\"])\n  }\n}\n\npredicate isNonEscapingArgument(Expr escaped) {\n  exists(Call call, AliasFunction aliasFunction, int i |\n    aliasFunction = call.getTarget() and\n    call.getArgument(i) = escaped.getUnconverted() and\n    (\n      aliasFunction.parameterNeverEscapes(i)\n      or\n      aliasFunction.parameterEscapesOnlyViaReturn(i) and\n      (call instanceof ExprInVoidContext or call.getConversion*() instanceof BoolConversion)\n    )\n  )\n}\n\npragma[noinline]\npredicate callToMemsetWithRelevantVariable(\n  LocalVariable v, VariableAccess acc, FunctionCall call, MemsetFunction memset\n) {\n  not v.isStatic() and\n  // Reference-typed variables get special treatment in `variableAddressEscapesTree` so we leave them\n  // out of this query.\n  not v.getUnspecifiedType() instanceof ReferenceType and\n  call.getTarget() = memset and\n  acc = v.getAnAccess() and\n  // `v` escapes as the argument to `memset`\n  variableAddressEscapesTree(acc, call.getArgument(0).getFullyConverted())\n}\n\npragma[noinline]\npredicate relevantVariable(LocalVariable v, FunctionCall call, MemsetFunction memset) {\n  exists(VariableAccess acc, VariableAccess anotherAcc |\n    callToMemsetWithRelevantVariable(v, acc, call, memset) and\n    // `v` is not only just used in the call to `memset`.\n    anotherAcc = v.getAnAccess() and\n    acc != anotherAcc and\n    not anotherAcc.isUnevaluated()\n  )\n}\n\nfrom FunctionCall call, LocalVariable v, MemsetFunction memset\nwhere\n  relevantVariable(v, call, memset) and\n  not isFromMacroDefinition(call) and\n  // `v` doesn't escape anywhere else.\n  forall(Expr escape | variableAddressEscapesTree(v.getAnAccess(), escape) |\n    isNonEscapingArgument(escape)\n  ) and\n  // There is no later use of `v`.\n  not v.getAnAccess() = call.getASuccessor*() and\n  // Not using the `-fno-builtin-memset` flag\n  exists(Compilation c |\n    c.getAFileCompiled() = call.getFile() and\n    not c.getAnArgument() = \"-fno-builtin-memset\"\n  )\nselect call, \"Call to \" + memset.getName() + \" may be deleted by the compiler.\"",
        "description": "Using the `memset` function to clear private data in a variable that has no subsequent use can make information-leak vulnerabilities easier to exploit because the compiler can remove the call.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-014/MemsetMayBeDeleted.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.FunctionWithWrappers\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport TaintedPath::PathGraph\n\nclass FileFunction extends FunctionWithWrappers {\n  FileFunction() {\n    exists(string nme | this.hasGlobalName(nme) |\n      nme = [\"fopen\", \"_fopen\", \"_wfopen\", \"open\", \"_open\", \"_wopen\"]\n      or\n      // create file function on windows\n      nme.matches(\"CreateFile%\")\n    )\n    or\n    this.hasQualifiedName(\"std\", \"fopen\")\n    or\n    // on any of the fstream classes, or filebuf\n    exists(string nme | this.getDeclaringType().hasQualifiedName(\"std\", nme) |\n      nme = [\"basic_fstream\", \"basic_ifstream\", \"basic_ofstream\", \"basic_filebuf\"]\n    ) and\n    // we look for either the open method or the constructor\n    (this.getName() = \"open\" or this instanceof Constructor)\n  }\n\n  // conveniently, all of these functions take the path as the first parameter!\n  override predicate interestingArg(int arg) { arg = 0 }\n}\n\npredicate hasUpperBoundsCheck(Variable var) {\n  exists(RelationalOperation oper, VariableAccess access |\n    oper.getAnOperand() = access and\n    access.getTarget() = var and\n    // Comparing to 0 is not an upper bound check\n    not oper.getAnOperand().getValue() = \"0\"\n  )\n}\n\nmodule TaintedPathConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof FlowSource }\n\n  predicate isSink(DataFlow::Node node) {\n    exists(FileFunction fileFunction |\n      fileFunction.outermostWrapperFunctionCall(node.asIndirectArgument(), _)\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.asExpr().(Call).getTarget().getUnspecifiedType() instanceof ArithmeticType\n    or\n    exists(LoadInstruction load, Variable checkedVar |\n      load = node.asInstruction() and\n      checkedVar = load.getSourceAddress().(VariableAddressInstruction).getAstVariable() and\n      hasUpperBoundsCheck(checkedVar)\n    )\n  }\n\n  predicate isBarrierOut(DataFlow::Node node) {\n    // make sinks barriers so that we only report the closest instance\n    isSink(node)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    result = sink.asIndirectArgument().getLocation()\n  }\n}\n\nmodule TaintedPath = TaintTracking::Global<TaintedPathConfig>;\n\nfrom\n  FileFunction fileFunction, Expr taintedArg, FlowSource taintSource,\n  TaintedPath::PathNode sourceNode, TaintedPath::PathNode sinkNode, string callChain\nwhere\n  taintedArg = sinkNode.getNode().asIndirectArgument() and\n  fileFunction.outermostWrapperFunctionCall(taintedArg, callChain) and\n  TaintedPath::flowPath(sourceNode, sinkNode) and\n  taintSource = sourceNode.getNode()\nselect taintedArg, sourceNode, sinkNode,\n  \"This argument to a file access function is derived from $@ and then passed to \" + callChain + \".\",\n  taintSource, \"user input (\" + taintSource.getSourceType() + \")\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-022/TaintedPath.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.new.DataFlow\nimport Flow::PathGraph\n\npredicate lastField(Field f) {\n  exists(Class c | c = f.getDeclaringType() |\n    f =\n      max(Field cand, int byteOffset |\n        cand.getDeclaringType() = c and byteOffset = f.getByteOffset()\n      |\n        cand order by byteOffset\n      )\n  )\n}\n\nbindingset[f1, offset, c2]\npragma[inline_late]\npredicate hasCompatibleFieldAtOffset(Field f1, int offset, Class c2) {\n  exists(Field f2 | offset = f2.getOffsetInClass(c2) |\n    // Let's not deal with bit-fields for now.\n    f2 instanceof BitField\n    or\n    f1.getUnspecifiedType().getSize() = f2.getUnspecifiedType().getSize()\n    or\n    lastField(f1) and\n    f1.getUnspecifiedType().getSize() <= f2.getUnspecifiedType().getSize()\n  )\n}\n\nbindingset[c1, c2]\npragma[inline_late]\npredicate prefix(Class c1, Class c2) {\n  not c1.isPolymorphic() and\n  not c2.isPolymorphic() and\n  if c1 instanceof Union\n  then\n    // If it's a union we just verify that one of it's variants is compatible with the other class\n    exists(Field f1, int offset |\n      // Let's not deal with bit-fields for now.\n      not f1 instanceof BitField and\n      offset = f1.getOffsetInClass(c1)\n    |\n      hasCompatibleFieldAtOffset(f1, offset, c2)\n    )\n  else\n    forall(Field f1, int offset |\n      // Let's not deal with bit-fields for now.\n      not f1 instanceof BitField and\n      offset = f1.getOffsetInClass(c1)\n    |\n      hasCompatibleFieldAtOffset(f1, offset, c2)\n    )\n}\n\nclass UnsafeCast extends Cast {\n  private Class toType;\n\n  UnsafeCast() {\n    (\n      this instanceof CStyleCast\n      or\n      this instanceof StaticCast\n      or\n      this instanceof ReinterpretCast\n    ) and\n    toType = this.getExplicitlyConverted().getUnspecifiedType().stripType() and\n    not this.isImplicit() and\n    exists(TypeDeclarationEntry tde |\n      tde = toType.getDefinition() and\n      not tde.isFromUninstantiatedTemplate(_)\n    )\n  }\n\n  Class getConvertedType() { result = toType }\n\n  /**\n   * Holds if the result of this cast can safely be interpreted as a value of\n   * type `t`.\n   *\n   * The compatibility rules are as follows:\n   *\n   * 1. the result of `(T)x` is compatible with the type `T` for any `T`\n   * 2. the result of `(T)x` is compatible with the type `U` for any `U` such\n   *    that `U` is a subtype of `T`, or `T` is a subtype of `U`.\n   * 3. the result of `(T)x` is compatible with the type `U` if the list\n   *    of fields of `T` is a prefix of the list of fields of `U`.\n   *    For example, if `U` is `struct { unsigned char x; int y; };`\n   *    and `T` is `struct { unsigned char uc; };`.\n   * 4. the result of `(T)x` is compatible with the type `U` if the list\n   *    of fields of `U` is a prefix of the list of fields of `T`.\n   *\n   *    Condition 4 is a bit controversial, since it assumes that the additional\n   *    fields in `T` won't be accessed. This may result in some FNs.\n   */\n  bindingset[this, t]\n  pragma[inline_late]\n  predicate compatibleWith(Type t) {\n    // Conition 1\n    t.stripType() = this.getConvertedType()\n    or\n    // Condition 3\n    prefix(this.getConvertedType(), t.stripType())\n    or\n    // Condition 4\n    prefix(t.stripType(), this.getConvertedType())\n    or\n    // Condition 2 (a)\n    t.stripType().(Class).getABaseClass+() = this.getConvertedType()\n    or\n    // Condition 2 (b)\n    t.stripType() = this.getConvertedType().getABaseClass+()\n  }\n}\n\npredicate isSourceImpl(DataFlow::Node source, Class type) {\n  exists(AllocationExpr alloc |\n    alloc = source.asExpr() and\n    type = alloc.getAllocatedElementType().stripType() and\n    not exists(\n      alloc\n          .(NewOrNewArrayExpr)\n          .getAllocator()\n          .(OperatorNewAllocationFunction)\n          .getPlacementArgument()\n    )\n  ) and\n  exists(TypeDeclarationEntry tde |\n    tde = type.getDefinition() and\n    not tde.isFromUninstantiatedTemplate(_)\n  )\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSourceImpl(source, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // We disable flow through global variables to reduce FPs from infeasible paths\n    node instanceof DataFlow::VariableNode\n    or\n    exists(Class c | c = node.getType().stripType() |\n      not c.hasDefinition()\n      or\n      exists(TypeDeclarationEntry tde |\n        tde = c.getDefinition() and\n        tde.isFromUninstantiatedTemplate(_)\n      )\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink.asExpr() = any(UnsafeCast cast).getUnconverted() }\n\n  int fieldFlowBranchLimit() { result = 0 }\n\n  predicate observeDiffInformedIncrementalMode() {\n    none() // used both positively and negatively\n  }\n}\n\nmodule Flow = DataFlow::Global<Config>;\n\npredicate relevantType(DataFlow::Node sink, Class allocatedType) {\n  exists(DataFlow::Node source |\n    Flow::flow(source, sink) and\n    isSourceImpl(source, allocatedType)\n  )\n}\n\npredicate isSinkImpl(\n  DataFlow::Node sink, Class allocatedType, Type convertedType, boolean compatible\n) {\n  exists(UnsafeCast cast |\n    relevantType(sink, allocatedType) and\n    sink.asExpr() = cast.getUnconverted() and\n    convertedType = cast.getConvertedType()\n  |\n    if cast.compatibleWith(allocatedType) then compatible = true else compatible = false\n  )\n}\n\nfrom\n  Flow::PathNode source, Flow::PathNode sink, Type badSourceType, Type sinkType,\n  DataFlow::Node sinkNode\nwhere\n  Flow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  isSourceImpl(source.getNode(), badSourceType) and\n  isSinkImpl(sinkNode, badSourceType, sinkType, false) and\n  // If there is any flow that would result in a valid cast then we don't\n  // report an alert here. This reduces the number of FPs from infeasible paths\n  // significantly.\n  not exists(DataFlow::Node goodSource, Type goodSourceType |\n    isSourceImpl(goodSource, goodSourceType) and\n    isSinkImpl(sinkNode, goodSourceType, sinkType, true) and\n    Flow::flow(goodSource, sinkNode)\n  )\nselect sinkNode, source, sink, \"Conversion from $@ to $@ is invalid.\", badSourceType,\n  badSourceType.toString(), sinkType, sinkType.toString()",
        "description": "Casting a value to an incompatible type can lead to undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-843/TypeConfusion.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport XML\nimport XxeFlow::PathGraph\n\nmodule XxeConfig implements DataFlow::StateConfigSig {\n  class FlowState = TXxeFlowState;\n\n  predicate isSource(DataFlow::Node node, FlowState flowstate) {\n    any(XmlLibrary l).configurationSource(node, flowstate)\n  }\n\n  predicate isSink(DataFlow::Node node, FlowState flowstate) {\n    any(XmlLibrary l).configurationSink(node, flowstate)\n  }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    // create additional flow steps for `XxeFlowStateTransformer`s\n    state2 = node2.asIndirectExpr().(XxeFlowStateTransformer).transform(state1) and\n    DataFlow::simpleLocalFlowStep(node1, node2, _)\n  }\n\n  predicate isBarrier(DataFlow::Node node, FlowState flowstate) {\n    // when the flowstate is transformed at a call node, block the original\n    // flowstate value.\n    node.asIndirectExpr().(XxeFlowStateTransformer).transform(flowstate) != flowstate\n  }\n\n  predicate neverSkip(DataFlow::Node node) { none() }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule XxeFlow = DataFlow::GlobalWithState<XxeConfig>;\n\nfrom XxeFlow::PathNode source, XxeFlow::PathNode sink\nwhere XxeFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"This $@ is not configured to prevent an XML external entity (XXE) attack.\", source, \"XML parser\"",
        "description": "Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-611/XXE.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.CommandExecution\nimport semmle.code.cpp.security.Security\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.models.implementations.Strcat\nimport ExecTaint::PathGraph\n\npredicate interestingConcatenation(DataFlow::Node incoming, DataFlow::Node outgoing) {\n  exists(FormattingFunctionCall call, int index, FormatLiteral literal |\n    incoming.asIndirectArgument() = call.getConversionArgument(index) and\n    outgoing.asDefiningArgument() = call.getOutputArgument(false) and\n    literal = call.getFormat() and\n    not literal.getConvSpecOffset(index) = 0 and\n    literal.getConversionChar(index) = [\"s\", \"S\"]\n  )\n  or\n  // strcat and friends\n  exists(StrcatFunction strcatFunc, Call call |\n    call.getTarget() = strcatFunc and\n    incoming.asIndirectArgument() = call.getArgument(strcatFunc.getParamSrc()) and\n    outgoing.asDefiningArgument() = call.getArgument(strcatFunc.getParamDest())\n  )\n  or\n  exists(Call call, Operator op |\n    call.getTarget() = op and\n    op.hasQualifiedName(\"std\", \"operator+\") and\n    op.getType().(UserType).hasQualifiedName(\"std\", \"basic_string\") and\n    incoming.asIndirectArgument() = call.getArgument(1) and // right operand\n    call = outgoing.asInstruction().getUnconvertedResultExpression()\n  )\n}\n\nnewtype TState =\n  TConcatState() or\n  TExecState(DataFlow::Node incoming, DataFlow::Node outgoing) {\n    interestingConcatenation(pragma[only_bind_into](incoming), pragma[only_bind_into](outgoing))\n  }\n\nclass ConcatState extends TConcatState {\n  string toString() { result = \"ConcatState\" }\n}\n\nclass ExecState extends TExecState {\n  DataFlow::Node incoming;\n  DataFlow::Node outgoing;\n\n  ExecState() { this = TExecState(incoming, outgoing) }\n\n  DataFlow::Node getIncomingNode() { result = incoming }\n\n  DataFlow::Node getOutgoingNode() { result = outgoing }\n\n  /**\n   * Holds if this is a possible `ExecState` at `sink`, that is, if `outgoing` flows to `sink`.\n   */\n  predicate isFeasibleForSink(DataFlow::Node sink) { ExecState::flow(outgoing, sink) }\n\n  string toString() { result = \"ExecState\" }\n}\n\npredicate isSinkImpl(DataFlow::Node sink, Expr command, string callChain) {\n  command = sink.asIndirectArgument() and\n  shellCommand(command, callChain)\n}\n\npredicate isBarrierImpl(DataFlow::Node node) {\n  node.asExpr().getUnspecifiedType() instanceof IntegralType\n  or\n  node.asExpr().getUnspecifiedType() instanceof FloatingPointType\n}\n\nmodule ExecStateConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { any(ExecState state).getOutgoingNode() = source }\n\n  predicate isSink(DataFlow::Node sink) { isSinkImpl(sink, _, _) }\n\n  predicate isBarrier(DataFlow::Node node) { isBarrierImpl(node) }\n\n  predicate isBarrierOut(DataFlow::Node node) {\n    isSink(node) // Prevent duplicates along a call chain, since `shellCommand` will include wrappers\n  }\n}\n\nmodule ExecState = TaintTracking::Global<ExecStateConfig>;\n\nmodule ExecTaintConfig implements DataFlow::StateConfigSig {\n  class FlowState = TState;\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    source instanceof FlowSource and\n    state instanceof ConcatState\n  }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    ExecStateConfig::isSink(sink) and\n    state.(ExecState).isFeasibleForSink(sink)\n  }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    state1 instanceof ConcatState and\n    state2.(ExecState).getIncomingNode() = node1 and\n    state2.(ExecState).getOutgoingNode() = node2\n  }\n\n  predicate isBarrier(DataFlow::Node node) { isBarrierImpl(node) }\n\n  predicate isBarrierOut(DataFlow::Node node, FlowState state) {\n    isSink(node, state) // Prevent duplicates along a call chain, since `shellCommand` will include wrappers\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(DataFlow::Node concatResult, Expr command, ExecState state |\n      result = [concatResult.getLocation(), command.getLocation()] and\n      isSink(sink, state) and\n      isSinkImpl(sink, command, _) and\n      concatResult = state.getOutgoingNode()\n    )\n  }\n}\n\nmodule ExecTaint = TaintTracking::GlobalWithState<ExecTaintConfig>;\n\nfrom\n  ExecTaint::PathNode sourceNode, ExecTaint::PathNode sinkNode, string taintCause, string callChain,\n  DataFlow::Node concatResult, Expr command\nwhere\n  ExecTaint::flowPath(sourceNode, sinkNode) and\n  taintCause = sourceNode.getNode().(FlowSource).getSourceType() and\n  isSinkImpl(sinkNode.getNode(), command, callChain) and\n  concatResult = sinkNode.getState().(ExecState).getOutgoingNode()\nselect command, sourceNode, sinkNode,\n  \"This argument to an OS command is derived from $@, dangerously concatenated into $@, and then passed to \"\n    + callChain + \".\", sourceNode, \"user input (\" + taintCause + \")\", concatResult,\n  concatResult.toString()",
        "description": "Using user-supplied data in an OS command, without neutralizing special elements, can make code vulnerable to command injection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-078/ExecTainted.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Environment\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.ir.IR\nimport Flow::PathGraph\n\nclass PrintStdoutCall extends FunctionCall {\n  PrintStdoutCall() { this.getTarget().hasGlobalOrStdName([\"puts\", \"printf\"]) }\n}\n\nclass QueryString extends EnvironmentRead {\n  QueryString() { this.getEnvironmentVariable() = \"QUERY_STRING\" }\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node.asIndirectExpr() instanceof QueryString }\n\n  predicate isSink(DataFlow::Node node) {\n    exists(PrintStdoutCall call | call.getAnArgument() = [node.asIndirectExpr(), node.asExpr()])\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    isSink(node) and node.asExpr().getUnspecifiedType() instanceof ArithmeticType\n    or\n    node.asCertainDefinition().getUnspecifiedType() instanceof ArithmeticType\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    exists(QueryString query | result = query.getLocation() | query = source.asIndirectExpr())\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom QueryString query, Flow::PathNode sourceNode, Flow::PathNode sinkNode\nwhere\n  Flow::flowPath(sourceNode, sinkNode) and\n  query = sourceNode.getNode().asIndirectExpr()\nselect sinkNode.getNode(), sourceNode, sinkNode, \"Cross-site scripting vulnerability due to $@.\",\n  query, \"this query data\"",
        "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Security/CWE/CWE-079/CgiXss.ql",
        "language": "cpp"
    },
    {
        "query": "import SAL\n\nfrom Function f, FunctionCall call\nwhere\n  call.getTarget() = f and\n  call instanceof ExprInVoidContext and\n  any(SalCheckReturn a).getDeclaration() = f and\n  not getOptions().okToIgnoreReturnValue(call)\nselect call, \"Return value of $@ discarded although a SAL annotation \" + \"requires inspecting it.\",\n  f, f.getName()",
        "description": "When a return value is discarded even though the SAL annotation requires inspecting it, a recoverable error may turn into a whole-program crash.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Microsoft/IgnoreReturnValueSAL.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport SAL\n\nfrom Parameter p, Call c, Expr arg\nwhere\n  any(SalNotNull a).getDeclaration() = p and\n  c.getTarget() = p.getFunction() and\n  arg = c.getArgument(p.getIndex()) and\n  nullValue(arg)\nselect arg,\n  \"Argument (\" + arg.toString() + \") for parameter $@ in call to \" + c.getTarget().getName() +\n    \" may be null, but a SAL annotation forbids this.\", p, p.getName()",
        "description": "When null is passed to a function that is SAL-annotated to forbid this, undefined behavior may result.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Microsoft/CallWithNullSAL.ql",
        "language": "cpp"
    },
    {
        "query": "import SAL\n\npredicate hasAnnotation(DeclarationEntry e, string name) {\n  exists(SalAnnotation a |\n    a.getMacro().getName() = name and\n    a.getDeclarationEntry() = e\n  )\n}\n\npredicate inheritsDeclAnnotations(DeclarationEntry e) {\n  // Is directly annotated\n  e.isDefinition() and\n  exists(SalAnnotation a | a.getMacro().getName() = \"_Use_decl_annotations_\" |\n    a.getDeclarationEntry() = e\n  )\n  or\n  // or is a parameter of a function with such an annotation\n  inheritsDeclAnnotations(e.(ParameterDeclarationEntry).getFunctionDeclarationEntry())\n}\n\nfrom DeclarationEntry e1, DeclarationEntry e2, string name\nwhere\n  e1.getDeclaration() = e2.getDeclaration() and\n  hasAnnotation(e1, name) and\n  not hasAnnotation(e2, name) and\n  not name = \"_Use_decl_annotations_\" and\n  not inheritsDeclAnnotations(e2)\nselect e2,\n  \"Missing SAL annotation \" + name + \" in \" + e2.toString() + \" although it is present on $@.\", e1,\n  e1.toString()",
        "description": "Annotations are different between declaration and definition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Microsoft/InconsistentSAL.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// Sometimes it is useful to have a class which is instantiated (on the stack)\n// but not otherwise used. This is usually to perform some task and have that\n// task automatically reversed when the current scope is left. For example,\n// sometimes locking is done this way.\n//\n// Obviously, such instantiations should not be treated as unused values.\nclass ScopeUtilityClass extends Class {\n  Call getAUse() { result = this.getAConstructor().getACallToThisFunction() }\n}\n\nfrom StackVariable v, ControlFlowNode def\nwhere\n  definition(v, def) and\n  not definitionUsePair(v, def, _) and\n  not v.getAnAccess().isAddressOfAccess() and\n  // parameter initializers are not in the call-graph at the moment\n  not v.(Parameter).getInitializer().getExpr() = def and\n  not v.getType().getUnderlyingType() instanceof ReferenceType and\n  not exists(ScopeUtilityClass util | def = util.getAUse()) and\n  not def.isInMacroExpansion()\nselect def, \"Variable '\" + v.getName() + \"' is assigned a value that is never used.\"",
        "description": "Assigning a value to a variable that is not used may indicate an error in the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/Unused.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.pointsto.PointsTo\n\npredicate closed(Expr e) {\n  exists(FunctionCall fc |\n    fc.getTarget().hasGlobalOrStdName(\"close\") and\n    fc.getArgument(0) = e\n  )\n}\n\nclass ClosedExpr extends PointsToExpr {\n  ClosedExpr() { closed(this) }\n\n  override predicate interesting() { closed(this) }\n}\n\nfrom Expr alloc\nwhere\n  allocateDescriptorCall(alloc) and\n  not exists(ClosedExpr closed | closed.pointsTo() = alloc)\nselect alloc, \"This file descriptor is never closed.\"",
        "description": "Functions that always return before closing the socket they opened leak resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/DescriptorNeverClosed.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate testAndBranch(Expr e, Stmt branch) {\n  exists(IfStmt ifstmt |\n    ifstmt.getCondition() = e and\n    (ifstmt.getThen() = branch or ifstmt.getElse() = branch)\n  )\n  or\n  exists(WhileStmt while |\n    while.getCondition() = e and\n    while.getStmt() = branch\n  )\n}\n\npredicate choice(StackVariable v, Stmt branch, string value) {\n  exists(AnalysedExpr e |\n    testAndBranch(e, branch) and\n    (\n      e.getNullSuccessor(v) = branch and value = \"null\"\n      or\n      e.getNonNullSuccessor(v) = branch and value = \"non-null\"\n    )\n  )\n}\n\npredicate guarded(StackVariable v, Stmt loopstart, AnalysedExpr child) {\n  choice(v, loopstart, _) and\n  loopstart.getChildStmt*() = child.getEnclosingStmt() and\n  (definition(v, child) or exists(child.getNullSuccessor(v)))\n}\n\npredicate addressLeak(Variable v, Stmt leak) {\n  exists(VariableAccess access |\n    v.getAnAccess() = access and\n    access.getEnclosingStmt() = leak and\n    access.isAddressOfAccess()\n  )\n}\n\nfrom StackVariable v, Stmt branch, AnalysedExpr cond, string context, string test, string testresult\nwhere\n  choice(v, branch, context) and\n  forall(ControlFlowNode def | definition(v, def) and definitionReaches(def, cond) |\n    not guarded(v, branch, def)\n  ) and\n  not cond.isDef(v) and\n  guarded(v, branch, cond) and\n  exists(cond.getNullSuccessor(v)) and\n  not addressLeak(v, branch.getChildStmt*()) and\n  (\n    cond.isNullCheck(v) and test = \"null\"\n    or\n    cond.isValidCheck(v) and test = \"non-null\"\n  ) and\n  (if context = test then testresult = \"succeed\" else testresult = \"fail\")\nselect cond,\n  \"Variable '\" + v.getName() + \"' is always \" + context + \", this check will always \" + testresult +\n    \".\"",
        "description": "The condition of the branching statement always evaluates to the same value. This means that only one branch will ever be executed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/DeadCodeCondition.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.models.Models\nimport semmle.code.cpp.commons.Buffer\n\npredicate baseType(AllocationExpr alloc, Type base) {\n  exists(PointerType pointer |\n    pointer.getBaseType() = base and\n    (\n      exists(AssignExpr assign |\n        assign.getRValue() = alloc and assign.getLValue().getType() = pointer\n      )\n      or\n      exists(Variable v | v.getInitializer().getExpr() = alloc and v.getType() = pointer)\n    )\n  )\n}\n\npredicate decideOnSize(Type t, int size) {\n  // If the codebase has more than one type with the same name, it can have more than one size. For\n  // most purposes in this query, we use the smallest.\n  size = min(t.getSize())\n}\n\nfrom AllocationExpr alloc, Type base, int basesize, int allocated\nwhere\n  baseType(alloc, base) and\n  allocated = alloc.getSizeBytes() and\n  decideOnSize(base, basesize) and\n  alloc.(FunctionCall).getTarget() instanceof AllocationFunction and // exclude `new` and similar\n  // If the codebase has more than one type with the same name, check if any matches\n  not exists(int size | base.getSize() = size |\n    size = 0 or\n    (allocated / size) * size = allocated\n  ) and\n  not basesize > allocated and // covered by SizeCheck.ql\n  not memberMayBeVarSize(base.getUnspecifiedType(), _) // exclude variable size types\nselect alloc,\n  \"Allocated memory (\" + allocated.toString() + \" bytes) is not a multiple of the size of '\" +\n    base.getName() + \"' (\" + basesize.toString() + \" bytes).\"",
        "description": "Calling 'malloc', 'calloc' or 'realloc' without allocating enough memory to contain multiple instances of the type of the pointer may result in a buffer overflow",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/SizeCheck2.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate limitedScope(Function f) {\n  f.isStatic() and not f instanceof MemberFunction\n  or\n  f.(MemberFunction).isPrivate()\n}\n\npredicate uncalled(Function f) {\n  limitedScope(f) and\n  not exists(Function g | g = f or g = f.(VirtualFunction).getAnOverriddenFunction+() |\n    exists(g.getACallToThisFunction()) or\n    exists(FunctionAccess fa | fa.getTarget() = g)\n  )\n}\n\nfrom Function f\nwhere\n  uncalled(f) and\n  forall(Function instance | f.(TemplateFunction).getAnInstantiation() = instance |\n    uncalled(instance)\n  ) and\n  // tweaks for good results:\n  exists(f.getBlock()) and\n  not (f instanceof Constructor or f instanceof Destructor or f.hasName(\"operator=\"))\nselect f, \"Dead Code: this function is never called.\"",
        "description": "Unused functions may increase object size, decrease readability, and create the possibility of misuse.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/DeadCodeFunction.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.controlflow.IRGuards\nimport semmle.code.cpp.security.FlowSources\nimport OverflowDestination::PathGraph\n\npredicate sourceSized(FunctionCall fc, Expr src) {\n  fc.getTarget().hasGlobalOrStdName([\"strncpy\", \"strncat\", \"memcpy\", \"memmove\"]) and\n  exists(Expr dest, Expr size, Variable v |\n    fc.getArgument(0) = dest and\n    fc.getArgument(1).getFullyConverted() = src and\n    fc.getArgument(2) = size and\n    src = v.getAnAccess().getFullyConverted() and\n    size.getAChild+() = v.getAnAccess() and\n    // exception: `dest` is also referenced in the size argument\n    not exists(Variable other |\n      dest = other.getAnAccess() and size.getAChild+() = other.getAnAccess()\n    ) and\n    // exception: `src` and `dest` are both arrays of the same type and size\n    not exists(ArrayType srctype, ArrayType desttype |\n      dest.getType().getUnderlyingType() = desttype and\n      src.getType().getUnderlyingType() = srctype and\n      desttype.getBaseType().getUnderlyingType() = srctype.getBaseType().getUnderlyingType() and\n      desttype.getArraySize() = srctype.getArraySize()\n    )\n  )\n}\n\npredicate readsVariable(LoadInstruction load, Variable var) {\n  load.getSourceAddress().(VariableAddressInstruction).getAstVariable() = var\n}\n\npredicate hasUpperBoundsCheck(Variable var) {\n  exists(RelationalOperation oper, VariableAccess access |\n    oper.getAnOperand() = access and\n    access.getTarget() = var and\n    // Comparing to 0 is not an upper bound check\n    not oper.getAnOperand().getValue() = \"0\"\n  )\n}\n\npredicate nodeIsBarrierEqualityCandidate(DataFlow::Node node, Operand access, Variable checkedVar) {\n  readsVariable(node.asInstruction(), checkedVar) and\n  any(IRGuardCondition guard).ensuresEq(access, _, _, node.asInstruction().getBlock(), true)\n}\n\nmodule OverflowDestinationConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof FlowSource }\n\n  predicate isSink(DataFlow::Node sink) { sourceSized(_, sink.asIndirectConvertedExpr()) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    exists(Variable checkedVar |\n      readsVariable(node.asInstruction(), checkedVar) and\n      hasUpperBoundsCheck(checkedVar)\n    )\n    or\n    exists(Variable checkedVar, Operand access |\n      readsVariable(access.getDef(), checkedVar) and\n      nodeIsBarrierEqualityCandidate(node, access, checkedVar)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(FunctionCall fc | result = fc.getLocation() |\n      sourceSized(fc, sink.asIndirectConvertedExpr())\n    )\n  }\n}\n\nmodule OverflowDestination = TaintTracking::Global<OverflowDestinationConfig>;\n\nfrom FunctionCall fc, OverflowDestination::PathNode source, OverflowDestination::PathNode sink\nwhere\n  OverflowDestination::flowPath(source, sink) and\n  sourceSized(fc, sink.getNode().asIndirectConvertedExpr())\nselect fc, source, sink,\n  \"To avoid overflow, this operation should be bounded by destination-buffer size, not source-buffer size.\"",
        "description": "Calling a copy operation with a size derived from the source buffer instead of the destination buffer may result in a buffer overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/OverflowDestination.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.EscapesTree\n\nfrom Function f, Parameter p, Type t, int size\nwhere\n  f.getAParameter() = p and\n  p.getType() = t and\n  t.getSize() = size and\n  size > 64 and\n  not t.getUnderlyingType() instanceof ArrayType and\n  not f instanceof CopyAssignmentOperator and\n  // exception: p is written to, which may mean the copy is intended\n  not p.getAnAccess().isAddressOfAccessNonConst() and\n  not exists(Expr e |\n    variableAccessedAsValue(p.getAnAccess(), e.getFullyConverted()) and\n    (\n      exists(Assignment an | an.getLValue() = e)\n      or\n      exists(CrementOperation co | co.getOperand() = e)\n      or\n      exists(FunctionCall fc | fc.getQualifier() = e and not fc.getTarget().hasSpecifier(\"const\"))\n    )\n  ) and\n  // if there's no block, we can't tell how the parameter is used\n  exists(f.getBlock())\nselect p,\n  \"This parameter of type $@ is \" + size.toString() +\n    \" bytes - consider passing a const pointer/reference instead.\", t, t.toString()",
        "description": "An object larger than 64 bytes is passed by value to a function. Passing large objects by value unnecessarily use up scarce stack space, increase the cost of calling a function and can be a security risk. Use a const pointer to the object instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/LargeParameter.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.models.Models\n\npredicate baseType(AllocationExpr alloc, Type base) {\n  exists(PointerType pointer |\n    pointer.getBaseType() = base and\n    (\n      exists(AssignExpr assign |\n        assign.getRValue() = alloc and assign.getLValue().getType() = pointer\n      )\n      or\n      exists(Variable v | v.getInitializer().getExpr() = alloc and v.getType() = pointer)\n    )\n  )\n}\n\npredicate decideOnSize(Type t, int size) {\n  // If the codebase has more than one type with the same name, it can have more than one size.\n  size = min(t.getSize())\n}\n\nfrom AllocationExpr alloc, Type base, int basesize, int allocated\nwhere\n  baseType(alloc, base) and\n  allocated = alloc.getSizeBytes() and\n  decideOnSize(base, basesize) and\n  alloc.(FunctionCall).getTarget() instanceof AllocationFunction and // exclude `new` and similar\n  basesize > allocated\nselect alloc,\n  \"Type '\" + base.getName() + \"' is \" + basesize.toString() + \" bytes, but only \" +\n    allocated.toString() + \" bytes are allocated.\"",
        "description": "Calling 'malloc', 'calloc' or 'realloc' without allocating enough memory to contain an instance of the type of the pointer may result in a buffer overflow",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/SizeCheck.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate negativeCheck(StackVariable v, ComparisonOperation op) {\n  exists(int varindex, string constant, Literal lit |\n    op.getChild(varindex) = v.getAnAccess() and\n    op.getChild(1 - varindex) = lit and\n    lit.getValue() = constant and\n    (\n      op.getOperator() = \"<\" and varindex = 0 and constant = \"0\"\n      or\n      op.getOperator() = \"<\" and varindex = 1 and constant = \"-1\"\n      or\n      op.getOperator() = \">\" and varindex = 0 and constant = \"-1\"\n      or\n      op.getOperator() = \">\" and varindex = 1 and constant = \"0\"\n      or\n      op.getOperator() = \"<=\" and varindex = 0 and constant = \"-1\"\n      or\n      op.getOperator() = \"<=\" and varindex = 1 and constant = \"0\"\n      or\n      op.getOperator() = \">=\" and varindex = 0 and constant = \"0\"\n      or\n      op.getOperator() = \">=\" and varindex = 1 and constant = \"-1\"\n    )\n  )\n}\n\nfrom StackVariable v, ArrayExpr dangerous, Expr check\nwhere\n  useUsePair(v, dangerous.getArrayOffset(), check.getAChild()) and\n  negativeCheck(v, check) and\n  not exists(Expr other |\n    negativeCheck(v, other) and useUsePair(v, other.getAChild(), dangerous.getArrayOffset())\n  )\nselect dangerous,\n  \"Variable '\" + v.getName() +\n    \"' is used as an array-offset before it is tested for being negative (test on line \" +\n    check.getLocation().getStartLine().toString() + \").\"",
        "description": "Accessing a pointer or array using an offset before checking if the value is positive may result in unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/LateNegativeTest.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom VariableAccess access\nwhere\n  maybeNull(access) and\n  dereferenced(access)\nselect access, \"Value may be null; it should be checked before dereferencing.\"",
        "description": "Dereferencing an untested value from a function that can return null may lead to undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/MissingNullTest.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.pointsto.CallGraph\n\npredicate global(GlobalVariable v) {\n  not exists(v.getInitializer()) and\n  not v.getType() instanceof ArrayType and\n  not v.getType() instanceof Class and\n  v.getAnAccess().isUsedAsLValue()\n}\n\npredicate mainCalled(Function f) {\n  f.hasGlobalName(\"main\")\n  or\n  exists(Function caller | mainCalled(caller) and allCalls(caller, f))\n}\n\npredicate called(Function f) {\n  mainCalled(f)\n  or\n  exists(FunctionAccess fa | fa.getTarget() = f)\n}\n\npredicate staticWithoutDereference(GlobalVariable v) {\n  v.isStatic() and\n  not exists(VariableAccess va |\n    va = v.getAnAccess() and\n    dereferenced(va)\n  )\n}\n\nfrom GlobalVariable v\nwhere\n  global(v) and\n  not staticWithoutDereference(v) and\n  not exists(VariableAccess lval |\n    v.getAnAccess() = lval and\n    lval.isUsedAsLValue() and\n    called(lval.getEnclosingFunction())\n  )\nselect v, \"Initialization code for '\" + v.getName() + \"' is never run.\"",
        "description": "Not running initialization code may lead to unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/InitialisationNotRun.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Scanf\nimport semmle.code.cpp.controlflow.Guards\nimport semmle.code.cpp.dataflow.new.DataFlow::DataFlow\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport ScanfChecks\nimport ScanfToUseFlow::PathGraph\n\npredicate isUninitialized(Node n) {\n  exists(n.asUninitialized()) or\n  n.asIndirectExpr(1) instanceof AllocationExpr\n}\n\npredicate isSink(ScanfFunctionCall call, int index, Node n, Expr input) {\n  input = call.getOutputArgument(index) and\n  n.asIndirectExpr() = input\n}\n\nmodule UninitializedToScanfConfig implements ConfigSig {\n  predicate isSource(Node source) { isUninitialized(source) }\n\n  predicate isSink(Node sink) { isSink(_, _, sink, _) }\n\n  FlowFeature getAFeature() { result instanceof FeatureEqualSourceSinkCallContext }\n\n  int accessPathLimit() { result = 0 }\n}\n\nmodule UninitializedToScanfFlow = Global<UninitializedToScanfConfig>;\n\npredicate isRelevantScanfCall(ScanfFunctionCall call, int index, Expr output) {\n  exists(Node n | UninitializedToScanfFlow::flowTo(n) and isSink(call, index, n, output)) and\n  // Exclude results from incorrectky checked scanf query\n  not incorrectlyCheckedScanf(call)\n}\n\npredicate isSource(ScanfFunctionCall call, int index, Node n, Expr output) {\n  isRelevantScanfCall(call, index, output) and\n  output = call.getOutputArgument(index) and\n  n.asDefiningArgument() = output\n}\n\npredicate isSink(Node n, Expr e) {\n  n.asExpr() = e and\n  not any(DeallocationExpr dealloc).getFreedExpr() = e\n}\n\nmodule ScanfToUseConfig implements ConfigSig {\n  predicate isSource(Node source) { isSource(_, _, source, _) }\n\n  predicate isSink(Node sink) { isSink(sink, _) }\n\n  predicate isBarrierOut(Node n) {\n    // We disable flow out of sinks to reduce result duplication\n    isSink(n, _)\n    or\n    // If the node is being passed to a function it may be\n    // modified, and thus it's safe to later read the value.\n    exists(n.asIndirectArgument())\n  }\n}\n\nmodule ScanfToUseFlow = Global<ScanfToUseConfig>;\n\npredicate flowPath(\n  ScanfToUseFlow::PathNode source, ScanfFunctionCall call, int index, ScanfToUseFlow::PathNode sink,\n  Expr e\n) {\n  isSource(call, index, source.getNode(), _) and\n  ScanfToUseFlow::flowPath(source, sink) and\n  isSink(sink.getNode(), e)\n}\n\nint getMinimumGuardConstant(ScanfFunctionCall call, int index) {\n  isSource(call, index, _, _) and\n  result =\n    index + 1 -\n      count(ScanfFormatLiteral f, int n |\n        // Special case: %n writes to an argument without reading any input.\n        // It does not increase the count returned by `scanf`.\n        n <= index and f.getUse() = call and f.getConversionChar(n) = \"n\"\n      )\n}\n\npredicate hasNonGuardedAccess(\n  ScanfToUseFlow::PathNode source, ScanfFunctionCall call, ScanfToUseFlow::PathNode sink, Expr e,\n  int minGuard\n) {\n  exists(int index |\n    flowPath(source, call, index, sink, e) and\n    minGuard = getMinimumGuardConstant(call, index)\n  |\n    not exists(GuardCondition guard |\n      // call == k and k >= minGuard so call >= minGuard\n      guard\n          .ensuresEq(globalValueNumber(call).getAnExpr(), any(int k | minGuard <= k),\n            e.getBasicBlock(), true)\n      or\n      // call >= k and k >= minGuard so call >= minGuard\n      guard\n          .ensuresLt(globalValueNumber(call).getAnExpr(), any(int k | minGuard <= k),\n            e.getBasicBlock(), false)\n    )\n  )\n}\n\nfrom\n  ScanfToUseFlow::PathNode source, ScanfToUseFlow::PathNode sink, ScanfFunctionCall call, Expr e,\n  int minGuard\nwhere hasNonGuardedAccess(source, call, sink, e, minGuard)\nselect e, source, sink,\n  \"This variable is read, but may not have been written. \" +\n    \"It should be guarded by a check that the $@ returns at least \" + minGuard + \".\", call,\n  call.toString()",
        "description": "Failing to check that a call to 'scanf' actually writes to an output variable can lead to unexpected behavior at reading time.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/MissingCheckScanf.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.new.DataFlow\nimport semmle.code.cpp.security.flowafterfree.FlowAfterFree\nimport DoubleFree::PathGraph\n\npredicate isFree(DataFlow::Node n, Expr e) { isFree(_, n, e, _) }\n\nmodule DoubleFreeParam implements FlowFromFreeParamSig {\n  predicate isSink = isFree/2;\n\n  predicate isExcluded = isExcludedMmFreePageFromMdl/2;\n\n  predicate sourceSinkIsRelated = defaultSourceSinkIsRelated/2;\n}\n\nmodule DoubleFree = FlowFromFree<DoubleFreeParam>;\n\nfrom DoubleFree::PathNode source, DoubleFree::PathNode sink, DeallocationExpr dealloc, Expr e2\nwhere\n  DoubleFree::flowPath(source, sink) and\n  isFree(source.getNode(), _, _, dealloc) and\n  isFree(sink.getNode(), e2)\nselect sink.getNode(), source, sink, \"Memory pointed to by $@ may already have been freed by $@.\",\n  e2, e2.toString(), dealloc, dealloc.toString()",
        "description": "Freeing a resource more than once can lead to undefined behavior and cause memory corruption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/DoubleFree.ql",
        "language": "cpp"
    },
    {
        "query": "import FileClosed\nimport semmle.code.cpp.controlflow.StackVariableReachability\n\nclass MinusOne extends NullValue {\n  MinusOne() { this.(UnaryMinusExpr).getOperand().(Literal).getValue() = \"1\" }\n}\n\npredicate mayCallFunction(Expr call, Function f) {\n  call.(FunctionCall).getTarget() = f or\n  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =\n    f\n}\n\npredicate fopenCallOrIndirect(Expr e) {\n  // direct fopen call\n  fopenCall(e) and\n  // We are only interested in fopen calls that are\n  // actually closed somehow, as FileNeverClosed\n  // will catch those that aren't.\n  fopenCallMayBeClosed(e)\n  or\n  exists(ReturnStmt rtn |\n    // indirect fopen call\n    mayCallFunction(e, rtn.getEnclosingFunction()) and\n    (\n      // return fopen\n      fopenCallOrIndirect(rtn.getExpr())\n      or\n      // return variable assigned with fopen\n      exists(Variable v |\n        v = rtn.getExpr().(VariableAccess).getTarget() and\n        fopenCallOrIndirect(v.getAnAssignedValue()) and\n        not assignedToFieldOrGlobal(v, _)\n      )\n    )\n  )\n}\n\npredicate fcloseCallOrIndirect(FunctionCall fc, Variable v) {\n  // direct fclose call\n  fcloseCall(fc, v.getAnAccess())\n  or\n  // indirect fclose call\n  exists(FunctionCall midcall, Function mid, int arg |\n    fc.getArgument(arg) = v.getAnAccess() and\n    mayCallFunction(fc, mid) and\n    midcall.getEnclosingFunction() = mid and\n    fcloseCallOrIndirect(midcall, mid.getParameter(arg))\n  )\n}\n\npredicate fopenDefinition(StackVariable v, ControlFlowNode def) {\n  exists(Expr expr | exprDefinition(v, def, expr) and fopenCallOrIndirect(expr))\n}\n\nclass FOpenVariableReachability extends StackVariableReachabilityWithReassignment {\n  FOpenVariableReachability() { this = \"FOpenVariableReachability\" }\n\n  override predicate isSourceActual(ControlFlowNode node, StackVariable v) {\n    fopenDefinition(v, node)\n  }\n\n  override predicate isSinkActual(ControlFlowNode node, StackVariable v) {\n    // node may be used in fopenReaches\n    exists(node.(AnalysedExpr).getNullSuccessor(v)) or\n    fcloseCallOrIndirect(node, v) or\n    assignedToFieldOrGlobal(v, node) or\n    // node may be used directly in query\n    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()\n  }\n\n  override predicate isBarrier(ControlFlowNode node, StackVariable v) { definitionBarrier(v, node) }\n}\n\npredicate fopenVariableReaches(StackVariable v, ControlFlowNode def, ControlFlowNode node) {\n  exists(FOpenVariableReachability r |\n    // reachability\n    r.reachesTo(def, _, node, v)\n    or\n    // accept def node itself\n    r.isSource(def, v) and\n    node = def\n  )\n}\n\nclass FOpenReachability extends StackVariableReachabilityExt {\n  FOpenReachability() { this = \"FOpenReachability\" }\n\n  override predicate isSource(ControlFlowNode node, StackVariable v) { fopenDefinition(v, node) }\n\n  override predicate isSink(ControlFlowNode node, StackVariable v) {\n    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()\n  }\n\n  override predicate isBarrier(\n    ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v\n  ) {\n    this.isSource(source, v) and\n    next = node.getASuccessor() and\n    // the file (stored in any variable `v0`) opened at `source` is closed or\n    // assigned to a global at node, or NULL checked on the edge node -> next.\n    exists(StackVariable v0 | fopenVariableReaches(v0, source, node) |\n      node.(AnalysedExpr).getNullSuccessor(v0) = next or\n      fcloseCallOrIndirect(node, v0) or\n      assignedToFieldOrGlobal(v0, node)\n    )\n  }\n}\n\npredicate fopenReaches(ControlFlowNode def, ControlFlowNode node) {\n  exists(FOpenReachability r | r.reaches(def, _, node))\n}\n\npredicate assignedToFieldOrGlobal(StackVariable v, Expr e) {\n  // assigned to anything except a StackVariable\n  // (typically a field or global, but for example also *ptr = v)\n  e.(Assignment).getRValue() = v.getAnAccess() and\n  not e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable\n  or\n  exists(Expr midExpr, Function mid, int arg |\n    // indirect assignment\n    e.(FunctionCall).getArgument(arg) = v.getAnAccess() and\n    mayCallFunction(e, mid) and\n    midExpr.getEnclosingFunction() = mid and\n    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)\n  )\n  or\n  // assigned to a field via constructor field initializer\n  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()\n}\n\nfrom ControlFlowNode def, ReturnStmt ret\nwhere\n  fopenReaches(def, ret) and\n  not exists(StackVariable v |\n    fopenVariableReaches(v, def, ret) and\n    ret.getAChild*() = v.getAnAccess()\n  )\nselect def, \"This file may not be closed at $@.\", ret, \"this exit point\"",
        "description": "A function may return before closing a file that was opened in the function. Closing resources in the same function that opened them ties the lifetime of the resource to that of the function call, making it easier to avoid and detect resource leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/FileMayNotBeClosed.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.pointsto.PointsTo\nimport Negativity\n\npredicate closeCall(FunctionCall fc, Variable v) {\n  fc.getTarget().hasGlobalOrStdName(\"close\") and v.getAnAccess() = fc.getArgument(0)\n  or\n  exists(FunctionCall midcall, Function mid, int arg |\n    fc.getArgument(arg) = v.getAnAccess() and\n    fc.getTarget() = mid and\n    midcall.getEnclosingFunction() = mid and\n    closeCall(midcall, mid.getParameter(arg))\n  )\n}\n\npredicate openDefinition(StackVariable v, ControlFlowNode def) {\n  exists(Expr expr | exprDefinition(v, def, expr) and allocateDescriptorCall(expr))\n}\n\npredicate openReaches(ControlFlowNode def, ControlFlowNode node) {\n  openDefinition(_, def) and node = def.getASuccessor()\n  or\n  exists(StackVariable v, ControlFlowNode mid |\n    openDefinition(v, def) and\n    openReaches(def, mid) and\n    not errorSuccessor(v, mid) and\n    not closeCall(mid, v) and\n    not assignedToFieldOrGlobal(v, mid) and\n    node = mid.getASuccessor()\n  )\n}\n\npredicate assignedToFieldOrGlobal(StackVariable v, Assignment assign) {\n  exists(Variable external |\n    assign.getRValue() = v.getAnAccess() and\n    assign.getLValue().(VariableAccess).getTarget() = external and\n    (external instanceof Field or external instanceof GlobalVariable)\n  )\n}\n\nfrom StackVariable v, ControlFlowNode def, ReturnStmt ret\nwhere\n  openDefinition(v, def) and\n  openReaches(def, ret) and\n  checkedSuccess(v, ret) and\n  not ret.getExpr().getAChild*() = v.getAnAccess() and\n  exists(ReturnStmt other | other.getExpr() = v.getAnAccess())\nselect ret,\n  \"Descriptor assigned to '\" + v.getName().toString() + \"' (line \" +\n    def.getLocation().getStartLine().toString() + \") may not be closed.\"",
        "description": "Failing to close resources in the function that opened them makes it difficult to avoid and detect resource leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/DescriptorMayNotBeClosed.ql",
        "language": "cpp"
    },
    {
        "query": "import MemoryFreed\n\nfrom AllocationExpr alloc\nwhere\n  alloc.requiresDealloc() and\n  not allocMayBeFreed(alloc)\nselect alloc, \"This memory is never freed.\"",
        "description": "A function always returns before freeing memory that was allocated in the function. Freeing all memory allocated in the function before returning ties the lifetime of the memory blocks to that of the function call, making it easier to avoid and detect memory leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/MemoryNeverFreed.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.pointsto.PointsTo\n\nclass ReturnPointsToExpr extends PointsToExpr {\n  override predicate interesting() {\n    exists(ReturnStmt ret | ret.getExpr().getFullyConverted() = this) and\n    pointerValue(this)\n  }\n\n  ReturnStmt getReturnStmt() { result.getExpr().getFullyConverted() = this }\n}\n\nfrom ReturnPointsToExpr ret, StackVariable local, float confidence\nwhere\n  ret.pointsTo() = local and\n  ret.getReturnStmt().getEnclosingFunction() = local.getFunction() and\n  confidence = ret.confidence() and\n  confidence > 0.01\nselect ret,\n  \"This may return a pointer to '\" + local.getName() + \"' (declared on line \" +\n    local.getADeclarationLocation().getStartLine().toString() + \"), which is stack allocated.\"",
        "description": "Using a pointer to stack memory after the function has returned gives undefined results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/ReturnStackAllocatedObject.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Scanf\nimport ScanfChecks\n\nfrom ScanfFunctionCall call\nwhere incorrectlyCheckedScanf(call)\nselect call, \"The result of scanf is only checked against 0, but it can also return EOF.\"",
        "description": "Failing to account for EOF in a call to a scanf-like function can lead to undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/IncorrectCheckScanf.ql",
        "language": "cpp"
    },
    {
        "query": "import MemoryFreed\nimport semmle.code.cpp.controlflow.StackVariableReachability\n\npredicate mayCallFunction(Expr call, Function f) {\n  call.(FunctionCall).getTarget() = f or\n  call.(VariableCall).getVariable().getAnAssignedValue().getAChild*().(FunctionAccess).getTarget() =\n    f\n}\n\npredicate allocCallOrIndirect(Expr e) {\n  // direct alloc call\n  e.(AllocationExpr).requiresDealloc() and\n  // We are only interested in alloc calls that are\n  // actually freed somehow, as MemoryNeverFreed\n  // will catch those that aren't.\n  allocMayBeFreed(e)\n  or\n  exists(ReturnStmt rtn |\n    // indirect alloc call\n    mayCallFunction(e, rtn.getEnclosingFunction()) and\n    (\n      // return alloc\n      allocCallOrIndirect(rtn.getExpr())\n      or\n      // return variable assigned with alloc\n      exists(StackVariable v |\n        v = rtn.getExpr().(VariableAccess).getTarget() and\n        allocCallOrIndirect(v.getAnAssignedValue()) and\n        not assignedToFieldOrGlobal(v, _)\n      )\n    )\n  )\n}\n\npredicate verifiedRealloc(FunctionCall reallocCall, Variable v, ControlFlowNode verified) {\n  reallocCall.(AllocationExpr).getReallocPtr() = v.getAnAccess() and\n  (\n    exists(Variable newV, ControlFlowNode node |\n      // a realloc followed by a null check at 'node' (return the non-null\n      // successor, i.e. where the realloc is confirmed to have succeeded)\n      newV.getAnAssignedValue() = reallocCall and\n      node.(AnalysedExpr).getNonNullSuccessor(newV) = verified and\n      // note: this case uses naive flow logic (getAnAssignedValue).\n      // special case: if the result of the 'realloc' is assigned to the\n      // same variable, we don't discriminate properly between the old\n      // and the new allocation; better to not consider this a free at\n      // all in that case.\n      newV != v\n    )\n    or\n    // a realloc(ptr, 0), which always succeeds and frees\n    // (return the realloc itself)\n    reallocCall.(AllocationExpr).getReallocPtr().getValue() = \"0\" and\n    verified = reallocCall\n  )\n}\n\npredicate freeCallOrIndirect(ControlFlowNode n, Variable v) {\n  // direct free call\n  n.(DeallocationExpr).getFreedExpr() = v.getAnAccess() and\n  not exists(n.(AllocationExpr).getReallocPtr())\n  or\n  // verified realloc call\n  verifiedRealloc(_, v, n)\n  or\n  exists(FunctionCall midcall, Function mid, int arg |\n    // indirect free call\n    n.(Call).getArgument(arg) = v.getAnAccess() and\n    mayCallFunction(n, mid) and\n    midcall.getEnclosingFunction() = mid and\n    freeCallOrIndirect(midcall, mid.getParameter(arg))\n  )\n}\n\npredicate allocationDefinition(StackVariable v, ControlFlowNode def) {\n  exists(Expr expr | exprDefinition(v, def, expr) and allocCallOrIndirect(expr))\n}\n\nclass AllocVariableReachability extends StackVariableReachabilityWithReassignment {\n  AllocVariableReachability() { this = \"AllocVariableReachability\" }\n\n  override predicate isSourceActual(ControlFlowNode node, StackVariable v) {\n    allocationDefinition(v, node)\n  }\n\n  override predicate isSinkActual(ControlFlowNode node, StackVariable v) {\n    // node may be used in allocationReaches\n    exists(node.(AnalysedExpr).getNullSuccessor(v)) or\n    freeCallOrIndirect(node, v) or\n    assignedToFieldOrGlobal(v, node) or\n    // node may be used directly in query\n    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()\n  }\n\n  override predicate isBarrier(ControlFlowNode node, StackVariable v) { definitionBarrier(v, node) }\n}\n\npredicate allocatedVariableReaches(StackVariable v, ControlFlowNode def, ControlFlowNode node) {\n  exists(AllocVariableReachability r |\n    // reachability\n    r.reachesTo(def, _, node, v)\n    or\n    // accept def node itself\n    r.isSource(def, v) and\n    node = def\n  )\n}\n\nclass AllocReachability extends StackVariableReachabilityExt {\n  AllocReachability() { this = \"AllocReachability\" }\n\n  override predicate isSource(ControlFlowNode node, StackVariable v) {\n    allocationDefinition(v, node)\n  }\n\n  override predicate isSink(ControlFlowNode node, StackVariable v) {\n    v.getFunction() = node.(ReturnStmt).getEnclosingFunction()\n  }\n\n  override predicate isBarrier(\n    ControlFlowNode source, ControlFlowNode node, ControlFlowNode next, StackVariable v\n  ) {\n    this.isSource(source, v) and\n    next = node.getASuccessor() and\n    // the memory (stored in any variable `v0`) allocated at `source` is freed or\n    // assigned to a global at node, or NULL checked on the edge node -> next.\n    exists(StackVariable v0 | allocatedVariableReaches(v0, source, node) |\n      node.(AnalysedExpr).getNullSuccessor(v0) = next or\n      freeCallOrIndirect(node, v0) or\n      assignedToFieldOrGlobal(v0, node)\n    )\n  }\n}\n\npredicate allocationReaches(ControlFlowNode def, ControlFlowNode node) {\n  exists(AllocReachability r | r.reaches(def, _, node))\n}\n\npredicate assignedToFieldOrGlobal(StackVariable v, Expr e) {\n  // assigned to anything except a StackVariable\n  // (typically a field or global, but for example also *ptr = v)\n  e.(Assignment).getRValue() = v.getAnAccess() and\n  not e.(Assignment).getLValue().(VariableAccess).getTarget() instanceof StackVariable\n  or\n  exists(Expr midExpr, Function mid, int arg |\n    // indirect assignment\n    e.(FunctionCall).getArgument(arg) = v.getAnAccess() and\n    mayCallFunction(e, mid) and\n    midExpr.getEnclosingFunction() = mid and\n    assignedToFieldOrGlobal(mid.getParameter(arg), midExpr)\n  )\n  or\n  // assigned to a field via constructor field initializer\n  e.(ConstructorFieldInit).getExpr() = v.getAnAccess()\n}\n\nfrom ControlFlowNode def, ReturnStmt ret\nwhere\n  allocationReaches(def, ret) and\n  not exists(StackVariable v |\n    allocatedVariableReaches(v, def, ret) and\n    ret.getAChild*() = v.getAnAccess()\n  )\nselect def, \"This memory allocation may not be released at $@.\", ret, \"this exit point\"",
        "description": "A function may return before freeing memory that was allocated in the function. Freeing all memory allocated in the function before returning ties the lifetime of the memory blocks to that of the function call, making it easier to avoid and detect memory leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/MemoryMayNotBeFreed.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom StackVariable v, ControlFlowNode def, VariableAccess checked, VariableAccess unchecked\nwhere\n  checked = v.getAnAccess() and\n  // The check can often be in a macro for handling exception\n  not checked.isInMacroExpansion() and\n  dereferenced(checked) and\n  unchecked = v.getAnAccess() and\n  dereferenced(unchecked) and\n  definitionUsePair(v, def, checked) and\n  definitionUsePair(v, def, unchecked) and\n  checkedValid(v, checked) and\n  not checkedValid(v, unchecked) and\n  not unchecked.getParent+() instanceof SizeofOperator and\n  forall(ControlFlowNode other | definitionUsePair(v, other, checked) |\n    definitionUsePair(v, other, unchecked)\n  )\nselect unchecked,\n  \"This dereference is not guarded by a non-null check, whereas other dereferences are guarded.\"",
        "description": "A dereferenced pointer is not checked for nullness in this location, but it is checked in other locations. Dereferencing a null pointer leads to undefined results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/InconsistentNullnessTesting.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate defines(ControlFlowNode s, Variable lv) {\n  exists(VariableAccess va | va = s and va.getTarget() = lv and va.isUsedAsLValue())\n}\n\npredicate uses(ControlFlowNode s, Variable lv) {\n  exists(VariableAccess va |\n    va = s and\n    va.getTarget() = lv and\n    va.isRValue() and\n    not va.getParent+() instanceof SizeofOperator\n  )\n}\n\npredicate noDefPath(LocalVariable lv, ControlFlowNode n) {\n  n.(DeclStmt).getADeclaration() = lv and not exists(lv.getInitializer())\n  or\n  exists(ControlFlowNode p | noDefPath(lv, p) and n = p.getASuccessor() and not defines(p, lv))\n}\n\npredicate isAggregateType(Type t) { t instanceof Class or t instanceof ArrayType }\n\npredicate undefinedLocalUse(VariableAccess va) {\n  exists(LocalVariable lv |\n    // it is hard to tell when a struct or array has been initialized, so we\n    // ignore them\n    not isAggregateType(lv.getUnderlyingType()) and\n    not lv.isStatic() and // static variables are initialized to zero or null by default\n    not lv.getType().hasName(\"va_list\") and\n    va = lv.getAnAccess() and\n    noDefPath(lv, va) and\n    uses(va, lv)\n  )\n}\n\npredicate uninitialisedGlobal(GlobalVariable gv) {\n  exists(VariableAccess va |\n    not isAggregateType(gv.getUnderlyingType()) and\n    va = gv.getAnAccess() and\n    va.isRValue() and\n    not gv.hasInitializer() and\n    not gv.hasSpecifier(\"extern\") and\n    not gv.isStatic() // static variables are initialized to zero or null by default\n  )\n}\n\nfrom Element elt\nwhere undefinedLocalUse(elt) or uninitialisedGlobal(elt)\nselect elt, \"Variable '\" + elt.toString() + \"' is not initialized.\"",
        "description": "Using an uninitialized variable may lead to undefined results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/NotInitialised.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.models.interfaces.Allocation\n\npredicate spaceProblem(FunctionCall append, string msg) {\n  exists(\n    AllocationExpr malloc, StrlenCall strlen, AddExpr add, FunctionCall insert, Variable buffer\n  |\n    add.getAChild() = strlen and\n    exists(add.getAChild().getValue()) and\n    DataFlow::localExprFlow(add, malloc.getSizeExpr()) and\n    buffer.getAnAccess() = strlen.getStringExpr() and\n    (\n      insert.getTarget().hasGlobalOrStdName(\"strcpy\") or\n      insert.getTarget().hasGlobalOrStdName(\"strncpy\")\n    ) and\n    (\n      append.getTarget().hasGlobalOrStdName(\"strcat\") or\n      append.getTarget().hasGlobalOrStdName(\"strncat\")\n    ) and\n    malloc.getASuccessor+() = insert and\n    insert.getArgument(1) = buffer.getAnAccess() and\n    insert.getASuccessor+() = append and\n    msg =\n      \"This buffer only contains enough room for '\" + buffer.getName() + \"' (copied on line \" +\n        insert.getLocation().getStartLine().toString() + \")\"\n  )\n}\n\nfrom Expr problem, string msg\nwhere spaceProblem(problem, msg)\nselect problem, msg",
        "description": "A buffer allocated using 'malloc' may not have enough space for a string that is being copied into it. The operation can cause a buffer overrun. Make sure that the buffer contains enough room for the string (including the zero terminator).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/OverflowCalculated.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Buffer\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport semmle.code.cpp.ConfigurationTestFile\nimport LoopBounds\n\nprivate predicate staticBufferBase(VariableAccess access, Variable v) {\n  v.getType().(ArrayType).getBaseType() instanceof CharType and\n  access = v.getAnAccess() and\n  not memberMayBeVarSize(_, v) and\n  not access.isUnevaluated()\n}\n\npredicate staticBuffer(VariableAccess access, Variable v, int size) {\n  staticBufferBase(access, v) and\n  size = getBufferSize(access, _)\n}\n\nclass BufferAccess extends ArrayExpr {\n  BufferAccess() {\n    exists(int size |\n      staticBuffer(this.getArrayBase(), _, size) and\n      size != 0\n    ) and\n    // exclude accesses in macro implementation of `strcmp`,\n    // which are carefully controlled but can look dangerous.\n    not exists(Macro m |\n      m.getName() = \"strcmp\" and\n      m.getAnInvocation().getAnExpandedElement() = this\n    ) and\n    //A buffer access must be reachable (not in dead code)\n    reachable(this)\n  }\n\n  int bufferSize() { staticBuffer(this.getArrayBase(), _, result) }\n\n  Variable buffer() { result.getAnAccess() = this.getArrayBase() }\n}\n\npredicate overflowOffsetInLoop(BufferAccess bufaccess, string msg) {\n  exists(ClassicForLoop loop |\n    loop.getStmt().getAChild*() = bufaccess.getEnclosingStmt() and\n    loop.limit() >= bufaccess.bufferSize() and\n    loop.counter().getAnAccess() = bufaccess.getArrayOffset() and\n    // Ensure that we don't have an upper bound on the array index that's less than the buffer size.\n    not upperBound(bufaccess.getArrayOffset().getFullyConverted()) < bufaccess.bufferSize() and\n    // The upper bounds analysis must not have been widended\n    not upperBoundMayBeWidened(bufaccess.getArrayOffset().getFullyConverted()) and\n    msg =\n      \"Potential buffer-overflow: counter '\" + loop.counter().toString() + \"' <= \" +\n        loop.limit().toString() + \" but '\" + bufaccess.buffer().getName() + \"' has \" +\n        bufaccess.bufferSize().toString() + \" elements.\"\n  )\n}\n\npredicate bufferAndSizeFunction(Function f, int buf, int size) {\n  f.hasGlobalName(\"read\") and buf = 1 and size = 2\n  or\n  f.hasGlobalOrStdName(\"fgets\") and buf = 0 and size = 1\n  or\n  f.hasGlobalOrStdName(\"strncpy\") and buf = 0 and size = 2\n  or\n  f.hasGlobalOrStdName(\"strncat\") and buf = 0 and size = 2\n  or\n  f.hasGlobalOrStdName(\"memcpy\") and buf = 0 and size = 2\n  or\n  f.hasGlobalOrStdName(\"memmove\") and buf = 0 and size = 2\n  or\n  f.hasGlobalOrStdName(\"snprintf\") and buf = 0 and size = 1\n  or\n  f.hasGlobalOrStdName(\"vsnprintf\") and buf = 0 and size = 1\n}\n\nclass CallWithBufferSize extends FunctionCall {\n  CallWithBufferSize() { bufferAndSizeFunction(this.getTarget(), _, _) }\n\n  Expr buffer() {\n    exists(int i |\n      bufferAndSizeFunction(this.getTarget(), i, _) and\n      result = this.getArgument(i)\n    )\n  }\n\n  Expr statedSizeExpr() {\n    exists(int i |\n      bufferAndSizeFunction(this.getTarget(), _, i) and\n      result = this.getArgument(i)\n    )\n  }\n\n  int statedSizeValue() {\n    // `upperBound(e)` defaults to `exprMaxVal(e)` when `e` isn't analyzable. So to get a meaningful\n    // result in this case we pick the minimum value obtainable from dataflow and range analysis.\n    result =\n      upperBound(this.statedSizeExpr())\n          .minimum(min(Expr statedSizeSrc |\n              DataFlow::localExprFlow(statedSizeSrc, this.statedSizeExpr())\n            |\n              statedSizeSrc.getValue().toInt()\n            ))\n  }\n}\n\npredicate wrongBufferSize(Expr error, string msg) {\n  exists(CallWithBufferSize call, int bufsize, Variable buf, int statedSize |\n    staticBuffer(call.buffer(), buf, bufsize) and\n    statedSize = call.statedSizeValue() and\n    statedSize > bufsize and\n    error = call.statedSizeExpr() and\n    msg =\n      \"Potential buffer-overflow: '\" + buf.getName() + \"' has size \" + bufsize.toString() + \" not \" +\n        statedSize + \".\"\n  )\n}\n\npredicate outOfBounds(BufferAccess bufaccess, string msg) {\n  exists(int size, int access, string buf |\n    buf = bufaccess.buffer().getName() and\n    bufaccess.bufferSize() = size and\n    bufaccess.getArrayOffset().getValue().toInt() = access and\n    (\n      access > size\n      or\n      access = size and\n      not exists(AddressOfExpr addof | bufaccess = addof.getOperand()) and\n      not exists(BuiltInOperationBuiltInOffsetOf offsetof | offsetof.getAChild() = bufaccess)\n    ) and\n    msg =\n      \"Potential buffer-overflow: '\" + buf + \"' has size \" + size.toString() + \" but '\" + buf + \"[\" +\n        access.toString() + \"]' may be accessed here.\"\n  )\n}\n\nfrom Element error, string msg\nwhere\n  (\n    overflowOffsetInLoop(error, msg) or\n    wrongBufferSize(error, msg) or\n    outOfBounds(error, msg)\n  ) and\n  not error.getFile() instanceof ConfigurationTestFile // elements in files generated during configuration are likely false positives\nselect error, msg",
        "description": "Exceeding the size of a static array during write or access operations may result in a buffer overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/OverflowStatic.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.new.DataFlow\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.security.flowafterfree.FlowAfterFree\nimport semmle.code.cpp.security.flowafterfree.UseAfterFree\nimport UseAfterFreeTrace::PathGraph\n\nmodule UseAfterFreeParam implements FlowFromFreeParamSig {\n  predicate isSink = isUse/2;\n\n  predicate isExcluded = isExcludedMmFreePageFromMdl/2;\n\n  predicate sourceSinkIsRelated = defaultSourceSinkIsRelated/2;\n}\n\nimport UseAfterFreeParam\n\nmodule UseAfterFreeTrace = FlowFromFree<UseAfterFreeParam>;\n\nfrom UseAfterFreeTrace::PathNode source, UseAfterFreeTrace::PathNode sink, DeallocationExpr dealloc\nwhere\n  UseAfterFreeTrace::flowPath(source, sink) and\n  isFree(source.getNode(), _, _, dealloc)\nselect sink.getNode(), source, sink, \"Memory may have been previously freed by $@.\", dealloc,\n  dealloc.toString()",
        "description": "An allocated memory block is used after it has been freed. Behavior in such cases is undefined and can cause memory corruption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/UseAfterFree.ql",
        "language": "cpp"
    },
    {
        "query": "import NewDelete\n\nfrom Expr alloc, Expr free, Expr freed\nwhere\n  allocReaches(freed, alloc, \"new[]\") and\n  freeExprOrIndirect(free, freed, \"delete\")\nselect free, \"This memory may have been allocated with $@, not 'new'.\", alloc, \"new[]\"",
        "description": "An array allocated with 'new[]' is being freed using 'delete'. Behavior in such cases is undefined and should be avoided. Use 'delete[]' when freeing arrays allocated with 'new[]'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/NewArrayDeleteMismatch.ql",
        "language": "cpp"
    },
    {
        "query": "import NewDelete\n\nfrom Expr alloc, Expr free, Expr freed\nwhere\n  allocReaches(freed, alloc, \"new\") and\n  freeExprOrIndirect(free, freed, \"delete[]\")\nselect free, \"This memory may have been allocated with $@, not 'new[]'.\", alloc, \"new\"",
        "description": "An object that was allocated with 'new' is being freed using 'delete[]'. Behavior in such cases is undefined and should be avoided. Use 'delete' instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/NewDeleteArrayMismatch.ql",
        "language": "cpp"
    },
    {
        "query": "import NewDelete\n\npredicate correspondingKinds(string allocKind, string freeKind) {\n  allocKind = \"malloc\" and\n  freeKind = \"free\"\n  or\n  allocKind = \"new\" and\n  freeKind = \"delete\"\n}\n\nfrom\n  Expr alloc, string allocKind, string allocKindSimple, Expr free, Expr freed, string freeKind,\n  string freeKindSimple\nwhere\n  allocReaches(freed, alloc, allocKind) and\n  freeExprOrIndirect(free, freed, freeKind) and\n  allocKindSimple = allocKind.replaceAll(\"[]\", \"\") and\n  freeKindSimple = freeKind.replaceAll(\"[]\", \"\") and\n  not correspondingKinds(allocKindSimple, freeKindSimple)\nselect free,\n  \"There is a \" + allocKindSimple + \"/\" + freeKindSimple + \" mismatch between this \" + freeKind +\n    \" and the corresponding $@.\", alloc, allocKind",
        "description": "An object that was allocated with 'malloc' or 'new' is being freed using a mismatching 'free' or 'delete'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/NewFreeMismatch.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.pointsto.CallGraph\n\npredicate initFunc(GlobalVariable v, Function f) {\n  exists(VariableAccess access |\n    v.getAnAccess() = access and\n    access.isUsedAsLValue() and\n    access.getEnclosingFunction() = f\n  )\n}\n\npredicate dominatingInitInFunc(GlobalVariable v, Function f, ControlFlowNode node) {\n  exists(VariableAccess initAccess |\n    v.getAnAccess() = initAccess and\n    initAccess.isUsedAsLValue() and\n    initAccess.getEnclosingFunction() = f and\n    dominates(initAccess, node)\n  )\n}\n\npredicate safeAccess(VariableAccess access) {\n  // it is safe if the variable access is part of a `sizeof` expression\n  exists(SizeofExprOperator e | e.getAChild*() = access)\n}\n\npredicate useFunc(GlobalVariable v, Function f) {\n  exists(VariableAccess access |\n    v.getAnAccess() = access and\n    access.isRValue() and\n    access.getEnclosingFunction() = f and\n    not safeAccess(access) and\n    not dominatingInitInFunc(v, f, access)\n  )\n}\n\npredicate uninitialisedBefore(GlobalVariable v, Function f) {\n  f.hasGlobalName(\"main\") and\n  not initialisedAtDeclaration(v) and\n  not isStdlibVariable(v)\n  or\n  exists(Call call, Function g |\n    uninitialisedBefore(v, g) and\n    call.getEnclosingFunction() = g and\n    (not functionInitialises(g, v) or locallyUninitialisedAt(v, call)) and\n    resolvedCall(call, f)\n  )\n}\n\npredicate functionInitialises(Function f, GlobalVariable v) {\n  initFunc(v, f)\n  or\n  exists(Call call |\n    call.getEnclosingFunction() = f and\n    initialisedBy(v, call)\n  )\n}\n\n// this predicate is restricted to global variables used in the\n// same function as \"call\"\npredicate locallyUninitialisedAt(GlobalVariable v, Call call) {\n  functionInitialises(call.getEnclosingFunction(), v) and\n  (\n    firstCall(call)\n    or\n    exists(Call mid |\n      locallyUninitialisedAt(v, mid) and not initialisedBy(v, mid) and callPair(mid, call)\n    )\n  ) and\n  not dominatingInitInFunc(v, call.getEnclosingFunction(), call)\n}\n\npredicate initialisedBy(GlobalVariable v, Call call) {\n  exists(Function f |\n    resolvedCall(call, f) and\n    initialises(v, f)\n  )\n}\n\npredicate initialises(GlobalVariable v, Function f) {\n  initFunc(v, f)\n  or\n  exists(Function mid | initialises(v, mid) and allCalls(f, mid))\n}\n\npredicate firstCall(Call call) { beforeCall(call) }\n\npredicate beforeCall(ControlFlowNode node) {\n  exists(Function f | f.getBlock() = node)\n  or\n  exists(ControlFlowNode mid |\n    beforeCall(mid) and\n    not mid instanceof Call and\n    node = mid.getASuccessor()\n  )\n}\n\npredicate callPair(Call call, Call successor) { callReaches(call, successor) }\n\npredicate callReaches(Call call, ControlFlowNode successor) {\n  call.getASuccessor() = successor\n  or\n  exists(ControlFlowNode mid |\n    callReaches(call, mid) and\n    not mid instanceof Call and\n    mid.getASuccessor() = successor\n  )\n}\n\npredicate initialisedAtDeclaration(GlobalVariable v) { exists(v.getInitializer()) }\n\npredicate isStdlibVariable(GlobalVariable v) { v.hasGlobalName([\"stdin\", \"stdout\", \"stderr\"]) }\n\nfrom GlobalVariable v, Function f\nwhere\n  uninitialisedBefore(v, f) and\n  useFunc(v, f)\nselect f, \"The variable $@ is used in this function but may not be initialized when it is called.\",\n  v, v.getName()",
        "description": "Using an uninitialized variable may lead to undefined results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/GlobalUseBeforeInit.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Exclusions\n\nStmt getNextRealStmt(BlockStmt b, int i) {\n  result = b.getStmt(i + 1) and\n  not result instanceof EmptyStmt\n  or\n  b.getStmt(i + 1) instanceof EmptyStmt and\n  result = getNextRealStmt(b, i + 1)\n}\n\nfrom JumpStmt js, BlockStmt b, int i, Stmt s\nwhere\n  b.getStmt(i) = js and\n  s = getNextRealStmt(b, i) and\n  // the next statement isn't jumped to\n  not s instanceof LabelStmt and\n  not s instanceof SwitchCase and\n  // the next statement isn't breaking out of a switch\n  not s.(BreakStmt).getBreakable() instanceof SwitchStmt and\n  // the next statement isn't a loop that can be jumped into\n  not s.(Loop).getStmt().getAChild*() instanceof LabelStmt and\n  not s.(Loop).getStmt().getAChild*() instanceof SwitchCase and\n  // no preprocessor logic applies\n  not functionContainsPreprocCode(js.getEnclosingFunction())\nselect js, \"This statement makes $@ unreachable.\", s, s.toString()",
        "description": "A goto or break statement is followed by unreachable code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/DeadCodeGoto.ql",
        "language": "cpp"
    },
    {
        "query": "import FileClosed\n\nfrom Expr alloc\nwhere fopenCall(alloc) and not fopenCallMayBeClosed(alloc)\nselect alloc, \"The file is never closed.\"",
        "description": "A function always returns before closing a file that was opened in the function. Closing resources in the same function that opened them ties the lifetime of the resource to that of the function call, making it easier to avoid and detect resource leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/FileNeverClosed.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Negativity\n\nclass IntegralReturnValue extends FunctionCall {\n  IntegralReturnValue() { this.getType().getUnderlyingType() instanceof IntegralType }\n\n  predicate isChecked() {\n    exists(ControlFlowNode def, ControlFlowNode test, Variable v |\n      exprDefinition(v, def, this) and\n      definitionReaches(def, test) and\n      errorSuccessor(v, test.getASuccessor())\n    )\n  }\n}\n\nclass FunctionWithNegativeReturn extends Function {\n  FunctionWithNegativeReturn() {\n    this.getType().getUnderlyingType() instanceof IntegralType and\n    (\n      exists(ReturnStmt ret |\n        ret.getExpr().getValue().toInt() < 0 and\n        ret.getEnclosingFunction() = this\n      )\n      or\n      count(IntegralReturnValue val | val.getTarget() = this and val.isChecked()) * 100 /\n        count(IntegralReturnValue val | val.getTarget() = this) >= 80\n    )\n  }\n}\n\npredicate dangerousUse(IntegralReturnValue val, Expr use) {\n  exists(ArrayExpr ae | ae.getArrayOffset() = val and use = val)\n  or\n  exists(StackVariable v, ControlFlowNode def, ArrayExpr ae |\n    exprDefinition(v, def, val) and\n    use = ae.getArrayOffset() and\n    not boundsChecked(v, use) and\n    definitionUsePair(v, def, use)\n  )\n  or\n  use.getParent().(AddExpr).getAnOperand() = val and\n  val = use and\n  use.getType().getUnderlyingType() instanceof PointerType\n  or\n  exists(StackVariable v, ControlFlowNode def, AddExpr add |\n    exprDefinition(v, def, val) and\n    definitionUsePair(v, def, use) and\n    add.getAnOperand() = use and\n    not boundsChecked(v, use) and\n    add.getType().getUnderlyingType() instanceof PointerType\n  )\n}\n\nfrom FunctionWithNegativeReturn f, IntegralReturnValue val, Expr dangerous\nwhere\n  val.getTarget() = f and\n  dangerousUse(val, dangerous)\nselect dangerous,\n  \"Dangerous use of possibly negative value (return value of '\" + f.getName() + \"').\"",
        "description": "Using a return value as a pointer offset without checking that the value is positive may lead to buffer overruns.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/MissingNegativityTest.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate unused(Expr e) { e instanceof ExprInVoidContext }\n\npredicate important(Function f, string message) {\n  message = \"the result of this function must always be checked.\" and\n  getOptions().alwaysCheckReturnValue(f)\n}\n\n// statistically dubious ignored return values\npredicate dubious(Function f, string message) {\n  not important(f, _) and\n  exists(Options opts, int used, int total, int percentage |\n    used =\n      count(FunctionCall fc |\n        fc.getTarget() = f and not opts.okToIgnoreReturnValue(fc) and not unused(fc)\n      ) and\n    total = count(FunctionCall fc | fc.getTarget() = f and not opts.okToIgnoreReturnValue(fc)) and\n    used != total and\n    percentage = used * 100 / total and\n    percentage >= 90 and\n    message = percentage.toString() + \"% of calls to this function have their result used.\"\n  )\n}\n\nfrom FunctionCall unused, string message\nwhere\n  unused(unused) and\n  not exists(Options opts | opts.okToIgnoreReturnValue(unused)) and\n  (important(unused.getTarget(), message) or dubious(unused.getTarget(), message)) and\n  not unused.getTarget().getName().matches(\"operator%\") // exclude user defined operators\nselect unused, \"Result of call to \" + unused.getTarget().getName() + \" is ignored; \" + message",
        "description": "A call to a function ignores its return value, but at least 90% of the total number of calls to the function check the return value. Check the return value of functions consistently, especially for functions like 'fread' or the 'scanf' functions that return the status of the operation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Critical/ReturnValueIgnored.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.headers.MultipleInclusion\n\n\nfrom HeaderFile hf, PreprocessorDirective ifndef, string macroName, int num\nwhere\n  hasIncludeGuard(hf, ifndef, _, macroName) and\n  exists(HeaderFile other |\n    hasIncludeGuard(other, _, _, macroName) and hf.getShortName() != other.getShortName()\n  ) and\n  num = strictcount(HeaderFile other | hasIncludeGuard(other, _, _, macroName)) and\n  correctIncludeGuard(_, _, _, _, macroName)\nselect ifndef,\n  \"The macro name '\" + macroName + \"' of this include guard is used in \" + num +\n    \" different header files.\"",
        "description": "Using the same include guard macro in more than one header file may cause unexpected behavior from the compiler.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Header Cleanup/Cleanup-DuplicateIncludeGuard.ql",
        "language": "cpp"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string noflow\nwhere noflow = captureNeutral(api)\nselect noflow order by noflow",
        "description": "Finds neutral models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/utils/modelgenerator/CaptureNeutralModels.ql",
        "language": "cpp"
    },
    {
        "query": "import internal.CaptureModels\nimport SinkModels\n\nfrom DataFlowSinkTargetApi api, string sink\nwhere sink = Heuristic::captureSink(api)\nselect sink order by sink",
        "description": "Finds public methods that act as sinks as they flow into a known sink.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/utils/modelgenerator/CaptureSinkModels.ql",
        "language": "cpp"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = ContentSensitive::captureFlow(api, _, _, _, _)\nselect flow order by flow",
        "description": "Finds applicable content based summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/utils/modelgenerator/CaptureContentSummaryModels.ql",
        "language": "cpp"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = captureFlow(api, _)\nselect flow order by flow",
        "description": "Finds applicable summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/utils/modelgenerator/CaptureSummaryModels.ql",
        "language": "cpp"
    },
    {
        "query": "import internal.CaptureModels\nimport SourceModels\n\nfrom DataFlowSourceTargetApi api, string source\nwhere source = Heuristic::captureSource(api)\nselect source order by source",
        "description": "Finds APIs that act as sources as they expose already known sources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/utils/modelgenerator/CaptureSourceModels.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.04 Environment/AV Rule 9.ql\"\nselect d, d.getMessage()",
        "description": "Only those characters specified in the C++ basic source character set will be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.04 Environment/AV Rule 9.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Literal l\nwhere\n  l.getType() instanceof Wchar_t or\n  l.getType().(ArrayType).getBaseType().getUnspecifiedType() instanceof Wchar_t\nselect l, \"AV Rule 13: Multi-byte characters and wide string literals will not be used.\"",
        "description": "Multi-byte characters and wide string literals will not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.04 Environment/AV Rule 13.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.04 Environment/AV Rule 12.ql\"\nselect d, d.getMessage()",
        "description": "Digraphs will not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.04 Environment/AV Rule 12.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.04 Environment/AV Rule 11.ql\"\nselect d, d.getMessage()",
        "description": "Trigraphs will not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.04 Environment/AV Rule 11.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Literal l\nwhere\n  l.fromSource() and\n  l.getValueText().regexpMatch(\".*[ul][uUlL]*\\\\s*\")\nselect l, \"AV Rule 14: Literal suffixes shall use uppercase rather than lowercase letters.\"",
        "description": "Literal suffixes shall use uppercase rather than lowercase letters.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.04 Environment/AV Rule 14.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere\n  f.fromSource() and\n  f.calls+(f)\nselect f, \"Functions shall not call themselves, either directly or indirectly.\"",
        "description": "Functions shall not call themselves, either directly or indirectly (i.e. recursion shall not be allowed).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 119.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere f.fromSource() and f.hasSpecifier(\"varargs\")\nselect f, \"AV Rule 108: Functions with variable number of arguments shall not be used.\"",
        "description": "Functions with variable number of arguments shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 108.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom DeclStmt ds\nwhere\n  ds.getADeclaration() instanceof Function and\n  not ds.isInMacroExpansion() and\n  not exists(MacroInvocation mi | mi.getLocation() = ds.getADeclarationEntry().getLocation())\nselect ds, \"Functions should be declared at file scope, not inside blocks.\"",
        "description": "Functions should always be declared at file scope. It is confusing to declare a function at block scope, and the visibility of the function is not what would be expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 107.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f, Stmt s1, Stmt s2\nwhere\n  s1 = f.getAPredecessor().getEnclosingStmt() and\n  s2 = f.getAPredecessor().getEnclosingStmt() and\n  s1 != s2\nselect f, \"AV Rule 113: Functions will have a single exit point.\"",
        "description": "Functions will have a single exit point.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 113.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.pointsto.PointsTo\n\nclass ReturnPointsToExpr extends PointsToExpr {\n  override predicate interesting() {\n    exists(ReturnStmt ret | ret.getExpr() = this) and\n    pointerValue(this)\n  }\n\n  ReturnStmt getReturnStmt() { result.getExpr() = this }\n}\n\nfrom ReturnPointsToExpr ret, StackVariable dest\nwhere\n  ret.pointsTo() = dest and\n  ret.getReturnStmt().getParentStmt().getEnclosingFunction() = dest.getFunction()\nselect ret.getReturnStmt(),\n  \"AV Rule 111: A function shall not return a pointer or reference to a non-static local object.\"",
        "description": "A function must not return a pointer or reference to a non-static local object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 111.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// a return statement that looks like it returns an error code\n// we use an extremely simple approximation: any return statement that returns\n// a literal or a symbolic constant is considered to return an error code; we\n// make an exception for integral constant zero, which often indicates success\n// (unlike, of course, the null pointer)\nclass ErrorReturn extends ReturnStmt {\n  ErrorReturn() {\n    exists(Expr e |\n      e = super.getExpr() and\n      (\n        e instanceof Literal or\n        e.(VariableAccess).getTarget().isConst()\n      ) and\n      not (e.getValue() = \"0\" and e.getActualType() instanceof IntegralType)\n    )\n  }\n}\n\n// a function that has both a return statement returning an error code, and one that doesn't\nclass FunctionReturningErrorCode extends Function {\n  FunctionReturningErrorCode() {\n    exists(ErrorReturn er, ReturnStmt nr |\n      er.getEnclosingFunction() = this and\n      nr.getEnclosingFunction() = this and\n      not nr instanceof ErrorReturn\n    )\n  }\n}\n\nfrom FunctionReturningErrorCode frec, Call c\nwhere\n  c = frec.getACallToThisFunction() and\n  c instanceof ExprInVoidContext\nselect c, \"AV Rule 115: If a function returns error information, it will be tested.\"",
        "description": "If a function returns error information, then that information will be tested.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 115.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate functionsMissingReturnStmt(Function f, ControlFlowNode blame) {\n  f.fromSource() and\n  exists(Type returnType |\n    returnType = f.getUnspecifiedType() and\n    not returnType instanceof VoidType and\n    not returnType instanceof TypeTemplateParameter\n  ) and\n  exists(ReturnStmt s |\n    f.getAPredecessor() = s and\n    (\n      blame = s.getAPredecessor() and\n      count(blame.getASuccessor()) = 1\n      or\n      blame = s and\n      exists(ControlFlowNode pred | pred = s.getAPredecessor() | count(pred.getASuccessor()) != 1)\n    )\n  )\n}\n\npredicate functionImperfectlyExtracted(Function f) {\n  exists(CompilerError e | f.getBlock().getLocation().subsumes(e.getLocation()))\n  or\n  f.hasErrors()\n  or\n  count(f.getType()) > 1\n  or\n  // an `AsmStmt` isn't strictly 'imperfectly extracted', but it's beyond the scope\n  // of this analysis.\n  exists(AsmStmt asm | asm.getEnclosingFunction() = f)\n}\n\nfrom Stmt stmt, string msg, Function f, ControlFlowNode blame\nwhere\n  functionsMissingReturnStmt(f, blame) and\n  reachable(blame) and\n  not functionImperfectlyExtracted(f) and\n  not f.isFromUninstantiatedTemplate(_) and\n  (blame = stmt or blame.(Expr).getEnclosingStmt() = stmt) and\n  msg =\n    \"Function \" + f.getName() + \" should return a value of type \" + f.getType().getName() +\n      \" but does not return a value here\"\nselect stmt, msg",
        "description": "All functions that are not void should return a value on every exit path.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 114.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere\n  f.getNumberOfParameters() > 7 and\n  f.fromSource()\nselect f, \"AV Rule 110: Functions with more than 7 arguments will not be used.\"",
        "description": "Functions with more than 7 arguments will not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.13 Functions/AV Rule 110.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate relevant(Declaration d) {\n  d instanceof UserType or\n  d.(Function).hasSpecifier(\"inline\")\n}\n\npredicate hasTwoDefinitions(Declaration d) {\n  exists(Location l1, Location l2 |\n    l1 = d.getDefinitionLocation() and\n    l2 = d.getDefinitionLocation() and\n    l1 != l2\n  )\n}\n\npredicate definedInImplementationFile(Declaration d) {\n  d.getDefinitionLocation().getFile() instanceof CppFile or\n  d.getDefinitionLocation().getFile() instanceof CFile\n}\n\nfrom Declaration d, string message\nwhere\n  relevant(d) and\n  (\n    hasTwoDefinitions(d) and message = \" should not have several definitions.\"\n    or\n    definedInImplementationFile(d) and message = \" should be defined in a header file.\"\n  ) and\n  // Don't count member functions - the only way they can match this rule is by\n  // being in a class definition that already matches, so it would be redundant\n  not d instanceof MemberFunction\nselect d.getDefinitionLocation(), \"AV Rule 40: \" + d.getName() + message",
        "description": "Every implementation file shall include the header files that uniquely define the inline functions, types, and templates used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.08 Implementation Files/AV Rule 40.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate allowed(TypeDeclarationEntry tde, FunctionPointerType t) {\n  tde.getDeclaration().(TypedefType).getBaseType() = t\n}\n\nfrom FunctionPointerType t, Locatable l\nwhere\n  t.getATypeNameUse() = l and\n  not allowed(l, t)\nselect l, \"AV Rule 176: A typedef will be used when declaring function pointers.\"",
        "description": "A typedef will be used to simplify program syntax when declaring function pointers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.22 Pointers and References/AV Rule 176.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom Assignment a, Variable global, Variable local\nwhere\n  a.fromSource() and\n  global.getAnAccess() = a.getLValue() and\n  local.getAnAccess() = a.getRValue().(AddressOfExpr).getOperand() and\n  local.hasSpecifier(\"auto\") and\n  (\n    not global instanceof LocalVariable or\n    global.getParentScope() = local.getParentScope().getParentScope+() or\n    global.hasSpecifier(\"static\")\n  )\nselect a,\n  \"AV Rule 173: The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist.\"",
        "description": "The address of an object with automatic storage shall not be assigned to an object which persists after the object has ceased to exist.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.22 Pointers and References/AV Rule 173.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PointerType t, Element e\nwhere\n  t.getPointerIndirectionLevel() > 2 and\n  t.getATypeNameUse() = e\nselect e, \"AV Rule 170: More than two levels of pointer indirection shall not be used.\"",
        "description": "More than two levels of pointer indirection shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.22 Pointers and References/AV Rule 170.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.pointsto.PointsTo\n\nclass PointerInComparison extends PointsToExpr {\n  override predicate interesting() {\n    exists(ComparisonOperation comp | comp.getAChild() = this) and\n    pointerValue(this)\n  }\n\n  ComparisonOperation getComparison() { result.getAChild() = this }\n}\n\npredicate mayBeCompared(PointerInComparison p, PointerInComparison q) {\n  p.getUnderlyingType() = q.getUnderlyingType() and\n  p.pointsTo() = q.pointsTo()\n  or\n  // TODO: should handle null pointers (p and q can only be compared if either both or none can be null)\n  // for now, just allow comparisons with null\n  p.getValue() = \"0\"\n  or\n  q.getValue() = \"0\"\n}\n\nfrom PointerInComparison p, PointerInComparison q\nwhere\n  p.getComparison() = q.getComparison() and\n  not mayBeCompared(p, q)\nselect p.getComparison(),\n  \"AV Rule 171: Relational operators shall not be applied to pointer types except in very specific circumstances.\"",
        "description": "Relational operations shall not be applied to pointer types except where both operands are of the same type and point to or into the same object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.22 Pointers and References/AV Rule 171.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom NULL null\nwhere\n  exists(Assignment a | null = a.getRValue()) or\n  exists(ComparisonOperation op | null = op.getAnOperand())\nselect null, \"A pointer shall not be compared to NULL or be assigned NULL; use plain 0 instead.\"",
        "description": "A pointer shall not be compared to NULL or be assigned NULL; use plain 0 instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.22 Pointers and References/AV Rule 175.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nclass PointerOrArrayType extends DerivedType {\n  PointerOrArrayType() { this instanceof PointerType or this instanceof ArrayType }\n}\n\n// cast from pointer to integral type to pointer to a different integral type\nclass ExposingIntegralCastExpr extends Expr {\n  ExposingIntegralCastExpr() {\n    exists(\n      PointerOrArrayType src, PointerOrArrayType dst, IntegralType srcbase, IntegralType dstbase\n    |\n      src = this.getUnderlyingType() and\n      srcbase = src.getBaseType().getUnderlyingType() and\n      dst = this.getActualType() and\n      dstbase = dst.getBaseType().getUnderlyingType() and\n      srcbase != dstbase\n    )\n  }\n}\n\nclass ExposingIntegralUnion extends Union {\n  ExposingIntegralUnion() {\n    exists(MemberVariable mv1, MemberVariable mv2, IntegralType mv1tp, IntegralType mv2tp |\n      mv1 = this.getAMemberVariable() and\n      mv2 = this.getAMemberVariable() and\n      mv1tp = mv1.getUnderlyingType() and\n      (\n        mv2tp = mv2.getUnderlyingType()\n        or\n        mv2tp = mv2.getUnderlyingType().(ArrayType).getBaseType().getUnderlyingType()\n      ) and\n      mv1tp.getSize() > mv2tp.getSize()\n    )\n  }\n}\n\nfrom Element e, string message\nwhere\n  e instanceof ExposingIntegralCastExpr and\n  message = \"AV Rule 210: This cast makes assumptions concerning data representation in memory.\"\n  or\n  e instanceof ExposingIntegralUnion and\n  message = \"AV Rule 210: This union may make assumptions concerning data representation in memory.\"\nselect e, message",
        "description": "Algorithms shall not make assumptions concerning how data is represented in memory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.28 Portable Code/AV Rule 210.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// whether e is part of an initializer of a global variable in file f\npredicate inGlobalInitializer(Expr e, File f) {\n  exists(GlobalVariable gv |\n    gv.getInitializer().getExpr() = e.getParent*() and\n    f = gv.getFile()\n  )\n}\n\n// whether c is called from within a global initializer in f\n// TODO: this should be transitive, but maybe it's not worth the extra hassle\npredicate calledFromGlobalInitializer(Function fn, File f) {\n  exists(FunctionCall c | inGlobalInitializer(c, f) and fn = c.getTarget())\n}\n\npredicate evaluatedBeforeMain(Expr e, File f) {\n  inGlobalInitializer(e, f)\n  or\n  exists(Function fn | calledFromGlobalInitializer(fn, f) and fn = e.getControlFlowScope())\n}\n\n// whether f1 and f2 belong to the same translation unit\npredicate sameTranslationUnit(File f1, File f2) {\n  exists(File f | f.getAnIncludedFile*() = f1 and f.getAnIncludedFile*() = f2)\n}\n\nfrom VariableAccess v, File f1, File f2\nwhere\n  v.fromSource() and\n  v.isRValue() and\n  evaluatedBeforeMain(v, f1) and\n  v.getTarget().getFile() = f2 and\n  not sameTranslationUnit(f1, f2)\nselect v,\n  \"AV Rule 214: It shall not be assumed that objects in separated translation units are initialized in a special order.\"",
        "description": "Assuming that non-local static objects, in separate translation units, are initialized in a special order shall not be done.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.28 Portable Code/AV Rule 214.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PointerArithmeticOperation pao\nwhere pao.fromSource()\nselect pao, \"AV Rule 215: Pointer arithmetic will not be used.\"",
        "description": "Pointer arithmetic will not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.28 Portable Code/AV Rule 215.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate isNonNegative(Expr e) {\n  e.getUnderlyingType().(IntegralType).isUnsigned() or\n  e.getValue().toInt() >= 0\n}\n\npredicate sameExpr(Expr e, Expr f) {\n  e.(VariableAccess).getTarget() = f.(VariableAccess).getTarget()\n  // adding the following disjunct OOMs on non-trivial databases\n  //or e.getValue() = f.getValue()\n}\n\nclass UnreliableOverflowTest extends LTExpr {\n  UnreliableOverflowTest() {\n    exists(AddExpr l, Expr a, Expr b, Expr r |\n      l = super.getLeftOperand() and\n      a = l.getLeftOperand() and\n      b = l.getRightOperand() and\n      r = super.getRightOperand() and\n      (\n        sameExpr(a, r) and isNonNegative(b)\n        or\n        sameExpr(b, r) and isNonNegative(a)\n      )\n    )\n  }\n}\n\nfrom UnreliableOverflowTest t\nselect t, \"AV Rule 212: Underflow or overflow functioning shall not be depended on.\"",
        "description": "Underflow or overflow functioning shall not be depended on in any special way.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.28 Portable Code/AV Rule 212.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate arithmeticPrecedence(int p) { p = 12 or p = 13 }\n\npredicate comparisonPrecedence(int p) { p = 9 or p = 10 }\n\nfrom Expr e1, Expr e2, int p1, int p2\nwhere\n  e1.getAChild() = e2 and\n  p1 = e1.getPrecedence() and\n  p2 = e2.getPrecedence() and\n  p1 < p2 and\n  not e2.isParenthesised() and\n  p1 <= 11 and\n  p2 <= 13 and // allow > arithmetic operators\n  not (arithmeticPrecedence(p2) and comparisonPrecedence(p1)) and // arith-compare deviation\n  not e2 = e1.(Assignment).getRValue() // assignment deviation\nselect e1, \"AV Rule 213: Limited dependence shall be placed on operator precedence rules.\"",
        "description": "No dependence shall be placed on C++'s operator precedence rules, below arithmetic operators, in expressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.28 Portable Code/AV Rule 213.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Element u, ArithmeticType at\nwhere\n  at.hasName([\"int\", \"short\", \"long\", \"float\", \"double\"]) and\n  u = at.getATypeNameUse() and\n  not at instanceof WideCharType\nselect u, \"AV Rule 209: The basic types of int, short, long, float and double shall not be used.\"",
        "description": "The basic types of int, short, long, float and double shall not be used, but specific-length equivalents should be typedef'd accordingly for each compiler, and these type names used in the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.28 Portable Code/AV Rule 209.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f, int c\nwhere\n  c = f.getMetrics().getCyclomaticComplexity() and\n  c > 20\nselect f, \"AV Rule 3: All functions shall have a cyclomatic complexity number of 20 or less.\"",
        "description": "All functions shall have a cyclomatic complexity number of 20 or less.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/3.02 Code Size and Complexity/AV Rule 3.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// We look for code that converts between function pointers and non-function, non-void\n// pointers. This will obviously not catch code that uses inline assembly to achieve\n// self-modification, nor will it spot the use of OS mechanisms to write into process\n// memory (such as WriteProcessMemory under Windows).\npredicate maybeSmcConversion(Type t1, Type t2) {\n  t1 instanceof FunctionPointerType and\n  t2 instanceof PointerType and\n  not t2 instanceof FunctionPointerType and\n  not t2 instanceof VoidPointerType\n  or\n  maybeSmcConversion(t2, t1)\n}\n\nfrom Expr e\nwhere\n  e.fromSource() and\n  maybeSmcConversion(e.getUnderlyingType(), e.getActualType())\nselect e, \"AV Rule 2: There shall not be any self-modifying code.\"",
        "description": "There shall not be any self-modifying code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/3.02 Code Size and Complexity/AV Rule 2.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f, int n\nwhere\n  n = f.getMetrics().getNumberOfLinesOfCode() and\n  n > 200\nselect f,\n  \"AV Rule 1: any one function (or method) will contain no more than 200 logical source lines of code. Function '\"\n    + f.toString() + \"' contains \" + n.toString() + \" lines of code.\"",
        "description": "Any one function (or method) will contain no more than 200 logical source lines of code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/3.02 Code Size and Complexity/AV Rule 1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate isNonSolitary(Declaration d) {\n  exists(DeclStmt ds, Variable v |\n    ds.fromSource() and\n    d = ds.getADeclaration() and\n    d instanceof Variable and\n    v = ds.getADeclaration() and\n    v != d\n  )\n  or\n  exists(GlobalVariable g |\n    g.fromSource() and\n    g.getLocation().getStartLine() = d.(GlobalVariable).getLocation().getStartLine() and\n    g.getLocation().getFile() = d.getLocation().getFile() and\n    g != d\n  )\n  or\n  exists(Field f |\n    f.fromSource() and\n    f.getLocation().getStartLine() = d.(Field).getLocation().getStartLine() and\n    f.getLocation().getFile() = d.getLocation().getFile() and\n    f != d\n  )\n}\n\nfrom Declaration d\nwhere isNonSolitary(d)\nselect d, \"AV Rule 152: Multiple variable declarations shall not be allowed on the same line.\"",
        "description": "Multiple variable declarations shall not be allowed on the same line.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.19 Variables/AV Rule 152.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Macro m\nwhere m.getHead().matches(\"%(%\") // Macro functions are simply macros with brackets in the head\nselect m, \"The #define pre-processor directive shall not be used to create inline macros.\"",
        "description": "The #define pre-processor directive shall not be used to create inline macros. Inline functions shall be used instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.06 Pre-Processing Directives/AV Rule 29.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.headers.MultipleInclusion\n\nfrom PreprocessorDirective directive\nwhere\n  (directive instanceof PreprocessorIfndef or directive instanceof PreprocessorEndif) and\n  not exists(CorrectIncludeGuard cig | directive = cig.getIfndef() or directive = cig.getEndif())\nselect directive,\n  \"AV Rule 28: the #ifndef and #endif directives will only be used as defined in AV Rule 27.\"",
        "description": "The #ifndef and #endif directives will only be used as defined in AV Rule 27 to prevent multiple inclusions of the same header file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.06 Pre-Processing Directives/AV Rule 28.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.headers.MultipleInclusion\n\nfrom BadIncludeGuard bad\nselect bad.blame(),\n  \"AV Rule 27: techniques other than #ifndef/#define/#endif will not be used to prevent multiple inclusions of header files.\"",
        "description": "The #ifndef, #define and #endif directives will be used to prevent multiple inclusions of the same header files. Other techniques to prevent multiple inclusion will not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.06 Pre-Processing Directives/AV Rule 27.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.AutogeneratedFile\n\nfrom Include i, File f, string extension\nwhere\n  f = i.getIncludedFile() and\n  extension = f.getExtension().toLowerCase() and\n  extension != \"def\" and\n  extension != \"inc\" and\n  extension != \"inl\" and\n  extension != \"tcc\" and\n  extension != \"tpp\" and\n  extension != \"txx\" and\n  extension != \"xpm\" and\n  not f instanceof AutogeneratedFile and\n  not f instanceof HeaderFile\nselect i, \"The #include pre-processor directive should only be used to include header files.\"",
        "description": "The #include pre-processor directive should only be used to include header files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.06 Pre-Processing Directives/AV Rule 32.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PreprocessorDirective directive\nwhere\n  not directive instanceof PreprocessorIfndef and\n  not directive instanceof PreprocessorEndif and\n  not directive instanceof Macro and\n  not directive instanceof Include\nselect directive,\n  \"AV Rule 26: only the #ifndef, #endif, #define and #include directives shall be used.\"",
        "description": "Only the #ifndef, #define, #endif and #include preprocessor directives shall be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.06 Pre-Processing Directives/AV Rule 26.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.headers.MultipleInclusion\n\nfrom Macro macro\nwhere not exists(CorrectIncludeGuard cig | macro = cig.getDefine())\nselect macro,\n  \"AV Rule 31: The #define directive will only be used as part of the technique to prevent multiple inclusions of the same header file.\"",
        "description": "The #define directive will only be used as part of the technique to prevent multiple inclusions of the same header file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.06 Pre-Processing Directives/AV Rule 31.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass ConstantDefMacro extends Macro {\n  ConstantDefMacro() {\n    // Exclude functions\n    not this.getHead().matches(\"%(%\") and\n    exists(string body |\n      body = this.getBody() and\n      // Empty defines are allowed (rule 31 restricts their use though)\n      body != \"\" and\n      // No special characters in the body\n      not body.matches(\"%(%\") and\n      not body.matches(\"%{%\")\n    )\n  }\n}\n\npredicate commonMacro(string name) {\n  name = \"NULL\" // TODO\n}\n\nfrom ConstantDefMacro m\nwhere\n  not commonMacro(m.getHead()) and\n  m.fromSource()\nselect m, \"The #define pre-processor directive shall not be used to define constant values.\"",
        "description": "The #define pre-processor directive shall not be used to define constant values. Instead, the const qualifier shall be applied to variable declarations to specify constant values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.06 Pre-Processing Directives/AV Rule 30.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass SideEffectVariableExpr extends VariableAccess {\n  SideEffectVariableExpr() {\n    exists(CrementOperation o | o.getOperand() = this) or\n    exists(AssignExpr e | e.getLValue() = this)\n  }\n}\n\npredicate characteristicSequencePointExpr(Expr e, Expr c) {\n  if\n    exists(Expr p |\n      p = e.getParent() and\n      not p instanceof BinaryLogicalOperation and\n      not p instanceof CommaExpr and\n      not p instanceof ConditionalExpr\n    )\n  then characteristicSequencePointExpr(e.getParent(), c)\n  else e = c\n}\n\nfrom SideEffectVariableExpr e, Expr c, Variable v, VariableAccess va\nwhere\n  e.getTarget() = v and\n  va.getTarget() = v and\n  characteristicSequencePointExpr(e, c) and\n  characteristicSequencePointExpr(va, c) and\n  va != e and\n  not e.getParent().(AssignExpr).getLValue() = e\nselect c,\n  \"AV Rule 204.1: The value of an expression shall be the same under any order of evaluation that the standard permits.\"",
        "description": "The value of an expression shall be the same under any order of evaluation that the standard permits. Except where noted, the order in which operators and subexpression are evaluated, as well as the order in which side effects take place, is unspecified.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.25 Expressions/AV Rule 204.1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// whether the main operation of e is pure (not considering its operands)\npredicate isPureOperation(Expr e) {\n  e instanceof Operation and\n  not e instanceof Assignment and\n  not e instanceof CrementOperation\n}\n\n// f is the smallest expression containing e composed entirely of\n// pure operators such that e is the only non-constant subexpression\n// e.g., in x = g(y) + 1, if e is g(y), then f is g(y) + 1\npredicate stripOffConstants(Expr e, Expr f) {\n  not isPureOperation(e.getParent()) and f = e\n  or\n  exists(Operation p |\n    p = e.getParent() and\n    isPureOperation(p) and\n    (\n      if forall(Expr g | g = p.getAChild() and e != g | g.isConstant())\n      then stripOffConstants(p, f)\n      else f = e\n    )\n  )\n}\n\n// whether e occurs by itself as a statement\npredicate occursByItself(Expr e) {\n  exists(ExprStmt s | e = s.getExpr()) or\n  exists(ForStmt s | s.getUpdate() = e)\n}\n\n// whether e is the source of an assignment or an initializer\npredicate isOnRightOfAssignment(Expr e) {\n  exists(Assignment a | a.getRValue() = e) or\n  exists(Initializer i | i.getExpr() = e)\n}\n\n// whether e is a loop condition, an if condition, or a switch expression\npredicate isControllingExpr(Expr e) { exists(ControlStructure c | c.getControllingExpr() = e) }\n\n// whether e is the only impure argument expression of a function call\npredicate isSoleNonConstFunArg(Expr e) {\n  exists(FunctionCall fc |\n    fc.getAnArgument() = e and\n    forall(Expr g | g = fc.getAnArgument() and g != e | g.isPure())\n  )\n}\n\n// whether e occurs as part of a chain of qualifiers\npredicate isPartOfChain(Expr e) { qualifies(e, _) or qualifies(_, e) }\n\n// whether q qualifies e\npredicate qualifies(Expr q, Expr e) {\n  q = e.(Call).getQualifier() or q = e.(VariableAccess).getQualifier()\n}\n\npredicate impureExprInDisallowedContext(Expr e) {\n  exists(Expr f |\n    e.fromSource() and\n    not e.isPure() and\n    stripOffConstants(e, f) and\n    not occursByItself(f) and\n    not isOnRightOfAssignment(f) and\n    not isControllingExpr(f) and\n    not isSoleNonConstFunArg(f) and\n    not isPartOfChain(f)\n  )\n}\n\nfrom Expr e\nwhere\n  impureExprInDisallowedContext(e) and\n  not e.isCompilerGenerated() and\n  // A few cases that are always ok\n  not e instanceof Conversion and\n  not exists(@ctorinit ci | e = mkElement(ci)) and\n  not exists(@dtordestruct dd | e = mkElement(dd)) and\n  // Avoid flagging nested expressions\n  not impureExprInDisallowedContext(e.getParent+())\nselect e.findRootCause(),\n  \"AV Rule 204: A single operation with side-effects shall only be used in certain contexts.\"",
        "description": "A single operation with side-effects shall only be used by itself, to the right of an assignment, in a condition, as the only argument with side-effects in a function call, as a loop condition, as a switch condition, or as a part of a chained operation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.25 Expressions/AV Rule 204.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// whether it is acceptable for s to be declared volatile\n// by default, we accept volatile specifiers on external global variables\npredicate acceptableVolatile(Variable v) {\n  v instanceof GlobalVariable and v.hasSpecifier(\"extern\")\n}\n\nfrom Variable v\nwhere\n  v.getType().hasSpecifier(\"volatile\") and\n  not acceptableVolatile(v)\nselect v,\n  \"AV Rule 205: The volatile keyword shall not be used unless directly interfacing with hardware.\"",
        "description": "The volatile keyword shall not be used unless directly interfacing with hardware.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.25 Expressions/AV Rule 205.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom EqualityOperation e\nwhere\n  e.fromSource() and\n  e.getAnOperand().getType() instanceof FloatingPointType\nselect e,\n  \"AV Rule 202: Floating point variables shall not be tested for exact equality or inequality.\"",
        "description": "Floating point variables shall not be tested for exact equality or inequality.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.25 Expressions/AV Rule 202.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// Pick a representative file for a namespace - more than a bit dodgy, but otherwise\n// the results don't show up anywhere which is less than helpful\npredicate namespaceRepresentative(Namespace ns, File rep) {\n  rep.getAbsolutePath() =\n    min(File f |\n      exists(Declaration d | d = ns.getADeclaration() | d.getFile() = f)\n    |\n      f.getAbsolutePath()\n    )\n}\n\nfrom Namespace ns, File rep\nwhere\n  exists(ns.getParentNamespace().getParentNamespace().getParentNamespace()) and\n  namespaceRepresentative(ns, rep)\nselect rep, \"AV Rule 99: namespace \" + ns.toString() + \" is nested more than two levels deep.\"",
        "description": "Namespaces will not be nested more than two levels deep",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.11 Namespaces/AV Rule 99.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass WarningLateTemplateSpecialization extends CompilerWarning {\n  WarningLateTemplateSpecialization() {\n    this.getTag() =\n      [\"partial_spec_after_instantiation\", \"partial_spec_after_instantiation_ambiguous\"]\n  }\n}\n\nfrom WarningLateTemplateSpecialization warning\nselect warning,\n  \"AV Rule 104: A template specialization shall be declared before its use; \" + warning.getMessage()\n    + \".\"",
        "description": "A template specialization shall be declared before its use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.12 Templates/AV Rule 104.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Include incl\nwhere incl.getIncludedFile().getAbsolutePath().matches(\"%locale.h\")\nselect incl, \"AV Rule 19: <locale.h> and the setlocale function shall not be used.\"",
        "description": "<locale.h> and the setlocale function shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 19.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Macro offsetof\nwhere\n  offsetof.getHead().matches(\"offsetof(%,%)\") and\n  offsetof.getFile().getAbsolutePath().matches(\"%stddef.h\")\nselect offsetof.getAnInvocation(),\n  \"AV Rule 18: The macro offsetof, in library <stddef.h>, shall not be used.\"",
        "description": "The macro offsetof, in library <stddef.h>, shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 18.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Locatable errno, Locatable use\nwhere\n  (\n    errno.(Macro).getHead() = \"errno\" and use = errno.(Macro).getAnInvocation()\n    or\n    errno.(Variable).hasName(\"errno\") and use = errno.(Variable).getAnAccess()\n  ) and\n  errno.getFile().getAbsolutePath().matches(\"%errno.h\")\nselect use, \"AV Rule 17: The error indicator errno shall not be used.\"",
        "description": "The error indicator errno shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 17.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere\n  f.getName() = [\"atof\", \"atoi\", \"atol\"] and\n  f.getFile().getAbsolutePath().matches(\"%stdlib.h\")\nselect f.getACallToThisFunction(),\n  \"AV Rule 23: The library functions atof, atoi and atol from library <stdlib.h> shall not be used.\"",
        "description": "The library functions atof, atoi and atol from library <stdlib.h> shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 23.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Include incl\nwhere incl.getIncludedFile().getAbsolutePath().matches(\"%stdio.h\")\nselect incl, \"AV Rule 22: The input/output library <stdio.h> shall not be used.\"",
        "description": "The input/output library <stdio.h> shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 22.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Include incl\nwhere incl.getIncludedFile().getAbsolutePath().matches(\"%signal.h\")\nselect incl, \"AV Rule 21: The signal handling facilities of <signal.h> shall not be used.\"",
        "description": "The signal handling facilities of <signal.h> shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 21.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Include incl\nwhere incl.getIncludedFile().getAbsolutePath().matches(\"%time.h\")\nselect incl, \"AV Rule 25: The time handling functions of library <time.h> shall not be used.\"",
        "description": "The time handling functions of library <time.h> shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 25.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere\n  f.getName() = [\"abort\", \"exit\", \"getenv\", \"system\"] and\n  f.getFile().getAbsolutePath().matches(\"%stdlib.h\")\nselect f.getACallToThisFunction(),\n  \"The library functions abort, exit, getenv and system from library <stdlib.h> should not be used.\"",
        "description": "The library functions abort, exit, getenv and system from library <stdlib.h> should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 24.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass Setjmp extends Macro {\n  Setjmp() {\n    super.getHead().matches(\"setjmp(%)\") and\n    super.getFile().getAbsolutePath().matches(\"%setjmp.h\")\n  }\n}\n\nclass Longjmp extends Function {\n  Longjmp() {\n    super.hasName(\"longjmp\") and\n    super.getNumberOfParameters() = 2 and\n    super.getFile().getAbsolutePath().matches(\"%setjmp.h\")\n  }\n}\n\nfrom Setjmp setjmp, Longjmp longjmp, Locatable use\nwhere\n  use = setjmp.getAnInvocation() or\n  use = longjmp.getACallToThisFunction()\nselect use, \"AV Rule 20: The setjmp macro and the longjmp function shall not be used.\"",
        "description": "The setjmp macro and the longjmp function shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.05 Libraries/AV Rule 20.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Element e\nwhere e instanceof TryStmt or e instanceof ThrowExpr\nselect e, \"AV Rule 208: C++ exceptions shall not be used.\"",
        "description": "C++ exceptions shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.27 Fault Handling/AV Rule 208.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate forbidden(Declaration d) {\n  d instanceof Variable and not d.(Variable).isConst()\n  or\n  d instanceof Function and not d.hasSpecifier(\"inline\")\n}\n\nfrom Declaration d\nwhere\n  d.getDefinitionLocation().getFile() instanceof HeaderFile and\n  forbidden(d)\nselect d.getDefinitionLocation(),\n  \"AV Rule 38: header files will not contain non-const variable definitions or function definitions.\"",
        "description": "Header files (*.h) will not contain non-const variable definitions or function definitions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.07 Header Files/AV Rule 39.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Include i\nwhere i.getIncludeText().matches(\"<%\")\nselect i, \"AV Rule 33: the #include <filename.h> notation shall be used.\"",
        "description": "The #include directive shall use the <filename.h> notation to include header files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.07 Header Files/AV Rule 33.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.headers.MultipleInclusion\n\nstring possibleGuard(HeaderFile hf, string body) {\n  exists(Macro m | m.getFile() = hf and m.getBody() = body | result = m.getHead())\n}\n\nnewtype TMaybePreprocessorDirective =\n  TSomePreprocessorDirective(PreprocessorDirective pd) or\n  TNoPreprocessorDirective()\n\nabstract class MaybePreprocessorDirective extends TMaybePreprocessorDirective {\n  abstract string toString();\n\n  abstract Location getLocation();\n}\n\nclass NoPreprocessorDirective extends TNoPreprocessorDirective, MaybePreprocessorDirective {\n  override string toString() { result = \"\" }\n\n  override Location getLocation() { result instanceof UnknownLocation }\n}\n\nclass SomePreprocessorDirective extends TSomePreprocessorDirective, MaybePreprocessorDirective {\n  PreprocessorDirective pd;\n\n  SomePreprocessorDirective() { this = TSomePreprocessorDirective(pd) }\n\n  override string toString() { result = pd.toString() }\n\n  override Location getLocation() { result = pd.getLocation() }\n\n  PreprocessorDirective getPreprocessorDirective() { result = pd }\n}\n\nstring extraDetail(\n  HeaderFile hf, SomePreprocessorDirective detail1, SomePreprocessorDirective detail2\n) {\n  exists(string s, PreprocessorEndif endif, PreprocessorDirective ifndef |\n    startsWithIfndef(hf, ifndef, s) and endif.getIf() = ifndef\n  |\n    detail1.getPreprocessorDirective() = endif and\n    detail2.getPreprocessorDirective() = ifndef and\n    if not endsWithEndif(hf, endif)\n    then result = \" ($@ matching $@ occurs before the end of the file).\"\n    else\n      if exists(Macro m | m.getFile() = hf and m.getHead() = s)\n      then result = \" (#define \" + s + \" needs to appear immediately after #ifndef \" + s + \").\"\n      else\n        if strictcount(possibleGuard(hf, _)) = 1\n        then\n          result =\n            \" (\" + possibleGuard(hf, _) + \" should appear in the #ifndef rather than \" + s + \").\"\n        else\n          if strictcount(possibleGuard(hf, \"\")) = 1\n          then\n            result =\n              \" (\" + possibleGuard(hf, \"\") + \" should appear in the #ifndef rather than \" + s + \").\"\n          else result = \" (the macro \" + s + \" is checked for, but is not defined).\"\n  )\n}\n\npredicate usesMacro(HeaderFile hf, string macroName) {\n  not hf instanceof IncludeGuardedHeader and // restrict to cases the query looks at\n  exists(MacroAccess ma |\n    ma.getFile() = hf and\n    ma.getMacro().getName() = macroName\n  )\n}\n\npredicate definesMacro(File f, string macroName) {\n  exists(Macro m |\n    m.getFile() = f and\n    m.getName() = macroName\n  )\n}\n\npredicate undefinesMacro(File f, string macroName) {\n  exists(PreprocessorUndef ud |\n    ud.getFile() = f and\n    ud.getName() = macroName\n  )\n}\n\npredicate defUndef(File f, string macroName) {\n  definesMacro(f, macroName) and\n  undefinesMacro(f, macroName)\n}\n\npredicate hasXMacro(HeaderFile hf) {\n  // Every header that includes `hf` both defines and undefines a macro that's\n  // used in `hf`.\n  exists(string macroName |\n    usesMacro(hf, macroName) and\n    forex(File f | f.getAnIncludedFile() = hf | defUndef(f, macroName))\n  )\n  or\n  // Every header that includes `hf` defines a macro that's used in `hf`, and\n  // `hf` itself undefines it.\n  exists(string macroName |\n    usesMacro(hf, macroName) and\n    undefinesMacro(hf, macroName) and\n    forex(File f | f.getAnIncludedFile() = hf | definesMacro(f, macroName))\n  )\n}\n\nfrom\n  HeaderFile hf, string detail, MaybePreprocessorDirective detail1,\n  MaybePreprocessorDirective detail2\nwhere\n  not hf instanceof IncludeGuardedHeader and\n  (\n    if exists(extraDetail(hf, _, _))\n    then detail = extraDetail(hf, detail1, detail2)\n    else (\n      detail = \".\" and\n      detail1 instanceof NoPreprocessorDirective and\n      detail2 instanceof NoPreprocessorDirective\n    )\n  ) and\n  // Exclude files which contain no declaration entries or top level\n  // declarations (e.g. just preprocessor directives; or non-top level\n  // code).\n  not hf.noTopLevelCode() and\n  // Exclude files which look like they contain 'x-macros'\n  not hasXMacro(hf) and\n  // Exclude files which are always #imported.\n  not forex(Include i | i.getIncludedFile() = hf | i instanceof Import) and\n  // Exclude files which are only included once.\n  not strictcount(Include i | i.getIncludedFile() = hf) = 1\nselect hf, \"This header file should contain a header guard to prevent multiple inclusion\" + detail,\n  detail1, detail1.toString(), detail2, detail2.toString()",
        "description": "Header files should contain header guards (#defines to prevent the file from being included twice). This prevents errors and inefficiencies caused by repeated inclusion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.07 Header Files/AV Rule 35.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// whether s defines variable v (conservative)\npredicate defines(ControlFlowNode s, Variable lv) {\n  exists(VariableAccess va | va = s and va.getTarget() = lv and va.isLValue())\n}\n\n// whether s uses variable v (conservative)\npredicate uses(ControlFlowNode s, Variable lv) {\n  exists(VariableAccess va |\n    va = s and\n    va.getTarget() = lv and\n    va.isRValue() and\n    not va.getParent+() instanceof SizeofOperator\n  )\n}\n\n// whether there is a path from the declaration of lv to n such that lv is definitely not defined before n\npredicate noDefPath(LocalVariable lv, ControlFlowNode n) {\n  n.(DeclStmt).getADeclaration() = lv and not exists(lv.getInitializer())\n  or\n  exists(ControlFlowNode p | noDefPath(lv, p) and n = p.getASuccessor() and not defines(p, lv))\n}\n\npredicate isAggregateType(Type t) { t instanceof Class or t instanceof ArrayType }\n\n// whether va is a use of a local variable that has not been previously defined\npredicate undefinedLocalUse(VariableAccess va) {\n  exists(LocalVariable lv |\n    // it is hard to tell when a struct or array has been initialised, so we ignore them\n    not isAggregateType(lv.getUnderlyingType()) and\n    not lv.getType().hasName(\"va_list\") and\n    va = lv.getAnAccess() and\n    noDefPath(lv, va) and\n    uses(va, lv)\n  )\n}\n\n// whether gv is a potentially uninitialised global variable\npredicate uninitialisedGlobal(GlobalVariable gv) {\n  exists(VariableAccess va |\n    not isAggregateType(gv.getUnderlyingType()) and\n    va = gv.getAnAccess() and\n    va.isRValue() and\n    not gv.hasInitializer() and\n    not gv.hasSpecifier(\"extern\")\n  )\n}\n\nfrom Element elt\nwhere undefinedLocalUse(elt) or uninitialisedGlobal(elt)\nselect elt, \"AV Rule 142: All variables shall be initialized before use.\"",
        "description": "All variables shall be initialized before use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.16 Initialization/AV Rule 142.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// whether s defines variable v (conservative)\npredicate defines(VariableAccess va, Variable lv) { va.getTarget() = lv and va.isLValue() }\n\n// whether s uses variable v (conservative)\npredicate uses(ControlFlowNode s, Variable lv) {\n  exists(VariableAccess va |\n    va = s and\n    va.getTarget() = lv and\n    va.isRValue() and\n    not va.getParent+() instanceof SizeofOperator\n  )\n}\n\n// whether there is a path from the declaration of lv to n such that lv is definitely not used or defined\n// before n\npredicate noDefUsePath(LocalVariable lv, ControlFlowNode n) {\n  n.(DeclStmt).getADeclaration() = lv\n  or\n  exists(ControlFlowNode p |\n    noDefUsePath(lv, p) and\n    n = p.getASuccessor() and\n    not defines(p, lv) and\n    not uses(p, lv)\n  )\n}\n\npredicate neighbouringStmts(Stmt s1, Stmt s2) {\n  exists(BlockStmt b, int i |\n    i in [0 .. b.getNumStmt() - 2] and\n    s1 = b.getStmt(i) and\n    s2 = b.getStmt(i + 1)\n  )\n}\n\nfrom LocalVariable lv, VariableAccess def, DeclStmt d\nwhere\n  lv.fromSource() and\n  d.getADeclaration() = lv and\n  noDefUsePath(lv, def) and\n  defines(def, lv) and\n  not neighbouringStmts(d, def.getEnclosingStmt()) and\n  not exists(ControlFlowNode use | noDefUsePath(lv, use) and uses(use, lv))\nselect def,\n  \"AV Rule 143: Variables will not be introduced until they can be initialized with meaningful values.\"",
        "description": "Variables will not be introduced until they can be initialized with meaningful values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.16 Initialization/AV Rule 143.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate hasInitializer(EnumConstant c) { c.getInitializer().fromSource() }\n\npredicate hasNonReferenceInitializer(EnumConstant c) {\n  exists(Initializer init |\n    init = c.getInitializer() and\n    init.fromSource() and\n    not init.getExpr().(EnumConstantAccess).getTarget().getDeclaringEnum() = c.getDeclaringEnum()\n  )\n}\n\npredicate hasReferenceInitializer(EnumConstant c) {\n  exists(Initializer init |\n    init = c.getInitializer() and\n    init.fromSource() and\n    init.getExpr().(EnumConstantAccess).getTarget().getDeclaringEnum() = c.getDeclaringEnum()\n  )\n}\n\nEnumConstant getNonReferenceInitializedEnumConstantByRank(Enum e, int rnk) {\n  result =\n    rank[rnk](EnumConstant cand, int pos, string filepath, int startline, int startcolumn |\n      e.getEnumConstant(pos) = cand and\n      not hasReferenceInitializer(cand) and\n      cand.getLocation().hasLocationInfo(filepath, startline, startcolumn, _, _)\n    |\n      cand order by pos, filepath, startline, startcolumn\n    )\n}\n\npredicate hasNextWithoutReferenceInitializer(Enum e, EnumConstant ec) {\n  exists(int rnk |\n    ec = getNonReferenceInitializedEnumConstantByRank(e, rnk) and\n    exists(getNonReferenceInitializedEnumConstantByRank(e, rnk + 1))\n  )\n}\n\n// There exists another constant whose value is implicit, but it's\n// not the last one: the last value is okay to use to get the highest\n// enum value automatically. It can be followed by aliases though.\npredicate enumThatHasConstantWithImplicitValue(Enum e) {\n  exists(EnumConstant ec |\n    ec = e.getAnEnumConstant() and\n    not hasInitializer(ec) and\n    hasNextWithoutReferenceInitializer(e, ec)\n  )\n}\n\nfrom Enum e, int i\nwhere\n  // e is at position i, and has an explicit value in the source - but\n  // not just a reference to another enum constant\n  hasNonReferenceInitializer(e.getEnumConstant(i)) and\n  // but e is not the first or the last constant of the enum\n  i != 0 and\n  exists(e.getEnumConstant(i + 1)) and\n  // and there exists another constant whose value is implicit, but it's\n  // not the last one: the last value is okay to use to get the highest\n  // enum value automatically. It can be followed by aliases though.\n  enumThatHasConstantWithImplicitValue(e)\nselect e,\n  \"In an enumerator list, the = construct should not be used to explicitly initialize members other than the first, unless all items are explicitly initialized.\"",
        "description": "In an enumerator list, the = construct should not be used to explicitly initialize members other than the first, unless all items are explicitly initialized. An exception is the pattern to use the last element of an enumerator list to get the number of possible values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.16 Initialization/AV Rule 145.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate occursAfterInitialization(Expr e) {\n  not e.getEnclosingFunction() instanceof Constructor and\n  not e.getEnclosingFunction() instanceof Destructor\n}\n\nfrom Expr e\nwhere isMemoryManagementExpr(e) and occursAfterInitialization(e)\nselect e, \"AV Rule 206: Memory management shall not occur after initialization.\"",
        "description": "Allocation/deallocation from/to the free store (heap) shall not occur after initialization.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.26 Memory Allocation/AV Rule 206.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate unencapsulated(Type t) {\n  exists(Type base |\n    base = t.getUnderlyingType() and\n    (\n      base instanceof ArithmeticType or\n      base instanceof Enum or\n      base instanceof StructLikeClass or\n      unencapsulated(base.(PointerType).getBaseType()) or\n      unencapsulated(base.(SpecifiedType).getBaseType()) or\n      unencapsulated(base.(ReferenceType).getBaseType())\n    )\n  )\n}\n\nfrom GlobalVariable gv\nwhere\n  unencapsulated(gv.getType()) and\n  // Allow immutable global constants\n  not gv.getType().isDeeplyConst()\nselect gv, \"AV Rule 207: Unencapsulated global data will be avoided.\"",
        "description": "Unencapsulated global data will be avoided. Global non-constant variables should be objects of encapsulated types - not basic types, structs or struct-like classes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.26 Memory Allocation/AV Rule 207.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate twoDeclarations(Declaration element, Location l1, Location l2) {\n  l1 = element.getADeclarationLocation() and\n  l2 = element.getADeclarationLocation() and\n  l1.getFile() != l2.getFile() and\n  l1 != element.getDefinitionLocation() and\n  l2 != element.getDefinitionLocation()\n}\n\npredicate twoDeclarationFilesWithDifferentNames(Declaration d, string f1, string f2) {\n  f1 =\n    min(string s, File f, Location l |\n      twoDeclarations(d, l, _) and l.getFile() = f and s = f.getBaseName()\n    |\n      s\n    ) and\n  f2 =\n    min(string s, File f, Location l |\n      twoDeclarations(d, l, _) and l.getFile() = f and s = f.getBaseName() and s != f1\n    |\n      s\n    )\n}\n\npredicate twoDeclarationFilesWithSameNames(Declaration d, string f1, string f2) {\n  f1 =\n    min(string s, File f, Location l |\n      twoDeclarations(d, l, _) and l.getFile() = f and s = f.toString()\n    |\n      s\n    ) and\n  f2 =\n    min(string s, File f, Location l |\n      twoDeclarations(d, l, _) and l.getFile() = f and s = f.toString() and s != f1\n    |\n      s\n    )\n}\n\npredicate twoDeclarationFilesMessage(Declaration d, string msg) {\n  // If we can get two files with different names, all the better for the error message\n  if twoDeclarationFilesWithDifferentNames(d, _, _)\n  then\n    exists(string f1, string f2 |\n      twoDeclarationFilesWithDifferentNames(d, f1, f2) and msg = \"Declared in \" + f1 + \" and \" + f2\n    )\n  else\n    exists(string f1, string f2 |\n      twoDeclarationFilesWithSameNames(d, f1, f2) and msg = \"Declared in \" + f1 + \" and \" + f2\n    )\n}\n\nfrom Declaration d, string msg\nwhere\n  twoDeclarations(d, _, _) and\n  twoDeclarationFilesMessage(d, msg)\nselect d, \"AV Rule 139: external objects will not be declared in more than one file. \" + msg",
        "description": "External objects will not be declared in more than one file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.15 Declarations and Definitions/AV Rule 139.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\n\npredicate externalLinkage(Variable v) {\n  v.getADeclarationEntry().hasSpecifier(\"extern\")\n  or\n  v instanceof GlobalVariable and\n  not v.isConst() and\n  not v.isStatic()\n}\n\npredicate internalLinkage(GlobalVariable v) {\n  v.isStatic()\n  or\n  v.isConst() and\n  not v.hasSpecifier(\"extern\")\n}\n\nfrom Variable v\nwhere externalLinkage(v) and internalLinkage(v)\nselect v,\n  \"AV Rule 138: Identifiers shall not simultaneously have both internal and external linkage in the same translation unit.\"",
        "description": "Identifiers shall not simultaneously have both internal and external linkage in the same translation unit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.15 Declarations and Definitions/AV Rule 138.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Best_Practices.Hiding.Shadowing\n\n// Shadowing globals by locals or parameters. Only in the same file;\n// otherwise the rule is violated too often\nclass LocalVariableOrParameter extends Variable {\n  LocalVariableOrParameter() { this instanceof LocalVariable or this instanceof Parameter }\n\n  predicate shadowsGlobal(GlobalVariable gv) {\n    this.getName() = gv.getName() and this.getFile() = gv.getFile()\n  }\n}\n\n// Shadowing parameters by locals\npredicate localShadowsParameter(LocalVariable lv, Parameter p) {\n  p.getName() = lv.getName() and\n  p.getFunction() = lv.getFunction()\n}\n\nfrom Variable v, Variable shadowed\nwhere\n  not v.getParentScope().(BlockStmt).isInMacroExpansion() and\n  (\n    v.(LocalVariableOrParameter).shadowsGlobal(shadowed) or\n    localShadowsParameter(v, shadowed) or\n    shadowing(v, shadowed)\n  )\nselect v, \"Identifiers in an inner scope should not hide identifiers in an outer scope.\"",
        "description": "Identifiers in an inner scope should not use the same name as an identifier in an outer scope, and therefore hide that identifier.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.15 Declarations and Definitions/AV Rule 135.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Declaration d\nwhere d.hasSpecifier(\"register\")\nselect d,\n  \"The register storage class specifier should not be used; compilers can be trusted to decide whether to store a variable in a register.\"",
        "description": "The register storage class specifier shall not be used. It is better and more portable to rely on the compiler to allocate registers automatically.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.15 Declarations and Definitions/AV Rule 140.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\n// whether t is the last statement of s, possibly peeling off blocks\npredicate isTerminatingStmt(Stmt s, Stmt t) {\n  s = t or isTerminatingStmt(s.(BlockStmt).getLastStmt(), t)\n}\n\nfrom BreakStmt s\nwhere\n  s.fromSource() and\n  // exclude break statements that terminate switch cases\n  not exists(SwitchCase sc | isTerminatingStmt(sc.getLastStmt(), s))\nselect s, \"AV Rule 191: The break statement shall not be used.\"",
        "description": "The break statement shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 191.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom ForStmt f\nwhere\n  f.fromSource() and\n  (not exists(f.getInitialization()) or not exists(f.getUpdate()))\nselect f, \"AV Rule 200: Every for loop will have non-null initialize and increment expressions.\"",
        "description": "Null initialize or increment expressions in for loops will not be used; a while loop will be used instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 200.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom SwitchStmt s\nwhere\n  s.fromSource() and\n  s.getExpr().getUnderlyingType() instanceof BoolType\nselect s, \"AV Rule 195: A switch expression will not represent a Boolean value.\"",
        "description": "A switch expression will not represent a Boolean value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 195.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom EnumSwitch es, EnumConstant ec\nwhere\n  // A switch without a default case ...\n  not es.hasDefaultCase() and\n  // ... that misses at least one value ...\n  ec = es.getAMissingCase() and\n  // ... and make sure we pick a single missed value; choose the first one\n  not exists(EnumConstant ec2, int i, int j |\n    ec2 = es.getAMissingCase() and\n    ec2 = ec2.getDeclaringEnum().getEnumConstant(i) and\n    ec = ec.getDeclaringEnum().getEnumConstant(j) and\n    i < j\n  )\nselect es,\n  \"AV Rule 195: all switch statements that do not intend to test for every enumeration value shall contain a final default clause. This statement is missing a case for \"\n    + ec.getName()",
        "description": "All switch statements that do not intend to test for every enumeration value shall contain a final default clause.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 194.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Likely_Bugs.NestedLoopSameVar\n\npragma[noopt]\npredicate loopModification(ForStmt for, Variable loopVariable, VariableAccess acc) {\n  loopVariable = for.getAnIterationVariable() and\n  acc = loopVariable.getAnAccess() and\n  acc.isModified() and\n  exists(Stmt stmt | acc.getEnclosingStmt() = stmt and stmtInForBody(stmt, for))\n}\n\npragma[noopt]\npredicate stmtInForBody(Stmt stmt, ForStmt forStmt) {\n  (\n    forStmt.getStmt() = stmt\n    or\n    exists(StmtParent parent | parent = stmt.getParent() | stmtInForBody(parent, forStmt))\n  ) and\n  forStmt instanceof ForStmt\n}\n\nfrom ForStmt for, Variable loopVariable, VariableAccess acc\nwhere\n  loopModification(for, loopVariable, acc) and\n  // field accesses must have the same object\n  (\n    loopVariable instanceof Field\n    implies\n    exists(Variable obj |\n      simpleFieldAccess(obj, loopVariable, acc) and\n      simpleFieldAccess(obj, loopVariable, for.getCondition().getAChild*())\n    )\n  ) and\n  // don't duplicate results from NestedLoopSameVar.ql\n  not exists(ForStmt inner |\n    nestedForViolation(inner, loopVariable, for) and\n    (\n      acc.getParent*() = inner or\n      acc.getParent*() = inner.getInitialization()\n    )\n  )\nselect acc, \"Loop counters should not be modified in the body of the $@.\", for.getStmt(), \"loop\"",
        "description": "Numeric variables being used within a for loop for iteration counting should not be modified in the body of the loop. Reserve for loops for straightforward iterations, and use a while loop instead for more complex cases.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 201.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom ContinueStmt s\nwhere s.fromSource()\nselect s, \"AV Rule 190: The continue statement shall not be used.\"",
        "description": "The continue statement shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 190.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom LoopCounter lc\nwhere lc.getUnderlyingType() instanceof FloatingPointType\nselect lc, \"Floating point variables should not be used as loop counters.\"",
        "description": "Floating point variables should not be used as loop counters. For loops are best suited to simple increments and termination conditions; while loops are preferable for more complex uses.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 197.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Stmt s\nwhere\n  s.fromSource() and\n  // Exclude empty statements\n  not s instanceof EmptyStmt and\n  // Exclude control statements\n  not s instanceof LabelStmt and\n  not s instanceof JumpStmt and\n  not s instanceof ReturnStmt and\n  not s instanceof ControlStructure and\n  // Exclude blocks; if a child of the block violates the rule that will still\n  // be picked up so there is no point in blaming the block as well\n  not s instanceof BlockStmt and\n  s.isPure()\nselect s, \"AV Rule 187: All non-null statements shall potentially have a side-effect.\"",
        "description": "All non-null statements shall potentially have a side-effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 187.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate lastDefaultCase(SwitchCase sc) {\n  sc.isDefault() and\n  not exists(SwitchCase sc2 |\n    sc2.getSwitchStmt() = sc.getSwitchStmt() and sc2.getChildNum() > sc.getChildNum()\n  )\n}\n\nfrom SwitchCase sc\nwhere\n  sc.fromSource() and\n  exists(sc.getAStmt()) and\n  not lastDefaultCase(sc) and\n  not sc.terminatesInBreakStmt() and\n  not sc.terminatesInReturnStmt()\nselect sc,\n  \"AV Rule 193: Every non-empty case clause in a switch statement shall be terminated with a break statement.\"",
        "description": "Every non-empty case clause in a switch statement shall be terminated with a break statement.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 193.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// the extractor associates comments with the statement immediately following them\n// additionally, we also want to count comments that come right after the if statement,\n// as this seems a likely place to put a comment explaining the absence of an else\npredicate isCommented(IfStmt i) {\n  exists(Comment c |\n    c.getCommentedElement() = i or\n    i.getLocation().getEndLine() = c.getLocation().getStartLine()\n  )\n}\n\nfrom IfStmt i\nwhere\n  i.fromSource() and\n  // only applies if there are one or more else-ifs\n  exists(IfStmt i2 | i2.getElse() = i) and\n  not i.hasElse() and\n  not isCommented(i)\nselect i,\n  \"AV Rule 192: All if-else if chains will have an else clause or a comment explaining its absence.\"",
        "description": "All if, else if constructs will contain either a final else clause or a comment indicating why a final else clause is not necessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 192.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom SwitchStmt s\nwhere\n  s.fromSource() and\n  count(SwitchCase sc | sc.getSwitchStmt() = s and not sc instanceof DefaultCase) < 2 and\n  not exists(s.getGeneratingMacro())\nselect s,\n  \"This switch statement should either handle more cases, or be rewritten as an if statement.\"",
        "description": "Using a switch statement when there are fewer than two non-default cases leads to unclear code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 196.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// whether f is to be considered an API entry point, and hence reachable by default\npredicate isApi(Function f) {\n  f.hasName(\"main\") or\n  f.(MemberFunction).hasSpecifier(\"public\")\n}\n\npredicate unusedFunction(Function f) {\n  not isApi(f) and\n  not exists(FunctionCall c | c.getTarget() = f) and\n  not exists(Access acc | acc.getTarget() = f) and\n  f.hasDefinition()\n}\n\npredicate unreachableStmt(Stmt s) { not s.getControlFlowScope().getBlock().getASuccessor*() = s }\n\nfrom ControlFlowNode n\nwhere unreachableStmt(n) or unusedFunction(n)\nselect n, \"AV Rule 186: There shall be no unreachable code.\"",
        "description": "There shall be no unreachable code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 186.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate isValidLoopUpdate(Expr e) {\n  e instanceof CrementOperation or\n  e instanceof AssignExpr or\n  e instanceof FunctionCall // this is to account for overloaded operators\n}\n\nfrom ForStmt for\nwhere\n  for.fromSource() and\n  not isValidLoopUpdate(for.getUpdate())\nselect for,\n  \"AV Rule 199: The increment expression in a for loop will only update a single for loop parameter.\"",
        "description": "The increment expression in a for loop will only update a single loop parameter.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 199.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom GotoStmt s\nwhere\n  s.fromSource() and\n  not s.breaksFromNestedLoops()\nselect s, \"AV Rule 189: The goto statement shall not be used.\"",
        "description": "The goto statement shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 189.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate isValidLoopInitialization(Stmt s) {\n  s instanceof DeclStmt or\n  s.(ExprStmt).getExpr() instanceof AssignExpr\n}\n\nfrom ForStmt for\nwhere\n  for.fromSource() and\n  not isValidLoopInitialization(for.getInitialization())\nselect for,\n  \"AV Rule 198: The initialization statement in a for loop will only initialize a single loop parameter.\"",
        "description": "The initialization statement in a for loop will only initialize a single loop parameter.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 198.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom LabelStmt l\nwhere not exists(GotoStmt g | g.breaksFromNestedLoops() and g.getTarget() = l)\nselect l, \"AV Rule 188: Labels will not be used, except in switch statements.\"",
        "description": "Labels will not be used, except in switch statements.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.24 Control Flow Structures/AV Rule 188.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\n\npredicate definesDefaultConstructor(Class c) {\n  exists(Constructor constr | constr.getDeclaringType() = c and constr.isDefault())\n  or\n  definesDefaultConstructor(c.getABaseClass())\n}\n\npredicate definesCopyConstructor(Class c) {\n  exists(CopyConstructor constr | constr.getDeclaringType() = c) or\n  definesCopyConstructor(c.getABaseClass())\n}\n\npredicate definesCopyAssignmentOperator(Class c) {\n  exists(CopyAssignmentOperator op | op.getDeclaringType() = c) or\n  definesCopyAssignmentOperator(c.getABaseClass())\n}\n\npredicate definesDestructor(Class c) {\n  exists(Destructor op | op.getDeclaringType() = c) or\n  definesDestructor(c.getABaseClass())\n}\n\nclass ProperClass extends Class {\n  ProperClass() { not this instanceof Struct }\n}\n\n\nfrom ProperClass c, string msg\nwhere\n  not definesDefaultConstructor(c) and\n  not c.hasConstructor() and\n  msg =\n    \"AV Rule 68: class \" + c.getName() +\n      \" does not need a default constructor and should explicitly disallow it.\"\n  or\n  not definesCopyConstructor(c) and\n  msg =\n    \"AV Rule 68: class \" + c.getName() +\n      \" does not need a copy constructor and should explicitly disallow it.\"\n  or\n  not definesCopyAssignmentOperator(c) and\n  msg =\n    \"AV Rule 68: class \" + c.getName() +\n      \" does not need a copy assignment operator and should explicitly disallow it.\"\n  or\n  not definesDestructor(c) and\n  msg =\n    \"AV Rule 68: class \" + c.getName() +\n      \" does not need a destructor and should explicitly disallow it.\"\nselect c, msg",
        "description": "Unneeded implicitly generated member functions shall be explicitly disallowed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 68.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom Class c\nwhere\n  exists(VirtualFunction f | f.getDeclaringType() = c) and\n  exists(Destructor d |\n    d.getDeclaringType() = c and\n    not d.isVirtual() and\n    not d.isDeleted() and\n    not d.isCompilerGenerated()\n  ) and\n  exists(ClassDerivation d | d.getBaseClass() = c)\nselect c, \"Base classes with a virtual function must define a virtual destructor.\"",
        "description": "All base classes with a virtual function should define a virtual destructor. If an application attempts to delete a derived class object through a base class pointer, the result is undefined if the base class destructor is non-virtual.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 78.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MemberFunction mf\nwhere\n  mf.fromSource() and\n  mf.hasDefinition() and\n  not mf instanceof Constructor and\n  not exists(VariableAccess va |\n    va.isLValue() and\n    va.getEnclosingFunction() = mf and\n    (\n      va.getTarget() instanceof MemberVariable or\n      va.getTarget() instanceof GlobalVariable\n    )\n  ) and\n  forall(Call c | c.getEnclosingFunction() = mf | c.isPure()) and\n  not mf.hasSpecifier(\"const\")\nselect mf,\n  \"AV Rule 69: A member function that does not affect the state of an object will be declared const.\"",
        "description": "A member function that does not affect the state of an object will be declared const.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 69.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom EqualityOperation e, PointerToMemberType t, Class c\nwhere\n  e.getAnOperand().getType() = t and\n  t.getClass() = c and\n  c.getAMemberFunction() instanceof VirtualFunction\nselect e,\n  \"AV Rule 97.1: Neither operand of an equality operator shall be a pointer to a virtual member function.\"",
        "description": "Neither operand of an equality operator (== or !=) shall be a pointer to a virtual member function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 97.1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Critical.NewDelete\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\npredicate acquireExpr(Expr acquire, string kind) {\n  exists(FunctionCall fc, Function f, string name |\n    fc = acquire and\n    f = fc.getTarget() and\n    f.hasGlobalOrStdName(name) and\n    (\n      name = \"fopen\" and\n      kind = \"file\"\n      or\n      name = \"open\" and\n      kind = \"file descriptor\"\n      or\n      name = \"socket\" and\n      kind = \"file descriptor\"\n    )\n  )\n  or\n  allocExpr(acquire, kind)\n}\n\npredicate releaseExpr(Expr release, Expr resource, string kind) {\n  exists(FunctionCall fc, Function f, string name |\n    fc = release and\n    f = fc.getTarget() and\n    f.hasGlobalOrStdName(name) and\n    (\n      name = \"fclose\" and\n      resource = fc.getArgument(0) and\n      kind = \"file\"\n      or\n      name = \"close\" and\n      resource = fc.getArgument(0) and\n      kind = \"file descriptor\"\n    )\n  )\n  or\n  exists(string releaseKind |\n    freeExpr(release, resource, releaseKind) and\n    (\n      kind = \"malloc\" and\n      releaseKind = \"free\"\n      or\n      kind = \"new\" and\n      releaseKind = \"delete\"\n      or\n      kind = \"new[]\" and\n      releaseKind = \"delete[]\"\n    )\n  )\n}\n\nExpr exprOrDereference(Expr e) {\n  result = e or\n  result.(PointerDereferenceExpr).getOperand() = e\n}\n\nprivate predicate exprReleases(Expr e, Expr released, string kind) {\n  // `e` is a call to a release function and `released` is the released argument\n  releaseExpr(e, released, kind)\n  or\n  exists(int arg, VariableAccess access, Function f |\n    // `e` is a call to a function that releases one of it's parameters,\n    // and `released` is the corresponding argument\n    (\n      e.(FunctionCall).getTarget() = f or\n      e.(FunctionCall).getTarget().(MemberFunction).getAnOverridingFunction+() = f\n    ) and\n    access = f.getParameter(pragma[only_bind_into](arg)).getAnAccess() and\n    e.(FunctionCall).getArgument(pragma[only_bind_into](arg)) = released and\n    exprReleases(_,\n      pragma[only_bind_into](exprOrDereference(globalValueNumber(access).getAnExpr())), kind)\n  )\n  or\n  exists(Function f, ThisExpr innerThis |\n    // `e` is a call to a method that releases `this`, and `released`\n    // is the object that is called\n    (\n      e.(FunctionCall).getTarget() = f or\n      e.(FunctionCall).getTarget().(MemberFunction).getAnOverridingFunction+() = f\n    ) and\n    e.(FunctionCall).getQualifier() = exprOrDereference(released) and\n    innerThis.getEnclosingFunction() = f and\n    exprReleases(_, pragma[only_bind_into](globalValueNumber(innerThis).getAnExpr()), kind)\n  )\n}\n\nclass Resource extends MemberVariable {\n  Resource() { not this.isStatic() }\n\n  // Check that an expr is somewhere in this class - does not have to be a constructor\n  predicate inSameClass(Expr e) {\n    e.getEnclosingFunction().(MemberFunction).getDeclaringType() = this.getDeclaringType()\n  }\n\n  private predicate calledFromDestructor(Function f) {\n    pragma[only_bind_into](f) instanceof Destructor and\n    f.getDeclaringType() = this.getDeclaringType()\n    or\n    exists(Function mid |\n      this.calledFromDestructor(mid) and\n      mid.calls(f) and\n      pragma[only_bind_out](f.getDeclaringType()) = pragma[only_bind_out](this.getDeclaringType())\n    )\n  }\n\n  predicate inDestructor(Expr e) {\n    exists(Function f | f = e.getEnclosingFunction() | this.calledFromDestructor(f))\n  }\n\n  predicate acquisitionWithRequiredKind(Assignment acquireAssign, string kind) {\n    // acquireAssign is an assignment to this resource\n    acquireAssign.getLValue() = this.getAnAccess() and\n    // Should be in this class, but *any* member method will do\n    this.inSameClass(acquireAssign) and\n    // Check that it is an acquisition function and return the corresponding kind\n    acquireExpr(acquireAssign.getRValue(), kind)\n  }\n\n  Expr getAReleaseExpr(string kind) { exprReleases(result, this.getAnAccess(), kind) }\n}\n\npredicate unreleasedResource(Resource r, Expr acquire, File f, int acquireLine) {\n  // Note: there could be several release functions, because there could be\n  // several functions called 'fclose' for example. We want to check that\n  // *none* of these functions are called to release the resource\n  r.acquisitionWithRequiredKind(acquire, _) and\n  not exists(Expr releaseExpr, string kind |\n    r.acquisitionWithRequiredKind(acquire, kind) and\n    releaseExpr = r.getAReleaseExpr(kind) and\n    r.inDestructor(releaseExpr)\n  ) and\n  f = acquire.getFile() and\n  acquireLine = acquire.getLocation().getStartLine() and\n  not exists(ExprCall exprCall |\n    // expression call (function pointer or lambda) with `r` as an\n    // argument, which could release it.\n    exprCall.getAnArgument() = r.getAnAccess() and\n    r.inDestructor(exprCall)\n  ) and\n  // check that any destructor for this class has a block; if it doesn't,\n  // we must be missing information.\n  forall(Class c, Destructor d |\n    r.getDeclaringType().isConstructedFrom*(c) and\n    d = c.getAMember() and\n    not d.isCompilerGenerated() and\n    not d.isDefaulted() and\n    not d.isDeleted()\n  |\n    exists(d.getBlock())\n  )\n}\n\npredicate freedInSameMethod(Resource r, Expr acquire) {\n  unreleasedResource(r, acquire, _, _) and\n  exists(Expr releaseExpr, string kind |\n    r.acquisitionWithRequiredKind(acquire, kind) and\n    releaseExpr = r.getAReleaseExpr(kind) and\n    releaseExpr.getEnclosingElement+() = acquire.getEnclosingFunction()\n  )\n}\n\npredicate leakedInSameMethod(Resource r, Expr acquire) {\n  unreleasedResource(r, acquire, _, _) and\n  exists(Function f |\n    acquire.getEnclosingFunction() = f and\n    (\n      exists(FunctionCall fc |\n        // `r` (or something computed from it) is passed to another function\n        // near to where it's acquired, and might be stored elsewhere.\n        fc.getAnArgument().getAChild*() = r.getAnAccess() and\n        fc.getEnclosingFunction() = f\n      )\n      or\n      exists(Variable v, Expr e |\n        // `r` (or something computed from it) is stored in another variable\n        // near to where it's acquired, and might be released through that\n        // variable.\n        v.getAnAssignedValue() = e and\n        e.getAChild*() = r.getAnAccess() and\n        e.getEnclosingFunction() = f\n      )\n      or\n      exists(FunctionCall fc |\n        // `this` (i.e. the class where `r` is acquired) is passed into `r` via a\n        // method, or the constructor.  `r` may use this to register itself with\n        // `this` in some way, ensuring it is later deleted.\n        fc.getEnclosingFunction() = f and\n        fc.getAnArgument() instanceof ThisExpr and\n        (\n          fc.getQualifier() = r.getAnAccess() or // e.g. `r->setOwner(this)`\n          fc = acquire.getAChild*() // e.g. `r = new MyClass(this)`\n        )\n      )\n    )\n  )\n  or\n  exists(FunctionAccess fa, string kind |\n    // the address of a function that releases `r` is taken (and likely\n    // used to release `r` at some point).\n    r.acquisitionWithRequiredKind(acquire, kind) and\n    fa.getTarget() = r.getAReleaseExpr(kind).getEnclosingFunction()\n  )\n}\n\npragma[noopt]\npredicate badRelease(Resource r, Expr acquire, Function functionCallingRelease, int line) {\n  unreleasedResource(r, acquire, _, _) and\n  exists(Expr releaseExpr, string kind, Location releaseExprLocation, Function acquireFunction |\n    r.acquisitionWithRequiredKind(acquire, kind) and\n    releaseExpr = r.getAReleaseExpr(kind) and\n    releaseExpr.getEnclosingFunction() = functionCallingRelease and\n    functionCallingRelease.getDeclaringType() = r.getDeclaringType() and\n    releaseExprLocation = releaseExpr.getLocation() and\n    line = releaseExprLocation.getStartLine() and\n    acquireFunction = acquire.getEnclosingFunction() and\n    functionCallingRelease != acquireFunction\n  )\n}\n\nClass qtObject() { result.getABaseClass*().hasGlobalName(\"QObject\") }\n\nPointerType qtObjectReference() { result.getBaseType() = qtObject() }\n\nConstructor qtParentConstructor() {\n  exists(Parameter p |\n    p.getName() = \"parent\" and\n    p.getType() = qtObjectReference() and\n    result.getAParameter() = p and\n    result.getDeclaringType() = qtObject()\n  )\n}\n\npredicate automaticallyReleased(Assignment acquire) {\n  // sub-types of the Qt type QObject are released by their parent (if they have one)\n  exists(NewExpr alloc |\n    alloc.getAllocatedType() = qtObject() and\n    acquire.getRValue() = alloc and\n    alloc.getInitializer() = qtParentConstructor().getACallToThisFunction()\n  )\n}\n\nfrom Resource r, Expr acquire, File f, string message\nwhere\n  unreleasedResource(r, acquire, f, _) and\n  not freedInSameMethod(r, acquire) and\n  not leakedInSameMethod(r, acquire) and\n  (\n    exists(Function releaseFunction, int releaseLine |\n      badRelease(r, acquire, releaseFunction, releaseLine) and\n      message =\n        \"Resource \" + r.getName() + \" is acquired by class \" + r.getDeclaringType().getName() +\n          \" but not released in the destructor. It is released from \" + releaseFunction.getName() +\n          \" on line \" + releaseLine +\n          \", so this function may need to be called from the destructor.\"\n    )\n    or\n    not badRelease(r, _, _, _) and\n    message =\n      \"Resource \" + r.getName() + \" is acquired by class \" + r.getDeclaringType().getName() +\n        \" but not released anywhere in this class.\"\n  ) and\n  not automaticallyReleased(acquire) and\n  not r.getDeclaringType() instanceof TemplateClass // template classes may contain insufficient information for this analysis; results from instantiations will usually suffice.\nselect acquire, message",
        "description": "All resources acquired by a class should be released by its destructor. Avoid the use of the 'open / close' pattern, since C++ constructors and destructors provide a safer way to handle resource acquisition and release. Best practice in C++ is to use the 'RAII' technique: constructors allocate resources and destructors free them.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 79.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate memberParameterWithDefault(\n  MemberFunction f, int ix, Parameter p, Expr initExpr, string initValue\n) {\n  f.getParameter(ix) = p and\n  initExpr = p.getInitializer().getExpr() and\n  initValue = initExpr.getValue()\n}\n\nfrom\n  Parameter p, Parameter superP, MemberFunction subF, MemberFunction superF, int i, Expr subExpr,\n  string subValue, string superValue\nwhere\n  memberParameterWithDefault(subF, i, p, subExpr, subValue) and\n  subF.overrides(superF) and\n  memberParameterWithDefault(superF, i, superP, _, superValue) and\n  subValue != superValue\nselect subExpr,\n  \"Parameter \" + p.getName() + \" redefines its default value to \" + subValue +\n    \" from the inherited default value \" + superValue + \" (in \" +\n    superF.getDeclaringType().getName() +\n    \").\\nThe default value will be resolved statically, not by dispatch, so this can cause confusion.\"",
        "description": "An inherited default parameter shall never be redefined. Default values are bound statically which is confusing when combined with dynamically bound function calls.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 95.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate hasPointerMember(Class c) {\n  // Note: any function pointers are fine\n  exists(MemberVariable v, Type t |\n    v.getDeclaringType() = c and\n    t = v.getType().getUnderlyingType() and\n    (t instanceof PointerType or t instanceof PointerToMemberType) and\n    not t instanceof FunctionPointerType and\n    not t.(PointerToMemberType).getBaseType() instanceof RoutineType\n  )\n}\n\nclass TrivialStmt extends Stmt {\n  TrivialStmt() {\n    this instanceof EmptyStmt\n    or\n    this instanceof ReturnStmt and not this.(ReturnStmt).hasExpr()\n  }\n}\n\n// What is a nontrivial destructor? JSF is unclear about that. We'll just\n// take any nonempty destructor as nontrivial. Exclude the generated 'return' stmt\npredicate hasNontrivialDestructor(Class c) {\n  exists(Stmt s | s = c.getDestructor().getBlock().getAStmt() | not s instanceof TrivialStmt)\n}\n\nfrom Class c\nwhere\n  (hasPointerMember(c) or hasNontrivialDestructor(c)) and\n  (\n    c.hasImplicitCopyAssignmentOperator() or\n    c.hasImplicitCopyConstructor()\n  ) and\n  not c instanceof Struct\nselect c,\n  \"AV Rule 76: A copy constructor and an assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors.\"",
        "description": "A copy constructor and an assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors. If the copy constructor and assignment operators are not required, they should be explicitly disallowed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 76.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate oppositeOperators(string op1, string op2) {\n  op1 = \"operator<\" and op2 = \"operator>=\"\n  or\n  op1 = \"operator<=\" and op2 = \"operator>\"\n  or\n  op1 = \"operator==\" and op2 = \"operator!=\"\n  or\n  oppositeOperators(op2, op1)\n}\n\npredicate implementedAsNegationOf(Operator op1, Operator op2) {\n  exists(BlockStmt b, ReturnStmt r, NotExpr n, Expr o |\n    b = op1.getBlock() and\n    b.getNumStmt() = 1 and\n    r = b.getStmt(0) and\n    n = r.getExpr() and\n    o = n.getOperand() and\n    (\n      o instanceof LTExpr and op2.hasName(\"operator<\")\n      or\n      o instanceof LEExpr and op2.hasName(\"operator<=\")\n      or\n      o instanceof GTExpr and op2.hasName(\"operator>\")\n      or\n      o instanceof GEExpr and op2.hasName(\"operator>=\")\n      or\n      o instanceof EQExpr and op2.hasName(\"operator==\")\n      or\n      o instanceof NEExpr and op2.hasName(\"operator!=\")\n      or\n      o.(FunctionCall).getTarget() = op2\n    )\n  )\n}\n\npredicate classIsCheckableFor(Class c, string op) {\n  oppositeOperators(op, _) and\n  // We check the template, not its instantiations\n  not c instanceof ClassTemplateInstantiation and\n  // Member functions of templates are not necessarily instantiated, so\n  // if the function we want to check exists, then make sure that its\n  // body also exists\n  (\n    c instanceof TemplateClass\n    implies\n    forall(Function f | f = c.getAMember() and f.hasName(op) | exists(f.getEntryPoint()))\n  )\n}\n\nfrom Class c, string op, string opp, Operator rator\nwhere\n  c.fromSource() and\n  oppositeOperators(op, opp) and\n  classIsCheckableFor(c, op) and\n  classIsCheckableFor(c, opp) and\n  rator = c.getAMember() and\n  rator.hasName(op) and\n  forex(Operator aRator | aRator = c.getAMember() and aRator.hasName(op) |\n    not exists(Operator oprator |\n      oprator = c.getAMember() and\n      oprator.hasName(opp) and\n      (\n        implementedAsNegationOf(aRator, oprator) or\n        implementedAsNegationOf(oprator, aRator)\n      )\n    )\n  )\nselect c,\n  \"When two operators are opposites, both should be defined and one should be defined in terms of the other. Operator \"\n    + op + \" is declared on line \" + rator.getLocation().getStartLine().toString() +\n    \", but it is not defined in terms of its opposite operator \" + opp + \".\"",
        "description": "When two operators are opposites, both should be defined and one should be defined in terms of the other.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 85.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nclass ReferenceCopyAssignmentOperator extends MemberFunction {\n  ReferenceCopyAssignmentOperator() {\n    this.getName() = \"operator=\" and\n    this.getNumberOfParameters() = 1 and\n    exists(ReferenceType rt |\n      rt = this.getParameter(0).getType() and\n      (\n        rt.getBaseType() = this.getDeclaringType() or\n        rt.getBaseType().(SpecifiedType).getBaseType() = this.getDeclaringType()\n      )\n    )\n  }\n\n  Parameter getRhs() { result = this.getParameter(0) }\n\n  /** A self-equality test: between 'this' and the RHS parameter */\n  IfStmt getASelfEqualityTest() {\n    result.getEnclosingFunction() = this and\n    exists(ComparisonOperation op |\n      op = result.getCondition() and\n      op.getAnOperand() instanceof ThisExpr and\n      op.getAnOperand().(AddressOfExpr).getOperand().(VariableAccess).getTarget() = this.getRhs()\n    )\n  }\n\n  /**\n   * A call to a function called swap. Note: could be a member,\n   * `std::swap` or a function overloading `std::swap` (not in `std::`)\n   * so keep it simple\n   */\n  FunctionCall getASwapCall() {\n    result.getEnclosingFunction() = this and\n    result.getTarget().getName() = \"swap\"\n  }\n\n  /** A call to delete on a member variable */\n  DeleteExpr getADeleteExpr() {\n    result.getEnclosingFunction() = this and\n    result.getExpr().(VariableAccess).getTarget().(MemberVariable).getDeclaringType() =\n      this.getDeclaringType()\n  }\n}\n\npredicate hasResource(Class c) {\n  exists(MemberVariable mv |\n    mv.getDeclaringType() = c and\n    mv.getType() instanceof PointerType\n  )\n}\n\nfrom ReferenceCopyAssignmentOperator op\nwhere\n  hasResource(op.getDeclaringType()) and\n  not exists(op.getASelfEqualityTest()) and\n  not exists(op.getASwapCall()) and\n  exists(op.getADeleteExpr())\nselect op, \"AV Rule 81: The assignment operator shall handle self-assignment correctly.\"",
        "description": "The assignment operator shall handle self-assignment correctly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 81.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom Constructor c, MemberVariable f\nwhere\n  c.fromSource() and\n  c.isDefault() and\n  not c.isCompilerGenerated() and\n  f = c.getAWrittenVariable() and\n  forall(MemberFunction m, VariableAccess va |\n    va = f.getAnAccess() and\n    m = va.getEnclosingFunction() and\n    not m instanceof Constructor and\n    not va.getEnclosingStmt() instanceof IfStmt\n  |\n    exists(VariableAccess va2 | va2 = f.getAnAccess() and m = va2.getEnclosingFunction() |\n      va != va2 and\n      va2.getEnclosingStmt() instanceof IfStmt\n    )\n  ) and\n  not (\n    exists(ArrayType at | at.getBaseType+() = c.getDeclaringType())\n    or\n    exists(NewArrayExpr nae | nae.getType().(ArrayType).getBaseType+() = c.getDeclaringType())\n    or\n    exists(ClassDerivation cd |\n      cd.hasSpecifier(\"virtual\") and cd.getBaseClass() = c.getDeclaringType()\n    )\n  )\nselect c,\n  \"This default constructor possibly doesn't put the object in a usable state, indicated by the member variable $@.\",\n  f, f.toString()",
        "description": "Unnecessary default constructors shall not be defined.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 73.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MemberFunction f1, MemberFunction f2\nwhere\n  f1 != f2 and\n  not f1 instanceof VirtualFunction and\n  not f2 instanceof VirtualFunction and\n  f1.getDeclaringType().getABaseClass+() = f2.getDeclaringType() and\n  f1.getName() = f2.getName() and\n  forall(Parameter p1, Parameter p2, int i | f1.getParameter(i) = p1 and f2.getParameter(i) = p2 |\n    p1.getType() = p2.getType()\n  )\nselect f1, \"AV Rule 94: An inherited nonvirtual function shall not be redefined in a derived class.\"",
        "description": "An inherited nonvirtual function shall not be redefined in a derived class. Such definitions would hide the function in the base class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 94.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// whether b is the same as a, or b is \"const a&\"\npredicate isTypeOrConstRef(Type a, Type b) {\n  a = b\n  or\n  exists(ReferenceType r, SpecifiedType s |\n    b = r and s = r.getBaseType() and s.hasSpecifier(\"const\") and a = s.getUnspecifiedType()\n  )\n}\n\n// whether the first parameter of f may be subject to implicit conversions\npredicate implicitConvOnFirstParm(Function f) {\n  exists(ImplicitConversionFunction conv |\n    isTypeOrConstRef(conv.getDestType(), f.getParameter(0).getUnderlyingType())\n  )\n}\n\n// whether f is declared as a friend by all its parameter types\npredicate multiFriend(Function f) {\n  f.getNumberOfParameters() > 1 and\n  forall(Parameter p | p = f.getAParameter() |\n    exists(FriendDecl fd |\n      fd.getFriend() = f and\n      p.getType().refersTo(fd.getDeclaringClass())\n    )\n  )\n}\n\nfrom FriendDecl fd\nwhere\n  not implicitConvOnFirstParm(fd.getFriend()) and\n  not multiFriend(fd.getFriend())\nselect fd,\n  \"AV Rule 70: Friend declarations will only be used if the friend is unable to be a member of the class for logical or efficiency reasons.\"",
        "description": "A class will have friends only when a function or object requires access to the private elements of the class, but is unable to be a member of the class for logical or efficiency reasons.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 70.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate derivesVirtual(Class c, Class base) {\n  exists(ClassDerivation d |\n    d.getDerivedClass() = c and\n    d.getBaseClass() = base and\n    d.hasSpecifier(\"virtual\")\n  )\n}\n\npredicate derivesVirtualStar(Class c, Class base) {\n  derivesVirtual(c, base) or derivesVirtualStar(c.getABaseClass(), base)\n}\n\nfrom Class c, Class base\nwhere\n  c.getABaseClass+() = base and\n  derivesVirtualStar(c, base) and\n  not derivesVirtual(c, base)\nselect c, \"AV Rule 88.1: The virtual base \" + base.getName() + \" shall be explicitly declared.\"",
        "description": "A stateful virtual base shall be explicitly declared in each derived class that accesses it. Explicitly declaring a stateful virtual base at each level in a hierarchy (where that base is used), documents that fact that no assumptions can be made with respect to the exclusive use of the data contained within the virtual base.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 88.1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate thisCall(FunctionCall c) {\n  c.getQualifier() instanceof ThisExpr or\n  c.getQualifier().(PointerDereferenceExpr).getChild(0) instanceof ThisExpr\n}\n\npredicate virtualThisCall(FunctionCall c, Function overridingFunction) {\n  c.isVirtual() and\n  thisCall(c) and\n  overridingFunction = c.getTarget().(VirtualFunction).getAnOverridingFunction()\n}\n\n\npredicate nonVirtualMember(MemberFunction mf, Class c) {\n  mf = c.getAMemberFunction() and\n  not mf instanceof Constructor and\n  not mf instanceof Destructor and\n  not mf.isVirtual()\n}\n\npredicate callFromNonVirtual(MemberFunction source, Class c, MemberFunction targ) {\n  exists(FunctionCall fc |\n    fc.getEnclosingFunction() = source and fc.getTarget() = targ and thisCall(fc)\n  ) and\n  targ = c.getAMemberFunction() and\n  nonVirtualMember(source, c)\n}\n\npragma[noopt]\npredicate indirectlyCallsVirtualFunction(MemberFunction caller, Function target, Class c) {\n  exists(FunctionCall fc |\n    virtualThisCall(fc, _) and\n    fc.getEnclosingFunction() = caller and\n    fc.getTarget() = target and\n    nonVirtualMember(caller, c)\n  )\n  or\n  exists(MemberFunction mid |\n    indirectlyCallsVirtualFunction(mid, target, c) and\n    callFromNonVirtual(caller, c, mid)\n  )\n}\n\nfrom FunctionCall call, string explanation, Function virtFunction, Function overridingFunction\nwhere\n  (\n    call.getEnclosingFunction() instanceof Constructor or\n    call.getEnclosingFunction() instanceof Destructor\n  ) and\n  (\n    (\n      virtualThisCall(call, overridingFunction) and\n      explanation =\n        \"Call to virtual function $@ which is overridden in $@. If you intend to statically call this virtual function, it should be qualified with \"\n          + virtFunction.getDeclaringType().toString() + \"::.\"\n    ) and\n    virtFunction = call.getTarget() and\n    overridingFunction.getDeclaringType().getABaseClass+() =\n      call.getEnclosingFunction().getDeclaringType()\n    or\n    exists(VirtualFunction target |\n      thisCall(call) and indirectlyCallsVirtualFunction(call.getTarget(), target, _)\n    |\n      explanation =\n        \"Call to function \" + call.getTarget().getName() +\n          \" that calls virtual function $@ (overridden in $@).\" and\n      virtFunction = target and\n      overridingFunction = target.getAnOverridingFunction() and\n      overridingFunction.getDeclaringType().getABaseClass+() =\n        call.getEnclosingFunction().getDeclaringType()\n    )\n  )\nselect call, explanation, virtFunction, virtFunction.getName(), overridingFunction,\n  overridingFunction.getDeclaringType().getName()",
        "description": "Virtual functions should not be invoked from a constructor or destructor of the same class. Confusingly, virtual functions are resolved statically (not dynamically) in constructors and destructors for the same class. The call should be made explicitly static by qualifying it using the scope resolution operator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 71.1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate containsArray(Type t) {\n  t instanceof ArrayType\n  or\n  containsArray(t.(PointerType).getBaseType())\n  or\n  containsArray(t.(SpecifiedType).getBaseType())\n  or\n  containsArray(t.getUnderlyingType()) and\n  not exists(TypedefType allowed | allowed = t |\n    allowed.hasGlobalOrStdName(\"jmp_buf\") or\n    allowed.hasGlobalOrStdName(\"va_list\")\n  )\n}\n\npredicate functionApiViolation(MemberFunction f) {\n  f.isPublic() and\n  containsArray(f.getAParameter().getType())\n}\n\nfrom MemberFunction m\nwhere\n  functionApiViolation(m) and\n  not m.getDeclaringType() instanceof Struct\nselect m, \"Raw arrays should not be used in interfaces. A container class should be used instead.\"",
        "description": "Arrays should not be used in interfaces. Arrays degenerate to pointers when passed as parameters. This array decay problem has long been known to be a source of errors. Consider using std::vector or encapsulating the array in an Array class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 97.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// find assignment to non-static member variable in constructor, where that variable is\n// not also initialised through the member initialisation list\nfrom Assignment ass, Field mv, Constructor ctor\nwhere\n  ass.getEnclosingFunction() = ctor and\n  mv.getDeclaringType() = ctor.getDeclaringType() and\n  ass.getLValue().(Access).getTarget() = mv and\n  not exists(ConstructorFieldInit cfi | cfi = ctor.getAnInitializer() | cfi.getTarget() = mv)\nselect ass,\n  \"AV Rule 74: Nonstatic members will be initialized through the member initialization list, not through assignment.\"",
        "description": "Initialization of nonstatic class members will be performed through the member initialization list rather than through assignment in the body of a constructor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 74.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate compatible(Type t1, Type t2) {\n  t1 = t2 or\n  compatible(t1.(DerivedType).getBaseType().getUnspecifiedType(),\n    t2.(DerivedType).getBaseType().getUnspecifiedType())\n}\n\npredicate baseElement(ArrayType t, Type e) {\n  t.getBaseType() instanceof ArrayType and baseElement(t.getBaseType(), e)\n  or\n  not t.getBaseType() instanceof ArrayType and e = t.getBaseType()\n}\n\nfrom Expr e, Class cl\nwhere\n  e.getType() instanceof ArrayType and\n  exists(FunctionCall c, int i, Function f |\n    c.getArgument(i) = e and\n    c.getTarget() = f and\n    exists(f.getParameter(i)) and // varargs\n    baseElement(e.getType(), cl) and // only interested in arrays with classes\n    not compatible(f.getParameter(i).getUnspecifiedType(), e.getUnspecifiedType())\n  )\nselect e, \"AV Rule 96: Arrays shall not be teated polymorphically.\"",
        "description": "Arrays shall not be treated polymorphically. Array indexing in C/C++ is implemented as pointer arithmetic. Hence, a[i] is equivalent to a+i*SIZEOF(array element). Since derived classes are often larger than base classes, polymorphism and pointer arithmetic are not compatible techniques.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 96.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Diagnostic d\nwhere d.hasTag(\"out_of_order_ctor_init\")\nselect d,\n  \"AV Rule 75: Members of the initialization list shall be listed in the order in which they are declared in the class.\"",
        "description": "Members of the initialization list shall be listed in the order in which they are declared in the class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 75.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate callOnThis(FunctionCall fc) {\n  // `this->f(...)`\n  fc.getQualifier() instanceof ThisExpr\n  or\n  // `(*this).f(...)`\n  fc.getQualifier().(PointerDereferenceExpr).getChild(0) instanceof ThisExpr\n}\n\npredicate pointerThis(Expr e) {\n  e instanceof ThisExpr\n  or\n  // `f(...)`\n  // (includes `this = ...`, where `=` is overloaded so a `FunctionCall`)\n  exists(FunctionCall fc | fc = e and callOnThis(fc) | returnsPointerThis(fc.getTarget()))\n  or\n  // `this = ...` (where `=` is not overloaded, so an `AssignExpr`)\n  pointerThis(e.(AssignExpr).getLValue())\n}\n\npredicate dereferenceThis(Expr e) {\n  pointerThis(e.(PointerDereferenceExpr).getChild(0))\n  or\n  // `f(...)`\n  // (includes `*this = ...`, where `=` is overloaded so a `FunctionCall`)\n  exists(FunctionCall fc | fc = e and callOnThis(fc) | returnsDereferenceThis(fc.getTarget()))\n  or\n  // `*this = ...` (where `=` is not overloaded, so an `AssignExpr`)\n  dereferenceThis(e.(AssignExpr).getLValue())\n  or\n  // `e ? ... : ... `\n  exists(ConditionalExpr cond |\n    cond = e and\n    dereferenceThis(cond.getThen()) and\n    dereferenceThis(cond.getElse())\n  )\n  or\n  // `..., ... `\n  dereferenceThis(e.(CommaExpr).getRightOperand())\n}\n\npredicate returnsPointerThis(Function f) {\n  forall(ReturnStmt s | s.getEnclosingFunction() = f and reachable(s) |\n    // `return this`\n    pointerThis(s.getExpr())\n  )\n}\n\npredicate returnsDereferenceThis(Function f) {\n  forall(ReturnStmt s | s.getEnclosingFunction() = f and reachable(s) |\n    // `return *this`\n    dereferenceThis(s.getExpr())\n  )\n}\n\npredicate assignOperatorWithWrongType(Operator op, string msg) {\n  op.hasName(\"operator=\") and\n  exists(op.getBlock()) and\n  exists(Class c |\n    c = op.getDeclaringType() and\n    op.getUnspecifiedType() = c and\n    msg =\n      \"Assignment operator in class \" + c.getName() + \" should have return type \" + c.getName() +\n        \"&. Otherwise a copy is created at each call.\"\n  )\n}\n\npredicate assignOperatorWithWrongResult(Operator op, string msg) {\n  op.hasName(\"operator=\") and\n  not returnsDereferenceThis(op) and\n  exists(op.getBlock()) and\n  not op.getType() instanceof VoidType and\n  not assignOperatorWithWrongType(op, _) and\n  msg =\n    \"Assignment operator in class \" + op.getDeclaringType().getName() +\n      \" does not return a reference to *this.\"\n}\n\nfrom Operator op, string msg\nwhere\n  (\n    assignOperatorWithWrongType(op, msg) or\n    assignOperatorWithWrongResult(op, msg)\n  ) and\n  // exclude code in templates which may be incomplete\n  not op.isFromUninstantiatedTemplate(_)\nselect op, msg",
        "description": "An assignment operator should return a reference to *this. Both the standard library types and the built-in types behave in this manner.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 82.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\n\npredicate memberDirectlyNeedsVariable(MemberFunction mf, Class c, MemberVariable mv) {\n  (mf.isPublic() or mf.isProtected()) and\n  c = mf.getDeclaringType() and\n  c = mv.getDeclaringType() and\n  exists(VariableAccess va |\n    va = mv.getAnAccess() and\n    not exists(Assignment a | va = a.getLValue()) and\n    va.getEnclosingFunction() = mf\n  )\n}\n\npredicate memberNeedsVariable(MemberFunction mf, Class c, MemberVariable mv) {\n  memberDirectlyNeedsVariable(mf, c, mv)\n  or\n  exists(MemberFunction mf2 |\n    memberNeedsVariable(mf2, c, mv) and\n    mf.getDeclaringType() = c and\n    (mf.isPublic() or mf.isProtected()) and\n    mf.calls(mf2)\n  )\n}\n\n\npredicate memberDirectlyInitialisesVariable(MemberFunction mf, Class c, MemberVariable mv) {\n  c = mf.getDeclaringType() and\n  c = mv.getDeclaringType() and\n  mv.getAnAssignedValue().getEnclosingFunction() = mf\n}\n\npredicate memberInitialisesVariable(MemberFunction mf, Class c, MemberVariable mv) {\n  memberDirectlyInitialisesVariable(mf, c, mv)\n  or\n  exists(MemberFunction mf2 |\n    memberDirectlyInitialisesVariable(_, c, mv) and // (optimizer hint)\n    memberInitialisesVariable(mf2, c, mv) and\n    mf.getDeclaringType() = c and\n    mf.calls(mf2)\n  )\n}\n\n\npredicate preInitialises(Constructor c, MemberVariable mv) {\n  exists(ConstructorFieldInit cfi | cfi = c.getAnInitializer() | cfi.getTarget() = mv)\n}\n\npredicate exprInitialises(Constructor c, ControlFlowNode cf, MemberVariable mv) {\n  cf.getControlFlowScope() = c and\n  (\n    cf.(Assignment).getLValue() = mv.getAnAccess() or\n    memberInitialisesVariable(cf.(FunctionCall).getTarget(), c.getDeclaringType(), mv)\n  )\n}\n\npredicate initialises(Constructor c, MemberVariable mv) {\n  exprInitialises(c, _, mv) or\n  preInitialises(c, mv)\n}\n\npredicate doesNotInitialise(Constructor c, MemberVariable mv) {\n  mv.getDeclaringType() = c.getDeclaringType() and\n  not initialises(c, mv)\n}\n\n\npredicate reachableWithoutInitialising(Constructor c, ControlFlowNode cf, MemberVariable mv) {\n  not preInitialises(c, mv) and\n  (\n    cf = c.getBlock()\n    or\n    exists(ControlFlowNode mid |\n      reachableWithoutInitialising(c, mid, mv) and\n      cf = mid.getASuccessor() and\n      not exprInitialises(c, cf, mv)\n    )\n  )\n}\n\npredicate badCall(Constructor c, FunctionCall call, MemberVariable mv) {\n  reachableWithoutInitialising(c, call, mv) and\n  memberNeedsVariable(call.getTarget(), c.getDeclaringType(), mv)\n}\n\n\nfrom Element e, MemberVariable mv, string message\nwhere\n  doesNotInitialise(e, mv) and\n  message = \"Constructor does not initialize member variable \" + mv.getName() + \".\"\n  or\n  badCall(_, e, mv) and\n  message = \"Constructor calls function using \" + mv.getName() + \" before it is initialized.\"\nselect e, \"AV Rule 71: \" + message",
        "description": "Calls to an externally visible operation of an object, other than its constructors, shall not be allowed until the object has been fully initialized.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 71.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom CopyConstructor f\nwhere\n  f.getNumberOfParameters() > 1 and\n  not f.mayNotBeCopyConstructorInInstantiation()\nselect f,\n  f.getName() +\n    \" is signature-compatible with a copy constructor when its default arguments are taken into account.\"",
        "description": "Constructors with default arguments should not be signature-compatible with a copy constructor when their default arguments are taken into account.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 77.1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate derivesVirtual(Class c, Class base) {\n  exists(ClassDerivation d |\n    d.getDerivedClass() = c and\n    d.getBaseClass() = base and\n    d.hasSpecifier(\"virtual\")\n  )\n  or\n  derivesVirtual(c.getABaseClass(), base)\n}\n\npredicate derivesNonVirtual(Class c, Class base) {\n  exists(ClassDerivation d |\n    d.getDerivedClass() = c and\n    d.getBaseClass() = base and\n    not d.hasSpecifier(\"virtual\")\n  )\n  or\n  derivesNonVirtual(c.getABaseClass(), base)\n}\n\nfrom Class c, Class base\nwhere\n  c.getABaseClass+() = base and\n  derivesVirtual(c, base) and\n  derivesNonVirtual(c, base)\nselect c,\n  \"AV Rule 89: The base class \" + base.getName() + \" is derived both virtual and non-virtual.\"",
        "description": "A base class shall not be both virtual and non-virtual in the same hierarchy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 89.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass InterfaceClass extends Class {\n  InterfaceClass() {\n    exists(MemberFunction m |\n      m.getDeclaringType() = this and not compgenerated(unresolveElement(m))\n    ) and\n    forall(MemberFunction m |\n      m.getDeclaringType() = this and not compgenerated(unresolveElement(m))\n    |\n      m instanceof PureVirtualFunction\n    ) and\n    count(MemberVariable v | v.getDeclaringType() = this) < 3\n  }\n}\n\nclass InterfaceImplementor extends Class {\n  InterfaceImplementor() {\n    exists(ClassDerivation d |\n      d.getDerivedClass() = this and d.getBaseClass() instanceof InterfaceClass\n    )\n  }\n\n  int getNumInterfaces() {\n    result =\n      count(ClassDerivation d |\n        d.getDerivedClass() = this and d.getBaseClass() instanceof InterfaceClass\n      )\n  }\n\n  int getNumProtectedImplementations() {\n    result =\n      count(ClassDerivation d |\n        d.hasSpecifier(\"protected\") and\n        d.getDerivedClass() = this and\n        not d.getBaseClass() instanceof InterfaceClass\n      )\n  }\n\n  int getNumPrivateImplementations() {\n    result =\n      count(ClassDerivation d |\n        d.hasSpecifier(\"private\") and\n        d.getDerivedClass() = this and\n        not d.getBaseClass() instanceof InterfaceClass\n      )\n  }\n\n  int getNumPublicImplementations() {\n    result =\n      count(ClassDerivation d |\n        d.hasSpecifier(\"public\") and\n        d.getDerivedClass() = this and\n        not d.getBaseClass() instanceof InterfaceClass\n      )\n  }\n}\n\nfrom InterfaceImplementor d\nwhere\n  d.getNumPublicImplementations() > 0 or\n  d.getNumProtectedImplementations() > 1\nselect d,\n  \"Multiple inheritance should not be used with \" + d.getNumInterfaces().toString() +\n    \" interfaces, \" + d.getNumPrivateImplementations().toString() + \" private implementations, \" +\n    d.getNumProtectedImplementations().toString() + \" protected implementations, and \" +\n    d.getNumPublicImplementations().toString() + \" public implementations.\"",
        "description": "Multiple inheritance should only be used in the following restricted form: n interfaces plus m private implementations, plus at most one protected implementation. Multiple inheritance can lead to complicated inheritance hierarchies that are difficult to comprehend and maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.10 Classes/AV Rule 88.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate subtype(Type sub, Type sup) {\n  sub.getUnderlyingType().(Class).getABaseClass+() = sup.getUnderlyingType()\n}\n\nfrom Expr e, Type declared, Type converted\nwhere\n  e.fromSource() and\n  declared = e.getUnderlyingType() and\n  converted = e.getActualType() and\n  (\n    subtype(converted.(ReferenceType).getBaseType(), declared.(ReferenceType).getBaseType())\n    or\n    subtype(converted.(PointerType).getBaseType(), declared.(PointerType).getBaseType())\n  )\nselect e, \"AV Rule 178: Down casting shall only be allowed through virtual functions.\"",
        "description": "Down casting (casting from base to derived class) shall only be allowed through virtual functions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.23 Type Conversions/AV Rule 178.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Expr e, Class declared, Class converted, Class sub, Class sup\nwhere\n  e.fromSource() and\n  declared = e.getUnderlyingType().(PointerType).getBaseType().getUnderlyingType() and\n  converted = e.getActualType().(PointerType).getBaseType().getUnderlyingType() and\n  converted.getABaseClass*() = sub and\n  sub.hasVirtualBaseClass(sup) and\n  sup.getABaseClass*() = declared\nselect e,\n  \"AV Rule 179: A pointer to a virtual base class shall not be converted to a pointer to a derived class.\"",
        "description": "A pointer to a virtual base class shall not be converted to a pointer to a derived class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.23 Type Conversions/AV Rule 179.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Expr e, Conversion c\nwhere\n  e.fromSource() and\n  c = e.getConversion() and\n  not c instanceof ParenthesisExpr and\n  not c.isCompilerGenerated() and\n  c.getUnderlyingType() = e.getUnderlyingType()\nselect c.findRootCause(), \"AV Rule 181: Redundant explicit casts will not be used.\"",
        "description": "Redundant explicit casts will not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.23 Type Conversions/AV Rule 181.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Cast c\nwhere\n  c.fromSource() and\n  c.getFile() instanceof CppFile and // Ignore C-style casts in C files\n  not c instanceof ConstCast and\n  not c instanceof ReinterpretCast and\n  not c instanceof StaticCast\nselect c.findRootCause(),\n  \"AV Rule 184: C++ style casts shall be used instead of the traditional C-style casts.\"",
        "description": "C++ style casts (const_cast, reinterpret_cast, and static_cast) shall be used instead of the traditional C-style cast.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.23 Type Conversions/AV Rule 185.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// extend to allow certain conversions\npredicate necessaryFloatToIntConversion(Expr e) { none() }\n\npredicate badConversion(Expr e) {\n  e.fromSource() and\n  e.getUnderlyingType() instanceof FloatingPointType and\n  e.getActualType() instanceof IntegralType and\n  not necessaryFloatToIntConversion(e)\n}\n\nfrom Expr e\nwhere\n  badConversion(e) and\n  // Only include outermost matches; no need to be transitive\n  // (should report an expr if a distant parent is a violation\n  //  but the exprs in between are fine). Exclude brackets\n  not badConversion(e.getParent()) and\n  not e instanceof ParenthesisExpr\nselect e, \"AV Rule 184: Floating point numbers shall not be converted to integers.\"",
        "description": "Floating point numbers shall not be converted to integers, unless such a conversion is a specified algorithmic requirement or is necessary for a hardware interface.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.23 Type Conversions/AV Rule 184.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass IntConstantExpr extends Expr {\n  IntConstantExpr() {\n    this.getType() instanceof IntegralType and\n    exists(this.getValue())\n  }\n\n  int getIntValue() { result = this.getValue().toInt() }\n\n  predicate isNegative() { this.getIntValue() < 0 }\n\n  /**\n   * Find out how many (8, 16, 32, 64) bits are required.\n   *      FIXME Currently only works up to 32 bits\n   */\n  int getRequiredSizeBits() {\n    exists(int value |\n      value = this.getIntValue() and\n      (\n        value < -32768 and result = 32\n        or\n        value >= -32768 and value < -128 and result = 16\n        or\n        value >= -128 and value < 0 and result = 8\n        or\n        value >= 0 and value < 128 and result = 7\n        or\n        value >= 128 and value < 256 and result = 8\n        or\n        value >= 256 and value < 32768 and result = 15\n        or\n        value >= 32768 and value < 65536 and result = 16\n        or\n        value >= 65536 and value <= 2147483647 and result = 31\n        or\n        value > 2147483647 and result = 32\n      )\n    )\n  }\n}\n\nclass ImplicitConversion extends Expr {\n  ImplicitConversion() { super.hasImplicitConversion() }\n\n  Type getUnderlyingSourceType() { result = this.getUnderlyingType() }\n\n  Type getUnderlyingTargetType() { result = this.getConversion().getUnderlyingType() }\n\n  int getSourceSize() {\n    if this instanceof IntConstantExpr\n    then result = this.(IntConstantExpr).getRequiredSizeBits()\n    else result = this.getUnderlyingSourceType().getSize() * 8\n  }\n\n  int getTargetSize() { result = this.getUnderlyingTargetType().getSize() * 8 }\n\n  predicate isSourceSignedInt() {\n    if this instanceof IntConstantExpr\n    then this.(IntConstantExpr).isNegative()\n    else this.getUnderlyingSourceType().(IntegralType).isSigned()\n  }\n\n  predicate isTargetSignedInt() { this.getUnderlyingTargetType().(IntegralType).isSigned() }\n}\n\nclass LossyImplicitConversion extends ImplicitConversion {\n  LossyImplicitConversion() {\n    // conversion to smaller type\n    super.getTargetSize() < super.getSourceSize()\n    or\n    // signed to unsigned conversion\n    super.isSourceSignedInt() and not super.isTargetSignedInt()\n    or\n    // unsigned to signed conversion without increasing size\n    not super.isSourceSignedInt() and\n    super.isTargetSignedInt() and\n    super.getTargetSize() = super.getSourceSize()\n    or\n    // floating-integral conversion\n    super.getUnderlyingSourceType() instanceof FloatingPointType and\n    super.getUnderlyingTargetType() instanceof IntegralType\n    or\n    // integral-floating conversion\n    super.getUnderlyingSourceType() instanceof IntegralType and\n    super.getUnderlyingTargetType() instanceof FloatingPointType\n  }\n}\n\nfrom LossyImplicitConversion lic\nwhere\n  // Conversions to bool are always fine\n  not lic.getUnderlyingTargetType() instanceof BoolType\nselect lic,\n  \"AV Rule 180: implicit conversion from \" + lic.getUnderlyingSourceType().toString() + \" to \" +\n    lic.getUnderlyingTargetType().toString() + \" may lose information.\"",
        "description": "Implicit conversions that may result in a loss of information shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.23 Type Conversions/AV Rule 180.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass NullPointer extends Expr {\n  NullPointer() {\n    this.getValue() = \"0\" and this.getType() instanceof IntegralType\n    or\n    this instanceof NULL\n  }\n}\n\nfrom Expr e, Type t1, Type t2\nwhere\n  t1 = e.getUnspecifiedType() and\n  t2 = e.getFullyConverted().getUnspecifiedType() and\n  t1 != t2 and\n  (t1 instanceof PointerType or t2 instanceof PointerType) and\n  not (t2 instanceof VoidPointerType and t1 instanceof PointerType) and\n  // Conversion to bool type is always fine\n  not t2 instanceof BoolType and\n  // Ignore assigning NULL to a pointer\n  not e instanceof NullPointer and\n  // Allow array -> pointer conversion\n  not t1.(ArrayType).getBaseType() = t2.(PointerType).getBaseType()\nselect e,\n  \"AV Rule 182: illegal cast from type \" + t1.toString() + \" to type \" + t2.toString() +\n    \". Casting to or from pointers shall not be used.\"",
        "description": "Type casting from any type to or from pointers shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.23 Type Conversions/AV Rule 182.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom CommaExpr ce\nwhere\n  ce.fromSource() and\n  not exists(MacroInvocation me | ce = me.getAnAffectedElement())\nselect ce, \"AV Rule 168: The comma operator shall not be used.\"",
        "description": "The comma operator shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 168.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom BinaryLogicalOperation blo, BinaryOperation bo\nwhere\n  blo.fromSource() and\n  bo = blo.getAnOperand() and\n  not bo.isParenthesised()\nselect blo,\n  \"AV Rule 158: The operands of a logical && or || operator shall be parenthesized if the operands contain binary operators.\"",
        "description": "The operands of a logical && or || operator shall be parenthesized if the operands contain binary operators.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 158.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function o, string message\nwhere\n  o.getName() = \"operator&&\" and\n  message =\n    \"AV Rule 159: the && operator shall not be overloaded as short-circuit semantics cannot be obtained.\"\n  or\n  o.getName() = \"operator||\" and\n  message =\n    \"AV Rule 159: the || operator shall not be overloaded as short-circuit semantics cannot be obtained.\"\n  or\n  o.getName() = \"operator&\" and\n  o.getNumberOfParameters() = 1 and\n  message =\n    \"AV Rule 159: the unary & operator shall not be overloaded because of undefined behavior.\"\nselect o, message",
        "description": "Operators ||, &&, and unary & shall not be overloaded",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 159.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate excluded(Expr e) {\n  // Don't bother with literals - signed/unsigned is less meaningful there\n  e instanceof Literal\n}\n\npredicate isSignedOperand(Expr e) {\n  e.getExplicitlyConverted().getUnderlyingType().(IntegralType).isSigned() and\n  not excluded(e)\n}\n\npredicate isUnsignedOperand(Expr e) {\n  e.getExplicitlyConverted().getUnderlyingType().(IntegralType).isUnsigned() and\n  not excluded(e)\n}\n\nfrom BinaryOperation op\nwhere\n  (op instanceof BinaryArithmeticOperation or op instanceof ComparisonOperation) and\n  isSignedOperand(op.getAnOperand()) and\n  isUnsignedOperand(op.getAnOperand())\nselect op,\n  \"AV Rule 162: signed and unsigned values shall not be mixed in arithmetic or comparison operations.\"",
        "description": "Signed and unsigned values shall not be mixed in arithmetic or comparison operations. Mixing signed and unsigned values is error prone as it subjects operations to numerous arithmetic conversion and integral promotion rules.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 162.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport jsf.lib.section_4_21_Operators.AV_Rule_166\n\nfrom SizeofImpureExprOperator sz\nselect sz,\n  \"A sizeof operator should not be used on expressions that contain side effects as the effect is confusing.\"",
        "description": "The sizeof operator should not be used on expressions that contain side effects. It is subtle whether the side effects will occur or not.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 166.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom BinaryLogicalOperation blo\nwhere\n  blo.fromSource() and\n  not blo.getRightOperand().isPure()\nselect blo,\n  \"AV Rule 157: The right hand operand of a && or || operator shall not contain side effects.\"",
        "description": "The right hand operand of a && or || operator shall not contain side effects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 157.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate excluded(Expr e) {\n  // Don't bother with literals - signed/unsigned is less meaningful there\n  e instanceof Literal\n}\n\npredicate isUnsignedOperand(Expr e) {\n  e.getUnderlyingType().(IntegralType).isUnsigned() and\n  not excluded(e)\n}\n\nfrom BinaryOperation op\nwhere\n  op instanceof BinaryArithmeticOperation and\n  isUnsignedOperand(op.getChild(0)) and\n  isUnsignedOperand(op.getChild(1))\nselect op, \"AV Rule 163: unsigned arithmetic shall not be used.\"",
        "description": "Unsigned arithmetic shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 163.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate possibleValue(Variable v, Expr value) {\n  v.getInitializer().getExpr() = value or\n  value = v.getAnAssignedValue()\n}\n\npredicate constantValue(Expr e, int value) {\n  e.getUnspecifiedType() instanceof IntegralType and\n  (\n    // Either the expr has a constant value\n    value = e.getValue().toInt()\n    or\n    // The expr is a variable access and all values of the variable are constant\n    exists(VariableAccess va |\n      va = e and\n      forall(Expr init | possibleValue(va.getTarget(), init) | constantValue(init, _)) and\n      exists(Expr init | possibleValue(va.getTarget(), init) | constantValue(init, value))\n    )\n  )\n}\n\npredicate violation(BinaryBitwiseOperation op, int lhsBytes, int value) {\n  (op instanceof LShiftExpr or op instanceof RShiftExpr) and\n  constantValue(op.getRightOperand(), value) and\n  lhsBytes = op.getLeftOperand().getExplicitlyConverted().getType().getSize() and\n  (value < 0 or value >= lhsBytes * 8)\n}\n\nfrom BinaryBitwiseOperation op, int lhsBytes, int canonicalValue\nwhere canonicalValue = min(int v | violation(op, lhsBytes, v))\nselect op,\n  \"AV Rule 164: The right-hand operand (here a value is \" + canonicalValue.toString() +\n    \") of this shift shall lie between 0 and \" + (lhsBytes * 8 - 1).toString() + \".\"",
        "description": "The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the left-hand operand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 164.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate multipleAssignExpr(Expr e) {\n  e instanceof AssignExpr\n  or\n  exists(CommaExpr ce | ce = e |\n    multipleAssignExpr(ce.getLeftOperand()) and\n    multipleAssignExpr(ce.getRightOperand())\n  )\n}\n\nclass MultipleAssignExpr extends Expr {\n  MultipleAssignExpr() { multipleAssignExpr(this) }\n\n  Assignment getAnAssignment() { result = this.getAChild*() }\n}\n\nclass ForStmtSideEffectExpr extends Expr {\n  ForStmtSideEffectExpr() {\n    exists(ForStmt stmt |\n      this = stmt.getUpdate() or\n      this = stmt.getInitialization().getAChild().(MultipleAssignExpr).getAnAssignment()\n    )\n  }\n}\n\nfrom AssignExpr ae\nwhere\n  ae.fromSource() and\n  not ae.getParent() instanceof ExprStmt and\n  not ae instanceof ForStmtSideEffectExpr\nselect ae,\n  \"AV Rule 160: An assignment expression shall be used only as the expression in an expression statement.\"",
        "description": "An assignment expression shall be used only as the expression in an expression statement.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 160.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom UnaryMinusExpr ume\nwhere\n  ume.getOperand().getExplicitlyConverted().getUnderlyingType().(IntegralType).isUnsigned() and\n  not ume.getOperand() instanceof Literal\nselect ume, \"The unary minus operator should not be applied to an unsigned expression.\"",
        "description": "The unary minus operator should not be applied to unsigned expressions - cast the expression to a signed type to avoid unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.21 Operators/AV Rule 165.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// flag switch statements where every non-default case dispatches on an integer constant\nfrom SwitchStmt s\nwhere\n  forex(SwitchCase sc | sc = s.getASwitchCase() and not sc instanceof DefaultCase |\n    sc.getExpr().(VariableAccess).getTarget().isConst()\n  ) and\n  // Allow switch on character types\n  not s.getExpr().getUnspecifiedType() instanceof CharType\nselect s,\n  \"Enumeration types should be used instead of integers to select from a limited series of choices.\"",
        "description": "Enumeration types should be used instead of integer types (and constants) to select from a limited series of choices.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.17 Types/AV Rule 148.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nclass GeneralPointerType extends DerivedType {\n  GeneralPointerType() { this instanceof PointerType or this instanceof ArrayType }\n}\n\nclass InvalidFloatCastExpr extends Expr {\n  InvalidFloatCastExpr() {\n    exists(Type src, Type dst |\n      src = this.getUnspecifiedType() and\n      dst = this.getFullyConverted().getUnspecifiedType() and\n      src.(GeneralPointerType).getBaseType() instanceof FloatingPointType and\n      src.(GeneralPointerType).getBaseType() != dst.(GeneralPointerType).getBaseType()\n    )\n  }\n}\n\nclass FloatUnion extends Union {\n  FloatUnion() {\n    exists(MemberVariable mv |\n      this.getAMemberVariable() = mv and\n      mv.getType().getUnderlyingType() instanceof FloatingPointType\n    ) and\n    exists(MemberVariable mv |\n      this.getAMemberVariable() = mv and\n      not mv.getType().getUnderlyingType() instanceof FloatingPointType\n    )\n  }\n\n  MemberVariable getAFloatMember() {\n    result = this.getAMemberVariable() and\n    result.getType().getUnderlyingType() instanceof FloatingPointType\n  }\n}\n\nfrom Element e, string message\nwhere\n  e instanceof InvalidFloatCastExpr and\n  message =\n    \"Casting a float pointer to another pointer type exposes the bit representation of the float, leading to unportable code.\"\n  or\n  exists(FloatUnion fu | e = fu.getAFloatMember()) and\n  message =\n    \"Defining a union with a float member exposes the bit representation of the float, leading to unportable code.\"\nselect e, message",
        "description": "The underlying bit representation of floating point numbers should not be used in any way by the programmer. This leads to non-portable and hard to maintain code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.17 Types/AV Rule 147.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass ParamLoc extends Parameter {\n  int getValidLine() {\n    result = this.getLocation().getStartLine() and result = this.getLocation().getEndLine()\n  }\n}\n\npredicate valid(Function f) {\n  // Check that the first parameter is okay\n  f.getParameter(0).(ParamLoc).getValidLine() = f.getLocation().getStartLine() and\n  // Check that each subsequent parameter is on its own line\n  not exists(ParamLoc p1, ParamLoc p2 |\n    p1 = f.getAParameter() and\n    p2 = f.getAParameter() and\n    p1 != p2 and\n    p1.getValidLine() = p2.getValidLine()\n  ) and\n  // Check that there are no parameters on two lines\n  forall(ParamLoc p | p = f.getAParameter() | exists(p.getValidLine()))\n}\n\nfrom Function f\nwhere\n  f.getNumberOfParameters() > 2 and\n  f.hasDefinition() and\n  not valid(f)\nselect f,\n  \"AV Rule 58: functions with more than two parameters will conform to style rules for declaring parameters.\"",
        "description": "When declaring and defining functions with more than two parameters, the leading parenthesis and the first argument will be written on the same line as the function name. Each additional argument will be written on a separate line (with the closing parenthesis directly after the last argument).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 58.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\n// Implement rules (a) and (b)\npredicate canonicalName1(Declaration d, string canonical) {\n  canonical = d.getName().replaceAll(\"_\", \"\").toLowerCase()\n}\n\npredicate canonicalName2(Declaration d, string canonical) {\n  canonical =\n    d.getName()\n        .replaceAll(\"_\", \"\")\n        .replaceAll(\"0\", \"O\")\n        .replaceAll(\"D\", \"O\")\n        .replaceAll(\"1\", \"I\")\n        .replaceAll(\"l\", \"I\")\n        .replaceAll(\"S\", \"5\")\n        .replaceAll(\"Z\", \"2\")\n        .replaceAll(\"n\", \"h\")\n}\n\npredicate same(Declaration d1, Declaration d2) {\n  exists(string common | canonicalName1(d1, common) and canonicalName1(d2, common))\n  or\n  exists(string common | canonicalName2(d1, common) and canonicalName2(d2, common))\n}\n\npredicate local(Declaration d, Function f) {\n  d.(Parameter).getFunction() = f\n  or\n  exists(DeclStmt ds | d = ds.getADeclaration().(LocalVariable) and ds.getEnclosingFunction() = f)\n}\n\npredicate structLocal(Declaration d, Struct s) { d = s.getAMemberVariable() }\n\npredicate compatibleScopes(Declaration d1, Declaration d2) {\n  // Either they're both local to the same struct, or\n  exists(Struct s | structLocal(d1, s) and structLocal(d2, s))\n  or\n  // Neither of them is a struct member and ...\n  not structLocal(d1, _) and\n  not structLocal(d2, _) and\n  same(d1, d2) and\n  (\n    // d2 is global and d1 is either, or\n    not local(d2, _)\n    or\n    // both are local to the same function\n    exists(Function f | local(d1, f) and local(d2, f))\n  )\n}\n\nfrom Declaration d1, Declaration d2\nwhere\n  d1.fromSource() and\n  d2.fromSource() and\n  // Test that the names are confusing according to the above criteria\n  same(d1, d2) and\n  d1.getName() != d2.getName() and\n  (\n    // either they are both type names, or\n    d1 instanceof UserType and d2 instanceof UserType\n    or\n    // they are both variable names in close enough scopes for the confusion to matter\n    d1 instanceof Variable and d2 instanceof Variable and compatibleScopes(d1, d2)\n  )\nselect d1, \"AV Rule 48: this identifier is too close to another identifier (\" + d2.getName() + \").\"",
        "description": "Indentifiers will not differ by: (a) only case, (b) only underscores, (c) O vs 0 and D, (d) I vs 1 and l, (e) S vs 5, (f) Z vs 2, (g) n vs h",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 48.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Stmt parent, Stmt child\nwhere\n  not child instanceof BlockStmt and\n  (\n    child = parent.(IfStmt).getThen()\n    or\n    child = parent.(WhileStmt).getStmt()\n    or\n    child = parent.(DoStmt).getStmt()\n    or\n    child = parent.(ForStmt).getStmt()\n    or\n    child = parent.(IfStmt).getElse() and not child instanceof IfStmt\n  )\nselect child.findRootCause(),\n  \"The statements forming the body of an if, else if, else, while, do...while or for statement shall always be enclosed in braces, even if the braces form an empty block.\"",
        "description": "The statements forming the body of an if, else if, else, while, do-while or for statement shall always be enclosed in braces, even if the braces form an empty block.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 59.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Naming\n\n\nfrom Declaration d, Name n, Word w\nwhere\n  d.fromSource() and\n  n = d.getName() and\n  w = n.getAWord() and\n  w.isDefiniteAcronym() and\n  not w.isUppercase()\nselect d,\n  \"AV Rule 49: acronyms in identifiers will be uppercase. Incorrect case for acronym \" +\n    w.toString() + \".\"",
        "description": "All acronyms in an identifier will be composed of uppercase letters.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 49.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Include i, string name\nwhere\n  name = i.getIncludeText() and\n  name.matches([\"%'%\", \"%\\\\\\\\%\", \"%/*%\", \"%//%\", \"%\\\"%\\\"%\\\"%\", \"%<%\\\"%>%\"])\nselect i, \"AV Rule 53.1: Invalid character sequence in header file name '\" + name + \"'.\"",
        "description": "The following character sequences shall not appear in header file names: ', \\, /*, //, or \".",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 53.1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Naming\n\npredicate relevant(Declaration d, string kind) {\n  d instanceof EnumConstant and kind = \"enumerator\"\n  or\n  d.(Variable).isConst() and kind = \"constant\"\n}\n\nfrom Declaration d, Word w, string kind\nwhere\n  relevant(d, kind) and\n  w = d.getName().(Name).getAWord() and\n  not (w.couldBeUppercaseAcronym() and w != d.getName()) and\n  not w.isLowercase()\nselect d, \"AV Rule 52: identifiers for \" + kind + \" values shall be lowercase.\"",
        "description": "Identifiers for constant and enumerator values shall be lowercase.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 52.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate exprInStmtContext(Expr e, Location l, File f) {\n  e.getParent() instanceof ExprStmt and\n  l = e.getLocation() and\n  f = l.getFile()\n}\n\npredicate overlappingExprs(Expr e1, Expr e2) {\n  exists(Location l1, File f, Location l2 |\n    exprInStmtContext(e1, l1, f) and\n    exprInStmtContext(e2, l2, f) and\n    e1 != e2 and\n    l1.getEndLine() >= l2.getStartLine() and\n    l1.getStartLine() <= l2.getEndLine()\n  )\n}\n\nfrom Expr e\nwhere overlappingExprs(e, _) and not e.isInMacroExpansion()\nselect e, \"AV Rule 42: Each expression-statement will be on a separate line.\"",
        "description": "Each expression-statement will be on a separate line.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 42.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\npredicate longNameSignificance(Element e, string significance) {\n  exists(string name |\n    elementName(e, name) and\n    name.length() > 64 and\n    significance = name.substring(0, 64)\n  )\n}\n\npredicate elementName(Element e, string name) {\n  name = e.(Declaration).getName() or name = e.(Namespace).getName()\n}\n\npredicate clash(Element e1, Element e2) {\n  exists(string significance, string n1, string n2 |\n    longNameSignificance(e1, significance) and\n    longNameSignificance(e2, significance) and\n    elementName(e1, n1) and\n    elementName(e2, n2) and\n    n1 != n2\n  )\n}\n\nfrom Element e1, Element e2, string name\nwhere\n  clash(e1, e2) and\n  elementName(e2, name)\nselect e1, \"AV Rule 46: relies on more than 64 characters to separate from \" + name",
        "description": "User-specified identifiers (internal and external) will not rely on significance of more than 64 characters.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 46.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate hasLocation(Expr e) { e.getLocation().getStartLine() != 0 }\n\npredicate outermostConvWithLocation(Expr e, Expr res) {\n  if exists(Expr p | e.getConversion+() = p and hasLocation(p))\n  then outermostConvWithLocation(e.getConversion(), res)\n  else res = e\n}\n\npredicate diffEndBegin(Expr lhs, Expr rhs, int length) {\n  exists(Location l, Location r |\n    l = lhs.getLocation() and\n    r = rhs.getLocation() and\n    length = r.getStartColumn() - l.getEndColumn() and\n    l.getEndLine() = r.getStartLine()\n  )\n}\n\npredicate diffEndEnd(Expr lhs, Expr rhs, int length) {\n  exists(Location l, Location r |\n    l = lhs.getLocation() and\n    r = rhs.getLocation() and\n    length = r.getEndColumn() - l.getEndColumn() and\n    l.getEndLine() = r.getEndLine()\n  )\n}\n\npredicate diffBeginBegin(Expr lhs, Expr rhs, int length) {\n  exists(Location l, Location r |\n    l = lhs.getLocation() and\n    r = rhs.getLocation() and\n    length = r.getStartColumn() - l.getStartColumn() and\n    l.getStartLine() = r.getStartLine()\n  )\n}\n\n\nfrom Expr err\nwhere\n  not err.isInMacroExpansion() and\n  hasLocation(err) and\n  (\n    exists(Call c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getQualifier(), e) and\n      e.getType() instanceof PointerType and\n      not diffEndBegin(e, c, 3)\n    )\n    or\n    exists(Call c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getQualifier(), e) and\n      not e.getType() instanceof PointerType and\n      not diffEndBegin(e, c, 2)\n    )\n    or\n    exists(VariableAccess c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getQualifier(), e) and\n      e.getType() instanceof PointerType and\n      not diffEndBegin(e, c, 3)\n    )\n    or\n    exists(VariableAccess c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getQualifier(), e) and\n      not e.getType() instanceof PointerType and\n      not diffEndBegin(e, c, 2)\n    )\n    or\n    exists(UnaryOperation c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getOperand(), e) and\n      (\n        c instanceof ComplementExpr or\n        c instanceof NotExpr or\n        c instanceof UnaryMinusExpr or\n        c instanceof UnaryPlusExpr or\n        c instanceof AddressOfExpr\n      ) and\n      not diffBeginBegin(c, e, 1)\n    )\n    or\n    exists(PrefixIncrExpr c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getOperand(), e) and\n      not diffBeginBegin(c, e, 2)\n    )\n    or\n    exists(PrefixDecrExpr c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getOperand(), e) and\n      not diffBeginBegin(c, e, 2)\n    )\n    or\n    exists(PointerDereferenceExpr c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getChild(0), e) and\n      not diffBeginBegin(c, e, 1)\n    )\n    or\n    exists(PostfixIncrExpr c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getOperand(), e) and\n      not diffEndEnd(e, c, 2)\n    )\n    or\n    exists(PostfixDecrExpr c, Expr e |\n      c = err and\n      outermostConvWithLocation(c.getOperand(), e) and\n      not diffEndEnd(e, c, 2)\n    )\n  )\nselect err,\n  \"AV Rule 63: Spaces will not be used around '.' or '->', nor between unary operators and operands.\"",
        "description": "Spaces will not be used around '.' or '->', nor between unary operators and operands.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 63.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c, Declaration m1, Declaration m2, int pos1, int pos2\nwhere\n  m1 = c.getCanonicalMember(pos1) and\n  m2 = c.getCanonicalMember(pos2) and\n  pos1 < pos2 and\n  (\n    m1.hasSpecifier(\"private\") and m2.hasSpecifier(\"protected\")\n    or\n    m1.hasSpecifier(\"private\") and m2.hasSpecifier(\"public\")\n    or\n    m1.hasSpecifier(\"protected\") and m2.hasSpecifier(\"public\")\n  )\nselect c,\n  \"AV Rule 57: The public, protected, and private sections of a class will be declared in that order.\"",
        "description": "The public, protected, and private sections of a class will be declared in that order.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 57.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Declaration d\nwhere\n  d.fromSource() and\n  d.getName().matches(\"\\\\_%\")\nselect d, \"Identifiers will not begin with the underscore character.\"",
        "description": "Identifiers will not begin with the underscore character.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 47.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom File f\nwhere\n  f.getExtension().toLowerCase() = [\"h\", \"hpp\"] and\n  f.getExtension() != \"h\"\nselect f, \"AV Rule 53: Header files will always have a file name extension of .h.\"",
        "description": "Header files will always have a file name extension of .h.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 53.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.09 Style/AV Rule 43.ql\"\nselect d, d.getMessage()",
        "description": "Tabs should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 43.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.09 Style/AV Rule 60.ql\"\nselect d, d.getMessage()",
        "description": "Braces which enclose a block will be placed in the same column, on separate lines directly before and after the block.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 60.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom CppFile f\nwhere f.getExtension() != \"cpp\"\nselect f, \"AV Rule 53: Implementation files will always have a file name extension of .cpp.\"",
        "description": "Implementation files will always have a file name extension of .cpp.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 54.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.09 Style/AV Rule 44.ql\"\nselect d, d.getMessage()",
        "description": "All indentations will be at least two spaces and be consistent within the same source file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 44.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Naming\n\npredicate relevant(Element elem, Element blame, string kind, string name) {\n  exists(Class c | elem = c and blame = c and kind = \"class or struct\" and name = c.getName()) // includes struct\n  or\n  exists(Namespace n |\n    elem = n and blame = n.getADeclarationEntry() and kind = \"namespace\" and name = n.getName()\n  )\n  or\n  exists(Enum e | elem = e and blame = e and kind = \"enumeration\" and name = e.getName())\n  or\n  exists(TypedefType t | elem = t and blame = t and kind = \"typedef\" and name = t.getName())\n}\n\nfrom Element d, Element blame, Word w, int pos, string kind, string name\nwhere\n  relevant(d, blame, kind, name) and\n  w = name.(Name).getWord(pos) and\n  not (w.couldBeUppercaseAcronym() and w != name) and\n  (\n    pos = 0 and not w.isCapitalized()\n    or\n    pos > 0 and not w.isLowercase()\n  )\nselect blame,\n  \"AV Rule 50: The first word of a \" + kind +\n    \" will begin with an uppercase letter, and all other letters will be lowercase.\"",
        "description": "The first word of the name of a class, structure, namespace, enumeration, or type created with typedef will begin with an uppercase letter. All other letters will be lowercase.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 50.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Naming\n\npredicate relevant(Declaration d, string kind) {\n  d instanceof Function and kind = \"function\"\n  or\n  d instanceof Variable and kind = \"variable\"\n}\n\nfrom Declaration d, Word w, string kind\nwhere\n  relevant(d, kind) and\n  w = d.getName().(Name).getAWord() and\n  not (w.couldBeUppercaseAcronym() and w != d.getName()) and\n  not w.isLowercase()\nselect d, \"AV Rule 51: All letters contained in \" + kind + \" names will be lowercase.\"",
        "description": "All letters contained in function and variable names will be lowercase.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 51.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.09 Style/AV Rule 41.ql\"\nselect d, d.getMessage()",
        "description": "Source lines will be kept to a length of 120 characters or less.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 41.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.09 Style/AV Rule 61.ql\"\nselect d, d.getMessage()",
        "description": "Braces which enclose a block will have nothing else on the line except comments (if necessary).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 61.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom Declaration d, string name, string lowerCase, string upperCase, int pos\nwhere\n  name = d.getName() and\n  d.fromSource() and\n  lowerCase = name.charAt(pos) and\n  upperCase = name.charAt(pos + 1) and\n  lowerCase.regexpMatch(\"[a-z]\") and\n  upperCase.regexpMatch(\"[A-Z]\")\nselect d,\n  \"AV Rule 45: All words in an identifier will be separated by the underscore character. Camel-case is not allowed.\"",
        "description": "All words in an identifier will be separated by the underscore character.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.09 Style/AV Rule 45.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass FirstComment extends Comment {\n  FirstComment() {\n    not exists(Locatable l |\n      l != this and\n      shouldNotBeBefore(l) and\n      l.getFile() = this.getFile() and\n      l.getLocation().getEndLine() <= this.getLocation().getStartLine()\n    )\n  }\n\n  /*\n   * Test whether the comment is a reasonable start-of-file comment.\n   * CUSTOMIZATION POINT: INSERT STYLE RULES FOR THE START-OF-FILE COMMENT HERE\n   * Simple checks only - if there is a comment at the beginning of the file, that\n   * is pretty much enough\n   */\n\n  predicate isValid() {\n    // At least 3 lines long: make sure it's a proper comment\n    this.getLocation().getEndLine() >= this.getLocation().getStartLine() + 2 and\n    exists(string contents | contents = this.getContents() |\n      // Make sure the name of the file is included\n      contents.matches(\"%\" + this.getFile().getShortName() + \"%\")\n      // Other checks could go here; for instance containing a standard copyright notice\n    )\n  }\n}\n\npredicate shouldNotBeBefore(Locatable l) {\n  l instanceof Comment or\n  l instanceof Declaration or\n  l instanceof PreprocessorDirective\n}\n\nfrom File f, Element blame, string message\nwhere\n  f.fromSource() and\n  (\n    not exists(FirstComment comment | comment.getFile() = f) and\n    blame = f and\n    message = \"\"\n    or\n    exists(FirstComment comment |\n      comment.getFile() = f and not comment.isValid() and blame = comment\n    ) and\n    message = \"The introductory comment does not match the required style rules.\"\n  )\nselect blame,\n  \"AV Rule 133: every source file will be documented with an introductory comment. \" + message",
        "description": "Every source file will be documented with an introductory comment that provides information on the file name, its contents, and any program-required information (eg. legal statements, copyright information, etc)",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.14 Comments/AV Rule 133.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.ExternalArtifact\n\nfrom DefectExternalData d\nwhere d.getQueryPath() = \"jsf/4.14 Comments/AV Rule 127.ql\"\nselect d, d.getMessage()",
        "description": "Code that is not used (commented out) shall be deleted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.14 Comments/AV Rule 127.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Comment c\nwhere\n  c.fromSource() and\n  not c.getContents().regexpMatch(\"\\\\s*//.*\")\nselect c, \"AV Rule 126: Only valid C++ style comments shall be used.\"",
        "description": "Only valid C++ style comments shall be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.14 Comments/AV Rule 126.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom OctalLiteral l\nwhere\n  l.fromSource() and\n  l.getValue() != \"0\"\nselect l, \"AV Rule 149: Octal constants (other than zero) shall not be used.\"",
        "description": "Octal constants (other than zero) shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.18 Constants/AV Rule 149.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nclass NonConstStringType extends DerivedType {\n  NonConstStringType() {\n    this.(ArrayType).getBaseType() instanceof CharType or\n    this.(PointerType).getBaseType() instanceof CharType\n  }\n}\n\nfrom StringLiteral l\nwhere l.getFullyConverted().getType().getUnderlyingType() instanceof NonConstStringType\nselect l,\n  \"A string literal must not be used as a non-const value: modifying string literals leads to undefined behavior.\"",
        "description": "A string literal must not be modified, as the result is undefined. To ensure this, only variables of type const char * or const char [] can hold string literals.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.18 Constants/AV Rule 151.1.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom HexLiteral l\nwhere\n  l.fromSource() and\n  l.getValueText().regexpMatch(\".*[a-z].*\")\nselect l, \"AV Rule 150: Hexadecimal constants will be represented using all uppercase letters.\"",
        "description": "Hexadecimal constants will be represented using all uppercase letters.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.18 Constants/AV Rule 150.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Literal l\nwhere\n  l.fromSource() and\n  l.getType() instanceof ArithmeticType and\n  not l.isInMacroExpansion() and\n  not l.getParent() instanceof ArrayExpr and\n  not exists(Variable v | v.getInitializer().getExpr() = l) and\n  not exists(Assignment a |\n    a.getLValue() instanceof ArrayExpr and\n    a.getRValue() = l and\n    a.getControlFlowScope() instanceof Constructor\n  ) and\n  not l.getValue() = \"0\" and\n  not l.getValue() = \"1\"\nselect l,\n  \"AV Rule 151: Numeric values in code will not be used; symbolic values will be used instead.\"",
        "description": "Numeric values in code will not be used; symbolic values will be used instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.18 Constants/AV Rule 151.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom Declaration m\nwhere\n  m.isMember() and\n  m.getName().matches(\"(%\") and\n  not m.(BitField).getDeclaredNumBits() = 0\nselect m,\n  \"AV Rule 156: All the members of a structure (or class) shall be named and shall only be accessed via their names.\"",
        "description": "All the members of a structure (or class) shall be named and shall only be accessed via their names.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.20 Unions and Bit Fields/AV Rule 156.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom Union u\nwhere u.fromSource()\nselect u, \"AV Rule 153: Unions shall not be used.\"",
        "description": "Unions shall not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.20 Unions and Bit Fields/AV Rule 153.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom BitField bf\nwhere\n  not bf.getUnspecifiedType().(IntegralType).isUnsigned() and\n  not bf.getUnderlyingType() instanceof Enum and\n  not bf.getUnspecifiedType() instanceof BoolType and\n  not bf.getType().hasName(\"BOOL\") and // At least for C programs on Windows, BOOL is a common typedef for a type representing BoolType.\n  not bf.getDeclaredNumBits() = bf.getType().getSize() * 8 and // If this is true, then there cannot be unsigned sign extension or overflow.\n  not bf.isAnonymous()\nselect bf,\n  \"Bit field \" + bf.getName() + \" of type \" + bf.getUnderlyingType().getName() +\n    \" should have explicitly unsigned integral or enumeration type.\"",
        "description": "Failing to explicitly assign bit fields to unsigned integer or enumeration types may result in unexpected sign extension or overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.20 Unions and Bit Fields/AV Rule 154.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom BitField bf\nwhere\n  not bf.getUnderlyingType() instanceof Enum and\n  not bf.getDeclaredNumBits() = 0\nselect bf, \"AV Rule 155: Bit fields will not be used purely to save space.\"",
        "description": "Bit fields will not be used to pack data into a word for the sole purpose of saving space.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/jsf/4.20 Unions and Bit Fields/AV Rule 155.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ConfigurationTestFile\n\nfrom GlobalVariable gv\nwhere\n  gv.getName().length() <= 3 and\n  // We will give an alert for the TemplateVariable, so we don't\n  // need to also give one for each instantiation\n  not gv instanceof VariableTemplateInstantiation and\n  not gv.isStatic() and\n  not gv.getFile() instanceof ConfigurationTestFile // variables in files generated during configuration are likely false positives\nselect gv,\n  \"Poor global variable name '\" + gv.getName() +\n    \"'. Prefer longer, descriptive names for globals (eg. kMyGlobalConstant, not foo).\"",
        "description": "Global variables should have descriptive names, to help document their use, avoid namespace pollution and reduce the risk of shadowing with local variables.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/SloppyGlobal.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate logicalOp(string op) { op = \"&&\" or op = \"||\" }\n\npredicate nontrivialLogicalOperator(Operation e) {\n  exists(string op |\n    op = e.getOperator() and\n    logicalOp(op) and\n    not op = e.getParent().(Operation).getOperator()\n  ) and\n  not e.isInMacroExpansion()\n}\n\nfrom Expr e, int operators\nwhere\n  not e.getParent() instanceof Expr and\n  operators = count(Operation op | op.getParent*() = e and nontrivialLogicalOperator(op)) and\n  operators > 5\nselect e, \"Complex condition: too many logical operations in this expression.\"",
        "description": "Boolean expressions that are too deeply nested are hard to read and understand. Consider naming intermediate results as local variables.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/ComplexCondition.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass ComplexStmt extends Stmt {\n  ComplexStmt() {\n    exists(BlockStmt body |\n      body = this.(Loop).getStmt() or\n      body = this.(SwitchStmt).getStmt()\n    |\n      strictcount(body.getAStmt+()) > 6\n    ) and\n    not exists(this.getGeneratingMacro())\n  }\n}\n\nfrom BlockStmt b, int n, ComplexStmt complexStmt\nwhere\n  n = strictcount(ComplexStmt s | s = b.getAStmt()) and\n  n > 3 and\n  complexStmt = b.getAStmt()\nselect b, \"Block with too many statements (\" + n.toString() + \" complex statements in the block).\"",
        "description": "Blocks with too many consecutive statements are candidates for refactoring. Only complex statements are counted here (eg. for, while, switch ...). The top-level logic will be clearer if each complex statement is extracted to a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/BlockWithTooManyStatements.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass JumpTarget extends Stmt {\n  JumpTarget() { exists(GotoStmt g | g.getTarget() = this) }\n\n  FunctionDeclarationEntry getFde() { result.getBlock() = this.getParentStmt+() }\n\n  predicate isForward() {\n    exists(GotoStmt g | g.getTarget() = this |\n      g.getLocation().getEndLine() < this.getLocation().getStartLine()\n    )\n  }\n\n  predicate isBackward() {\n    exists(GotoStmt g | g.getTarget() = this |\n      this.getLocation().getEndLine() < g.getLocation().getStartLine()\n    )\n  }\n}\n\nfrom FunctionDeclarationEntry fde, int nforward, int nbackward\nwhere\n  nforward = strictcount(JumpTarget t | t.getFde() = fde and t.isForward()) and\n  nbackward = strictcount(JumpTarget t | t.getFde() = fde and t.isBackward()) and\n  nforward != 1 and\n  nbackward != 1\nselect fde,\n  \"Multiple forward and backward goto statements may make function \" + fde.getName() +\n    \" hard to understand.\"",
        "description": "The goto statement can make the control flow of a function hard to understand, when used for purposes other than error handling.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/UseOfGoto.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n//see http://www.gotw.ca/publications/mill18.htm\nfrom MemberFunction f\nwhere\n  f.hasSpecifier(\"public\") and\n  f.hasSpecifier(\"virtual\") and\n  f.getFile().fromSource() and\n  not f instanceof Destructor\nselect f, \"Avoid having public virtual methods (NVI idiom).\"",
        "description": "When public methods can be overridden, base classes are unable to enforce invariants that should hold for the whole hierarchy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/NVI.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// This query enforces the Rule of Two, which is a conservative variation of\n// the more well-known Rule of Three.\n//\n// The Rule of Two is usually phrased informally, ignoring the distinction\n// between whether a member is missing because it's auto-generated (missing\n// from the source) or missing because it can't be called (missing from the\n// generated code).\n//\n// This query checks if one member is explicitly defined while the other is\n// auto-generated. This can lead to memory safety issues. It's a separate issue\n// whether one is callable while the other is not callable; that is an API\n// design question and carries has no safety risk.\npredicate generatedCopyAssignment(CopyConstructor cc, string msg) {\n  cc.getDeclaringType().hasImplicitCopyAssignmentOperator() and\n  msg =\n    \"No matching copy assignment operator in class \" + cc.getDeclaringType().getName() +\n      \". It is good practice to match a copy constructor with a \" + \"copy assignment operator.\"\n}\n\npredicate generatedCopyConstructor(CopyAssignmentOperator ca, string msg) {\n  ca.getDeclaringType().hasImplicitCopyConstructor() and\n  msg =\n    \"No matching copy constructor in class \" + ca.getDeclaringType().getName() +\n      \". It is good practice to match a copy assignment operator with a \" + \"copy constructor.\"\n}\n\nfrom MemberFunction f, string msg\nwhere\n  (\n    generatedCopyAssignment(f, msg) or\n    generatedCopyConstructor(f, msg)\n  ) and\n  // Ignore template instantiations to prevent an explosion of alerts\n  not f.getDeclaringType().isConstructedFrom(_) and\n  // Ignore private members since a private constructor or assignment operator\n  // is a common idiom that simulates suppressing the default-generated\n  // members. It would be better to use C++11's \"delete\" facility or use\n  // appropriate Boost helper classes, but it is too common to report as a\n  // violation.\n  not f.isPrivate() and\n  // If it is truly user-defined then it must have a body. This leaves out\n  // C++11 members that use `= delete` or `= default`.\n  exists(f.getBlock()) and\n  // In rare cases, the extractor pretends that an auto-generated copy\n  // constructor has a block that is one character long and is located on top\n  // of the first character of the class name. Checking for\n  // `isCompilerGenerated` will remove those results.\n  not f.isCompilerGenerated() and\n  not f.isDeleted()\nselect f, msg",
        "description": "Classes that have an explicit copy constructor or copy assignment operator may behave inconsistently if they do not have both.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/RuleOfTwo.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate switchCaseStartLine(SwitchCase sc, int start) { sc.getLocation().getStartLine() = start }\n\npredicate switchStmtEndLine(SwitchStmt s, int start) { s.getLocation().getEndLine() = start }\n\npredicate switchCaseLength(SwitchCase sc, int length) {\n  exists(SwitchCase next, int l1, int l2 |\n    next = sc.getNextSwitchCase() and\n    switchCaseStartLine(next, l1) and\n    switchCaseStartLine(sc, l2) and\n    length = l1 - l2 - 1\n  )\n  or\n  not exists(sc.getNextSwitchCase()) and\n  exists(int l1, int l2 |\n    switchStmtEndLine(sc.getSwitchStmt(), l1) and\n    switchCaseStartLine(sc, l2) and\n    length = l1 - l2 - 1\n  )\n}\n\npredicate tooLong(SwitchCase sc) { exists(int n | switchCaseLength(sc, n) and n > 30) }\n\nfrom SwitchStmt switch, SwitchCase sc, int lines\nwhere\n  sc = switch.getASwitchCase() and\n  tooLong(sc) and\n  switchCaseLength(sc, lines)\nselect switch, \"Switch has at least one case that is too long: $@.\", sc,\n  sc.getExpr().toString() + \" (\" + lines.toString() + \" lines)\"",
        "description": "A switch statement with too much code in its cases can make the control flow hard to follow. Consider wrapping the code for each case in a function and just using the switch statement to invoke the appropriate function in each case.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/SwitchLongCase.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.Guards\n\nclass FreeCall extends FunctionCall {\n  FreeCall() { this.getTarget().hasGlobalName(\"free\") }\n}\n\npredicate blockContainsPreprocessorBranches(BasicBlock bb) {\n  exists(PreprocessorBranch ppb, Location bbLoc, Location ppbLoc |\n    bbLoc = bb.(Stmt).getLocation() and ppbLoc = ppb.getLocation()\n  |\n    bbLoc.getFile() = ppb.getFile() and\n    bbLoc.getStartLine() < ppbLoc.getStartLine() and\n    ppbLoc.getEndLine() < bbLoc.getEndLine()\n  )\n}\n\npragma[nomagic]\nprivate predicate interesting(GuardCondition gc, FreeCall fc, Variable v, BasicBlock bb) {\n  gc.ensuresEq(v.getAnAccess(), 0, bb, false) and\n  fc.getArgument(0) = v.getAnAccess() and\n  bb = fc.getBasicBlock() and\n  (\n    // No block statement: if (x) free(x);\n    bb = fc.getEnclosingStmt()\n    or\n    // Block statement with a single nested statement: if (x) { free(x); }\n    strictcount(bb.(BlockStmt).getAStmt()) = 1\n  ) and\n  not fc.isInMacroExpansion() and\n  not blockContainsPreprocessorBranches(bb) and\n  not (gc instanceof BinaryOperation and not gc instanceof ComparisonOperation) and\n  not exists(CommaExpr c | c.getAChild*() = fc)\n}\n\nbindingset[gc]\npragma[inline_late]\nprivate predicate guardConditionGuardsUniqueBlock(GuardCondition gc) {\n  strictcount(BasicBlock bb | gc.ensuresEq(_, 0, bb, _)) = 1\n}\n\nfrom GuardCondition gc, FreeCall fc, Variable v, BasicBlock bb\nwhere\n  interesting(gc, fc, v, bb) and\n  guardConditionGuardsUniqueBlock(gc)\nselect gc, \"unnecessary NULL check before call to $@\", fc, \"free\"",
        "description": "NULL-condition guards before function calls to the memory-deallocation function free(3) are unnecessary, because passing NULL to free(3) is a no-op.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/GuardedFree.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n//see http://www.gotw.ca/publications/mill18.htm\nfrom MemberFunction f, int hubIndex, Class fclass\nwhere\n  f.hasSpecifier(\"public\") and\n  f.hasSpecifier(\"virtual\") and\n  f.getFile().fromSource() and\n  not f instanceof Destructor and\n  fclass = f.getDeclaringType() and\n  hubIndex = fclass.getMetrics().getAfferentCoupling() * fclass.getMetrics().getEfferentCoupling() and\n  hubIndex > 100\nselect f, \"Avoid having public virtual methods (NVI idiom).\"",
        "description": "When public methods can be overridden, base classes are unable to enforce invariants that should hold for the whole hierarchy. This is especially problematic in classes with many dependencies or dependents.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/NVIHub.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass BigThree extends MemberFunction {\n  BigThree() {\n    this instanceof Destructor or\n    this instanceof CopyConstructor or\n    this instanceof CopyAssignmentOperator\n  }\n}\n\nfrom Class c, BigThree b\nwhere\n  b.getDeclaringType() = c and\n  not (\n    c.hasDestructor() and\n    c.getAMemberFunction() instanceof CopyConstructor and\n    c.getAMemberFunction() instanceof CopyAssignmentOperator\n  )\nselect c,\n  \"Class defines a destructor, copy constructor, or copy assignment operator, but not all three.\"",
        "description": "Classes that have an explicit destructor, copy constructor, or copy assignment operator may behave inconsistently if they do not have all three.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/RuleOfThree.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nFile sourceFile() {\n  result instanceof CFile or\n  result instanceof CppFile\n}\n\nfrom Include include, File source, File unneeded\nwhere\n  include.getFile() = source and\n  source = sourceFile() and\n  unneeded = include.getIncludedFile() and\n  not unneeded.getAnIncludedFile*() = source.getMetrics().getAFileDependency() and\n  unneeded.fromSource() and\n  not unneeded.getBaseName().matches(\"%Debug.h\")\nselect include, \"Redundant include, this file does not require $@.\", unneeded,\n  unneeded.getAbsolutePath()",
        "description": "Finds #include directives that are not needed because none of the included elements are used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Unused Entities/UnusedIncludes.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npragma[noinline]\npredicate possiblyIncompleteFile(File f) {\n  exists(Diagnostic d | d.getFile() = f and d.getSeverity() >= 3)\n}\n\npredicate immediatelyReachableFunction(Function f) {\n  not f.isStatic()\n  or\n  exists(BlockExpr be | be.getFunction() = f)\n  or\n  f instanceof MemberFunction\n  or\n  f instanceof TemplateFunction\n  or\n  f.getFile() instanceof HeaderFile\n  or\n  f.getAnAttribute().hasName(\"constructor\")\n  or\n  f.getAnAttribute().hasName(\"destructor\")\n  or\n  f.getAnAttribute().hasName(\"used\")\n  or\n  f.getAnAttribute().hasName(\"unused\")\n  or\n  // a compiler error in the same file suggests we may be missing data\n  possiblyIncompleteFile(f.getFile())\n}\n\npredicate immediatelyReachableVariable(Variable v) {\n  v.isTopLevel() and not v.isStatic()\n  or\n  exists(v.getDeclaringType())\n  or\n  v.getFile() instanceof HeaderFile\n  or\n  v.getAnAttribute().hasName(\"used\")\n  or\n  v.getAnAttribute().hasName(\"unused\")\n}\n\nclass ImmediatelyReachableThing extends Thing {\n  ImmediatelyReachableThing() {\n    immediatelyReachableFunction(this) or\n    immediatelyReachableVariable(this)\n  }\n}\n\npredicate reachableThing(Thing t) {\n  t instanceof ImmediatelyReachableThing\n  or\n  exists(Thing mid | reachableThing(mid) and mid.callsOrAccesses() = t)\n}\n\npragma[nomagic]\npredicate callsOrAccessesPlus(Thing thing1, FunctionToRemove thing2) {\n  thing1.callsOrAccesses() = thing2\n  or\n  exists(Thing mid |\n    thing1.callsOrAccesses() = mid and\n    callsOrAccessesPlus(mid, thing2)\n  )\n}\n\nclass Thing extends Locatable {\n  Thing() {\n    this instanceof Function or\n    this instanceof Variable\n  }\n\n  string getName() {\n    result = this.(Function).getName() or\n    result = this.(Variable).getName()\n  }\n\n  Thing callsOrAccesses() {\n    this.(Function).calls(result)\n    or\n    this.(Function).accesses(result.(Function))\n    or\n    this.(Function).accesses(result.(Variable))\n    or\n    exists(Access a | this.(Variable).getInitializer().getExpr().getAChild*() = a |\n      result = a.getTarget()\n    )\n  }\n}\n\nclass FunctionToRemove extends Function {\n  FunctionToRemove() {\n    this.hasDefinition() and\n    not reachableThing(this)\n  }\n\n  Thing getOther() {\n    callsOrAccessesPlus(result, this) and\n    this != result and\n    // We will already be reporting the enclosing function of a\n    // local variable, so don't also report the variable\n    not result instanceof LocalVariable\n  }\n}\n\nfrom FunctionToRemove f, string clarification, Thing other\nwhere\n  if exists(f.getOther())\n  then (\n    clarification = \" ($@ must be removed at the same time)\" and\n    other = f.getOther()\n  ) else (\n    clarification = \"\" and other = f\n  )\nselect f, \"Static function \" + f.getName() + \" is unreachable\" + clarification, other,\n  other.getName()",
        "description": "A static function that is never called or accessed may be an indication that the code is incomplete or has a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Unused Entities/UnusedStaticFunctions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass TemplateDependentType extends Type {\n  TemplateDependentType() {\n    this instanceof TypeTemplateParameter\n    or\n    exists(TemplateDependentType t |\n      this.refersToDirectly(t) and\n      not this instanceof PointerType and\n      not this instanceof ReferenceType\n    )\n  }\n}\n\npredicate declarationHasSideEffects(Variable v) {\n  exists(Class c | c = v.getUnspecifiedType() |\n    c.hasConstructor() or\n    c.hasDestructor()\n  )\n  or\n  v.getType() instanceof TemplateDependentType // may have a constructor/destructor\n}\n\nfrom LocalVariable v, Function f\nwhere\n  f = v.getFunction() and\n  not exists(v.getAnAccess()) and\n  not v.isConst() and // workaround for folded constants\n  not exists(DeclStmt ds | ds.getADeclaration() = v and ds.isInMacroExpansion()) and // variable declared in a macro expansion\n  not declarationHasSideEffects(v) and\n  not exists(AsmStmt s | f = s.getEnclosingFunction()) and\n  not v.getAnAttribute().getName() = \"unused\" and\n  not f.hasErrors() // Unextracted expressions may use `v`\nselect v, \"Variable \" + v.getName() + \" is not used.\"",
        "description": "A local variable that is never called or accessed may be an indication that the code is incomplete or has a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Unused Entities/UnusedLocals.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate declarationHasSideEffects(Variable v) {\n  exists(Class c | c = v.getUnspecifiedType() | c.hasConstructor() or c.hasDestructor())\n}\n\nfrom Variable v\nwhere\n  v.isStatic() and\n  v.hasDefinition() and\n  not v.isConstexpr() and\n  not exists(VariableAccess a | a.getTarget() = v) and\n  not v instanceof MemberVariable and\n  not declarationHasSideEffects(v) and\n  not v.getAnAttribute().hasName(\"used\") and\n  not v.getAnAttribute().hasName(\"unused\")\nselect v, \"Static variable \" + v.getName() + \" is never read.\"",
        "description": "A static variable that is never accessed may be an indication that the code is incomplete or has a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Unused Entities/UnusedStaticVariables.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom ThrowExpr throw, NewExpr new, Type t\nwhere\n  new.getParent() = throw and\n  // Microsoft MFC's CException hierarchy should be thrown (and caught) as pointers\n  t = new.getAllocatedType() and\n  not t.getUnderlyingType().(Class).getABaseClass*().hasName(\"CException\")\nselect throw, \"This should throw a \" + t.toString() + \" rather than a pointer to one.\"",
        "description": "Exceptions should be objects rather than pointers to objects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Exceptions/ThrowingPointers.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate doesRethrow(Function f) {\n  exists(ReThrowExpr e | e.getEnclosingFunction() = f |\n    not e.getEnclosingStmt().getParent*() instanceof CatchBlock\n  )\n  or\n  exists(FunctionCall fc | fc.getEnclosingFunction() = f | doesRethrow(fc.getTarget()))\n}\n\npredicate deletesException(Expr expr, Parameter exception) {\n  expr.getEnclosingBlock().getParent*().(CatchBlock).getParameter() = exception and\n  (\n    exists(FunctionCall fc | fc = expr |\n      // Calling a delete function on the exception will free it (MFC's CException has a Delete function).\n      fc.getQualifier() = exception.getAnAccess() and\n      fc.getTarget().getName().toLowerCase().matches(\"%delete%\")\n      or\n      // Passing the exception to a function might free it.\n      fc.getAnArgument() = exception.getAnAccess()\n      or\n      // Calling a function which rethrows the current exception might cause the exception to be freed.\n      doesRethrow(fc.getTarget())\n    )\n    or\n    // Calling operator delete on the exception will free it.\n    exists(DeleteExpr d | d = expr | d.getExpr() = exception.getAnAccess())\n  )\n}\n\nfrom CatchBlock cb\nwhere\n  cb.getParameter().getType().getUnderlyingType() instanceof PointerType and\n  not exists(Expr e | e.getEnclosingBlock().getParent*() = cb |\n    deletesException(e, cb.getParameter())\n  )\nselect cb, \"This catch block does not free the caught exception, thereby leaking memory.\"",
        "description": "If an exception is allocated on the heap, then it should be deleted when caught.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Exceptions/LeakyCatch.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom CatchBlock cb, Class caughtType\nwhere caughtType = cb.getParameter().getUnspecifiedType()\nselect cb,\n  \"This should catch a \" + caughtType.getName() + \" by (const) reference rather than by value.\"",
        "description": "Catching an exception by value will create a copy of the thrown exception, thereby potentially slicing the original exception object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Exceptions/CatchingByValue.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate isInCatch(Expr e) {\n  e.getEnclosingStmt().getParent*() instanceof CatchBlock // Lexically enclosing catch blocks will cause there to be a current exception,\n  or\n  exists(Function f | f = e.getEnclosingFunction() |\n    isInCatch(f.getACallToThisFunction()) or // as will dynamically enclosing catch blocks.\n    f.getName().toLowerCase().matches(\"%exception%\") // We assume that rethrows are intended when the function is called *exception*.\n  )\n}\n\nfrom ReThrowExpr e\nwhere not isInCatch(e)\nselect e, \"As there is no current exception, this rethrow expression will terminate the program.\"",
        "description": "When there is nothing to rethrow, attempting to rethrow an exception will terminate the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Exceptions/AccidentalRethrow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nFunction getConstructedFrom(Function f) {\n  f.isConstructedFrom(result)\n  or\n  not f.isConstructedFrom(_) and\n  result = f\n}\n\nParameterDeclarationEntry functionParameterNames(Function f, string name) {\n  exists(FunctionDeclarationEntry fe |\n    result.getFunctionDeclarationEntry() = fe and\n    getConstructedFrom(f).getDefinition() = fe and\n    fe.getLocation() = f.getDefinitionLocation() and\n    strictcount(f.getDefinitionLocation()) = 1 and\n    result.getName() = name\n  )\n}\n\npragma[nomagic]\nLocalVariable localVariableNames(Function f, string name) {\n  name = result.getName() and\n  f = result.getFunction()\n}\n\nfrom Function f, LocalVariable lv, ParameterDeclarationEntry pde, string name\nwhere\n  lv = localVariableNames(f, name) and\n  pde = functionParameterNames(f, name) and\n  not lv.isInMacroExpansion()\nselect lv, \"Local variable '\" + lv.getName() + \"' hides a $@.\", pde, \"parameter of the same name\"",
        "description": "A local variable hides a parameter. This may be confusing. Consider renaming one of them.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Hiding/DeclarationHidesParameter.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Best_Practices.Hiding.Shadowing\n\nfrom LocalVariable lv1, LocalVariable lv2\nwhere\n  shadowing(lv1, lv2) and\n  not lv1.isCompilerGenerated() and\n  not lv2.isCompilerGenerated() and\n  not lv1.getParentScope().(BlockStmt).isInMacroExpansion() and\n  not lv2.getParentScope().(BlockStmt).isInMacroExpansion()\nselect lv1, \"Variable \" + lv1.getName() + \" hides another variable of the same name (on $@).\", lv2,\n  \"line \" + lv2.getLocation().getStartLine().toString()",
        "description": "A local variable hides another local variable from a surrounding scope. This may be confusing. Consider renaming one of the variables.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Hiding/DeclarationHidesVariable.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass LocalVariableOrParameter extends VariableDeclarationEntry {\n  LocalVariableOrParameter() {\n    this.getVariable() instanceof LocalScopeVariable and\n    (\n      // we only need to report parameters hiding globals when the clash is with the parameter\n      // name as used in the function definition.  The parameter name used in any other function\n      // declaration is harmless.\n      this instanceof ParameterDeclarationEntry\n      implies\n      exists(this.(ParameterDeclarationEntry).getFunctionDeclarationEntry().getBlock())\n    )\n  }\n\n  string type() {\n    if this.getVariable() instanceof Parameter\n    then result = \"Parameter \"\n    else result = \"Local variable \"\n  }\n}\n\nfrom LocalVariableOrParameter lv, GlobalVariable gv\nwhere\n  lv.getName() = gv.getName() and\n  lv.getFile() = gv.getFile()\nselect lv, lv.type() + gv.getName() + \" hides a $@ with the same name.\", gv, \"global variable\"",
        "description": "A local variable or parameter that hides a global variable of the same name. This may be confusing. Consider renaming one of the variables.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Hiding/LocalVariableHidesGlobalVariable.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npragma[nomagic]\npredicate beforeArrayAccess(Variable v, ArrayExpr access, Expr before) {\n  exists(LogicalAndExpr andexpr |\n    access.getArrayOffset() = v.getAnAccess() and\n    andexpr.getRightOperand().getAChild*() = access and\n    andexpr.getLeftOperand() = before\n  )\n}\n\npragma[nomagic]\npredicate afterArrayAccess(Variable v, ArrayExpr access, Expr after) {\n  exists(LogicalAndExpr andexpr |\n    access.getArrayOffset() = v.getAnAccess() and\n    andexpr.getLeftOperand().getAChild*() = access and\n    andexpr.getRightOperand() = after\n  )\n}\n\nfrom Variable v, ArrayExpr access, LTExpr rangecheck\nwhere\n  afterArrayAccess(v, access, rangecheck) and\n  rangecheck.getLeftOperand() = v.getAnAccess() and\n  not access.isInMacroExpansion() and\n  not exists(LTExpr altcheck |\n    beforeArrayAccess(v, access, altcheck) and\n    altcheck.getLeftOperand() = v.getAnAccess()\n  )\nselect access, \"This use of offset '\" + v.getName() + \"' should follow the $@.\", rangecheck,\n  \"range check\"",
        "description": "Accessing an array offset before checking the range means that the program may attempt to read beyond the end of a buffer",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Likely Errors/OffsetUseBeforeRangeCheck.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom AssignExpr e, Class lhsType, Class rhsType\nwhere\n  e.getLValue().getType() = lhsType and\n  e.getRValue().getType() = rhsType and\n  rhsType.getABaseClass+() = lhsType and\n  exists(Declaration m |\n    rhsType.getAMember() = m and\n    not m.(VirtualFunction).isPure()\n  ) // add additional checks for concrete members in in-between supertypes\nselect e, \"This assignment expression slices from type $@ to $@.\", rhsType, rhsType.getName(),\n  lhsType, lhsType.getName()",
        "description": "Assigning a non-reference instance of a derived type to a variable of the base type slices off all members added by the derived class, and can cause an unexpected state.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Likely Errors/Slicing.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Exclusions\n\npragma[inline]\nExpr getAChildWithConversions(Expr e) {\n  result.getParentWithConversions() = e and\n  not result = any(Call c).getAnArgument()\n}\n\nint getCandidateColumn(Expr e) {\n  result = e.getLocation().getStartColumn() or\n  result = getCandidateColumn(getAChildWithConversions(e))\n}\n\nExpr normalizeExpr(Expr e) {\n  e.getLocation().getStartColumn() = min(getCandidateColumn(e)) and\n  result = e\n  or\n  not e.getLocation().getStartColumn() = min(getCandidateColumn(e)) and\n  result = normalizeExpr(getAChildWithConversions(e)) and\n  result.getLocation().getStartColumn() = min(getCandidateColumn(e))\n}\n\npredicate isParenthesized(CommaExpr ce) {\n  ce.getParent*().(Expr).isParenthesised()\n  or\n  ce.isUnevaluated() // sizeof(), decltype(), alignof(), noexcept(), typeid()\n  or\n  ce.getParent*() = [any(IfStmt i).getCondition(), any(SwitchStmt s).getExpr()]\n  or\n  ce.getParent*() = [any(Loop l).getCondition(), any(ForStmt f).getUpdate()]\n  or\n  ce.getEnclosingStmt() = any(ForStmt f).getInitialization()\n}\n\nfrom CommaExpr ce, Expr left, Expr right, Location leftLoc, Location rightLoc\nwhere\n  ce.fromSource() and\n  not isFromMacroDefinition(ce) and\n  left = normalizeExpr(ce.getLeftOperand().getFullyConverted()) and\n  right = normalizeExpr(ce.getRightOperand().getFullyConverted()) and\n  leftLoc = left.getLocation() and\n  rightLoc = right.getLocation() and\n  not isParenthesized(ce) and\n  leftLoc.getEndLine() < rightLoc.getStartLine() and\n  leftLoc.getStartColumn() > rightLoc.getStartColumn()\nselect right, \"The indentation level may be misleading for some tab sizes.\"",
        "description": "If expressions before and after a comma operator use different indentation, it is easy to misread the purpose of the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Likely Errors/CommaBeforeMisleadingIndentation.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate emptyBlock(ControlStructure s, BlockStmt b) {\n  b = s.getAChild() and\n  not exists(b.getAChild()) and\n  not b.isInMacroExpansion() and\n  not s instanceof Loop\n}\n\nclass AffectedFile extends File {\n  AffectedFile() {\n    exists(BlockStmt b |\n      emptyBlock(_, b) and\n      this = b.getFile()\n    )\n  }\n}\n\nclass BlockOrNonChild extends Element {\n  BlockOrNonChild() {\n    (\n      this instanceof BlockStmt\n      or\n      this instanceof Comment\n      or\n      this instanceof PreprocessorDirective\n      or\n      this instanceof MacroInvocation\n    ) and\n    this.getFile() instanceof AffectedFile\n  }\n\n  private int getNonContiguousStartRankIn(AffectedFile file) {\n    // When using `rank` with `order by`, the ranks may not be contiguous.\n    this =\n      rank[result](BlockOrNonChild boc, int startLine, int startCol |\n        boc.getLocation().hasLocationInfo(file.getAbsolutePath(), startLine, startCol, _, _)\n      |\n        boc order by startLine, startCol\n      )\n  }\n\n  int getStartRankIn(AffectedFile file) {\n    this.getNonContiguousStartRankIn(file) =\n      rank[result](int rnk |\n        exists(BlockOrNonChild boc | boc.getNonContiguousStartRankIn(file) = rnk)\n      )\n  }\n\n  int getNonContiguousEndRankIn(AffectedFile file) {\n    this =\n      rank[result](BlockOrNonChild boc, int endLine, int endCol |\n        boc.getLocation().hasLocationInfo(file.getAbsolutePath(), _, _, endLine, endCol)\n      |\n        boc order by endLine, endCol\n      )\n  }\n}\n\npredicate emptyBlockContainsNonchild(BlockStmt b) {\n  emptyBlock(_, b) and\n  exists(BlockOrNonChild c, AffectedFile file |\n    c.getStartRankIn(file) = 1 + b.(BlockOrNonChild).getStartRankIn(file) and\n    c.getNonContiguousEndRankIn(file) < b.(BlockOrNonChild).getNonContiguousEndRankIn(file)\n  )\n}\n\npredicate lineComment(BlockStmt b) {\n  emptyBlock(_, b) and\n  exists(Location bLocation, File f, int line |\n    bLocation = b.getLocation() and\n    f = bLocation.getFile() and\n    line = bLocation.getStartLine() and\n    line = bLocation.getEndLine() and\n    exists(Comment c, Location cLocation |\n      cLocation = c.getLocation() and\n      cLocation.getFile() = f and\n      cLocation.getStartLine() = line\n    )\n  )\n}\n\nfrom ControlStructure s, BlockStmt eb\nwhere\n  emptyBlock(s, eb) and\n  not emptyBlockContainsNonchild(eb) and\n  not lineComment(eb)\nselect eb, \"Empty block without comment.\"",
        "description": "An empty block after a conditional can be a sign of an omission and can decrease maintainability of the code. Such blocks should contain an explanatory comment to aid future maintainers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Likely Errors/EmptyBlock.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport MagicConstants\n\npragma[noopt]\npredicate selection(Element e, string msg) { magicConstant(e, msg) and stringLiteral(e) }\n\nfrom Literal e, string msg\nwhere selection(e, msg)\nselect e, msg",
        "description": "'Magic constants' should be avoided: if a nontrivial constant is used repeatedly, it should be encapsulated into a const variable or macro definition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Magic Constants/MagicConstantsString.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport MagicConstants\n\nfrom Literal magicLiteral, string message, Variable constant, string linkText\nwhere\n  numberType(magicLiteral.getType()) and\n  literalInsteadOfConstant(magicLiteral, message, constant, linkText)\nselect magicLiteral, message, constant, linkText",
        "description": "A numeric literal that matches the initializer of a constant variable was found. Consider using the constant variable instead of the numeric literal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Magic Constants/MagicNumbersUseConstant.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport MagicConstants\n\npragma[noopt]\npredicate selection(Element e, string msg) {\n  magicConstant(e, msg) and\n  exists(Literal l, Type t | l = e and t = l.getType() and numberType(t) and l instanceof Literal)\n}\n\nfrom Literal e, string msg\nwhere selection(e, msg)\nselect e, msg",
        "description": "'Magic constants' should be avoided: if a nontrivial constant is used repeatedly, it should be encapsulated into a const variable or macro definition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Magic Constants/MagicConstantsNumbers.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport MagicConstants\n\nfrom Literal magicLiteral, string message, Variable constant, string linkText\nwhere\n  stringLiteral(magicLiteral) and\n  literalInsteadOfConstant(magicLiteral, message, constant, linkText)\nselect magicLiteral, message, constant, linkText",
        "description": "A string literal that matches the initializer of a constant variable was found. Consider using the constant variable instead of the string literal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Magic Constants/MagicStringsUseConstant.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.DateTime\n\npredicate assignedYear(Struct s, YearFieldAccess year, int value) {\n  exists(Operation yearAssignment |\n    s.getAField().getAnAccess() = year and\n    yearAssignment.getAnOperand() = year and\n    yearAssignment.getAnOperand().getValue().toInt() = value\n  )\n}\n\npredicate assignedMonth(Struct s, MonthFieldAccess month, int value) {\n  exists(Operation monthAssignment |\n    s.getAField().getAnAccess() = month and\n    monthAssignment.getAnOperand() = month and\n    monthAssignment.getAnOperand().getValue().toInt() = value\n  )\n}\n\npredicate assignedDay(Struct s, DayFieldAccess day, int value) {\n  exists(Operation dayAssignment |\n    s.getAField().getAnAccess() = day and\n    dayAssignment.getAnOperand() = day and\n    dayAssignment.getAnOperand().getValue().toInt() = value\n  )\n}\n\npredicate eraDate(int year, int month, int day) {\n  year = 1989 and month = 1 and day = 8\n  or\n  year = 2019 and month = 5 and day = 1\n}\n\npredicate badStructInitialization(Element target, string message) {\n  exists(StructLikeClass s, YearFieldAccess year, int yearValue, int monthValue, int dayValue |\n    eraDate(yearValue, monthValue, dayValue) and\n    assignedYear(s, year, yearValue) and\n    assignedMonth(s, _, monthValue) and\n    assignedDay(s, _, dayValue) and\n    target = year and\n    message = \"A time struct that is initialized with exact Japanese calendar era start date.\"\n  )\n}\n\npredicate badCall(Element target, string message) {\n  exists(Call cc, int i |\n    eraDate(cc.getArgument(i).getValue().toInt(), cc.getArgument(i + 1).getValue().toInt(),\n      cc.getArgument(i + 2).getValue().toInt()) and\n    target = cc and\n    message = \"Call that appears to have hard-coded Japanese era start date as parameter.\"\n  )\n}\n\nfrom Element target, string message\nwhere\n  badStructInitialization(target, message) or\n  badCall(target, message)\nselect target, message",
        "description": "Japanese era changes can lead to code behaving differently. Avoid hard-coding Japanese era start dates.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Best Practices/Magic Constants/JapaneseEraDate.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate functionUsesVariable(Function source, Variable v, File target) {\n  v.getAnAccess().getEnclosingFunction() = source and\n  not v.(LocalScopeVariable).getFunction() = source and\n  v.getFile() = target\n}\n\npredicate functionUsesFunction(Function source, Function f, File target) {\n  exists(FunctionCall fc | fc.getEnclosingFunction() = source and fc.getTarget() = f) and\n  f.getFile() = target\n}\n\npredicate dependencyCount(Function source, File target, int res) {\n  res =\n    strictcount(Declaration d |\n      functionUsesVariable(source, d, target) or\n      functionUsesFunction(source, d, target)\n    )\n}\n\npredicate selfDependencyCountOrZero(Function source, int res) {\n  exists(File target | target = source.getFile() and onlyInFile(source, target) |\n    res = max(int i | dependencyCount(source, target, i) or i = 0)\n  )\n}\n\npredicate dependsHighlyOn(Function source, File target, int res) {\n  dependencyCount(source, target, res) and\n  target.fromSource() and\n  exists(int selfCount |\n    selfDependencyCountOrZero(source, selfCount) and\n    res > 2 * selfCount and\n    res > 4\n  )\n}\n\npredicate onlyInFile(Function f, File file) {\n  file = f.getFile() and\n  not exists(File file2 | file2 = f.getFile() and file2 != file)\n}\n\nfrom Function f, File other, int selfCount, int depCount, string selfDeps\nwhere\n  dependsHighlyOn(f, other, depCount) and\n  selfDependencyCountOrZero(f, selfCount) and\n  not exists(File yetAnother | dependsHighlyOn(f, yetAnother, _) and yetAnother != other) and\n  not other instanceof HeaderFile and\n  not f instanceof MemberFunction and\n  if selfCount = 0\n  then selfDeps = \"0 dependencies\"\n  else\n    if selfCount = 1\n    then selfDeps = \"only 1 dependency\"\n    else selfDeps = \"only \" + selfCount.toString() + \" dependencies\"\nselect f,\n  \"Function \" + f.getName() + \" could be moved to file $@\" + \" since it has \" + depCount.toString() +\n    \" dependencies to that file, but \" + selfDeps + \" to its own file.\", other, other.getBaseName()",
        "description": "A function that uses more functions and variables from another file than functions and variables from its own file. This function might be better placed in the other file, to avoid exposing internals of the file it depends on.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/FeatureEnvy.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate remoteVarAccess(File source, File target, VariableAccess va) {\n  va.getFile() = source and\n  va.getTarget().getFile() = target and\n  // Ignore variables with locations in multiple files\n  strictcount(File f | f = va.getTarget().getFile()) = 1 and\n  source != target\n}\n\npredicate remoteFunAccess(File source, File target, FunctionCall fc) {\n  fc.getFile() = source and\n  fc.getTarget().getFile() = target and\n  // Ignore functions with locations in multiple files\n  strictcount(File f | f = fc.getTarget().getFile()) = 1 and\n  source != target\n}\n\npredicate candidateFilePair(File source, File target) {\n  remoteVarAccess(source, target, _) or\n  remoteFunAccess(source, target, _)\n}\n\npredicate variableDependencyCount(File source, File target, int res) {\n  candidateFilePair(source, target) and\n  res = count(VariableAccess va | remoteVarAccess(source, target, va))\n}\n\npredicate functionDependencyCount(File source, File target, int res) {\n  candidateFilePair(source, target) and\n  res = count(FunctionCall fc | remoteFunAccess(source, target, fc))\n}\n\npredicate highDependencyCount(File source, File target, int res) {\n  exists(int varCount, int funCount |\n    variableDependencyCount(source, target, varCount) and\n    functionDependencyCount(source, target, funCount) and\n    res = varCount + funCount and\n    res > 20\n  )\n}\n\nfrom File a, File b, int ca, int cb\nwhere\n  highDependencyCount(a, b, ca) and\n  highDependencyCount(b, a, cb) and\n  ca >= cb and\n  a != b and\n  not a instanceof HeaderFile and\n  not b instanceof HeaderFile and\n  b.getShortName().trim().length() > 0\nselect a,\n  \"File is too closely tied to $@ (\" + ca.toString() + \" dependencies one way and \" + cb.toString() +\n    \" the other).\", b, b.getBaseName()",
        "description": "Two files share too much information about each other (accessing many operations or variables in both directions). It would be better to invert some of the dependencies to reduce the coupling between the two files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/InappropriateIntimacy.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate hasInheritanceDepth(Class c, int d) {\n  c.fromSource() and d = c.getMetrics().getInheritanceDepth()\n}\n\nfrom int depth\nwhere hasInheritanceDepth(_, depth)\nselect depth as inheritanceDepth, count(Class c | hasInheritanceDepth(c, depth)) as numberOfClasses\n  order by inheritanceDepth",
        "description": "Shows the distribution of inheritance depth across all classes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/General Class-Level Information/InheritanceDepthDistribution.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere c.fromSource()\nselect c as class_, c.getMetrics().getAfferentCoupling() as afferentCoupling,\n  c.getMetrics().getEfferentSourceCoupling() as efferentCoupling order by afferentCoupling desc",
        "description": "Shows coupling between classes. Large, red, boxes are hub types that depend on many other classes and are depended on by many other classes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/General Class-Level Information/HubClasses.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class s\nwhere s.fromSource()\nselect s, s.getABaseClass()",
        "description": "Shows an inheritance hierarchy for classes and their base classes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/General Class-Level Information/ClassHierarchies.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricNamespace a, MetricNamespace b\nwhere a.getANamespaceDependency() = b\nselect a, b",
        "description": "Shows dependencies between namespaces as a hierarchical graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/General Namespace-Level Information/NamespaceDependencies.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class c\nwhere\n  c.fromSource() and\n  c.isTopLevel() and\n  c.getParentScope() instanceof GlobalNamespace\nselect c, \"This class is not declared in any namespace.\"",
        "description": "Finds classes that belong to no namespace.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/General Namespace-Level Information/GlobalNamespaceClasses.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom MetricNamespace a, MetricNamespace b\nwhere a.getANamespaceDependency() = b and b.getANamespaceDependency*() = a\nselect a, b",
        "description": "Shows namespaces that cyclically depend on one another.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/General Namespace-Level Information/CyclicNamespaces.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom string l, string n\nwhere\n  l = \"Number of Namespaces\" and\n  n = count(Namespace p | p.fromSource()).toString()\n  or\n  l = \"Number of Files\" and\n  n = count(File f | f.fromSource()).toString()\n  or\n  l = \"Number of Header Files\" and\n  n = count(HeaderFile f | f.fromSource()).toString()\n  or\n  l = \"Number of C Files\" and\n  n = count(CFile f | f.fromSource()).toString()\n  or\n  l = \"Number of C++ Files\" and\n  n = count(CppFile f | f.fromSource()).toString()\n  or\n  l = \"Number of Classes\" and\n  n = count(Class c | c.fromSource() and not c instanceof Struct).toString()\n  or\n  l = \"Number of Structs\" and\n  n = count(Struct s | s.fromSource() and not s instanceof Union).toString()\n  or\n  l = \"Number of Unions\" and\n  n = count(Union u | u.fromSource()).toString()\n  or\n  l = \"Number of Functions\" and\n  n = count(Function f | f.fromSource()).toString()\n  or\n  l = \"Number of Lines Of Code\" and\n  n =\n    sum(File f, int toSum |\n      f.fromSource() and toSum = f.getMetrics().getNumberOfLinesOfCode()\n    |\n      toSum\n    ).toString()\n  or\n  l = \"Self-Containedness\" and\n  n =\n    (\n        100 * sum(Class c | c.fromSource() | c.getMetrics().getEfferentSourceCoupling()) /\n          sum(Class c | c.fromSource() | c.getMetrics().getEfferentCoupling())\n      ).toString() + \"%\"\nselect l as title, n as value",
        "description": "Shows general statistics about the application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/General Top-Level Information/GeneralStatistics.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class t, int n\nwhere\n  t.fromSource() and\n  n = t.getMetrics().getEfferentSourceCoupling() and\n  n > 10\nselect t as class_, \"This class has too many dependencies (\" + n.toString() + \").\"",
        "description": "Finds classes that depend on many other types; they could probably be refactored into smaller classes with fewer dependencies.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/Refactoring Opportunities/ClassesWithManyDependencies.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f\nwhere\n  f.fromSource() and\n  f.getMetrics().getNumberOfParameters() > 15\nselect f,\n  \"This function has too many parameters (\" + f.getMetrics().getNumberOfParameters().toString() +\n    \").\"",
        "description": "Finds functions with many parameters; they could probably be refactored by wrapping parameters into a struct.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/Refactoring Opportunities/FunctionsWithManyParameters.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nstring kindstr(Class c) {\n  exists(int kind | usertypes(unresolveElement(c), _, kind) |\n    kind = 1 and result = \"Struct\"\n    or\n    kind = 2 and result = \"Class\"\n    or\n    kind = [15, 16] and result = \"Template class\"\n  )\n}\n\npredicate vdeInfo(VariableDeclarationEntry vde, Class c, File f, int line) {\n  c = vde.getVariable().getDeclaringType() and\n  f = vde.getLocation().getFile() and\n  line = vde.getLocation().getStartLine()\n}\n\nnewtype TVariableDeclarationInfo =\n  TVariableDeclarationLine(Class c, File f, int line) { vdeInfo(_, c, f, line) }\n\nclass VariableDeclarationLine extends TVariableDeclarationInfo {\n  Class c;\n  File f;\n  int line;\n\n  VariableDeclarationLine() {\n    vdeInfo(_, c, f, line) and\n    this = TVariableDeclarationLine(c, f, line)\n  }\n\n  /**\n   * Gets the class associated with this `VariableDeclarationLine`.\n   */\n  Class getClass() { result = c }\n\n  /**\n   * Gets the line of this `VariableDeclarationLine`.\n   */\n  int getLine() { result = line }\n\n  /**\n   * Gets a `VariableDeclarationEntry` on this line.\n   */\n  VariableDeclarationEntry getAVde() { vdeInfo(result, c, f, line) }\n\n  /**\n   * Gets the start column of the first `VariableDeclarationEntry` on this line.\n   */\n  int getStartColumn() { result = min(this.getAVde().getLocation().getStartColumn()) }\n\n  /**\n   * Gets the end column of the last `VariableDeclarationEntry` on this line.\n   */\n  int getEndColumn() { result = max(this.getAVde().getLocation().getEndColumn()) }\n\n  /**\n   * Gets the rank of this `VariableDeclarationLine` in its file and class\n   * (that is, the first is 0, the second is 1 and so on).\n   */\n  private int getRank() {\n    line =\n      rank[result](VariableDeclarationLine vdl, int l | vdl = TVariableDeclarationLine(c, f, l) | l)\n  }\n\n  /**\n   * Gets the `VariableDeclarationLine` following this one, if any.\n   */\n  VariableDeclarationLine getNext() {\n    result = TVariableDeclarationLine(c, f, _) and\n    result.getRank() = this.getRank() + 1\n  }\n\n  /**\n   * Gets the `VariableDeclarationLine` following this one, if it is nearby.\n   */\n  VariableDeclarationLine getProximateNext() {\n    result = this.getNext() and\n    result.getLine() <= this.getLine() + 3\n  }\n\n  string toString() { result = \"VariableDeclarationLine\" }\n}\n\nclass VariableDeclarationGroup extends VariableDeclarationLine {\n  VariableDeclarationLine end;\n\n  VariableDeclarationGroup() {\n    // there is no `VariableDeclarationLine` within three lines previously\n    not any(VariableDeclarationLine prev).getProximateNext() = this and\n    // `end` is the last transitively proximate line\n    end = this.getProximateNext*() and\n    not exists(end.getProximateNext())\n  }\n\n  predicate hasLocationInfo(string path, int startline, int startcol, int endline, int endcol) {\n    path = f.getAbsolutePath() and\n    startline = this.getLine() and\n    startcol = this.getStartColumn() and\n    endline = end.getLine() and\n    endcol = end.getEndColumn()\n  }\n\n  /**\n   * Gets the number of uniquely named `VariableDeclarationEntry`s in this group.\n   */\n  int getCount() {\n    result =\n      count(VariableDeclarationLine l |\n        l = this.getProximateNext*()\n      |\n        l.getAVde().getVariable().getName()\n      )\n  }\n\n  override string toString() {\n    this.getCount() = 1 and\n    result = \"declaration of \" + this.getAVde().getVariable().getName()\n    or\n    this.getCount() > 1 and\n    result = \"group of \" + this.getCount() + \" fields here\"\n  }\n}\n\nclass ExtClass extends Class {\n  predicate hasOneVariableGroup() {\n    strictcount(VariableDeclarationGroup vdg | vdg.getClass() = this) = 1\n  }\n\n  predicate hasLocationInfo(string path, int startline, int startcol, int endline, int endcol) {\n    if this.hasOneVariableGroup()\n    then\n      exists(VariableDeclarationGroup vdg | vdg.getClass() = this |\n        vdg.hasLocationInfo(path, startline, startcol, endline, endcol)\n      )\n    else this.getLocation().hasLocationInfo(path, startline, startcol, endline, endcol)\n  }\n}\n\nfrom ExtClass c, int n, VariableDeclarationGroup vdg, string suffix\nwhere\n  n =\n    strictcount(string fieldName |\n      exists(Field f |\n        f.getDeclaringType() = c and\n        fieldName = f.getName()\n      )\n    ) and\n  n > 15 and\n  not c.isConstructedFrom(_) and\n  c = vdg.getClass() and\n  if c.hasOneVariableGroup() then suffix = \"\" else suffix = \" - see $@\"\nselect c,\n  kindstr(c) + \" \" + c.getName() + \" has \" + n +\n    \" fields; we suggest refactoring to 15 fields or fewer\" + suffix + \".\", vdg, vdg.toString()",
        "description": "Finds classes with many fields; they could probably be refactored by breaking them down into smaller classes, and using composition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/Refactoring Opportunities/ClassesWithManyFields.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f, int complexity\nwhere\n  complexity = f.getMetrics().getCyclomaticComplexity() and\n  complexity > 250\nselect f, \"Function has high cyclomatic complexity: \" + complexity.toString()",
        "description": "Functions with high cyclomatic complexity. With increasing cyclomatic complexity there need to be more test cases that are necessary to achieve a complete branch coverage when testing this function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/Refactoring Opportunities/CyclomaticComplexity.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Function f, int n\nwhere\n  f.fromSource() and\n  n = f.getMetrics().getNumberOfCalls() and\n  n > 99 and\n  not f.isMultiplyDefined()\nselect f as function, \"This function makes too many calls (\" + n.toString() + \").\"",
        "description": "Finds functions which call too many other functions. Splitting these functions would increase maintainability and readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Architecture/Refactoring Opportunities/ComplexFunctions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nstring describe(Compilation c) {\n  if c.getArgument(1) = \"--mimic\"\n  then result = \"compiler invocation \" + concat(int i | i > 1 | c.getArgument(i), \" \" order by i)\n  else result = \"extractor invocation \" + concat(int i | | c.getArgument(i), \" \" order by i)\n}\n\nprivate int getErrorSeverity() { result = 2 }\n\nfrom Compilation c\nwhere not c.normalTermination()\nselect \"Extraction aborted for \" + describe(c), getErrorSeverity()",
        "description": "Gives the command line of compilations for which extraction did not run to completion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Diagnostics/FailedExtractorInvocations.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom File f\nwhere exists(f.getRelativePath()) and f.fromSource()\nselect f, \"File successfully extracted.\"",
        "description": "Lists all files in the source code directory that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Diagnostics/ExtractedFiles.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport ExtractionProblems\n\nfrom ExtractionProblem warning\nwhere\n  warning instanceof ExtractionRecoverableWarning and exists(warning.getFile().getRelativePath())\n  or\n  warning instanceof ExtractionUnknownProblem\nselect warning,\n  \"Extraction failed in \" + warning.getFile() + \" with warning \" +\n    warning.getProblemMessage().replaceAll(\"$\", \"$$\"), warning.getSeverity()",
        "description": "List all extraction warnings for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Diagnostics/ExtractionWarnings.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport ExtractionErrors\n\n// NOTE:\n// This file looks like the other `diagnostics/extraction-errors` queries in other CodeQL supported\n// languages. However, since this diagnostic query is located in the `Internal` subdirectory it will not\n// appear in the Code Scanning suite. The related query `cpp/diagnostics/extraction-warnings` is,\n// however, included as a public diagnostics query.\nfrom ExtractionError error\nwhere\n  error instanceof ExtractionUnknownError or\n  exists(error.getFile().getRelativePath())\nselect error,\n  \"Extraction failed in \" + error.getFile() + \" with error \" +\n    error.getErrorMessage().replaceAll(\"$\", \"$$\"), error.getSeverity()",
        "description": "List all extraction errors for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Diagnostics/Internal/ExtractionErrors.ql",
        "language": "cpp"
    },
    {
        "query": "import Metrics\n\nfrom CppMetrics::ErrorCount m\nwhere RankMetric<CppMetrics::ErrorCount>::getRank(m) <= 50\nselect m.toString(), m.getValue()",
        "description": "A count of all compiler errors, grouped by error text.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Telemetry/CompilerErrors.ql",
        "language": "cpp"
    },
    {
        "query": "import Metrics\n\nfrom ExtractionMetric m\nselect m.toString(), m.getValue()",
        "description": "Raw metrics relating to extraction.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Telemetry/ExtractionMetrics.ql",
        "language": "cpp"
    },
    {
        "query": "import Metrics\n\nfrom CppMetrics::MissingIncludeCount e\nwhere RankMetric<CppMetrics::MissingIncludeCount>::getRank(e) <= 50\nselect e.getIncludeText(), e.getValue()",
        "description": "A count of all failed includes, grouped by filename.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Telemetry/MissingIncludes.ql",
        "language": "cpp"
    },
    {
        "query": "import Metrics\n\nfrom QualityMetric m\nselect m.toString(), m.getValue()",
        "description": "Metrics that indicate the quality of the database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Telemetry/DatabaseQuality.ql",
        "language": "cpp"
    },
    {
        "query": "import Metrics\n\nfrom CppMetrics::SucceededIncludeCount m\nwhere RankMetric<CppMetrics::SucceededIncludeCount>::getRank(m) <= 50\nselect m.getIncludeText(), m.getValue()",
        "description": "A count of all succeeded includes, grouped by filename.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Telemetry/SucceededIncludes.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nStmt exitFrom(Loop l) {\n  l.getAChild+() = result and\n  (\n    result instanceof ReturnStmt\n    or\n    exists(BreakStmt break | break = result | not l.getAChild*() = break.getTarget())\n  )\n}\n\nfrom Loop l, Stmt exit\nwhere\n  l.getControllingExpr().getValue().toInt() != 0 and\n  exit = exitFrom(l)\nselect exit, \"$@ should not be exited.\", l, \"This permanent loop\"",
        "description": "Permanent loops (like \"while(1) {..}\") are typically meant to be non-terminating and should not be terminated by other means.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 2/ExitPermanentLoop.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate validVarForBound(Loop loop, Variable var) {\n  // The variable is read in the loop controlling expression\n  var.getAnAccess().getParent*() = loop.getControllingExpr() and\n  // The variable is not assigned in the loop body\n  not inScope(loop, var.getAnAssignment().getEnclosingStmt()) and\n  // The variable is not incremented/decremented in the loop body\n  not inScope(loop, var.getAnAccess().getParent().(CrementOperation).getEnclosingStmt())\n}\n\npredicate upperBoundCheck(Loop loop, VariableAccess checked) {\n  exists(RelationalOperation rop | loop.getControllingExpr().getAChild*() = rop |\n    checked = rop.getLesserOperand() and\n    // The RHS is something \"valid\", i.e. a constant or\n    // a variable that isn't assigned in the loop body\n    (\n      exists(rop.getGreaterOperand().getValue()) or\n      rop.getGreaterOperand().(VariableAccess).getTarget().isConst() or\n      validVarForBound(loop, rop.getGreaterOperand().(VariableAccess).getTarget())\n    ) and\n    not rop.getGreaterOperand() instanceof CharLiteral\n  )\n}\n\npredicate lowerBoundCheck(Loop loop, VariableAccess checked) {\n  exists(RelationalOperation rop | loop.getControllingExpr().getAChild*() = rop |\n    checked = rop.getGreaterOperand() and\n    // The RHS is something \"valid\", i.e. a constant or\n    // a variable that isn't assigned in the loop body\n    (\n      exists(rop.getLesserOperand().getValue()) or\n      rop.getLesserOperand().(VariableAccess).getTarget().isConst() or\n      validVarForBound(loop, rop.getLesserOperand().(VariableAccess).getTarget())\n    ) and\n    not rop.getLesserOperand() instanceof CharLiteral\n  )\n}\n\nVariableAccess getAnIncrement(Variable var) {\n  result.getTarget() = var and\n  (\n    result.getParent() instanceof IncrementOperation\n    or\n    exists(AssignAddExpr a | a.getLValue() = result and a.getRValue().getValue().toInt() > 0)\n    or\n    exists(AssignExpr a | a.getLValue() = result |\n      a.getRValue() =\n        any(AddExpr ae |\n          ae.getAnOperand() = var.getAnAccess() and\n          ae.getAnOperand().getValue().toInt() > 0\n        )\n    )\n  )\n}\n\nVariableAccess getADecrement(Variable var) {\n  result.getTarget() = var and\n  (\n    result.getParent() instanceof DecrementOperation\n    or\n    exists(AssignSubExpr a | a.getLValue() = result and a.getRValue().getValue().toInt() > 0)\n    or\n    exists(AssignExpr a | a.getLValue() = result |\n      a.getRValue() =\n        any(SubExpr ae |\n          ae.getLeftOperand() = var.getAnAccess() and\n          ae.getRightOperand().getValue().toInt() > 0\n        )\n    )\n  )\n}\n\npredicate inScope(Loop l, Stmt s) { l.getAChild*() = s }\n\npredicate reachesNoInc(VariableAccess source, ControlFlowNode target) {\n  upperBoundCheck(_, source) and source.getASuccessor() = target\n  or\n  exists(ControlFlowNode mid |\n    reachesNoInc(source, mid) and not mid = getAnIncrement(source.getTarget())\n  |\n    target = mid.getASuccessor() and\n    inScope(source.getEnclosingStmt(), target.getEnclosingStmt())\n  )\n}\n\npredicate reachesNoDec(VariableAccess source, ControlFlowNode target) {\n  lowerBoundCheck(_, source) and source.getASuccessor() = target\n  or\n  exists(ControlFlowNode mid |\n    reachesNoDec(source, mid) and not mid = getADecrement(source.getTarget())\n  |\n    target = mid.getASuccessor() and\n    inScope(source.getEnclosingStmt(), target.getEnclosingStmt())\n  )\n}\n\npredicate hasSafeBound(Loop l) {\n  exists(VariableAccess bound | upperBoundCheck(l, bound) | not reachesNoInc(bound, bound))\n  or\n  exists(VariableAccess bound | lowerBoundCheck(l, bound) | not reachesNoDec(bound, bound))\n  or\n  exists(l.getControllingExpr().getValue())\n}\n\nfrom Loop loop, string msg\nwhere\n  not hasSafeBound(loop) and\n  (\n    not upperBoundCheck(loop, _) and\n    not lowerBoundCheck(loop, _) and\n    msg = \"This loop does not have a fixed bound.\"\n    or\n    exists(VariableAccess bound |\n      upperBoundCheck(loop, bound) and\n      reachesNoInc(bound, bound) and\n      msg =\n        \"The loop counter \" + bound.getTarget().getName() +\n          \" is not always incremented in the loop body.\"\n    )\n    or\n    exists(VariableAccess bound |\n      lowerBoundCheck(loop, bound) and\n      reachesNoDec(bound, bound) and\n      msg =\n        \"The loop counter \" + bound.getTarget().getName() +\n          \" is not always decremented in the loop body.\"\n    )\n  )\nselect loop, msg",
        "description": "All loops should have a fixed upper bound; the counter should also be incremented along all paths within the loop. This check excludes loops that are meant to be nonterminating (like schedulers).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 2/BoundedLoopIterations.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nfrom Assertion a\nwhere a.getAsserted().getType() instanceof PointerType\nselect a.getAsserted(), \"Assertions should be defined as Boolean tests.\"",
        "description": "Assertions should be defined as Boolean tests, meaning \"assert(p != NULL)\" rather than \"assert(p)\".",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 5/NonBooleanAssertion.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nfrom Assertion a, string value, string msg\nwhere\n  value = a.getAsserted().getValue() and\n  if value.toInt() = 0\n  then msg = \"This assertion is always false.\"\n  else msg = \"This assertion is always true.\"\nselect a.getAsserted(), msg",
        "description": "Assertions should check dynamic properties of pre-/post-conditions and invariants. Assertions that either always succeed or always fail are an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 5/ConstantAssertion.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nclass MacroFunctionCall extends MacroInvocation {\n  MacroFunctionCall() {\n    not exists(this.getParentInvocation()) and\n    this.getMacro().getHead().matches(\"%(%\")\n  }\n\n  FunctionDeclarationEntry getFunction() {\n    result.getFunction() = this.getAGeneratedElement().(Stmt).getEnclosingFunction()\n  }\n}\n\nint logicalLength(FunctionDeclarationEntry f) {\n  result =\n    count(Stmt s |\n        s.getEnclosingFunction() = f.getFunction() and\n        s.getFile() = f.getFile() and\n        not s instanceof BlockStmt and\n        not s instanceof EmptyStmt and\n        not exists(ForStmt for | s = for.getInitialization()) and\n        not s.isAffectedByMacro()\n      ) + count(MacroFunctionCall mf | mf.getFunction() = f)\n}\n\nint assertionCount(FunctionDeclarationEntry f) {\n  result =\n    count(Assertion a |\n      a.getAsserted().getEnclosingFunction() = f.getFunction() and a.getFile() = f.getFile()\n    )\n}\n\nfrom FunctionDeclarationEntry f, int numAsserts, int size, int minSize\nwhere\n  minSize = 20 and\n  numAsserts = assertionCount(f) and\n  numAsserts < 2 and\n  size = logicalLength(f) and\n  size > minSize\nselect f.getFunction(),\n  \"Function \" + f.getName() + \" has \" + size + \" logical lines, but only \" + numAsserts +\n    \" assertion(s) -- minimum is 2 (for functions over \" + minSize + \" logical lines).\"",
        "description": "Each function over 20 logical lines should have at least two assertions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 5/AssertionDensity.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.commons.Assertions\n\nfrom Assertion a\nwhere not a.getAsserted().isPure()\nselect a.getAsserted(), \"Assertions should not have side effects.\"",
        "description": "When an assertion has side effects, disabling assertions will alter program behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 5/AssertionSideEffect.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass OneLineStmt extends Stmt {\n  OneLineStmt() {\n    this.getLocation().getStartLine() = this.getLocation().getEndLine() and\n    not this instanceof BlockStmt and\n    not exists(ForStmt for | this = for.getInitialization()) and\n    (\n      // Either this statement is not touched by a macro at all...\n      not this.isAffectedByMacro()\n      or\n      // ... or it's the top-level statement generated by a macro invocation.\n      exists(MacroInvocation mi | this = mi.getAGeneratedElement() |\n        not this.getAChild+() = mi.getAGeneratedElement()\n      )\n    )\n  }\n\n  predicate onLine(File f, int line) {\n    f = this.getFile() and line = this.getLocation().getStartLine()\n  }\n}\n\nint numStmt(File f, int line) { result = strictcount(OneLineStmt o | o.onLine(f, line)) }\n\nfrom File f, int line, OneLineStmt o, int cnt\nwhere\n  numStmt(f, line) = cnt and\n  cnt > 1 and\n  o.onLine(f, line) and\n  o.getLocation().getStartColumn() =\n    min(OneLineStmt other, int toMin |\n      other.onLine(f, line) and toMin = other.getLocation().getStartColumn()\n    |\n      toMin\n    )\nselect o, \"This line contains \" + cnt + \" statements; only one is allowed.\"",
        "description": "Putting more than one statement on a single line hinders program understanding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 4/OneStmtPerLine.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass MacroFunctionCall extends MacroInvocation {\n  MacroFunctionCall() {\n    not exists(this.getParentInvocation()) and\n    this.getMacro().getHead().matches(\"%(%\")\n  }\n\n  FunctionDeclarationEntry getFunction() {\n    result.getFunction() = this.getAGeneratedElement().(Stmt).getEnclosingFunction()\n  }\n}\n\nint logicalLength(FunctionDeclarationEntry f) {\n  result =\n    count(Stmt s |\n        s.getEnclosingFunction() = f.getFunction() and\n        s.getFile() = f.getFile() and\n        not s instanceof BlockStmt and\n        not s instanceof EmptyStmt and\n        not exists(ForStmt for | s = for.getInitialization()) and\n        not s.isAffectedByMacro()\n      ) + count(MacroFunctionCall mf | mf.getFunction() = f)\n}\n\nfrom FunctionDeclarationEntry f, int n\nwhere logicalLength(f) = n and n > 60\nselect f.getFunction(),\n  \"Function \" + f.getName() + \" has too many logical lines (\" + n + \", while 60 are allowed).\"",
        "description": "Function length should be limited to what can be printed on a single sheet of paper (60 logical lines).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 4/FunctionTooLong.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass Initialization extends Function {\n  Initialization() {\n    // Adapt this query to your codebase by changing this predicate to match\n    // precisely what functions count as \"initialization\", and are, hence,\n    // allowed to perform dynamic memory allocation.\n    this.getName().toLowerCase().matches(\"init%\") or\n    this.getName().matches(\"%\\\\_init\")\n  }\n}\n\nclass Allocation extends FunctionCall {\n  Allocation() {\n    exists(string name | name = this.getTarget().getName() | name = \"malloc\" or name = \"calloc\")\n  }\n}\n\nfrom Function f, Allocation a\nwhere\n  not f instanceof Initialization and\n  a.getEnclosingFunction() = f\nselect a, \"Dynamic memory allocation is only allowed during initialization.\"",
        "description": "Dynamic memory allocation (using malloc() or calloc()) should be confined to the initialization routines of a program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 3/DynamicAllocAfterInit.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom GlobalVariable v, Function f\nwhere\n  v.getAnAccess().getEnclosingFunction() = f and\n  strictcount(v.getAnAccess().getEnclosingFunction()) = 1 and\n  forall(VariableAccess a | a = v.getAnAccess() | exists(a.getEnclosingFunction())) and\n  not v.getADeclarationEntry().getFile() instanceof HeaderFile // intended to be accessed elsewhere\nselect v,\n  \"The variable \" + v.getName() + \" is only accessed in $@ and should be scoped accordingly.\", f,\n  f.getName()",
        "description": "Global and file-scope variables that are accessed by only one function should be scoped within that function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 6/VariableScopeTooLarge.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom GlobalVariable v\nwhere\n  forex(VariableAccess va | va.getTarget() = v | va.getFile() = v.getDefinitionLocation().getFile()) and\n  not v.hasSpecifier(\"static\") and\n  strictcount(v.getAnAccess().getEnclosingFunction()) > 1 and // If = 1, variable should be function-scope.\n  not v.getADeclarationEntry().getFile() instanceof HeaderFile // intended to be accessed elsewhere\nselect v,\n  \"The global variable \" + v.getName() + \" is not accessed outside of \" + v.getFile().getBaseName() +\n    \" and could be made static.\"",
        "description": "Global variables that are not accessed outside their own file could be made static to promote information hiding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 6/GlobalCouldBeStatic.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom GotoStmt goto\nselect goto, \"The goto statement should not be used.\"",
        "description": "Using the goto statement complicates function control flow and hinders program understanding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 1/UseOfGoto.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass RecursiveCall extends FunctionCall {\n  RecursiveCall() { this.getTarget().calls*(this.getEnclosingFunction()) }\n}\n\nfrom RecursiveCall call, string msg\nwhere\n  if call.getTarget() = call.getEnclosingFunction()\n  then msg = \"This call directly invokes its containing function $@.\"\n  else\n    msg =\n      \"The function \" + call.getEnclosingFunction() +\n        \" is indirectly recursive via this call to $@.\"\nselect call, msg, call.getTarget(), call.getTarget().getName()",
        "description": "Recursion makes the program call graph cyclic and hinders program understanding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 1/UseOfRecursion.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass ForbiddenFunction extends Function {\n  ForbiddenFunction() {\n    exists(string name | name = this.getName() |\n      name = [\"setjmp\", \"longjmp\", \"sigsetjmp\", \"siglongjmp\"]\n    )\n  }\n}\n\nfrom FunctionCall call\nwhere call.getTarget() instanceof ForbiddenFunction\nselect call, \"The \" + call.getTarget().getName() + \" function should not be used.\"",
        "description": "Using the setjmp and longjmp functions complicates control flow and hinders program understanding.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 1/UseOfJmp.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PreprocessorDirective p\nwhere\n  not p instanceof Include and\n  not p instanceof Macro and\n  not p instanceof PreprocessorIf and\n  not p instanceof PreprocessorElif and\n  not p instanceof PreprocessorElse and\n  not p instanceof PreprocessorIfdef and\n  not p instanceof PreprocessorIfndef and\n  not p instanceof PreprocessorEndif\nselect p, \"This preprocessor directive is not allowed.\"",
        "description": "The use of the preprocessor must be limited to inclusion of header files and simple macro definitions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 8/RestrictPreprocessor.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Macro m, string msg\nwhere\n  m.getHead().matches(\"%...%\") and\n  msg = \"The macro \" + m.getHead() + \" is variadic, and hence not allowed.\"\n  or\n  m.getBody().matches(\"%##%\") and\n  msg = \"The macro \" + m.getHead() + \" uses token pasting and is not allowed.\"\nselect m, msg",
        "description": "Macros are not allowed to use complex preprocessor features like variable argument lists and token pasting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 8/UndisciplinedMacro.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate incomplete(Macro m) {\n  exists(string body | body = m.getBody() and not m.getBody().matches(\"%\\\\\") |\n    body.regexpMatch(\"[^(]*\\\\).*\") or\n    body.regexpMatch(\"[^\\\\[]*].*\") or\n    body.regexpMatch(\"[^{]*}.*\") or\n    body.regexpMatch(\".*\\\\([^)]*\") or\n    body.regexpMatch(\".*\\\\[[^\\\\]]*\") or\n    body.regexpMatch(\".*\\\\{[^}]*\") or\n    count(body.indexOf(\"(\")) != count(body.indexOf(\")\")) or\n    count(body.indexOf(\"[\")) != count(body.indexOf(\"]\")) or\n    count(body.indexOf(\"{\")) != count(body.indexOf(\"}\"))\n  )\n}\n\nfrom Macro m\nwhere incomplete(m)\nselect m, \"The macro \" + m.getHead() + \" will not expand into a syntactic unit.\"",
        "description": "Macros must expand to complete syntactic units -- \"#define MY_IF if(\" is not legal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 8/PartialMacro.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom PreprocessorDirective i\nwhere\n  (i instanceof PreprocessorIf or i instanceof PreprocessorIfdef or i instanceof PreprocessorIfndef) and\n  not i.getFile() instanceof HeaderFile\nselect i, \"Use of conditional compilation must be kept to a minimum.\"",
        "description": "The use of conditional compilation directives must be kept to a minimum -- e.g. for header guards only.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 8/AvoidConditionalCompilation.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom ExprCall e\nselect e, \"Calls through function pointers are not permitted.\"",
        "description": "Function pointers are not permitted -- they make it impossible for a tool to prove the absence of recursion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 9/FunctionPointer.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom TypedefType t\nwhere t.getBaseType().getPointerIndirectionLevel() > 0\nselect t, \"The typedef \" + t.getName() + \" hides pointer indirection.\"",
        "description": "Pointer indirection may not be hidden by typedefs -- \"typedef int* IntPtr;\" is not allowed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 9/HiddenPointerIndirection.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Variable v, int n\nwhere n = v.getType().(PointerType).getPointerIndirectionLevel() and n > 1\nselect v, \"The variable \" + v.getName() + \" uses \" + n + \" levels of pointer indirection.\"",
        "description": "No more than one level of pointer nesting/dereferencing should be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 9/PointerNesting.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate whitelist(Function f) {\n  // Example:\n  // f.hasName(\"printf\") or f.hasName(\"close\") or // ...\n  none()\n}\n\nfrom FunctionCall c, string msg\nwhere\n  not c.getTarget().getType() instanceof VoidType and\n  not whitelist(c.getTarget()) and\n  (\n    c instanceof ExprInVoidContext and\n    msg = \"The return value of non-void function $@ is not checked.\"\n    or\n    definition(_, c.getParent()) and\n    not definitionUsePair(_, c.getParent(), _) and\n    msg = \"$@'s return value is stored but not checked.\"\n  )\nselect c, msg, c.getTarget() as f, f.getName()",
        "description": "The return value of each non-void function call should be checked for error conditions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 7/CheckReturnValues.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate flow(Parameter p, ControlFlowNode n) {\n  exists(p.getAnAccess()) and n = p.getFunction().getBlock()\n  or\n  exists(ControlFlowNode mid |\n    flow(p, mid) and not mid = p.getAnAccess() and n = mid.getASuccessor()\n  )\n}\n\nVariableAccess firstAccess(Parameter p) { flow(p, result) and result = p.getAnAccess() }\n\nfrom Parameter p, VariableAccess va\nwhere\n  va = firstAccess(p) and\n  not exists(Expr e | e.isCondition() | e.getAChild*() = va)\nselect va, \"This use of parameter \" + p.getName() + \" has not been checked.\"",
        "description": "Functions should check their arguments before their first use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Power of 10/Rule 7/CheckArguments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.DefectFilter\n\nfrom DefectResult res\nselect res, \"Filtered query result: \" + res.getMessage()",
        "description": "This filter demonstrates how to edit the message generated by the query that it is filtering. In this example the string `Filtered query result: ` is prepended to the message.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/external/examples/filters/EditDefectMessage.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.DefectFilter\n\npredicate generatedFile(File f) { f.getAbsolutePath().matches(\"%generated%\") }\n\nfrom DefectResult res\nwhere not generatedFile(res.getFile())\nselect res, res.getMessage()",
        "description": "This filter demonstrates how to return results only if they meet certain criteria. In this example, results are only returned if they do not come from a file which contains 'generated' anywhere in its path.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/external/examples/filters/ExcludeGeneratedCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport external.MetricFilter\n\nfrom MetricResult res\nselect res, res.getValue() + 10",
        "description": "This filter demonstrates how to change the value computed by the metric that it is filtering. In this example the value is increased by 10.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/external/examples/filters/BumpMetricBy10.ql",
        "language": "cpp"
    },
    {
        "query": "import ReturnConstTypeCommon\n\nfrom MemberFunction f, string message\nwhere\n  hasSuperfluousConstReturn(f) and\n  if f.hasSpecifier(\"const\") or f.isStatic()\n  then\n    message =\n      \"The 'const' modifier has no effect on return types. The 'const' modifying the return type can be removed.\"\n  else\n    message =\n      \"The 'const' modifier has no effect on return types. For a const function, the 'const' should go after the parameter list.\"\nselect f, message",
        "description": "A 'const' modifier on a member function return type is useless. It is usually a typo or misunderstanding, since the syntax for a 'const' function is 'int foo() const', not 'const int foo()'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/ReturnConstTypeMember.ql",
        "language": "cpp"
    },
    {
        "query": "import NestedLoopSameVar\n\nfrom ForStmt inner, Variable iteration, ForStmt outer\nwhere nestedForViolation(inner, iteration, outer)\nselect inner.getCondition(), \"Nested for statement uses loop variable $@ of enclosing $@.\",\n  iteration, iteration.getName(), outer, \"for statement\"",
        "description": "When a nested loop uses the same iteration variable as its outer loop, the behavior of the outer loop easily becomes difficult to understand as the inner loop will affect its control flow. It is likely to be a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/NestedLoopSameVar.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom BitField bf\nwhere\n  not bf.getUnspecifiedType().(IntegralType).isExplicitlySigned() and\n  not bf.getUnspecifiedType().(IntegralType).isExplicitlyUnsigned() and\n  not bf.getUnspecifiedType() instanceof Enum and\n  not bf.getUnspecifiedType() instanceof BoolType and\n  // At least for C programs on Windows, BOOL is a common typedef for a type\n  // representing BoolType.\n  not bf.getType().hasName(\"BOOL\") and\n  // GLib's gboolean is a typedef for a type representing BoolType.\n  not bf.getType().hasName(\"gboolean\") and\n  // If this is true, then there cannot be unsigned sign extension or overflow.\n  not bf.getDeclaredNumBits() = bf.getType().getSize() * 8 and\n  not bf.isAnonymous() and\n  not bf.isFromUninstantiatedTemplate(_)\nselect bf,\n  \"Bit field \" + bf.getName() + \" of type \" + bf.getUnderlyingType().getName() +\n    \" should have explicitly unsigned integral, explicitly signed integral, or enumeration type.\"",
        "description": "Bit fields with integral types should have explicit signedness only. For example, use `unsigned int` rather than `int`. It is implementation specific whether an `int`-typed bit field is signed, so there could be unexpected sign extension or overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/AmbiguouslySignedBitField.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate short(Variable v) { v.getName().length() = 1 }\n\npredicate forStmtAncestor(Stmt child, ForStmt parent) {\n  child.getParent() = parent or forStmtAncestor(child.getParent(), parent)\n}\n\nArrayExpr getANestedArrayExpr(ArrayExpr ae) { result.getArrayBase() = ae }\n\npredicate coordinatePair(Variable a, Variable b) {\n  exists(ArrayExpr ae |\n    getANestedArrayExpr*(ae).getArrayOffset().getAChild*() = a.getAnAccess() and\n    getANestedArrayExpr*(ae).getArrayOffset().getAChild*() = b.getAnAccess() and\n    not a = b\n  )\n}\n\nfrom ForStmt outer, ForStmt inner, Variable iterationVar, Variable innerVar\nwhere\n  forStmtAncestor(inner, outer) and\n  short(innerVar) and\n  iterationVar = outer.getAnIterationVariable() and\n  innerVar = inner.getAnIterationVariable() and\n  short(iterationVar) and\n  not coordinatePair(iterationVar, innerVar)\nselect iterationVar,\n  \"Iteration variable \" + iterationVar.getName() +\n    \" for $@ should have a descriptive name, since there is a $@.\", outer, \"this loop\", inner,\n  \"nested loop\"",
        "description": "The iteration variable of a nested loop should have a descriptive name: short names like i, j, or k can cause confusion except in very simple loops.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/ShortLoopVarName.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass VariableAccessInInitializer extends VariableAccess {\n  Variable var;\n  Initializer init;\n\n  pragma[nomagic]\n  VariableAccessInInitializer() {\n    init.getDeclaration() = var and\n    init.getExpr().getAChild*() = this\n  }\n\n  predicate initializesItself(Variable v, Initializer i) {\n    v = var and i = init and var = this.getTarget()\n  }\n}\n\nfrom Initializer init, Variable v, VariableAccessInInitializer va\nwhere\n  va.initializesItself(v, init) and\n  (\n    va.hasLValueToRValueConversion() or\n    exists(Assignment assn | assn.getLValue() = va) or\n    exists(CrementOperation crement | crement.getAnOperand() = va)\n  ) and\n  not va.isUnevaluated() and\n  not v.isConst() and\n  not (\n    va.getParent() = init and\n    exists(MacroInvocation mi | va = mi.getExpr())\n  ) and\n  not va.getEnclosingStmt().isInMacroExpansion()\nselect va, v.getName() + \" is used in its own initializer.\"",
        "description": "Loading from a variable in its own initializer may lead to undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/UseInOwnInitializer.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate assertMacro(Macro m) { m.getHead().toLowerCase().matches(\"%assert%\") }\n\npredicate assertInvocation(File f, int line) {\n  exists(MacroInvocation i, Location l | assertMacro(i.getMacro()) and l = i.getLocation() |\n    l.getStartLine() = line and l.getEndLine() = line and f = l.getFile()\n  )\n}\n\nclass InterestingExpr extends Expr {\n  InterestingExpr() { nullCheckInCondition(this, _, _) }\n}\n\npredicate nullCheckAssert(InterestingExpr e, Variable v, Declaration qualifier) {\n  exists(File f, int i |\n    e.getLocation().getStartLine() = i and\n    e.getFile() = f and\n    assertInvocation(f, i) and\n    nullCheckInCondition(e, v, qualifier)\n  )\n}\n\nVariableAccess qualifiedAccess(Variable v, Declaration qualifier) {\n  result = v.getAnAccess() and\n  (\n    result.getQualifier().(VariableAccess).getTarget() = qualifier\n    or\n    exists(PointerDereferenceExpr e, VariableAccess va | result.getQualifier() = e |\n      e.getOperand() = va and va.getTarget() = qualifier\n    )\n    or\n    not exists(result.getQualifier()) and qualifier = result.getEnclosingFunction()\n    or\n    result.getQualifier() instanceof ThisExpr and qualifier = result.getEnclosingFunction()\n  )\n}\n\npredicate nullCheckInCondition(Expr e, Variable v, Declaration qualifier) {\n  // if(v)\n  exists(FunctionCall fc |\n    relevantFunctionCall(fc, _) and fc = assignedValueForVariableAndQualifier(v, qualifier)\n  |\n    e = qualifiedAccess(v, qualifier)\n  )\n  or\n  exists(AssignExpr a | a = e and a.getLValue() = qualifiedAccess(v, qualifier))\n  or\n  // if(v == NULL), if(v != NULL), if(NULL != v), if(NULL == v)\n  exists(EqualityOperation eq |\n    eq = e and\n    nullCheckInCondition(eq.getAnOperand(), v, qualifier) and\n    eq.getAnOperand().getValue() = \"0\"\n  )\n  or\n  // if(v && something)\n  exists(LogicalAndExpr exp | exp = e and nullCheckInCondition(exp.getAnOperand(), v, qualifier))\n  or\n  // if(v || something)\n  exists(LogicalOrExpr exp | exp = e and nullCheckInCondition(exp.getAnOperand(), v, qualifier))\n  or\n  // if(!v)\n  exists(NotExpr exp | exp = e and nullCheckInCondition(exp.getAnOperand(), v, qualifier))\n  or\n  exists(FunctionCall c |\n    c = e and\n    nullCheckInCondition(c.getAnArgument(), v, qualifier) and\n    c.getTarget().getName() = \"__builtin_expect\"\n  )\n  or\n  exists(ConditionDeclExpr d | d = e and nullCheckInCondition(d.getVariableAccess(), v, qualifier))\n}\n\npredicate hasNullCheck(Function enclosing, Variable v, Declaration qualifier) {\n  exists(Expr exp |\n    nullCheckInCondition(exp, v, qualifier) and exp.getEnclosingFunction() = enclosing\n  |\n    exists(ControlStructure s | exp = s.getControllingExpr())\n    or\n    exists(ConditionalExpr e | exp = e.getCondition())\n    or\n    exists(ReturnStmt s | exp = s.getExpr() and not exp instanceof VariableAccess)\n    or\n    exists(AssignExpr e | exp = e.getRValue() and not exp instanceof VariableAccess)\n    or\n    exists(AggregateLiteral al | exp = al.getAChild() and not exp instanceof VariableAccess)\n    or\n    exists(Variable other |\n      exp = other.getInitializer().getExpr() and not exp instanceof VariableAccess\n    )\n  )\n}\n\nExpr assignedValueForVariableAndQualifier(Variable v, Declaration qualifier) {\n  result = v.getInitializer().getExpr() and qualifier = result.getEnclosingFunction()\n  or\n  exists(AssignExpr e | e.getLValue() = qualifiedAccess(v, qualifier) and result = e.getRValue())\n}\n\npredicate checkedFunctionCall(FunctionCall fc) {\n  relevantFunctionCall(fc, _) and\n  exists(Variable v, Declaration qualifier |\n    fc = assignedValueForVariableAndQualifier(v, qualifier)\n  |\n    hasNullCheck(fc.getEnclosingFunction(), v, qualifier)\n  )\n}\n\npredicate uncheckedFunctionCall(FunctionCall fc) {\n  relevantFunctionCall(fc, _) and\n  not checkedFunctionCall(fc) and\n  not exists(File f, int line | f = fc.getFile() and line = fc.getLocation().getEndLine() |\n    assertInvocation(f, line + 1) or assertInvocation(f, line)\n  ) and\n  not exists(Variable v, Declaration qualifier |\n    fc = assignedValueForVariableAndQualifier(v, qualifier)\n  |\n    nullCheckAssert(_, v, qualifier)\n  ) and\n  not exists(ControlStructure s | callResultNullCheckInCondition(s.getControllingExpr(), fc)) and\n  not exists(FunctionCall other, Variable v, Declaration qualifier, Expr arg |\n    fc = assignedValueForVariableAndQualifier(v, qualifier)\n  |\n    arg = other.getAnArgument() and\n    nullCheckInCondition(arg, v, qualifier) and\n    not arg instanceof VariableAccess\n  )\n}\n\nDeclaration functionQualifier(FunctionCall fc) {\n  fc.getQualifier().(VariableAccess).getTarget() = result\n  or\n  exists(PointerDereferenceExpr e, VariableAccess va |\n    fc.getQualifier() = e and e.getOperand() = va and va.getTarget() = result\n  )\n  or\n  not exists(fc.getQualifier()) and result = fc.getEnclosingFunction()\n  or\n  fc.getQualifier() instanceof ThisExpr and result = fc.getEnclosingFunction()\n}\n\npredicate callTargetAndEnclosing(FunctionCall fc, Function target, Function enclosing) {\n  target = fc.getTarget() and enclosing = fc.getEnclosingFunction()\n}\n\npredicate callArgumentVariable(FunctionCall fc, Variable v, int i) {\n  fc.getArgument(i) = v.getAnAccess()\n}\n\npredicate callResultNullCheckInCondition(Expr e, FunctionCall fc) {\n  // if(v)\n  exists(FunctionCall other |\n    e = other and\n    relevantFunctionCall(fc, _) and\n    not checkedFunctionCall(fc) and\n    exists(Function called, Function enclosing |\n      callTargetAndEnclosing(fc, called, enclosing) and\n      callTargetAndEnclosing(other, called, enclosing)\n    ) and\n    forall(Variable v, int i | callArgumentVariable(fc, v, i) | callArgumentVariable(other, v, i)) and\n    (\n      functionQualifier(fc) = functionQualifier(other)\n      or\n      not exists(functionQualifier(fc)) and not exists(functionQualifier(other))\n    )\n  )\n  or\n  // if(v == NULL), if(v != NULL), if(NULL != v), if(NULL == v)\n  exists(EqualityOperation eq |\n    eq = e and\n    callResultNullCheckInCondition(eq.getAnOperand(), fc) and\n    eq.getAnOperand().getValue() = \"0\"\n  )\n  or\n  // if(v && something)\n  exists(LogicalAndExpr exp | exp = e and callResultNullCheckInCondition(exp.getAnOperand(), fc))\n  or\n  // if(v || something)\n  exists(LogicalOrExpr exp | exp = e and callResultNullCheckInCondition(exp.getAnOperand(), fc))\n  or\n  // if(!v)\n  exists(NotExpr exp | exp = e and callResultNullCheckInCondition(exp.getAnOperand(), fc))\n}\n\npredicate dereferenced(Variable v, Declaration qualifier, Function f) {\n  exists(PointerDereferenceExpr e |\n    e.getOperand() = qualifiedAccess(v, qualifier) and\n    e.getEnclosingFunction() = f and\n    not exists(SizeofExprOperator s | s.getExprOperand() = e)\n  )\n  or\n  exists(FunctionCall c |\n    c.getQualifier() = qualifiedAccess(v, qualifier) and\n    c.getEnclosingFunction() = f\n  )\n  or\n  exists(VariableAccess va |\n    va.getQualifier() = qualifiedAccess(v, qualifier) and\n    va.getEnclosingFunction() = f\n  )\n}\n\npredicate relevantFunctionCall(FunctionCall fc, Function f) {\n  fc.getTarget() = f and\n  exists(Variable v, Declaration qualifier |\n    fc = assignedValueForVariableAndQualifier(v, qualifier)\n  |\n    dereferenced(v, qualifier, fc.getEnclosingFunction())\n  ) and\n  not okToIgnore(fc)\n}\n\npredicate okToIgnore(FunctionCall fc) { fc.isInMacroExpansion() }\n\npredicate functionStats(Function f, int percentage) {\n  exists(int used, int total |\n    exists(PointerType pt | pt.getATypeNameUse() = f.getADeclarationEntry()) and\n    used = strictcount(FunctionCall fc | checkedFunctionCall(fc) and f = fc.getTarget()) and\n    total = strictcount(FunctionCall fc | relevantFunctionCall(fc, f)) and\n    percentage = used * 100 / total\n  )\n}\n\nfrom FunctionCall unchecked, Function f, int percent\nwhere\n  relevantFunctionCall(unchecked, f) and\n  uncheckedFunctionCall(unchecked) and\n  functionStats(f, percent) and\n  percent >= 70\nselect unchecked,\n  \"The result of this call to \" + f.getName() + \" is not checked for null, but \" + percent +\n    \"% of calls to \" + f.getName() + \" check for null.\"",
        "description": "The result value of a function is often checked for nullness, but not always. Since the value is mostly checked, it is likely that the function can return null values in some cases, and omitting the check could crash the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/InconsistentCheckReturnNull.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nDoStmt getAFalseLoop() {\n  result.getControllingExpr().getValue() = \"0\" and\n  not result.getControllingExpr().isAffectedByMacro()\n}\n\nDoStmt enclosingLoop(Stmt s) {\n  exists(Stmt parent |\n    parent = s.getParent() and\n    (\n      parent instanceof Loop and\n      result = parent\n      or\n      not parent instanceof Loop and\n      not parent instanceof SwitchStmt and\n      result = enclosingLoop(parent)\n    )\n  )\n}\n\nfrom DoStmt loop, ContinueStmt continue\nwhere\n  loop = getAFalseLoop() and\n  loop = enclosingLoop(continue)\nselect continue, \"This 'continue' never re-runs the loop - the $@ is always false.\",\n  loop.getControllingExpr(), \"loop condition\"",
        "description": "A 'continue' statement only re-runs the loop if the loop-condition is true. Therefore using 'continue' in a loop with a constant false condition is misleading and usually a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/ContinueInFalseLoop.ql",
        "language": "cpp"
    },
    {
        "query": "import ReturnConstTypeCommon\n\nfrom Function f\nwhere\n  hasSuperfluousConstReturn(f) and\n  not f instanceof MemberFunction\nselect f, \"The 'const' modifier has no effect on a return type and can be removed.\"",
        "description": "A 'const' modifier on a function return type is useless and should be removed for clarity.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/ReturnConstType.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.ValueNumbering\nimport PathGraph\n\nclass NullInstruction extends ConstantValueInstruction {\n  NullInstruction() {\n    this.getValue() = \"0\" and\n    this.getResultIRType() instanceof IRAddressType\n  }\n}\n\npredicate explicitNullTestOfInstruction(Instruction checked, Instruction bool) {\n  bool =\n    any(CompareInstruction cmp |\n      exists(NullInstruction null |\n        cmp.getLeft() = null and cmp.getRight() = checked\n        or\n        cmp.getLeft() = checked and cmp.getRight() = null\n      |\n        cmp instanceof CompareEQInstruction\n        or\n        cmp instanceof CompareNEInstruction\n      )\n    )\n  or\n  bool =\n    any(ConvertInstruction convert |\n      checked = convert.getUnary() and\n      convert.getResultIRType() instanceof IRBooleanType and\n      checked.getResultIRType() instanceof IRAddressType\n    )\n}\n\npragma[nomagic]\npredicate candidateResult(LoadInstruction checked, ValueNumber value, IRBlock dominator) {\n  explicitNullTestOfInstruction(checked, _) and\n  not checked.getAst().isInMacroExpansion() and\n  value.getAnInstruction() = checked and\n  dominator.dominates(checked.getBlock())\n}\n\nmodule PathGraph {\n  /**\n   * Holds if `deref` is a load instruction that loads a value\n   * from the address `address`. This predicate is restricted to\n   * those pairs for which we will end up reporting a result.\n   */\n  private predicate isSource(Instruction address, LoadInstruction deref) {\n    exists(ValueNumber sourceValue |\n      candidateResult(_, sourceValue, deref.getBlock()) and\n      sourceValue.getAnInstruction() = address and\n      deref.getSourceAddress() = address\n    )\n  }\n\n  /**\n   * Holds if `checked` has global value number `vn` and is an instruction that is\n   * used in a check against a null value.\n   */\n  private predicate isSink(LoadInstruction checked, ValueNumber vn) {\n    candidateResult(checked, vn, _)\n  }\n\n  /** Holds if `i` is control-flow reachable from a relevant `LoadInstruction`. */\n  private predicate fwdFlow(Instruction i) {\n    isSource(i, _)\n    or\n    exists(Instruction mid |\n      fwdFlow(mid) and\n      mid.getASuccessor() = i\n    )\n  }\n\n  /**\n   * Holds if `i` is part of a path from a relevant `LoadInstruction` to a\n   * check against a null value that compares a value against an instruction\n   * with global value number `vn`.\n   */\n  private predicate revFlow(Instruction i, ValueNumber vn) {\n    fwdFlow(i) and\n    (\n      isSink(i, vn)\n      or\n      exists(Instruction mid |\n        revFlow(mid, vn) and\n        i.getASuccessor() = mid\n      )\n    )\n  }\n\n  /**\n   * Gets a first control-flow successor of `i` that has the same\n   * global value number as `i`.\n   */\n  private Instruction getASuccessor(Instruction i) {\n    exists(ValueNumber vn |\n      vn.getAnInstruction() = i and\n      result = getASuccessorWithValueNumber(i, vn)\n    )\n  }\n\n  /**\n   * Gets a first control-flow successor of `i` that has the same\n   * global value number as `i`. Furthermore, `i` has global value\n   * number `vn`.\n   */\n  private Instruction getASuccessorWithValueNumber(Instruction i, ValueNumber vn) {\n    revFlow(i, vn) and\n    result = getASuccessorWithValueNumber0(vn, i.getASuccessor()) and\n    vn.getAnInstruction() = i\n  }\n\n  pragma[nomagic]\n  private Instruction getASuccessorWithValueNumber0(ValueNumber vn, Instruction i) {\n    result = getASuccessorIfDifferentValueNumberTC(vn, i) and\n    vn.getAnInstruction() = result\n  }\n\n  /**\n   * Computes the reflexive transitive closure of `getASuccessorIfDifferentValueNumber`.\n   */\n  private Instruction getASuccessorIfDifferentValueNumberTC(ValueNumber vn, Instruction i) {\n    revFlow(i, vn) and\n    (\n      i = result and\n      vn.getAnInstruction() = i\n      or\n      exists(Instruction mid |\n        mid = getASuccessorIfDifferentValueNumber(vn, i) and\n        result = getASuccessorIfDifferentValueNumberTC(vn, mid)\n      )\n    )\n  }\n\n  /**\n   * Gets an instruction that is a control-flow successor of `i` and which is not assigned\n   * the global value number `vn`.\n   */\n  private Instruction getASuccessorIfDifferentValueNumber(ValueNumber vn, Instruction i) {\n    revFlow(i, vn) and\n    revFlow(result, vn) and\n    not vn.getAnInstruction() = i and\n    pragma[only_bind_into](result) = pragma[only_bind_into](i).getASuccessor()\n  }\n\n  query predicate nodes(Instruction i, string key, string val) {\n    revFlow(i, _) and\n    key = \"semmle.label\" and\n    val = i.getAst().toString()\n  }\n\n  /**\n   * The control-flow successor relation, compacted by stepping\n   * over instruction that don't preserve the global value number.\n   *\n   * There is one exception to the above preservation rule: The\n   * initial step from the `LoadInstruction` (that is, the sink)\n   * steps to the first control-flow reachable instruction that\n   * has the same value number as the load instruction's address\n   * operand.\n   */\n  query predicate edges(Instruction i1, Instruction i2) {\n    getASuccessor(i1) = i2\n    or\n    // We could write `isSource(i2, i1)` here, but that would\n    // include a not-very-informative step from `*p` to `p`.\n    // So we collapse `*p` -> `p` -> `q` to `*p` -> `q`.\n    exists(Instruction mid |\n      isSource(mid, i1) and\n      getASuccessor(mid) = i2\n    )\n  }\n}\n\nfrom LoadInstruction checked, LoadInstruction deref, ValueNumber sourceValue, IRBlock dominator\nwhere\n  candidateResult(checked, sourceValue, dominator) and\n  sourceValue.getAnInstruction() = deref.getSourceAddress() and\n  // This also holds if the blocks are equal, meaning that the check could come\n  // before the deref. That's still not okay because when they're in the same\n  // basic block then the deref is unavoidable even if the check concluded that\n  // the pointer was null. To follow this idea to its full generality, we\n  // should also give an alert when `check` post-dominates `deref`.\n  deref.getBlock() = dominator\nselect checked, deref, checked, \"This null check is redundant because $@ in any case.\", deref,\n  \"the value is dereferenced\"",
        "description": "Checking a pointer for nullness after dereferencing it is likely to be a sign that either the check can be removed, or it should be moved before the dereference.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/RedundantNullCheckSimple.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate exclude(Function f) {\n  exists(string name | name = f.getName() |\n    name.toLowerCase().matches(\"get%\") or\n    name.matches(\"strto%\")\n  )\n}\n\npredicate checkExpr(Expr e, string operation, Variable v) {\n  exists(FunctionCall fc | fc = e and not exclude(fc.getTarget()) |\n    fc.getTarget().getName() = operation and\n    (fc.getAnArgument() = v.getAnAccess() or fc.getQualifier() = v.getAnAccess())\n  )\n  or\n  exists(DeleteExpr del | del = e |\n    del.getExpr() = v.getAnAccess() and\n    operation = \"delete\"\n  )\n  or\n  exists(DeleteArrayExpr del | del = e |\n    del.getExpr() = v.getAnAccess() and\n    operation = \"delete[]\"\n  )\n}\n\npredicate checkedFunctionCall(FunctionCall fc, string operation) {\n  relevantFunctionCall(fc, _) and\n  exists(Variable v, Expr check | v.getAnAssignedValue() = fc |\n    checkExpr(check, operation, v) and\n    check != fc\n  )\n}\n\npredicate relevantFunctionCall(FunctionCall fc, Function f) {\n  fc.getTarget() = f and\n  exists(Variable v | v.getAnAssignedValue() = fc) and\n  not okToIgnore(fc)\n}\n\npredicate okToIgnore(FunctionCall fc) { fc.isInMacroExpansion() }\n\npredicate functionStats(Function f, string operation, int used, int total, int percentage) {\n  exists(PointerType pt | pt.getATypeNameUse() = f.getADeclarationEntry()) and\n  used = strictcount(FunctionCall fc | checkedFunctionCall(fc, operation) and f = fc.getTarget()) and\n  total = strictcount(FunctionCall fc | relevantFunctionCall(fc, f)) and\n  percentage = used * 100 / total\n}\n\nfrom FunctionCall unchecked, Function f, string operation, int percent\nwhere\n  relevantFunctionCall(unchecked, f) and\n  not checkedFunctionCall(unchecked, operation) and\n  functionStats(f, operation, _, _, percent) and\n  percent >= 70 and\n  unchecked.getFile().getAbsolutePath().matches(\"%fbcode%\") and\n  not unchecked.getFile().getAbsolutePath().matches(\"%\\\\_build%\")\nselect unchecked,\n  \"After \" + percent.toString() + \"% of calls to \" + f.getName() + \" there is a call to \" +\n    operation + \" on the return value. The call may be missing in this case.\"",
        "description": "A function is called, and the same operation is usually performed on the return value - for example, free, delete, close etc. However, in some cases it is not performed. These unusual cases may indicate misuse of the API and could cause resource leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/InconsistentCallOnResult.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.DateTime\n\npredicate assignedYear(Struct s, YearFieldAccess year, int value) {\n  exists(Operation yearAssignment |\n    s.getAField().getAnAccess() = year and\n    yearAssignment.getAnOperand() = year and\n    yearAssignment.getAnOperand().getValue().toInt() = value\n  )\n}\n\npredicate assignedMonth(Struct s, MonthFieldAccess month, int value) {\n  exists(Operation monthAssignment |\n    s.getAField().getAnAccess() = month and\n    monthAssignment.getAnOperand() = month and\n    monthAssignment.getAnOperand().getValue().toInt() = value\n  )\n}\n\npredicate assignedDay(Struct s, DayFieldAccess day, int value) {\n  exists(Operation dayAssignment |\n    s.getAField().getAnAccess() = day and\n    dayAssignment.getAnOperand() = day and\n    dayAssignment.getAnOperand().getValue().toInt() = value\n  )\n}\n\nfrom StructLikeClass s, YearFieldAccess year, MonthFieldAccess month, DayFieldAccess day\nwhere\n  assignedYear(s, year, 1989) and\n  assignedMonth(s, month, 1) and\n  assignedDay(s, day, 8)\nselect year, \"A time struct that is initialized with exact Japanese calendar era start date.\"",
        "description": "Japanese era changes can lead to code behaving differently. Avoid hard-coding Japanese era start dates.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/JapaneseEra/StructWithExactEraDate.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Call cc, int i\nwhere\n  cc.getArgument(i).getValue().toInt() = 1989 and\n  cc.getArgument(i + 1).getValue().toInt() = 1 and\n  cc.getArgument(i + 2).getValue().toInt() = 8\nselect cc, \"Call that appears to have hard-coded Japanese era start date as parameter.\"",
        "description": "Japanese era changes can lead to code behaving differently. Avoid hard-coding Japanese era start dates.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/JapaneseEra/ConstructorOrMethodWithExactEraDate.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport TooFewArguments\nimport semmle.code.cpp.ConfigurationTestFile\n\nfrom FunctionCall fc, Function f\nwhere\n  tooFewArguments(fc, f) and\n  not fc.getFile() instanceof ConfigurationTestFile // calls in files generated during configuration are likely false positives\nselect fc, \"This call has fewer arguments than required by $@.\", f, f.toString()",
        "description": "A function call is passing fewer arguments than the number of declared parameters of the function. This may indicate that the code does not follow the author's intent. It is also a vulnerability, since the function is likely to operate on undefined data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Underspecified Functions/TooFewArguments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport MistypedFunctionArguments\nimport TooFewArguments\nimport TooManyArguments\nimport semmle.code.cpp.commons.Exclusions\n\npredicate locInfo(Locatable e, File file, int line, int col) {\n  e.getFile() = file and\n  e.getLocation().getStartLine() = line and\n  e.getLocation().getStartColumn() = col\n}\n\npredicate sameLocation(FunctionDeclarationEntry fde, FunctionCall fc) {\n  exists(File file, int line, int col |\n    locInfo(fde, file, line, col) and\n    locInfo(fc, file, line, col)\n  )\n}\n\npredicate isCompiledAsC(File f) {\n  f.compiledAsC()\n  or\n  exists(File src | isCompiledAsC(src) | src.getAnIncludedFile() = f)\n}\n\nfrom FunctionDeclarationEntry fdeIm, FunctionCall fc\nwhere\n  isCompiledAsC(fdeIm.getFile()) and\n  not isFromMacroDefinition(fc) and\n  fdeIm.isImplicit() and\n  sameLocation(fdeIm, fc) and\n  not mistypedFunctionArguments(fc, _, _) and\n  not tooFewArguments(fc, _) and\n  not tooManyArguments(fc, _)\nselect fc, \"Function call implicitly declares '\" + fdeIm.getName() + \"'.\"",
        "description": "An implicitly declared function is assumed to take no arguments and return an integer. If this assumption does not hold, it may lead to unpredictable behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Underspecified Functions/ImplicitFunctionDeclaration.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport MistypedFunctionArguments\n\nfrom FunctionCall fc, Function f, Parameter p\nwhere mistypedFunctionArguments(fc, f, p)\nselect fc, \"Calling $@: argument $@ of type $@ is incompatible with parameter $@.\", f, f.toString(),\n  fc.getArgument(p.getIndex()) as arg, arg.toString(),\n  arg.getExplicitlyConverted().getUnspecifiedType() as atype, atype.toString(), p, p.getTypedName()",
        "description": "When the type of a function argument is not compatible with the type of the corresponding parameter, it may lead to unpredictable behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Underspecified Functions/MistypedFunctionArguments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport TooManyArguments\n\nfrom FunctionCall fc, Function f\nwhere tooManyArguments(fc, f)\nselect fc, \"This call has more arguments than required by $@.\", f, f.toString()",
        "description": "A function call to a function passed more arguments than there are declared parameters of the function.  This may indicate that the code does not follow the author's intent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Underspecified Functions/TooManyArguments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass BitwiseOperation extends Expr {\n  BitwiseOperation() {\n    this instanceof BinaryBitwiseOperation or\n    this instanceof UnaryBitwiseOperation\n  }\n}\n\nclass LogicalOperation extends Expr {\n  LogicalOperation() {\n    this instanceof BinaryLogicalOperation or\n    this instanceof UnaryLogicalOperation or\n    this instanceof ComparisonOperation\n  }\n}\n\npredicate nonShortCircuitLogic2(BinaryBitwiseOperation op) {\n  (op instanceof BitwiseAndExpr or op instanceof BitwiseOrExpr or op instanceof BitwiseXorExpr) and\n  (op.getLeftOperand() instanceof LogicalOperation or nonShortCircuitLogic2(op.getLeftOperand())) and\n  (op.getRightOperand() instanceof LogicalOperation or nonShortCircuitLogic2(op.getRightOperand()))\n}\n\nfrom LogicalOperation o\nwhere\n  o.getParent() instanceof BitwiseOperation and\n  not nonShortCircuitLogic2(o.getParent()) and\n  not o.getParent().isInMacroExpansion() and // It's ok if o itself is in a macro expansion.\n  not o.getParent().(LShiftExpr).getLeftOperand() = o // Common pattern for producing bit masks: \"(a && b) << 16\".\nselect o, \"The result of this expression is Boolean, but it is used in a bitwise context.\"",
        "description": "A Boolean value (i.e. something that has been coerced to have a value of either 0 or 1) is used in a bitwise operation. This commonly indicates missing parentheses or mistyping logical operators as bitwise operators.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/BoolValueInBitOp.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate macroUse(Locatable l) {\n  l instanceof PreprocessorDirective or l instanceof MacroInvocation\n}\n\npredicate macroUseLocation(File f, int start, int end) {\n  exists(Locatable l, Location loc |\n    macroUse(l) and\n    loc = l.getLocation() and\n    f = loc.getFile() and\n    start = loc.getStartLine() and\n    end = loc.getEndLine()\n  )\n}\n\npragma[noopt]\npredicate emptyIf(IfStmt s, BlockStmt b, File f, int start, int end) {\n  s instanceof IfStmt and\n  not exists(s.getElse()) and\n  b = s.getThen() and\n  b instanceof BlockStmt and\n  not exists(b.getAChild()) and\n  f = b.getFile() and\n  exists(Location l |\n    l = b.getLocation() and\n    start = l.getStartLine() and\n    end = l.getEndLine()\n  )\n}\n\npragma[noopt]\npredicate query(IfStmt s, BlockStmt b) {\n  exists(File f, int blockStart, int blockEnd |\n    emptyIf(s, b, f, blockStart, blockEnd) and\n    not exists(int macroStart, int macroEnd |\n      macroUseLocation(f, macroStart, macroEnd) and\n      macroStart > blockStart and\n      macroEnd < blockEnd\n    )\n  )\n}\n\nfrom IfStmt s, BlockStmt b\nwhere\n  query(s, b) and\n  not b.isInMacroExpansion()\nselect s, \"If-statement with an empty then-branch and no else-branch.\"",
        "description": "An if-statement with an empty then-branch and no else-branch may indicate that the code is incomplete.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/FutileConditional.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.StackVariableReachability\n\nclass UndefReachability extends StackVariableReachability {\n  UndefReachability() { this = \"UndefReachability\" }\n\n  override predicate isSource(ControlFlowNode node, StackVariable v) {\n    candidateVariable(v) and\n    node = v.getParentScope() and\n    not v instanceof Parameter and\n    not v.hasInitializer()\n  }\n\n  override predicate isSink(ControlFlowNode node, StackVariable v) {\n    candidateVariable(v) and\n    node = v.getAnAccess()\n  }\n\n  override predicate isBarrier(ControlFlowNode node, StackVariable v) {\n    node.(AssignExpr).getLValue() = v.getAnAccess()\n  }\n}\n\nabstract class BooleanControllingAssignment extends AssignExpr {\n  abstract predicate isWhitelisted();\n}\n\nExpr getComparisonOperand(BinaryLogicalOperation op) { result = op.getAnOperand() }\n\nclass BooleanControllingAssignmentInExpr extends BooleanControllingAssignment {\n  BooleanControllingAssignmentInExpr() {\n    this.getParent() instanceof UnaryLogicalOperation or\n    this.getParent() instanceof BinaryLogicalOperation or\n    exists(ConditionalExpr c | c.getCondition() = this)\n  }\n\n  override predicate isWhitelisted() {\n    this.getConversion().(ParenthesisExpr).isParenthesised()\n    or\n    // Allow this assignment if all comparison operations in the expression that this\n    // assignment is part of, are not parenthesized. In that case it seems like programmer\n    // is fine with unparenthesized comparison operands to binary logical operators, and\n    // the parenthesis around this assignment was used to call it out as an assignment.\n    this.isParenthesised() and\n    forex(ComparisonOperation op | op = getComparisonOperand*(this.getParent+()) |\n      not op.isParenthesised()\n    )\n    or\n    // Match a pattern like:\n    // ```\n    // if((a = b) && use_value(a)) { ... }\n    // ```\n    // where the assignment is meant to update the value of `a` before it's used in some other boolean\n    // subexpression that is guaranteed to be evaluate _after_ the assignment.\n    this.isParenthesised() and\n    exists(LogicalAndExpr parent, Variable var, VariableAccess access |\n      var = this.getLValue().(VariableAccess).getTarget() and\n      access = var.getAnAccess() and\n      not access.isUsedAsLValue() and\n      parent.getRightOperand() = access.getParent*() and\n      parent.getLeftOperand() = this.getParent*()\n    )\n  }\n}\n\nclass BooleanControllingAssignmentInStmt extends BooleanControllingAssignment {\n  BooleanControllingAssignmentInStmt() {\n    exists(IfStmt i | i.getCondition() = this) or\n    exists(ForStmt f | f.getCondition() = this) or\n    exists(WhileStmt w | w.getCondition() = this) or\n    exists(DoStmt d | d.getCondition() = this)\n  }\n\n  override predicate isWhitelisted() { this.isParenthesised() }\n}\n\npredicate candidateResult(BooleanControllingAssignment ae) {\n  ae.getRValue().isConstant() and\n  not ae.isWhitelisted() and\n  not ae.getRValue() instanceof StringLiteral\n}\n\npredicate candidateVariable(Variable v) {\n  exists(BooleanControllingAssignment ae |\n    candidateResult(ae) and\n    ae.getLValue().(VariableAccess).getTarget() = v\n  )\n}\n\nfrom BooleanControllingAssignment ae, UndefReachability undef\nwhere\n  candidateResult(ae) and\n  not ae.isFromUninstantiatedTemplate(_) and\n  not undef.reaches(_, ae.getLValue().(VariableAccess).getTarget(), ae.getLValue())\nselect ae, \"Use of '=' where '==' may have been intended.\"",
        "description": "The '=' operator may have been used accidentally, where '==' was intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/AssignWhereCompareMeant.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom ExprInVoidContext op\nwhere\n  not op.isUnevaluated() and\n  not inMacroExpansion(op) and\n  (\n    op instanceof EQExpr\n    or\n    op.(FunctionCall).getTarget().hasName(\"operator==\")\n  )\nselect op, \"This '==' operator has no effect. The assignment ('=') operator was probably intended.\"",
        "description": "The '==' operator may have been used accidentally, where '=' was intended, resulting in a useless test.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/CompareWhereAssignMeant.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate doubleNegationNormalization(NotExpr notexpr) { notexpr.getAnOperand() instanceof NotExpr }\n\nfrom BinaryBitwiseOperation binbitwop\nwhere\n  exists(NotExpr notexpr |\n    binbitwop.getAnOperand() = notexpr and\n    not doubleNegationNormalization(notexpr) and\n    (\n      binbitwop instanceof BitwiseAndExpr or\n      binbitwop instanceof BitwiseOrExpr\n    )\n  )\nselect binbitwop, \"Usage of a logical not (!) expression as a bitwise operator.\"",
        "description": "Usage of a logical-not (!) operator as an operand for a bit-wise operation. This commonly indicates the usage of an incorrect operator instead of the bit-wise not (~) operator, also known as ones' complement operator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/IncorrectNotOperatorUsage.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom EnumSwitch es, float missing, float total, EnumConstant case\nwhere\n  not es.hasDefaultCase() and\n  missing = count(es.getAMissingCase()) and\n  total = missing + count(es.getASwitchCase()) and\n  missing / total < 0.3 and\n  case = es.getAMissingCase()\nselect es, \"Switch statement does not have a case for $@.\", case, case.getName()",
        "description": "A switch statement over an enum type is missing a case for some enum constant and does not have a default case. This may cause logic errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/MissingEnumCaseInSwitch.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate zeroComparison(EqualityOperation e) {\n  exists(Expr zero | zero.getValue() = \"0\" |\n    zero = e.getLeftOperand() or\n    zero = e.getRightOperand()\n  )\n}\n\npredicate inNullContext(AddressOfExpr e) {\n  e.getFullyConverted().getUnderlyingType() instanceof BoolType\n  or\n  exists(ControlStructure c | c.getControllingExpr() = e)\n  or\n  exists(EqualityOperation cmp | zeroComparison(cmp) |\n    e = cmp.getLeftOperand() or\n    e = cmp.getRightOperand()\n  )\n}\n\nFieldAccess chainedFields(FieldAccess fa) {\n  result = fa or\n  result = chainedFields(fa.getQualifier())\n}\n\nfrom AddressOfExpr addrof, FieldAccess fa, Variable v, int offset\nwhere\n  fa = addrof.getOperand() and\n  inNullContext(addrof) and\n  not addrof.isInMacroExpansion() and\n  v.getAnAccess() = chainedFields(fa).getQualifier() and\n  not v instanceof MemberVariable and\n  offset = strictsum(chainedFields(fa).getTarget().getByteOffset()) and\n  offset != 0\nselect addrof, \"This will only be NULL if \" + v.getName() + \" == -\" + offset + \".\"",
        "description": "The address of a field (except the first) will never be NULL, so it is misleading, at best, to check for that case.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/DubiousNullCheck.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Exclusions\nimport semmle.code.cpp.ConfigurationTestFile\n\nclass PureExprInVoidContext extends ExprInVoidContext {\n  PureExprInVoidContext() { this.isPure() }\n}\n\n// loop variable mentioned in the init stmt of a for\npredicate accessInInitOfForStmt(Expr e) {\n  e instanceof Access and\n  exists(ForStmt f, ExprStmt s |\n    f.getInitialization() = s and\n    s.getExpr() = e\n  )\n}\n\npredicate functionContainsDisabledCodeRecursive(Function f) {\n  functionContainsDisabledCode(f)\n  or\n  // recurse into function calls\n  exists(FunctionCall fc |\n    fc.getEnclosingFunction() = f and\n    functionContainsDisabledCodeRecursive(fc.getTarget())\n  )\n}\n\npredicate functionDefinedInIfDefRecursive(Function f) {\n  functionDefinedInIfDef(f)\n  or\n  // recurse into function calls\n  exists(FunctionCall fc |\n    fc.getEnclosingFunction() = f and\n    functionDefinedInIfDefRecursive(fc.getTarget())\n  )\n}\n\npredicate baseCall(FunctionCall call) {\n  call.getNameQualifier().getQualifyingElement() =\n    call.getEnclosingFunction().getDeclaringType().getABaseClass+()\n}\n\nfrom PureExprInVoidContext peivc, Locatable parent, Locatable info, string info_text, string tail\nwhere\n  // EQExprs are covered by CompareWhereAssignMeant.ql\n  not peivc instanceof EQExpr and\n  // as is operator==\n  not peivc.(FunctionCall).getTarget().hasName(\"operator==\") and\n  not baseCall(peivc) and\n  not accessInInitOfForStmt(peivc) and\n  not peivc.isCompilerGenerated() and\n  not peivc.getEnclosingFunction().isDefaulted() and\n  not exists(Macro m | peivc = m.getAnInvocation().getAnExpandedElement()) and\n  not peivc.isFromTemplateInstantiation(_) and\n  not peivc.isFromUninstantiatedTemplate(_) and\n  parent = peivc.getParent() and\n  not parent.isInMacroExpansion() and\n  not peivc.isUnevaluated() and\n  not parent instanceof PureExprInVoidContext and\n  not peivc.getEnclosingFunction().isCompilerGenerated() and\n  not peivc.getType() instanceof UnknownType and\n  not functionContainsDisabledCodeRecursive(peivc.(FunctionCall).getTarget()) and\n  not functionDefinedInIfDefRecursive(peivc.(FunctionCall).getTarget()) and\n  not peivc.getFile() instanceof ConfigurationTestFile and // expressions in files generated during configuration are likely false positives\n  if peivc instanceof FunctionCall\n  then\n    exists(Function target |\n      target = peivc.(FunctionCall).getTarget() and\n      info = target and\n      info_text = target.getName() and\n      tail = \" (because $@ has no external side effects).\"\n    )\n  else (\n    tail = \".\" and info = peivc and info_text = \"\"\n  )\nselect peivc, \"This expression has no effect\" + tail, info, info_text",
        "description": "A pure expression whose value is ignored is likely to be the result of a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/ExprHasNoEffect.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate simple(Literal l) {\n  l instanceof OctalLiteral or\n  l instanceof HexLiteral or\n  l instanceof CharLiteral or\n  l.getValueText() = \"true\" or\n  l.getValueText() = \"false\" or\n  // Parsing doubles is too slow...\n  //exists(l.getValueText().toFloat())\n  // Instead, check whether the literal starts with a letter.\n  not l.getValueText().regexpMatch(\"[a-zA-Z_].*\")\n}\n\npredicate booleanLiteral(Literal l) {\n  simple(l) and\n  (l.getValue() = \"0\" or l.getValue() = \"1\" or l.getValue() = \"true\" or l.getValue() = \"false\")\n}\n\nstring boolLiteralInLogicalOp(Literal literal) {\n  booleanLiteral(literal) and\n  literal.getParent() instanceof BinaryLogicalOperation and\n  result =\n    \"Literal value \" + literal.getValueText() +\n      \" is used in a logical expression; simplify or use a constant.\"\n}\n\nstring comparisonOnLiterals(ComparisonOperation op) {\n  simple(op.getLeftOperand()) and\n  simple(op.getRightOperand()) and\n  not op.getAnOperand().isInMacroExpansion() and\n  if exists(op.getValue())\n  then result = \"This comparison involves two literals and is always \" + op.getValue() + \".\"\n  else result = \"This comparison involves two literals and should be simplified.\"\n}\n\nfrom Expr e, string msg\nwhere\n  (msg = boolLiteralInLogicalOp(e) or msg = comparisonOnLiterals(e)) and\n  not e.isInMacroExpansion()\nselect e, msg",
        "description": "When a logical expression can be easily simplified, there may be an opportunity to improve readability by doing so, or it may indicate that the code contains a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/LogicalExprCouldBeSimplified.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfloat candidateExpr(Expr e) {\n  exists(BinaryLogicalOperation blo |\n    e = blo.getAnOperand() and\n    e.isConstant() and\n    result = e.getValue().toFloat() and\n    // exclusions\n    not e.isFromTemplateInstantiation(_) and\n    not e instanceof SizeofOperator and\n    not inMacroExpansion(blo) and\n    // exclude values 0 and 1\n    result != 0.0 and\n    result != 1.0\n  )\n}\n\nfrom Expr e, float v, int l, string msg\nwhere\n  v = candidateExpr(e) and\n  // before reporting an error, we check that the candidate is either a hex/octal\n  // literal, or its value is a power of two.\n  l = v.log2().floor() and\n  if v = 2.pow(l)\n  then\n    msg =\n      \"Operand to short-circuiting operator looks like a flag (\" + v + \" = 2 ^ \" + l +\n        \"), may be typo for bitwise operator.\"\n  else\n    exists(string kind |\n      (\n        e instanceof HexLiteral and kind = \"a hexadecimal literal\"\n        or\n        e instanceof OctalLiteral and kind = \"an octal literal\"\n      ) and\n      msg =\n        \"Operand to short-circuiting operator is \" + kind +\n          \", and therefore likely a flag; a bitwise operator may be intended.\"\n    )\nselect e, msg",
        "description": "A short-circuiting logical operator is applied to what looks like a flag. This may be a typo for a bitwise operator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/ShortCircuitBitMask.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.models.implementations.Strcpy\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\nclass InterestingStrcpyFunction extends StrcpyFunction {\n  InterestingStrcpyFunction() { this.getType().getUnspecifiedType() instanceof PointerType }\n}\n\npredicate isBoolean(Expr e1) {\n  exists(Type t1 |\n    t1 = e1.getType() and\n    (t1.hasName(\"bool\") or t1.hasName(\"BOOL\") or t1.hasName(\"_Bool\"))\n  )\n}\n\npredicate isStringCopyCastedAsBoolean(FunctionCall func, Expr expr1, string msg) {\n  DataFlow::localExprFlow(func, expr1) and\n  isBoolean(expr1.getConversion*()) and\n  func.getTarget() instanceof InterestingStrcpyFunction and\n  msg = \"Return value of \" + func.getTarget().getName() + \" used as a Boolean.\"\n}\n\npredicate isStringCopyUsedInLogicalOperationOrCondition(FunctionCall func, Expr expr1, string msg) {\n  func.getTarget() instanceof InterestingStrcpyFunction and\n  (\n    (\n      // it is being used in an equality or logical operation\n      exists(EqualityOperation eop |\n        eop = expr1 and\n        func = eop.getAnOperand()\n      )\n      or\n      exists(UnaryLogicalOperation ule |\n        expr1 = ule and\n        func = ule.getOperand()\n      )\n      or\n      exists(BinaryLogicalOperation ble |\n        expr1 = ble and\n        func = ble.getAnOperand()\n      )\n    ) and\n    msg = \"Return value of \" + func.getTarget().getName() + \" used in a logical operation.\"\n    or\n    // or the string copy function is used directly as the conditional expression\n    (\n      exists(ConditionalStmt condstmt |\n        func = condstmt.getControllingExpr() and\n        expr1 = func\n      )\n      or\n      exists(ConditionalExpr ce |\n        expr1 = ce and\n        func = ce.getCondition()\n      )\n    ) and\n    msg =\n      \"Return value of \" + func.getTarget().getName() +\n        \" used directly in a conditional expression.\"\n  )\n}\n\nfrom FunctionCall func, Expr expr1, string msg\nwhere\n  isStringCopyCastedAsBoolean(func, expr1, msg) and\n  not isStringCopyUsedInLogicalOperationOrCondition(func, _, _)\n  or\n  isStringCopyUsedInLogicalOperationOrCondition(func, expr1, msg)\nselect expr1, msg",
        "description": "The return value for strcpy, strncpy, or related string copy functions have no reserved return value to indicate an error. Using them in a condition is likely to be a logic error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/UsingStrcpyAsBoolean.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\npredicate candidateForStmt(\n  ForStmt forStmt, Variable v, CrementOperation update, RelationalOperation rel\n) {\n  update = forStmt.getUpdate() and\n  update.getAnOperand() = v.getAnAccess() and\n  rel = forStmt.getCondition()\n}\n\npragma[noinline]\npredicate candidateDecrForStmt(\n  ForStmt forStmt, Variable v, VariableAccess lesserOperand, Expr terminalCondition\n) {\n  exists(DecrementOperation update, RelationalOperation rel |\n    candidateForStmt(forStmt, v, update, rel) and\n    // condition is `v < terminalCondition`\n    terminalCondition = rel.getGreaterOperand() and\n    lesserOperand = rel.getLesserOperand() and\n    v.getAnAccess() = lesserOperand\n  )\n}\n\npredicate illDefinedDecrForStmt(\n  ForStmt forstmt, Variable v, Expr initialCondition, Expr terminalCondition\n) {\n  exists(VariableAccess lesserOperand |\n    // decrementing for loop\n    candidateDecrForStmt(forstmt, v, lesserOperand, terminalCondition) and\n    // `initialCondition` is a value of `v` in the for loop\n    v.getAnAssignedValue() = initialCondition and\n    DataFlow::localFlowStep+(DataFlow::exprNode(initialCondition), DataFlow::exprNode(lesserOperand)) and\n    // `initialCondition` < `terminalCondition`\n    (\n      upperBound(initialCondition) < lowerBound(terminalCondition) and\n      (\n        // exclude cases where the loop counter is `unsigned` (where wrapping behavior can be used deliberately)\n        v.getUnspecifiedType().(IntegralType).isSigned() or\n        initialCondition.getValue().toInt() = 0\n      )\n      or\n      (forstmt.conditionAlwaysFalse() or forstmt.conditionAlwaysTrue())\n    )\n  )\n}\n\npragma[noinline]\npredicate candidateIncrForStmt(\n  ForStmt forStmt, Variable v, VariableAccess greaterOperand, Expr terminalCondition\n) {\n  exists(IncrementOperation update, RelationalOperation rel |\n    candidateForStmt(forStmt, v, update, rel) and\n    // condition is `v > terminalCondition`\n    terminalCondition = rel.getLesserOperand() and\n    greaterOperand = rel.getGreaterOperand() and\n    v.getAnAccess() = greaterOperand\n  )\n}\n\npredicate illDefinedIncrForStmt(\n  ForStmt forstmt, Variable v, Expr initialCondition, Expr terminalCondition\n) {\n  exists(VariableAccess greaterOperand |\n    // incrementing for loop\n    candidateIncrForStmt(forstmt, v, greaterOperand, terminalCondition) and\n    // `initialCondition` is a value of `v` in the for loop\n    v.getAnAssignedValue() = initialCondition and\n    DataFlow::localFlowStep+(DataFlow::exprNode(initialCondition),\n      DataFlow::exprNode(greaterOperand)) and\n    // `terminalCondition` < `initialCondition`\n    (\n      upperBound(terminalCondition) < lowerBound(initialCondition)\n      or\n      (forstmt.conditionAlwaysFalse() or forstmt.conditionAlwaysTrue())\n    )\n  )\n}\n\npredicate illDefinedForStmtWrongDirection(\n  ForStmt forstmt, Variable v, Expr initialCondition, Expr terminalCondition, boolean isIncr\n) {\n  illDefinedDecrForStmt(forstmt, v, initialCondition, terminalCondition) and isIncr = false\n  or\n  illDefinedIncrForStmt(forstmt, v, initialCondition, terminalCondition) and isIncr = true\n}\n\nbindingset[b]\nprivate string forLoopdirection(boolean b) {\n  if b = true then result = \"upward\" else result = \"downward\"\n}\n\nbindingset[b]\nprivate string forLoopTerminalConditionRelationship(boolean b) {\n  if b = true then result = \"lower\" else result = \"higher\"\n}\n\npredicate illDefinedForStmt(ForStmt for, string message) {\n  exists(boolean isIncr, Variable v, Expr initialCondition, Expr terminalCondition |\n    illDefinedForStmtWrongDirection(for, v, initialCondition, terminalCondition, isIncr) and\n    if for.conditionAlwaysFalse()\n    then\n      message =\n        \"Ill-defined for-loop: a loop using variable \\\"\" + v + \"\\\" counts \" +\n          forLoopdirection(isIncr) + \" from a value (\" + initialCondition +\n          \"), but the terminal condition is always false.\"\n    else\n      if for.conditionAlwaysTrue()\n      then\n        message =\n          \"Ill-defined for-loop: a loop using variable \\\"\" + v + \"\\\" counts \" +\n            forLoopdirection(isIncr) + \" from a value (\" + initialCondition +\n            \"), but the terminal condition is always true.\"\n      else\n        message =\n          \"Ill-defined for-loop: a loop using variable \\\"\" + v + \"\\\" counts \" +\n            forLoopdirection(isIncr) + \" from a value (\" + initialCondition +\n            \"), but the terminal condition is \" + forLoopTerminalConditionRelationship(isIncr) +\n            \" (\" + terminalCondition + \").\"\n  )\n}\n\nfrom ForStmt forstmt, string message\nwhere illDefinedForStmt(forstmt, message)\nselect forstmt, message",
        "description": "A for-loop iteration expression goes backward with respect of the initialization statement and condition expression.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Likely Typos/inconsistentLoopDirection.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport LeapYear\n\nfrom Expr source, Expr sink\nwhere\n  PossibleYearArithmeticOperationCheckFlow::flow(DataFlow::exprNode(source),\n    DataFlow::exprNode(sink))\nselect sink,\n  \"An arithmetic operation $@ that uses a constant value of 365 ends up modifying this date/time, without considering leap year scenarios.\",\n  source, source.toString()",
        "description": "When an arithmetic operation modifies a date by a constant value of 365, it may be a sign that leap years are not taken into account.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Leap Year/Adding365DaysPerYear.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass LeapYearUnsafeDaysOfTheYearArrayType extends ArrayType {\n  LeapYearUnsafeDaysOfTheYearArrayType() { this.getArraySize() = 365 }\n}\n\nfrom Element element, string allocType\nwhere\n  exists(NewArrayExpr nae |\n    element = nae and\n    nae.getAllocatedType() instanceof LeapYearUnsafeDaysOfTheYearArrayType and\n    allocType = \"an array allocation\"\n  )\n  or\n  exists(Variable var |\n    var = element and\n    var.getType() instanceof LeapYearUnsafeDaysOfTheYearArrayType and\n    allocType = \"an array allocation\"\n  )\n  or\n  exists(ConstructorCall cc |\n    element = cc and\n    cc.getTarget().hasName(\"vector\") and\n    cc.getArgument(0).getValue().toInt() = 365 and\n    allocType = \"a std::vector allocation\"\n  )\nselect element,\n  \"There is \" + allocType +\n    \" with a hard-coded set of 365 elements, which may indicate the number of days in a year without considering leap year scenarios.\"",
        "description": "An array of 365 items typically indicates one entry per day of the year, but without considering leap years, which would be 366 days. An access on a leap year could result in buffer overflow bugs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Leap Year/UnsafeArrayForDaysOfYear.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport LeapYear\n\nclass DateStructModifiedFieldAccess extends LeapYearFieldAccess {\n  DateStructModifiedFieldAccess() {\n    exists(Field f, StructLikeClass struct |\n      f.getAnAccess() = this and\n      struct.getAField() = f and\n      struct.getUnderlyingType() instanceof UnpackedTimeType and\n      this.isModifiedByArithmeticOperation()\n    )\n  }\n}\n\nclass SafeTimeGatheringFunction extends Function {\n  SafeTimeGatheringFunction() {\n    this.getQualifiedName() = [\"GetFileTime\", \"GetSystemTime\", \"NtQuerySystemTime\"]\n  }\n}\n\nclass TimeConversionFunction extends Function {\n  TimeConversionFunction() {\n    this.getQualifiedName() =\n      [\n        \"FileTimeToSystemTime\", \"SystemTimeToFileTime\", \"SystemTimeToTzSpecificLocalTime\",\n        \"SystemTimeToTzSpecificLocalTimeEx\", \"TzSpecificLocalTimeToSystemTime\",\n        \"TzSpecificLocalTimeToSystemTimeEx\", \"RtlLocalTimeToSystemTime\",\n        \"RtlTimeToSecondsSince1970\", \"_mkgmtime\"\n      ]\n  }\n}\n\nfrom FunctionCall fcall, TimeConversionFunction trf, Variable var\nwhere\n  fcall = trf.getACallToThisFunction() and\n  fcall instanceof ExprInVoidContext and\n  var.getUnderlyingType() instanceof UnpackedTimeType and\n  (\n    exists(AddressOfExpr aoe |\n      aoe = fcall.getAnArgument() and\n      aoe.getAddressable() = var\n    )\n    or\n    exists(VariableAccess va |\n      fcall.getAnArgument() = va and\n      var.getAnAccess() = va\n    )\n  ) and\n  exists(DateStructModifiedFieldAccess dsmfa, VariableAccess modifiedVarAccess |\n    modifiedVarAccess = var.getAnAccess() and\n    modifiedVarAccess = dsmfa.getQualifier() and\n    modifiedVarAccess = fcall.getAPredecessor*()\n  ) and\n  // Remove false positives\n  not (\n    // Remove any instance where the predecessor is a SafeTimeGatheringFunction and no change to the data happened in between\n    exists(FunctionCall pred |\n      pred = fcall.getAPredecessor*() and\n      exists(SafeTimeGatheringFunction stgf | pred = stgf.getACallToThisFunction()) and\n      not exists(DateStructModifiedFieldAccess dsmfa, VariableAccess modifiedVarAccess |\n        modifiedVarAccess = var.getAnAccess() and\n        modifiedVarAccess = dsmfa.getQualifier() and\n        modifiedVarAccess = fcall.getAPredecessor*() and\n        modifiedVarAccess = pred.getASuccessor*()\n      )\n    )\n    or\n    // Remove any instance where the year is changed, but the month is set to 1 (year wrapping)\n    exists(MonthFieldAccess mfa, AssignExpr ae |\n      mfa.getQualifier() = var.getAnAccess() and\n      mfa.isModified() and\n      mfa = fcall.getAPredecessor*() and\n      ae = mfa.getEnclosingElement() and\n      ae.getAnOperand().getValue().toInt() = 1\n    )\n  )\nselect fcall,\n  \"Return value of $@ function should be verified to check for any error because variable $@ is not guaranteed to be safe.\",\n  trf, trf.getQualifiedName().toString(), var, var.getName()",
        "description": "When the return value of a fallible time conversion function is not checked for failure, its output parameters may contain invalid dates.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Leap Year/UncheckedReturnValueForTimeFunctions.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport LeapYear\n\nfrom Variable var, LeapYearFieldAccess yfa\nwhere\n  exists(VariableAccess va |\n    yfa.getQualifier() = va and\n    var.getAnAccess() = va and\n    // The year is modified with an arithmetic operation. Avoid values that are likely false positives\n    yfa.isModifiedByArithmeticOperationNotForNormalization() and\n    // Avoid false positives\n    not (\n      // If there is a local check for leap year after the modification\n      exists(LeapYearFieldAccess yfacheck |\n        yfacheck.getQualifier() = var.getAnAccess() and\n        yfacheck.isUsedInCorrectLeapYearCheck() and\n        yfacheck.getBasicBlock() = yfa.getBasicBlock().getASuccessor*()\n      )\n      or\n      // If there is a data flow from the variable that was modified to a function that seems to check for leap year\n      exists(VariableAccess source, ChecksForLeapYearFunctionCall fc |\n        source = var.getAnAccess() and\n        LeapYearCheckFlow::flow(DataFlow::exprNode(source), DataFlow::exprNode(fc.getAnArgument()))\n      )\n      or\n      // If there is a data flow from the field that was modified to a function that seems to check for leap year\n      exists(VariableAccess vacheck, YearFieldAccess yfacheck, ChecksForLeapYearFunctionCall fc |\n        vacheck = var.getAnAccess() and\n        yfacheck.getQualifier() = vacheck and\n        LeapYearCheckFlow::flow(DataFlow::exprNode(yfacheck), DataFlow::exprNode(fc.getAnArgument()))\n      )\n      or\n      // If there is a successor or predecessor that sets the month = 1\n      exists(MonthFieldAccess mfa, AssignExpr ae |\n        mfa.getQualifier() = var.getAnAccess() and\n        mfa.isModified() and\n        (\n          mfa.getBasicBlock() = yfa.getBasicBlock().getASuccessor*() or\n          yfa.getBasicBlock() = mfa.getBasicBlock().getASuccessor+()\n        ) and\n        ae = mfa.getEnclosingElement() and\n        ae.getAnOperand().getValue().toInt() = 1\n      )\n    )\n  )\nselect yfa,\n  \"Field $@ on variable $@ has been modified, but no appropriate check for LeapYear was found.\",\n  yfa.getTarget(), yfa.getTarget().toString(), var, var.toString()",
        "description": "A field that represents a year is being modified by an arithmetic operation, but no proper check for leap years can be detected afterwards.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Leap Year/UncheckedLeapYearAfterYearModification.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Buffer\n\nfrom Function f, FunctionCall c, int i, ArrayType argType, ArrayType paramType, int a, int b\nwhere\n  f = c.getTarget() and\n  argType = c.getArgument(i).getType() and\n  paramType = f.getParameter(i).getType() and\n  a = argType.getArraySize() and\n  b = paramType.getArraySize() and\n  argType.getBaseType().getSize() = paramType.getBaseType().getSize() and\n  a < b and\n  not memberMayBeVarSize(_, c.getArgument(i).(VariableAccess).getTarget()) and\n  // filter out results for inconsistent declarations\n  strictcount(f.getParameter(i).getType().getSize()) = 1\nselect c.getArgument(i),\n  \"Array of size \" + a + \" passed to $@ which expects an array of size \" + b + \".\", f, f.getName()",
        "description": "Finds function calls where the size of an array being passed is smaller than the array size of the declared parameter. This could lead to accesses to memory locations beyond the parameter's array bounds.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Conversion/ArrayArgSizeMismatch.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\nimport CastToPointerArithFlow::PathGraph\n\nType getFullyConvertedType(DataFlow::Node node) {\n  result = node.asExpr().getFullyConverted().getUnspecifiedType()\n}\n\nmodule CastToPointerArithFlowConfig implements DataFlow::StateConfigSig {\n  class FlowState = Type;\n\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    not node.asExpr() instanceof Conversion and\n    exists(Type baseType1, Type baseType2 |\n      hasBaseType(node.asExpr(), baseType1) and\n      hasBaseType(node.asExpr().getConversion*(), baseType2) and\n      introducesNewField(baseType1, baseType2)\n    ) and\n    getFullyConvertedType(node) = state\n  }\n\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    (\n      exists(PointerAddExpr pae | pae.getAnOperand() = node.asExpr()) or\n      exists(ArrayExpr ae | ae.getArrayBase() = node.asExpr())\n    ) and\n    getFullyConvertedType(node) = state\n  }\n\n  predicate isBarrierIn(DataFlow::Node node) { isSource(node, _) }\n\n  predicate isBarrierOut(DataFlow::Node node) { isSink(node, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\npragma[inline]\npredicate hasBaseType(Expr e, Type base) {\n  pragma[only_bind_into](base) = e.getType().(DerivedType).getBaseType()\n}\n\npredicate introducesNewField(Class derived, Class base) {\n  (\n    exists(Field f |\n      f.getDeclaringType() = derived and\n      derived.getABaseClass+() = base\n    )\n    or\n    introducesNewField(derived.getABaseClass(), base)\n  )\n}\n\nmodule CastToPointerArithFlow = DataFlow::GlobalWithState<CastToPointerArithFlowConfig>;\n\nfrom CastToPointerArithFlow::PathNode source, CastToPointerArithFlow::PathNode sink\nwhere CastToPointerArithFlow::flowPath(source, sink)\nselect sink, source, sink, \"This pointer arithmetic may be done with the wrong type because of $@.\",\n  source, \"this cast\"",
        "description": "An array with elements of a derived struct type is cast to a pointer to the base type of the struct. If pointer arithmetic or an array dereference is done on the resulting pointer, it will use the width of the base type, leading to misaligned reads.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Conversion/CastArrayPointerArithmetic.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom BitField fi, VariableAccess va, Type fct\nwhere\n  (\n    if va.getFullyConverted().getType() instanceof ReferenceType\n    then fct = va.getFullyConverted().getType().(ReferenceType).getBaseType()\n    else fct = va.getFullyConverted().getType()\n  ) and\n  fi.getNumBits() > fct.getSize() * 8 and\n  va.getExplicitlyConverted().getType().getSize() > fct.getSize() and\n  va.getTarget() = fi and\n  not fct.getUnspecifiedType() instanceof BoolType\nselect va, \"Implicit downcast of bitfield $@.\", fi, fi.toString()",
        "description": "A bitfield is implicitly downcast to a smaller integer type. This could lead to loss of upper bits of the bitfield.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Conversion/ImplicitDowncastFromBitfield.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\npredicate whitelist(Function f) {\n  f.getName() =\n    [\n      \"ceil\", \"ceilf\", \"ceill\", \"floor\", \"floorf\", \"floorl\", \"nearbyint\", \"nearbyintf\",\n      \"nearbyintl\", \"rint\", \"rintf\", \"rintl\", \"round\", \"roundf\", \"roundl\", \"trunc\", \"truncf\",\n      \"truncl\"\n    ] or\n  f.getName().matches(\"\\\\_\\\\_builtin\\\\_%\")\n}\n\npredicate whitelistPow(FunctionCall fc) {\n  fc.getTarget().getName() = [\"pow\", \"powf\", \"powl\"] and\n  exists(float value |\n    value = fc.getArgument(0).getValue().toFloat() and\n    (value.floor() - value).abs() < 0.001\n  )\n}\n\npredicate whiteListWrapped(FunctionCall fc) {\n  whitelist(fc.getTarget())\n  or\n  whitelistPow(fc)\n  or\n  exists(Expr e, ReturnStmt rs |\n    whiteListWrapped(e) and\n    DataFlow::localExprFlow(e, rs.getExpr()) and\n    fc.getTarget() = rs.getEnclosingFunction()\n  )\n}\n\nfrom FunctionCall c, FloatingPointType t1, IntegralType t2\nwhere\n  pragma[only_bind_into](t1) = c.getTarget().getType().getUnderlyingType() and\n  t2 = c.getActualType() and\n  c.hasImplicitConversion() and\n  not whiteListWrapped(c)\nselect c,\n  \"Return value of type \" + t1.toString() + \" is implicitly converted to \" + t2.toString() + \".\"",
        "description": "Finds function calls whose result type is a floating point type, and which are casted to an integral type. Includes only expressions with implicit cast and excludes function calls to ceil, floor and round.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Conversion/LossyFunctionResultCast.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate commonErrorCode(string value) {\n  value =\n    [\n      \"0\", \"1\", \"-1\", // common error codes\n      \"18446744073709551615\", // 2^64-1, i.e. -1 as an unsigned int64\n      \"4294967295\", // 2^32-1, i.e. -1 as an unsigned int32\n      \"3735928559\", // 0xdeadbeef\n      \"3735929054\", // 0xdeadc0de\n      \"3405691582\" // 0xcafebabe\n    ]\n}\n\nfrom Expr e\nwhere\n  e.isConstant() and\n  not commonErrorCode(e.getValue()) and\n  e.getFullyConverted().getType() instanceof PointerType and\n  not e.getType() instanceof ArrayType and\n  not e.getType() instanceof PointerType and\n  not e.isInMacroExpansion()\nselect e, \"Nonzero value \" + e.getValueText() + \" cast to pointer.\"",
        "description": "A constant value other than zero is converted to a pointer type. This is a dangerous practice, since the meaning of the numerical value of pointers is platform dependent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Conversion/NonzeroValueCastToPointer.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Expr e1, Cast e2, IntegralType it1, IntegralType it2\nwhere\n  e2 = e1.getConversion() and\n  e2.isImplicit() and\n  it1 = e1.getUnderlyingType() and\n  it2 = e2.getUnderlyingType() and\n  (\n    it1.isUnsigned() and it2.isSigned() and it1.getSize() >= it2.getSize()\n    or\n    it1.isSigned() and it2.isUnsigned()\n  ) and\n  not (\n    e1.isConstant() and\n    0 <= e1.getValue().toInt() and\n    e1.getValue().toInt() <= ((it2.getSize() * 8 - 1) * 2.log()).exp()\n  ) and\n  not e1.isConstant()\nselect e1,\n  \"Conversion between signed and unsigned types \" + it1.toString() + \" and \" + it2.toString() + \".\"",
        "description": "Finds conversions from unsigned to signed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Conversion/ConversionChangesSign.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate lossyPointerCast(Expr e, PointerType pt, IntegralType it) {\n  not it instanceof BoolType and\n  e.getConversion().getType().getUnderlyingType() = it and\n  e.getType().getUnderlyingType() = pt and\n  it.getSize() < pt.getSize() and\n  not e.isInMacroExpansion() and\n  // low bits of pointers are sometimes used to store flags\n  not exists(BitwiseAndExpr a | a.getAnOperand() = e)\n}\n\nfrom Expr e, PointerType pt, IntegralType it\nwhere lossyPointerCast(e, pt, it)\nselect e, \"Converted from \" + pt.getName() + \" to smaller type \" + it.getName()",
        "description": "A pointer type is converted to a smaller integer type. This may lead to loss of information in the variable and is highly non-portable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Conversion/LossyPointerCast.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.dataflow.MustFlow\nimport PathGraph\n\npredicate allocatedType(Type t) {\n  /* Arrays: \"int foo[1]; foo[0] = 42;\" is ok. */\n  t instanceof ArrayType\n  or\n  /* Structs: \"struct foo bar; bar.baz = 42\" is ok. */\n  t instanceof Class\n  or\n  /* Typedefs to other allocated types are fine. */\n  allocatedType(t.(TypedefType).getUnderlyingType())\n  or\n  /* Type specifiers don't affect whether or not a type is allocated. */\n  allocatedType(t.getUnspecifiedType())\n}\n\npragma[noinline]\npredicate containsInlineAssembly(Function f) { exists(AsmStmt s | s.getEnclosingFunction() = f) }\n\nVariableAccess commonException() {\n  // If the uninitialized use we've found is in a macro expansion, it's\n  // typically something like va_start(), and we don't want to complain.\n  result.getParent().isInMacroExpansion()\n  or\n  result.getParent() instanceof BuiltInOperation\n  or\n  // Ignore any uninitialized use that is explicitly cast to void and\n  // is an expression statement.\n  result.getActualType() instanceof VoidType and\n  result.getParent() instanceof ExprStmt\n  or\n  // Finally, exclude functions that contain assembly blocks. It's\n  // anyone's guess what happens in those.\n  containsInlineAssembly(result.getEnclosingFunction())\n  or\n  exists(Call c | c.getQualifier() = result | c.getTarget().isStatic())\n}\n\npredicate isSinkImpl(Instruction sink, VariableAccess va) {\n  exists(LoadInstruction load |\n    va = load.getUnconvertedResultExpression() and\n    not va = commonException() and\n    not va.getTarget().(LocalVariable).getFunction().hasErrors() and\n    sink = load.getSourceValue()\n  )\n}\n\nclass MustFlow extends MustFlowConfiguration {\n  MustFlow() { this = \"MustFlow\" }\n\n  override predicate isSource(Instruction source) {\n    source instanceof UninitializedInstruction and\n    exists(Type t | t = source.getResultType() | not allocatedType(t))\n  }\n\n  override predicate isSink(Operand sink) { isSinkImpl(sink.getDef(), _) }\n\n  override predicate allowInterproceduralFlow() { none() }\n\n  override predicate isBarrier(Instruction instr) { instr instanceof ChiInstruction }\n}\n\nfrom\n  VariableAccess va, LocalVariable v, MustFlow conf, MustFlowPathNode source, MustFlowPathNode sink\nwhere\n  conf.hasFlowPath(source, sink) and\n  isSinkImpl(sink.getInstruction(), va) and\n  v = va.getTarget()\nselect va, source, sink, \"The variable $@ may not be initialized at this access.\", v, v.getName()",
        "description": "Reading from a local variable that has not been assigned to will typically yield garbage.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/UninitializedLocal.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.commons.Buffer\n\nclass SprintfCall extends FunctionCall {\n  SprintfCall() { this.getTarget().hasName(\"sprintf\") or this.getTarget().hasName(\"vsprintf\") }\n\n  int getBufferSize() { result = getBufferSize(this.getArgument(0), _) }\n\n  int getMaxConvertedLength() {\n    result = this.getArgument(1).(FormatLiteral).getMaxConvertedLength()\n  }\n\n  predicate isDangerous() { this.getMaxConvertedLength() > this.getBufferSize() }\n\n  string getDescription() {\n    result =\n      \"This conversion may yield a string of length \" + this.getMaxConvertedLength().toString() +\n        \", which exceeds the allocated buffer size of \" + this.getBufferSize().toString()\n  }\n}\n\nfrom SprintfCall c\nwhere c.isDangerous()\nselect c, c.getDescription()",
        "description": "Using a library function that does not check buffer bounds requires the surrounding program to be very carefully written to avoid buffer overflows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/PotentialBufferOverflow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport NtohlArrayNoBound\n\nfrom DataFlow::Node source, DataFlow::Node sink\nwhere NetworkToBufferSizeFlow::flow(source, sink)\nselect sink, \"Unchecked use of data from network function $@.\", source, source.toString()",
        "description": "Using the result of a network-to-host byte order function, such as ntohl, as an array bound or length value without checking it may result in buffer overflows or other vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/NtohlArrayNoBound.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.StackVariableReachability\nimport semmle.code.cpp.commons.NullTermination\n\nDeclStmt declWithNoInit(LocalVariable v) {\n  result.getADeclaration() = v and\n  not exists(v.getInitializer())\n}\n\nclass ImproperNullTerminationReachability extends StackVariableReachabilityWithReassignment {\n  ImproperNullTerminationReachability() { this = \"ImproperNullTerminationReachability\" }\n\n  override predicate isSourceActual(ControlFlowNode node, StackVariable v) {\n    node = declWithNoInit(v)\n    or\n    exists(Call c, int bufferArg, int sizeArg |\n      c = node and\n      (\n        c.getTarget().hasName(\"readlink\") and bufferArg = 1 and sizeArg = 2\n        or\n        c.getTarget().hasName(\"readlinkat\") and bufferArg = 2 and sizeArg = 3\n      ) and\n      c.getArgument(bufferArg).(VariableAccess).getTarget() = v and\n      (\n        // buffer size parameter likely matches the full buffer size\n        c.getArgument(sizeArg) instanceof SizeofOperator or\n        c.getArgument(sizeArg).getValue().toInt() = v.getType().getSize()\n      )\n    )\n  }\n\n  override predicate isSinkActual(ControlFlowNode node, StackVariable v) {\n    node.(VariableAccess).getTarget() = v and\n    variableMustBeNullTerminated(node)\n  }\n\n  override predicate isBarrier(ControlFlowNode node, StackVariable v) {\n    exprDefinition(v, node, _) or\n    this.isSinkActual(node, v) // only report first use\n  }\n}\n\nclass NullTerminationReachability extends StackVariableReachabilityWithReassignment {\n  NullTerminationReachability() { this = \"NullTerminationReachability\" }\n\n  override predicate isSourceActual(ControlFlowNode node, StackVariable v) {\n    mayAddNullTerminator(node, v.getAnAccess()) or // null termination\n    node.(AddressOfExpr).getOperand() = v.getAnAccess() // address taken (possible null termination)\n  }\n\n  override predicate isSinkActual(ControlFlowNode node, StackVariable v) {\n    // have the same sinks as `ImproperNullTerminationReachability`.\n    exists(ImproperNullTerminationReachability r | r.isSinkActual(node, v))\n  }\n\n  override predicate isBarrier(ControlFlowNode node, StackVariable v) {\n    // don't look further back than the source, or further forward than the sink\n    exists(ImproperNullTerminationReachability r | r.isSourceActual(node, v)) or\n    exists(ImproperNullTerminationReachability r | r.isSinkActual(node, v))\n  }\n}\n\nfrom\n  ImproperNullTerminationReachability reaches, NullTerminationReachability nullTermReaches,\n  ControlFlowNode source, LocalVariable v, VariableAccess sink\nwhere\n  reaches.reaches(source, v, sink) and\n  not exists(ControlFlowNode termination |\n    nullTermReaches.reaches(termination, _, sink) and\n    termination != source\n  )\nselect sink, \"Variable $@ may not be null terminated.\", v, v.getName()",
        "description": "Using a string that may not be null terminated as an argument to a string function can result in buffer overflow or buffer over-read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/ImproperNullTermination.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Buffer\n\npredicate isEffectivelyConstAccess(VariableAccess a) {\n  exists(Variable v |\n    a.getTarget() = v and\n    v.getInitializer().getExpr().isConstant() and\n    not v.getAnAccess().isUsedAsLValue()\n  )\n}\n\nclass StrcatSource extends VariableAccess {\n  FunctionCall strcat;\n\n  StrcatSource() {\n    strcat.getTarget().hasName(\"strcat\") and\n    this = strcat.getArgument(1)\n  }\n\n  FunctionCall getStrcatCall() { result = strcat }\n}\n\nfrom StrcatSource src\nwhere\n  not src.getType() instanceof ArrayType and\n  not exists(BufferSizeExpr bse | bse.getArg().(VariableAccess).getTarget() = src.getTarget()) and\n  not isEffectivelyConstAccess(src)\nselect src.getStrcatCall(), \"Always check the size of the source buffer when using strcat.\"",
        "description": "Using 'strcat' without checking the size of the source string may result in a buffer overflow",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/UnsafeUseOfStrcat.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass CandidateParameter extends Parameter {\n  CandidateParameter() {\n    // an array parameter\n    this.getUnspecifiedType() instanceof ArrayType\n    or\n    // a pointer parameter\n    this.getUnspecifiedType() instanceof PointerType and\n    // whose address is never taken (rules out common\n    // false positive patterns)\n    not exists(AddressOfExpr aoe | aoe.getAddressable() = this)\n  }\n}\n\nfrom SizeofExprOperator seo, VariableAccess va\nwhere\n  seo.getExprOperand() = va and\n  va.getTarget() instanceof CandidateParameter and\n  not va.isAffectedByMacro() and\n  not va.isCompilerGenerated()\nselect seo, \"This evaluates to the size of the pointer type, which may not be what you want.\"",
        "description": "Taking 'sizeof' of an array parameter is often mistakenly thought to yield the size of the underlying array, but it always yields the machine pointer size.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/SuspiciousSizeof.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\npredicate sizeOfExpr(Expr e, Type t) {\n  t = e.(SizeofTypeOperator).getTypeOperand()\n  or\n  t = e.(SizeofExprOperator).getExprOperand().getType()\n  or\n  sizeOfExpr(e.(MulExpr).getAnOperand(), t) and\n  e.(MulExpr).getAnOperand() instanceof Literal\n}\n\nType stripType(Type t) {\n  result = stripType(t.(TypedefType).getBaseType())\n  or\n  result = stripType(t.(ArrayType).getBaseType())\n  or\n  result = stripType(t.(ReferenceType).getBaseType())\n  or\n  result = stripType(t.(SpecifiedType).getBaseType())\n  or\n  result = stripType(t.(Decltype).getBaseType())\n  or\n  result = stripType(t.(TypeofType).getBaseType())\n  or\n  result = stripType(t.(IntrinsicTransformedType).getBaseType())\n  or\n  not t instanceof TypedefType and\n  not t instanceof ArrayType and\n  not t instanceof ReferenceType and\n  not t instanceof SpecifiedType and\n  not t instanceof Decltype and\n  not t instanceof TypeofType and\n  not t instanceof IntrinsicTransformedType and\n  result = t\n}\n\npredicate pointerIndirection(Type t, int indirection, Type base) {\n  base = stripType(t) and\n  not base instanceof PointerType and\n  indirection = 0\n  or\n  pointerIndirection(stripType(t).(PointerType).getBaseType(), indirection - 1, base)\n}\n\npredicate pointerIndirection2(Type t, int indirection) {\n  not stripType(t) instanceof PointerType and\n  indirection = 0\n  or\n  pointerIndirection2(stripType(t).(PointerType).getBaseType(), indirection - 1)\n}\n\npredicate reasonableMemset(FunctionCall fc) {\n  exists(Expr dataArg, Expr sizeArg |\n    dataArg = fc.getArgument(0) and\n    sizeArg = fc.getArgument(2) and\n    exists(Type dataType, Type sizeOfType |\n      dataType = dataArg.getType() and\n      sizeOfExpr(sizeArg, sizeOfType) and\n      exists(int i |\n        exists(Type base |\n          // memset(&t, _, sizeof(t))\n          pointerIndirection(dataType, i + 1, base) and\n          pointerIndirection(sizeOfType, i, base)\n        )\n        or\n        exists(Type base |\n          // memset(t[n], _, sizeof(t))\n          pointerIndirection(dataType.getUnspecifiedType().(ArrayType), i, base) and\n          pointerIndirection(sizeOfType, i, base)\n        )\n        or\n        exists(VoidType vt |\n          // memset(void *, _, sizeof(t))\n          pointerIndirection(dataType, i + 1, vt) and\n          pointerIndirection2(sizeOfType, i)\n        )\n        or\n        exists(Type ct |\n          // memset(char *, _, sizeof(t)) and similar\n          ct.getSize() = 1 and\n          pointerIndirection(dataType, i + 1, ct) and\n          pointerIndirection2(sizeOfType, i)\n        )\n        or\n        exists(Type ct |\n          // memset(char [], _, sizeof(t)) and similar\n          ct.getSize() = 1 and\n          pointerIndirection(dataType.getUnspecifiedType().(ArrayType), i, ct) and\n          pointerIndirection2(sizeOfType, i)\n        )\n      )\n    )\n  )\n}\n\nfrom FunctionCall fc, Type t\nwhere\n  fc.getTarget().hasName(\"memset\") and\n  sizeOfExpr(fc.getArgument(2), t) and\n  not reasonableMemset(fc)\nselect fc,\n  \"The size of the memory area set by memset should not be the size of the type \" + t.getName() +\n    \".\"",
        "description": "Use of memset where the size argument is computed as the size of some non-struct type. When initializing a buffer, you should specify its size as `<number of elements> portability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/SuspiciousCallToMemset.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nprivate import semmle.code.cpp.valuenumbering.GlobalValueNumbering\nprivate import semmle.code.cpp.commons.Exclusions\n\nfrom RelationalOperation ro, PointerAddExpr add, Expr expr1, Expr expr2\nwhere\n  ro.getAnOperand() = add and\n  add.getAnOperand() = expr1 and\n  ro.getAnOperand() = expr2 and\n  globalValueNumber(expr1) = globalValueNumber(expr2) and\n  // Exclude macros but not their arguments\n  not isFromMacroDefinition(ro) and\n  // There must be a compilation of this file without a flag that makes pointer\n  // overflow well defined.\n  exists(Compilation c | c.getAFileCompiled() = ro.getFile() |\n    not c.getAnArgument() = \"-fwrapv-pointer\" and\n    not c.getAnArgument() = \"-fno-strict-overflow\"\n  )\nselect ro, \"Range check relying on pointer overflow.\"",
        "description": "Adding a value to a pointer to check if it overflows relies on undefined behavior and may lead to memory corruption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/PointerOverflow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.dataflow.MustFlow\nimport PathGraph\n\npredicate intentionallyReturnsStackPointer(Function f) {\n  f.getName().toLowerCase().matches([\"%stack%\", \"%sp%\"])\n}\n\nclass ReturnStackAllocatedMemoryConfig extends MustFlowConfiguration {\n  ReturnStackAllocatedMemoryConfig() { this = \"ReturnStackAllocatedMemoryConfig\" }\n\n  override predicate isSource(Instruction source) {\n    exists(Function func |\n      // Rule out FPs caused by extraction errors.\n      not func.hasErrors() and\n      not intentionallyReturnsStackPointer(func) and\n      func = source.getEnclosingFunction()\n    |\n      // `source` is an instruction that represents the use of a stack variable\n      exists(VariableAddressInstruction var |\n        var = source and\n        var.getAstVariable() instanceof StackVariable and\n        // Pointer-to-member types aren't properly handled in the dbscheme.\n        not var.getResultType() instanceof PointerToMemberType\n      )\n      or\n      // `source` is an instruction that represents the return value of a\n      // function that is known to return stack-allocated memory.\n      exists(Call call |\n        call.getTarget().hasGlobalName([\"alloca\", \"strdupa\", \"strndupa\", \"_alloca\", \"_malloca\"]) and\n        source.getUnconvertedResultExpression() = call\n      )\n    )\n  }\n\n  override predicate isSink(Operand sink) {\n    // Holds if `sink` is a node that represents the `StoreInstruction` that is subsequently used in\n    // a `ReturnValueInstruction`.\n    // We use the `StoreInstruction` instead of the instruction that defines the\n    // `ReturnValueInstruction`'s source value operand because the former has better location information.\n    exists(StoreInstruction store |\n      store.getDestinationAddress().(VariableAddressInstruction).getIRVariable() instanceof\n        IRReturnVariable and\n      sink = store.getSourceValueOperand()\n    )\n  }\n\n  //  We disable flow into callables in this query as we'd otherwise get a result on this piece of code:\n  //   ```cpp\n  //  int* id(int* px) {\n  //   return px; // this returns the local variable `x`, but it's fine as the local variable isn't declared in this scope.\n  //  }\n  //  void f() {\n  //   int x;\n  //   int* px = id(&x);\n  //  }\n  //   ```\n  override predicate allowInterproceduralFlow() { none() }\n\n  /**\n   * This configuration intentionally conflates addresses of fields and their object, and pointer offsets\n   * with their base pointer as this allows us to detect cases where an object's address flows to a\n   * return statement via a field. For example:\n   *\n   * ```cpp\n   * struct S { int x, y };\n   * int* test() {\n   *   S s;\n   *   return &s.x; // BAD: &s.x is an address of a variable on the stack.\n   * }\n   * ```\n   */\n  override predicate isAdditionalFlowStep(Operand node1, Instruction node2) {\n    node2.(FieldAddressInstruction).getObjectAddressOperand() = node1\n    or\n    node2.(PointerOffsetInstruction).getLeftOperand() = node1\n  }\n\n  override predicate isBarrier(Instruction n) { n.getResultType() instanceof ErroneousType }\n}\n\nfrom\n  MustFlowPathNode source, MustFlowPathNode sink, Instruction instr,\n  ReturnStackAllocatedMemoryConfig conf\nwhere\n  conf.hasFlowPath(pragma[only_bind_into](source), pragma[only_bind_into](sink)) and\n  source.getInstruction() = instr\nselect sink.getInstruction(), source, sink, \"May return stack-allocated memory from $@.\",\n  instr.getAst(), instr.getAst().toString()",
        "description": "A function returns a pointer to a stack-allocated region of memory. This memory is deallocated at the end of the function, which may lead the caller to dereference a dangling pointer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/ReturnStackAllocatedMemory.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.SSA\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\nclass StdString extends Class {\n  StdString() {\n    // `std::string` is usually a typedef and the actual class\n    // is called something like `string  std::__cxx11::basic_string`.\n    exists(Type stdstring, Namespace std |\n      stdstring.getName() = \"string\" and\n      this = stdstring.getUnspecifiedType() and\n      // Make sure that the class is in the `std` namespace.\n      std = this.getNamespace().getParentNamespace*() and\n      std.getName() = \"std\" and\n      std.getParentNamespace() instanceof GlobalNamespace\n    )\n  }\n}\n\npredicate refToStdString(DataFlow::Node node, ConstructorCall source) {\n  exists(StdString stdstring |\n    stdstring.getAMemberFunction() = source.getTarget() and\n    not exists(LocalVariable v |\n      source = v.getInitializer().getExpr() and\n      v.isStatic()\n    ) and\n    node.asExpr() = source\n  )\n  or\n  // Indirect use.\n  exists(DataFlow::Node prev |\n    refToStdString(prev, source) and\n    DataFlow::localFlowStep(prev, node)\n  )\n}\n\npredicate flowFunction(Function fcn, int argIndex) {\n  fcn.hasQualifiedName(\"\", \"_JNIEnv\", \"NewStringUTF\") and argIndex = 0\n  or\n  fcn.hasQualifiedName(\"art\", \"JNI\", \"NewStringUTF\") and argIndex = 1\n  or\n  fcn.hasQualifiedName(\"art\", \"CheckJNI\", \"NewStringUTF\") and argIndex = 1\n  // Add other functions that behave like NewStringUTF here.\n}\n\npredicate refToCStr(DataFlow::Node node, ConstructorCall source) {\n  exists(MemberFunction f, FunctionCall call, DataFlow::Node qualifier |\n    f.getName() = \"c_str\" and\n    call = node.asExpr() and\n    call.getTarget() = f and\n    qualifier.asIndirectArgument() = call.getQualifier() and\n    refToStdString(qualifier, source)\n  )\n  or\n  // Indirect use.\n  exists(DataFlow::Node prev |\n    refToCStr(prev, source) and\n    DataFlow::localFlowStep(prev, node)\n  )\n  or\n  // Some functions, such as `JNIEnv::NewStringUTF()` (from Java's JNI)\n  // embed return a structure containing a reference to the C-style string.\n  exists(Function f, int argIndex |\n    flowFunction(f, argIndex) and\n    f = node.asExpr().(Call).getTarget() and\n    refToCStr(DataFlow::exprNode(node.asExpr().(Call).getArgument(argIndex)), source)\n  )\n}\n\nfrom ReturnStmt r, ConstructorCall source\nwhere refToCStr(DataFlow::exprNode(r.getExpr()), source)\nselect r, \"Return value may contain a dangling pointer to $@.\", source, \"this local std::string\"",
        "description": "Returning the c_str of a locally allocated std::string could cause the program to crash or behave non-deterministically because the memory is deallocated when the std::string goes out of scope.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/ReturnCstrOfLocalStdString.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.RangeAnalysisUtils\nimport semmle.code.cpp.ir.dataflow.DataFlow\n\nLoop getAnEnclosingLoopOfExpr(Expr e) { result = getAnEnclosingLoopOfStmt(e.getEnclosingStmt()) }\n\nLoop getAnEnclosingLoopOfStmt(Stmt s) {\n  result = s.getParent*() and\n  not s = result.(ForStmt).getInitialization()\n  or\n  result = getAnEnclosingLoopOfExpr(s.getParent*())\n}\n\nclass AllocaCall extends FunctionCall {\n  AllocaCall() {\n    this.getTarget().getName() = \"__builtin_alloca\"\n    or\n    (this.getTarget().getName() = \"_alloca\" or this.getTarget().getName() = \"_malloca\") and\n    this.getTarget().getADeclarationEntry().getFile().getBaseName() = \"malloc.h\"\n  }\n}\n\nprivate Expr getExpr(DataFlow::Node node) {\n  result = node.asInstruction().getAst()\n  or\n  result = node.asOperand().getUse().getAst()\n  or\n  result = node.(DataFlow::RawIndirectInstruction).getInstruction().getAst()\n  or\n  result = node.(DataFlow::RawIndirectOperand).getOperand().getUse().getAst()\n}\n\nclass LoopWithAlloca extends Stmt {\n  LoopWithAlloca() { this = getAnEnclosingLoopOfExpr(any(AllocaCall ac)) }\n\n  /** Get an `alloca` call inside this loop. It may be in a nested loop. */\n  AllocaCall getAnAllocaCall() { this = getAnEnclosingLoopOfExpr(result) }\n\n  /**\n   * Holds if the condition of this loop will only be true if `e` is `truth`.\n   * For example, if the loop condition is `a == 0 && b`, then\n   * `conditionRequires(a, false)` and `conditionRequires(b, true)`.\n   */\n  private predicate conditionRequires(Expr e, boolean truth) {\n    e = this.(Loop).getCondition() and\n    truth = true\n    or\n    // `e == 0`\n    exists(EQExpr eq |\n      this.conditionRequires(eq, truth.booleanNot()) and\n      eq.getAnOperand().getValue().toInt() = 0 and\n      e = eq.getAnOperand() and\n      not exists(e.getValue())\n    )\n    or\n    // `e != 0`\n    exists(NEExpr eq |\n      this.conditionRequires(eq, truth) and\n      eq.getAnOperand().getValue().toInt() = 0 and\n      e = eq.getAnOperand() and\n      not exists(e.getValue())\n    )\n    or\n    // `(bool)e == true`\n    exists(EQExpr eq |\n      this.conditionRequires(eq, truth) and\n      eq.getAnOperand().getValue().toInt() = 1 and\n      e = eq.getAnOperand() and\n      e.getUnspecifiedType() instanceof BoolType and\n      not exists(e.getValue())\n    )\n    or\n    // `(bool)e != true`\n    exists(NEExpr eq |\n      this.conditionRequires(eq, truth.booleanNot()) and\n      eq.getAnOperand().getValue().toInt() = 1 and\n      e = eq.getAnOperand() and\n      e.getUnspecifiedType() instanceof BoolType and\n      not exists(e.getValue())\n    )\n    or\n    exists(NotExpr notExpr |\n      this.conditionRequires(notExpr, truth.booleanNot()) and\n      e = notExpr.getOperand()\n    )\n    or\n    // If the e of `this` requires `andExpr` to be true, then it\n    // requires both of its operand to be true as well.\n    exists(LogicalAndExpr andExpr |\n      truth = true and\n      this.conditionRequires(andExpr, truth) and\n      e = andExpr.getAnOperand()\n    )\n    or\n    // Dually, if the e of `this` requires `orExpr` to be false, then\n    // it requires both of its operand to be false as well.\n    exists(LogicalOrExpr orExpr |\n      truth = false and\n      this.conditionRequires(orExpr, truth) and\n      e = orExpr.getAnOperand()\n    )\n  }\n\n  /**\n   * Holds if the condition of this loop will only be true if `e` relates to\n   * `value` as `dir`. We don't keep track of whether the equality is strict\n   * since this predicate is only used to heuristically determine whether\n   * there's a reasonably tight upper bound on the number of loop iterations.\n   *\n   * For example, if the loop condition is `a < 2 && b`, then\n   * `conditionRequiresInequality(a, 2, Lesser())`.\n   */\n  private predicate conditionRequiresInequality(Expr e, int value, RelationDirection dir) {\n    exists(RelationalOperation rel, Expr constant, boolean branch |\n      this.conditionRequires(rel, branch) and\n      relOpWithSwapAndNegate(rel, e.getFullyConverted(), constant, dir, _, branch) and\n      value = constant.getValue().toInt() and\n      not exists(e.getValue())\n    )\n    or\n    // Because we're not worried about off-by-one, it's not important whether\n    // the `CrementOperation` is a {pre,post}-{inc,dec}rement.\n    exists(CrementOperation inc |\n      this.conditionRequiresInequality(inc, value, dir) and\n      e = inc.getOperand()\n    )\n  }\n\n  /**\n   * Gets a variable that's restricted by `conditionRequires` or\n   * `conditionRequiresInequality`.\n   */\n  private Variable getAControllingVariable() {\n    this.conditionRequires(result.getAnAccess(), _)\n    or\n    this.conditionRequiresInequality(result.getAnAccess(), _, _)\n  }\n\n  /**\n   * Gets a `VariableAccess` that changes `var` inside the loop body, where\n   * `var` is a controlling variable of this loop.\n   */\n  private VariableAccess getAControllingVariableUpdate(Variable var) {\n    var = result.getTarget() and\n    var = this.getAControllingVariable() and\n    this = getAnEnclosingLoopOfExpr(result) and\n    result.isUsedAsLValue()\n  }\n\n  /**\n   * Holds if there is a control-flow path from the condition of this loop to\n   * `node` that doesn't update `var`, where `var` is a controlling variable of\n   * this loop. The path has to stay within the loop. The path will start at\n   * the successor of the loop condition. If the path reaches all the way back\n   * to the loop condition, then it's possible to go around the loop without\n   * updating `var`.\n   */\n  private predicate conditionReachesWithoutUpdate(Variable var, ControlFlowNode node) {\n    // Don't leave the loop. It might cause us to leave the scope of `var`\n    (node instanceof Stmt implies this = getAnEnclosingLoopOfStmt(node)) and\n    (\n      node = this.(Loop).getCondition().getASuccessor() and\n      var = this.getAControllingVariable()\n      or\n      this.conditionReachesWithoutUpdate(var, node.getAPredecessor()) and\n      not node = this.getAControllingVariableUpdate(var)\n    )\n  }\n\n  /**\n   * Holds if all paths around the loop will update `var`, where `var` is a\n   * controlling variable of this loop.\n   */\n  private predicate hasMandatoryUpdate(Variable var) {\n    not this.conditionReachesWithoutUpdate(var, this.(Loop).getCondition())\n  }\n\n  /**\n   * Gets a definition that may be the most recent definition of the\n   * controlling variable `var` before this loop.\n   */\n  private DataFlow::Node getAPrecedingDef(Variable var) {\n    exists(VariableAccess va |\n      va = var.getAnAccess() and\n      this.conditionRequiresInequality(va, _, _) and\n      DataFlow::localFlow(result, DataFlow::exprNode(va)) and\n      // Phi nodes will be preceded by nodes that represent actual definitions\n      not result instanceof DataFlow::SsaSynthNode and\n      // A source is outside the loop if it's not inside the loop\n      not exists(Expr e | e = getExpr(result) | this = getAnEnclosingLoopOfExpr(e))\n    )\n  }\n\n  /**\n   * Gets a number that may be the most recent value assigned to the\n   * controlling variable `var` before this loop.\n   */\n  private int getAControllingVarInitialValue(Variable var, DataFlow::Node source) {\n    source = this.getAPrecedingDef(var) and\n    (\n      result = getExpr(source).getValue().toInt()\n      or\n      result = getExpr(source).(Assignment).getRValue().getValue().toInt()\n    )\n  }\n\n  /**\n   * Holds if the most recent definition of `var` before this loop may assign a\n   * value that is not a compile-time constant.\n   */\n  private predicate controllingVarHasUnknownInitialValue(Variable var) {\n    // A definition without a constant value was reached\n    exists(DataFlow::Node source |\n      source = this.getAPrecedingDef(var) and\n      not exists(this.getAControllingVarInitialValue(var, source))\n    )\n  }\n\n  /**\n   * Gets the least possible value that the controlling variable `var` may have\n   * before this loop, if such a value can be deduced.\n   */\n  private int getMinPrecedingDef(Variable var) {\n    not this.controllingVarHasUnknownInitialValue(var) and\n    result = min(this.getAControllingVarInitialValue(var, _))\n    or\n    this.controllingVarHasUnknownInitialValue(var) and\n    var.getType().(IntegralType).isUnsigned() and\n    result = 0\n  }\n\n  /**\n   * Gets the greatest possible value that the controlling variable `var` may\n   * have before this loop, if such a value can be deduced.\n   */\n  private int getMaxPrecedingDef(Variable var) {\n    not this.controllingVarHasUnknownInitialValue(var) and\n    result = max(this.getAControllingVarInitialValue(var, _))\n  }\n\n  /**\n   * Holds if this loop has a \"small\" number of iterations. The meaning of\n   * \"small\" should be such that the loop wouldn't be unreasonably large if\n   * manually unrolled.\n   */\n  predicate isTightlyBounded() {\n    exists(Variable var | this.hasMandatoryUpdate(var) |\n      this.conditionRequires(var.getAnAccess(), false) and\n      forall(VariableAccess update | update = this.getAControllingVariableUpdate(var) |\n        exists(AssignExpr assign |\n          assign.getLValue() = update and\n          assign.getRValue().getValue().toInt() != 0\n        )\n      )\n      or\n      this.conditionRequires(var.getAnAccess(), true) and\n      forall(VariableAccess update | update = this.getAControllingVariableUpdate(var) |\n        exists(AssignExpr assign |\n          assign.getLValue() = update and\n          assign.getRValue().getValue().toInt() = 0\n        )\n      )\n      or\n      exists(int bound |\n        this.conditionRequiresInequality(var.getAnAccess(), bound, Lesser()) and\n        bound - this.getMinPrecedingDef(var) <= 16 and\n        forall(VariableAccess update | update = this.getAControllingVariableUpdate(var) |\n          // var++;\n          // ++var;\n          exists(IncrementOperation inc | inc.getOperand() = update)\n          or\n          // var += positive_number;\n          exists(AssignAddExpr aa |\n            aa.getLValue() = update and\n            aa.getRValue().getValue().toInt() > 0\n          )\n          or\n          // var = var + positive_number;\n          // var = positive_number + var;\n          exists(AssignExpr assign, AddExpr add |\n            assign.getLValue() = update and\n            assign.getRValue() = add and\n            add.getAnOperand() = var.getAnAccess() and\n            add.getAnOperand().getValue().toInt() > 0\n          )\n        )\n      )\n      or\n      exists(int bound |\n        this.conditionRequiresInequality(var.getAnAccess(), bound, Greater()) and\n        this.getMaxPrecedingDef(var) - bound <= 16 and\n        forall(VariableAccess update | update = this.getAControllingVariableUpdate(var) |\n          // var--;\n          // --var;\n          exists(DecrementOperation inc | inc.getOperand() = update)\n          or\n          // var -= positive_number;\n          exists(AssignSubExpr aa |\n            aa.getLValue() = update and\n            aa.getRValue().getValue().toInt() > 0\n          )\n          or\n          // var = var - positive_number;\n          exists(AssignExpr assign, SubExpr add |\n            assign.getLValue() = update and\n            assign.getRValue() = add and\n            add.getLeftOperand() = var.getAnAccess() and\n            add.getRightOperand().getValue().toInt() > 0\n          )\n        )\n      )\n    )\n  }\n}\n\nfrom LoopWithAlloca l, AllocaCall alloc\nwhere\n  not l.(DoStmt).getCondition().getValue() = \"0\" and\n  not l.isTightlyBounded() and\n  alloc = l.getAnAllocaCall() and\n  alloc.getASuccessor*() = l.(Loop).getStmt()\nselect alloc, \"Stack allocation is inside a $@ loop.\", l, l.toString()",
        "description": "Using alloca in a loop can lead to a stack overflow",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/AllocaInLoop.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n// We don't actually use the global value numbering library in this query, but without it we end up\n// recomputing the IR.\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\nimport semmle.code.cpp.ir.IR\n\npredicate instructionHasVariable(VariableAddressInstruction vai, StackVariable var, Function f) {\n  var = vai.getAstVariable() and\n  f = vai.getEnclosingFunction() and\n  // Pointer-to-member types aren't properly handled in the dbscheme.\n  not vai.getResultType() instanceof PointerToMemberType and\n  // Rule out FPs caused by extraction errors.\n  not f.hasErrors()\n}\n\npredicate stackPointerFlowsToUse(Instruction address, VariableAddressInstruction source) {\n  address = source and\n  instructionHasVariable(source, _, _)\n  or\n  stackPointerFlowsToUse(address.(CopyInstruction).getSourceValue(), source)\n  or\n  stackPointerFlowsToUse(address.(ConvertInstruction).getUnary(), source)\n  or\n  stackPointerFlowsToUse(address.(CheckedConvertOrNullInstruction).getUnary(), source)\n  or\n  stackPointerFlowsToUse(address.(InheritanceConversionInstruction).getUnary(), source)\n  or\n  stackPointerFlowsToUse(address.(FieldAddressInstruction).getObjectAddress(), source)\n  or\n  stackPointerFlowsToUse(address.(PointerOffsetInstruction).getLeft(), source)\n}\n\nnewtype TGlobalAddress =\n  TGlobalVariable(GlobalOrNamespaceVariable v) {\n    // Pointer-to-member types aren't properly handled in the dbscheme.\n    not v.getUnspecifiedType() instanceof PointerToMemberType\n  } or\n  TLoad(TGlobalAddress address) {\n    address = globalAddress(any(LoadInstruction load).getSourceAddress())\n  } or\n  TConversion(string kind, TGlobalAddress address, Type fromType, Type toType) {\n    kind = \"unchecked\" and\n    exists(ConvertInstruction convert |\n      uncheckedConversionTypes(convert, fromType, toType) and\n      address = globalAddress(convert.getUnary())\n    )\n    or\n    kind = \"checked\" and\n    exists(CheckedConvertOrNullInstruction convert |\n      checkedConversionTypes(convert, fromType, toType) and\n      address = globalAddress(convert.getUnary())\n    )\n    or\n    kind = \"inheritance\" and\n    exists(InheritanceConversionInstruction convert |\n      inheritanceConversionTypes(convert, fromType, toType) and\n      address = globalAddress(convert.getUnary())\n    )\n  } or\n  TFieldAddress(TGlobalAddress address, Field f) {\n    exists(FieldAddressInstruction fai |\n      fai.getField() = f and\n      address = globalAddress(fai.getObjectAddress())\n    )\n  }\n\npragma[noinline]\npredicate uncheckedConversionTypes(ConvertInstruction convert, Type fromType, Type toType) {\n  fromType = convert.getUnary().getResultType() and\n  toType = convert.getResultType()\n}\n\npragma[noinline]\npredicate checkedConversionTypes(CheckedConvertOrNullInstruction convert, Type fromType, Type toType) {\n  fromType = convert.getUnary().getResultType() and\n  toType = convert.getResultType()\n}\n\npragma[noinline]\npredicate inheritanceConversionTypes(\n  InheritanceConversionInstruction convert, Type fromType, Type toType\n) {\n  fromType = convert.getUnary().getResultType() and\n  toType = convert.getResultType()\n}\n\nprivate signature class ConversionInstruction extends UnaryInstruction;\n\nmodule Conversion<ConversionInstruction I> {\n  signature predicate hasTypes(I instr, Type fromType, Type toType);\n\n  module Using<hasTypes/3 project> {\n    pragma[nomagic]\n    predicate hasOperandAndTypes(I convert, Instruction unary, Type fromType, Type toType) {\n      project(convert, fromType, toType) and\n      unary = convert.getUnary()\n    }\n  }\n}\n\npragma[nomagic]\npredicate hasObjectAndField(FieldAddressInstruction fai, Instruction object, Field f) {\n  fai.getObjectAddress() = object and\n  fai.getField() = f\n}\n\nTGlobalAddress globalAddress(Instruction instr) {\n  result = TGlobalVariable(instr.(VariableAddressInstruction).getAstVariable())\n  or\n  not instr instanceof LoadInstruction and\n  result = globalAddress(instr.(CopyInstruction).getSourceValue())\n  or\n  exists(LoadInstruction load | instr = load |\n    result = TLoad(globalAddress(load.getSourceAddress()))\n  )\n  or\n  exists(Type fromType, Type toType, Instruction unary |\n    Conversion<ConvertInstruction>::Using<uncheckedConversionTypes/3>::hasOperandAndTypes(instr,\n      unary, fromType, toType) and\n    result = TConversion(\"unchecked\", globalAddress(unary), fromType, toType)\n  )\n  or\n  exists(Type fromType, Type toType, Instruction unary |\n    Conversion<CheckedConvertOrNullInstruction>::Using<checkedConversionTypes/3>::hasOperandAndTypes(instr,\n      unary, fromType, toType) and\n    result = TConversion(\"checked\", globalAddress(unary), fromType, toType)\n  )\n  or\n  exists(Type fromType, Type toType, Instruction unary |\n    Conversion<InheritanceConversionInstruction>::Using<inheritanceConversionTypes/3>::hasOperandAndTypes(instr,\n      unary, fromType, toType) and\n    result = TConversion(\"inheritance\", globalAddress(unary), fromType, toType)\n  )\n  or\n  exists(FieldAddressInstruction fai, Instruction object, Field f | instr = fai |\n    hasObjectAndField(fai, object, f) and\n    result = TFieldAddress(globalAddress(object), f)\n  )\n  or\n  result = globalAddress(instr.(PointerOffsetInstruction).getLeft())\n}\n\nStoreInstruction getFirstStore(IRBlock block, TGlobalAddress globalAddress) {\n  1 = getStoreRank(result, block, globalAddress)\n  or\n  not exists(getStoreRank(_, block, globalAddress)) and\n  result = getFirstStore(block.getASuccessor(), globalAddress)\n}\n\nint getStoreRank(StoreInstruction store, IRBlock block, TGlobalAddress globalAddress) {\n  blockStoresToAddress(block, _, store, globalAddress) and\n  store =\n    rank[result](StoreInstruction anotherStore, int i |\n      blockStoresToAddress(_, i, anotherStore, globalAddress)\n    |\n      anotherStore order by i\n    )\n}\n\nStoreInstruction getANextStoreTo(StoreInstruction store, TGlobalAddress globalAddress) {\n  exists(IRBlock block, int rnk |\n    rnk = getStoreRank(store, block, globalAddress) and\n    rnk + 1 = getStoreRank(result, block, globalAddress)\n  )\n  or\n  exists(IRBlock block, int rnk, IRBlock succ |\n    rnk = getStoreRank(store, block, globalAddress) and\n    not rnk + 1 = getStoreRank(_, block, globalAddress) and\n    succ = block.getASuccessor() and\n    result = getFirstStore(succ, globalAddress)\n  )\n}\n\npredicate stackAddressEscapes(\n  StoreInstruction store, StackVariable var, TGlobalAddress globalAddress, Function f\n) {\n  globalAddress = globalAddress(store.getDestinationAddress()) and\n  exists(VariableAddressInstruction vai |\n    instructionHasVariable(pragma[only_bind_into](vai), var, f) and\n    stackPointerFlowsToUse(store.getSourceValue(), vai)\n  ) and\n  // Ensure there's no subsequent store that overrides the global address.\n  not exists(getANextStoreTo(store, globalAddress))\n}\n\npredicate blockStoresToAddress(\n  IRBlock block, int index, StoreInstruction store, TGlobalAddress globalAddress\n) {\n  block.getInstruction(index) = store and\n  globalAddress = globalAddress(store.getDestinationAddress())\n}\n\npredicate globalAddressPointsToStack(\n  StoreInstruction store, StackVariable var, CallInstruction call, IRBlock block,\n  TGlobalAddress globalAddress, boolean isCallBlock, boolean isStoreBlock\n) {\n  (\n    if blockStoresToAddress(block, _, _, globalAddress)\n    then isStoreBlock = true\n    else isStoreBlock = false\n  ) and\n  (\n    isCallBlock = true and\n    exists(Function f |\n      stackAddressEscapes(store, var, globalAddress, f) and\n      call.getStaticCallTarget() = f and\n      call.getBlock() = block\n    )\n    or\n    isCallBlock = false and\n    step(store, var, call, globalAddress, _, block)\n  )\n}\n\npragma[inline]\nint getInstructionIndex(Instruction instr, IRBlock block) { block.getInstruction(result) = instr }\n\npredicate step(\n  StoreInstruction store, StackVariable var, CallInstruction call, TGlobalAddress globalAddress,\n  IRBlock pred, IRBlock succ\n) {\n  exists(boolean isCallBlock, boolean isStoreBlock |\n    // Only recurse if there is no store to `globalAddress` in `mid`.\n    globalAddressPointsToStack(store, var, call, pred, globalAddress, isCallBlock, isStoreBlock)\n  |\n    // Post domination ensures that `block` is always executed after `mid`\n    // Domination ensures that `mid` is always executed before `block`\n    isStoreBlock = false and\n    succ.immediatelyPostDominates(pred) and\n    pred.immediatelyDominates(succ)\n    or\n    exists(CallInstruction anotherCall, int anotherCallIndex |\n      anotherCall = pred.getInstruction(anotherCallIndex) and\n      succ.getFirstInstruction() instanceof EnterFunctionInstruction and\n      succ.getEnclosingFunction() = anotherCall.getStaticCallTarget() and\n      (if isCallBlock = true then getInstructionIndex(call, _) < anotherCallIndex else any()) and\n      (\n        if isStoreBlock = true\n        then\n          forex(int storeIndex | blockStoresToAddress(pred, storeIndex, _, globalAddress) |\n            anotherCallIndex < storeIndex\n          )\n        else any()\n      )\n    )\n  )\n}\n\nnewtype TPathElement =\n  TStore(StoreInstruction store) { globalAddressPointsToStack(store, _, _, _, _, _, _) } or\n  TCall(CallInstruction call, IRBlock block) {\n    globalAddressPointsToStack(_, _, call, block, _, _, _)\n  } or\n  TMid(IRBlock block) { step(_, _, _, _, _, block) } or\n  TSink(LoadInstruction load, IRBlock block) {\n    exists(TGlobalAddress address |\n      globalAddressPointsToStack(_, _, _, block, address, _, _) and\n      block.getAnInstruction() = load and\n      globalAddress(load.getSourceAddress()) = address\n    )\n  }\n\nclass PathElement extends TPathElement {\n  StoreInstruction asStore() { this = TStore(result) }\n\n  CallInstruction asCall(IRBlock block) { this = TCall(result, block) }\n\n  predicate isCall(IRBlock block) { exists(this.asCall(block)) }\n\n  IRBlock asMid() { this = TMid(result) }\n\n  LoadInstruction asSink(IRBlock block) { this = TSink(result, block) }\n\n  predicate isSink(IRBlock block) { exists(this.asSink(block)) }\n\n  string toString() {\n    result =\n      [\n        this.asStore().toString(), this.asCall(_).toString(), this.asMid().toString(),\n        this.asSink(_).toString()\n      ]\n  }\n\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.asStore()\n        .getLocation()\n        .hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n    or\n    this.asCall(_)\n        .getLocation()\n        .hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n    or\n    this.asMid().getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n    or\n    this.asSink(_)\n        .getLocation()\n        .hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n}\n\npredicate isSink(LoadInstruction load, IRBlock block, int index, TGlobalAddress globalAddress) {\n  block.getInstruction(index) = load and\n  globalAddress(load.getSourceAddress()) = globalAddress\n}\n\nquery predicate edges(PathElement pred, PathElement succ) {\n  // Store -> caller\n  globalAddressPointsToStack(pred.asStore(), _, succ.asCall(_), _, _, _, _)\n  or\n  // Call -> basic block\n  pred.isCall(succ.asMid())\n  or\n  // Special case for when the caller goes directly to the load with no steps\n  // across basic blocks (i.e., caller -> sink)\n  exists(IRBlock block |\n    pred.isCall(block) and\n    succ.isSink(block)\n  )\n  or\n  // Basic block -> basic block\n  step(_, _, _, _, pred.asMid(), succ.asMid())\n  or\n  // Basic block -> load\n  succ.isSink(pred.asMid())\n}\n\nfrom\n  StoreInstruction store, StackVariable var, LoadInstruction load, CallInstruction call,\n  IRBlock block, boolean isCallBlock, TGlobalAddress address, boolean isStoreBlock,\n  PathElement source, PathElement sink, int loadIndex\nwhere\n  globalAddressPointsToStack(store, var, call, block, address, isCallBlock, isStoreBlock) and\n  isSink(load, block, loadIndex, address) and\n  (\n    // We know that we have a sequence:\n    // (1) store to `address` -> (2) return from `f` -> (3) load from `address`.\n    // But if (2) and (3) happen in the sam block we need to check the\n    // block indices to ensure that (3) happens after (2).\n    if isCallBlock = true\n    then\n      // If so, the load must happen after the call.\n      getInstructionIndex(call, _) < loadIndex\n    else any()\n  ) and\n  (\n    // If there is a store to the address we need to make sure that the load we found was\n    // before that store (So that the load doesn't read an overwritten value).\n    if isStoreBlock = true\n    then\n      forex(int storeIndex | blockStoresToAddress(block, storeIndex, _, address) |\n        loadIndex < storeIndex\n      )\n    else any()\n  ) and\n  source.asStore() = store and\n  sink.asSink(_) = load\nselect sink, source, sink, \"Stack variable $@ escapes at $@ and is used after it has expired.\", var,\n  var.toString(), store, \"this store\"",
        "description": "Accessing the stack-allocated memory of a function after it has returned can lead to memory corruption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/UsingExpiredStackAddress.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Buffer\nimport semmle.code.cpp.models.implementations.Strcat\nimport semmle.code.cpp.valuenumbering.GlobalValueNumbering\n\npredicate interestingCallWithArgs(Call call, Expr sizeArg, Expr destArg) {\n  exists(StrcatFunction strcat |\n    strcat = call.getTarget() and\n    sizeArg = call.getArgument(strcat.getParamSize()) and\n    destArg = call.getArgument(strcat.getParamDest())\n  )\n}\n\npredicate case1(FunctionCall fc, Expr sizeArg, VariableAccess destArg) {\n  interestingCallWithArgs(fc, sizeArg, destArg) and\n  exists(VariableAccess va |\n    va = sizeArg.(BufferSizeExpr).getArg() and\n    destArg.getTarget() = va.getTarget()\n  )\n}\n\npredicate case2(FunctionCall fc, Expr sizeArg, Expr destArg) {\n  interestingCallWithArgs(fc, pragma[only_bind_into](sizeArg), pragma[only_bind_into](destArg)) and\n  exists(SubExpr sub, int n |\n    // The destination buffer is an array of size n\n    pragma[only_bind_out](destArg.getUnspecifiedType().(ArrayType).getSize()) = n and\n    // The size argument is equivalent to a subtraction\n    globalValueNumber(sizeArg).getAnExpr() = sub and\n    // ... where the left side of the subtraction is the constant n\n    globalValueNumber(sub.getLeftOperand()).getAnExpr().getValue().toInt() = n and\n    // ... and the right side of the subtraction is a call to `strlen` where the argument is the\n    // destination buffer.\n    globalValueNumber(sub.getRightOperand()).getAnExpr().(StrlenCall).getStringExpr() =\n      globalValueNumber(destArg).getAnExpr()\n  )\n}\n\nfrom FunctionCall fc, Expr sizeArg, Expr destArg\nwhere case1(fc, sizeArg, destArg) or case2(fc, sizeArg, destArg)\nselect fc, \"Potentially unsafe call to strncat.\"",
        "description": "Calling 'strncat' with an incorrect size argument may result in a buffer overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/SuspiciousCallToStrncat.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport Buffer\nprivate import semmle.code.cpp.valuenumbering.GlobalValueNumbering\nprivate import semmle.code.cpp.models.implementations.Strcpy\n\npredicate isSizePlus(Expr e, BufferSizeExpr baseSize, int plus) {\n  // baseSize\n  e = baseSize and plus = 0\n  or\n  exists(AddExpr ae, Expr operand1, Expr operand2, int plusSub |\n    // baseSize + n or n + baseSize\n    ae = e and\n    operand1 = ae.getAnOperand() and\n    operand2 = ae.getAnOperand() and\n    operand1 != operand2 and\n    isSizePlus(operand1, baseSize, plusSub) and\n    plus = plusSub + operand2.getValue().toInt()\n  )\n  or\n  exists(SubExpr se, int plusSub |\n    // baseSize - n\n    se = e and\n    isSizePlus(se.getLeftOperand(), baseSize, plusSub) and\n    plus = plusSub - se.getRightOperand().getValue().toInt()\n  )\n}\n\nstring nthString(int num) {\n  num = 0 and\n  result = \"first\"\n  or\n  num = 1 and\n  result = \"second\"\n  or\n  num = 2 and\n  result = \"third\"\n}\n\nint arrayExprFixedSize(Expr e) {\n  result = e.getUnspecifiedType().(ArrayType).getSize()\n  or\n  result = e.(NewArrayExpr).getAllocatedType().(ArrayType).getSize()\n  or\n  exists(SsaDefinition def, LocalVariable v |\n    not e.getUnspecifiedType() instanceof ArrayType and\n    e = def.getAUse(v) and\n    result = arrayExprFixedSize(def.getDefiningValue(v))\n  )\n}\n\nfrom\n  StrcpyFunction f, FunctionCall fc, int argDest, int argSrc, int argLimit, int charSize,\n  Access copyDest, Access copySource, string name, string nth\nwhere\n  f = fc.getTarget() and\n  argDest = f.getParamDest() and\n  argSrc = f.getParamSrc() and\n  argLimit = f.getParamSize() and\n  copyDest = fc.getArgument(argDest) and\n  copySource = fc.getArgument(argSrc) and\n  // Some of the functions operate on a larger char type, like `wchar_t`, so we\n  // need to take this into account in the fixed size case.\n  charSize = f.getParameter(argDest).getUnspecifiedType().(PointerType).getBaseType().getSize() and\n  (\n    if exists(fc.getArgument(argLimit).getValue().toInt())\n    then\n      // Fixed sized case\n      exists(int size |\n        size = arrayExprFixedSize(copyDest) and\n        size < charSize * fc.getArgument(argLimit).getValue().toInt() and\n        size != 0 // if the array has zero size, something special is going on\n      )\n    else\n      exists(Access takenSizeOf, BufferSizeExpr sizeExpr, int plus |\n        // Variable sized case\n        sizeExpr = fc.getArgument(argLimit).getAChild*() and\n        isSizePlus(fc.getArgument(argLimit), sizeExpr, plus) and\n        plus >= 0 and\n        takenSizeOf = sizeExpr.getArg() and\n        globalValueNumber(copySource) = globalValueNumber(takenSizeOf) and // e.g. strncpy(x, y, strlen(y))\n        globalValueNumber(copyDest) != globalValueNumber(takenSizeOf) // e.g. strncpy(y, y, strlen(y))\n      )\n  ) and\n  name = fc.getTarget().getName() and\n  nth = nthString(argLimit)\nselect fc,\n  \"Potentially unsafe call to \" + name + \"; \" + nth + \" argument should be size of destination.\"",
        "description": "Calling 'strncpy' with the size of the source buffer as the third argument may result in a buffer overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/StrncpyFlippedArgs.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.dataflow.StackAddress\n\npredicate stackAddressEscapes(AssignExpr assignExpr, Expr source, boolean isLocal) {\n  stackPointerFlowsToUse(assignExpr.getRValue(), _, source, isLocal) and\n  not stackReferenceFlowsToUse(assignExpr.getLValue(), _, _, _)\n}\n\nfrom Expr use, Expr source, boolean isLocal, string msg, string srcStr\nwhere\n  stackAddressEscapes(use, source, isLocal) and\n  if isLocal = true\n  then (\n    msg = \"A stack address ($@) may be assigned to a non-local variable.\" and\n    srcStr = \"source\"\n  ) else (\n    msg = \"A stack address which arrived via a $@ may be assigned to a non-local variable.\" and\n    srcStr = \"parameter\"\n  )\nselect use, msg, source, srcStr",
        "description": "Storing the address of a local variable in non-local memory can cause a dangling pointer bug if the address is used after the function returns.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/StackAddressEscapes.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.padding.Padding\n\nclass SignedOrUnsignedCharPointerType extends CharPointerType {\n  SignedOrUnsignedCharPointerType() {\n    this.getBaseType().(CharType).isUnsigned() or\n    this.getBaseType().(CharType).isSigned()\n  }\n}\n\npragma[noopt]\nprivate predicate formattingFunctionCallExpectedType(\n  FormattingFunctionCall ffc, int pos, Type expected\n) {\n  exists(FormattingFunction f, int i, FormatLiteral fl |\n    ffc.getTarget() = f and\n    ffc instanceof FormattingFunctionCall and\n    f.getFormatParameterIndex() = i and\n    ffc.getArgument(i) = fl and\n    fl.getConversionType(pos) = expected\n  )\n}\n\npragma[noopt]\npredicate formatArgType(FormattingFunctionCall ffc, int pos, Type expected, Expr arg, Type actual) {\n  formattingFunctionCallExpectedType(ffc, pos, expected) and\n  ffc.getConversionArgument(pos) = arg and\n  exists(Type t | t = arg.getActualType() and t.getUnspecifiedType() = actual)\n}\n\npragma[noopt]\npredicate formatOtherArgType(\n  FormattingFunctionCall ffc, int pos, Type expected, Expr arg, Type actual\n) {\n  (arg = ffc.getMinFieldWidthArgument(pos) or arg = ffc.getPrecisionArgument(pos)) and\n  actual = arg.getActualType() and\n  exists(IntType it | it instanceof IntType and it.isImplicitlySigned() and expected = it)\n}\n\npredicate trivialConversion(Type expected, Type actual) {\n  formatArgType(_, _, expected, _, actual) and\n  (\n    expected instanceof VoidPointerType and actual instanceof PointerType\n    or\n    expected instanceof IntegralType and actual instanceof Enum\n    or\n    expected instanceof CharPointerType and actual instanceof SignedOrUnsignedCharPointerType\n    or\n    expected instanceof SignedOrUnsignedCharPointerType and actual instanceof CharPointerType\n    or\n    expected instanceof CharType and actual instanceof IntType\n    or\n    expected instanceof UnsignedCharType and actual instanceof IntType\n    or\n    expected.(IntegralType).getUnsigned() = actual.(IntegralType).getUnsigned()\n    or\n    expected = actual\n  )\n}\n\nfrom\n  FormattingFunctionCall ffc, int n, Expr arg, Type expected, Type actual, ILP32 ilp32, LP64 lp64,\n  int size32, int size64\nwhere\n  (\n    formatArgType(ffc, n, expected, arg, actual) and\n    not trivialConversion(expected, actual)\n    or\n    formatOtherArgType(ffc, n, expected, arg, actual) and\n    not actual instanceof IntType\n  ) and\n  not arg.isAffectedByMacro() and\n  size32 = ilp32.paddedSize(actual) and\n  size64 = lp64.paddedSize(actual) and\n  size64 != size32 and\n  not actual instanceof ErroneousType\nselect arg,\n  \"This argument should be of type '\" + expected.getName() + \"' but is of type '\" + actual.getName()\n    + \"' (which changes size from \" + size32 + \" to \" + size64 + \" on 64-bit systems).\"",
        "description": "When using a format specifier like %d (\"int\"), on a 32-bit architecture it's acceptable to pass a long since it's of the same size; when migrating to a 64-bit architecture this becomes problematic. Similar problems exist when printing pointers using 32-bit-wide format specifiers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/Padding/NonPortablePrintf.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.padding.Padding\n\nfrom PaddedType t, ILP32 ilp32, LP64 lp64, int w32, int w64\nwhere\n  w32 = t.wastedSpace(ilp32) - t.trailingPadding(ilp32) and\n  w64 = t.wastedSpace(lp64) - t.trailingPadding(lp64) and\n  w64 > w32 and\n  t.isPrecise()\nselect t,\n  t.getName() + \" includes \" + w32 + \" bits of padding on ILP32, but \" + w64 + \" bits on LP64.\"",
        "description": "Highlights structs for which the amount of padding would increase when migrating from a 32-bit architecture to 64-bit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/Padding/More64BitWaste.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.padding.Padding\n\nfrom\n  PaddedType t, Architecture arch, WideCharType wc, int holes, int size, int percentage, int optimum\nwhere\n  arch.pointerSize() = 64 and // Select 64-bit architecture\n  arch.wideCharSize() = (wc.getSize() * 8) and // Select Windows(sizeof(wchar_t == 2)) or non-Windows(sizeof(wchar_t == 4))\n  t.isPrecise() and\n  optimum = t.optimalSize(arch) and\n  size = arch.paddedSize(t) and\n  holes = size - optimum and\n  holes > 0 and\n  percentage = (holes * 100.0 / size.(float)).ceil()\nselect t,\n  t.getName() + \" could be optimized to save \" + holes + \"/\" + t.wastedSpace(arch) +\n    \" bits of padding (or \" + percentage + \"% of its size).\"",
        "description": "Highlights structs whose members are not laid out optimally, in the sense that by reordering them one could reduce the amount of internal padding on a 64-bit architecture.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Memory Management/Padding/Suboptimal64BitType.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.controlflow.SSA\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport semmle.code.cpp.rangeanalysis.RangeAnalysisUtils\n\npredicate likelySmall(Expr e) {\n  e.isConstant()\n  or\n  e.getType().getSize() <= 1\n  or\n  e.(ArrayExpr).getArrayBase().getType().(ArrayType).getBaseType().isConst()\n  or\n  exists(SsaDefinition def, Variable v |\n    def.getAUse(v) = e and\n    likelySmall(def.getDefiningValue(v))\n  )\n}\n\nExpr getMulOperand(MulExpr me) { result = me.getAnOperand() }\n\nint getEffectiveMulOperands(MulExpr me) {\n  result =\n    count(Expr op |\n      op = getMulOperand*(me) and\n      not op instanceof MulExpr and\n      not likelySmall(op)\n    )\n}\n\nclass AnalyzableExpr extends Expr {\n  float maxValue() { result = upperBound(this.getFullyConverted()) }\n\n  float minValue() { result = lowerBound(this.getFullyConverted()) }\n}\n\nclass ParenAnalyzableExpr extends AnalyzableExpr, ParenthesisExpr {\n  override float maxValue() { result = this.getExpr().(AnalyzableExpr).maxValue() }\n\n  override float minValue() { result = this.getExpr().(AnalyzableExpr).minValue() }\n}\n\nclass MulAnalyzableExpr extends AnalyzableExpr, MulExpr {\n  override float maxValue() {\n    exists(float x1, float y1, float x2, float y2 |\n      x1 = this.getLeftOperand().getFullyConverted().(AnalyzableExpr).minValue() and\n      x2 = this.getLeftOperand().getFullyConverted().(AnalyzableExpr).maxValue() and\n      y1 = this.getRightOperand().getFullyConverted().(AnalyzableExpr).minValue() and\n      y2 = this.getRightOperand().getFullyConverted().(AnalyzableExpr).maxValue() and\n      result = (x1 * y1).maximum(x1 * y2).maximum(x2 * y1).maximum(x2 * y2)\n    )\n  }\n\n  override float minValue() {\n    exists(float x1, float x2, float y1, float y2 |\n      x1 = this.getLeftOperand().getFullyConverted().(AnalyzableExpr).minValue() and\n      x2 = this.getLeftOperand().getFullyConverted().(AnalyzableExpr).maxValue() and\n      y1 = this.getRightOperand().getFullyConverted().(AnalyzableExpr).minValue() and\n      y2 = this.getRightOperand().getFullyConverted().(AnalyzableExpr).maxValue() and\n      result = (x1 * y1).minimum(x1 * y2).minimum(x2 * y1).minimum(x2 * y2)\n    )\n  }\n}\n\nclass AddAnalyzableExpr extends AnalyzableExpr, AddExpr {\n  override float maxValue() {\n    result =\n      this.getLeftOperand().getFullyConverted().(AnalyzableExpr).maxValue() +\n        this.getRightOperand().getFullyConverted().(AnalyzableExpr).maxValue()\n  }\n\n  override float minValue() {\n    result =\n      this.getLeftOperand().getFullyConverted().(AnalyzableExpr).minValue() +\n        this.getRightOperand().getFullyConverted().(AnalyzableExpr).minValue()\n  }\n}\n\nclass SubAnalyzableExpr extends AnalyzableExpr, SubExpr {\n  override float maxValue() {\n    result =\n      this.getLeftOperand().getFullyConverted().(AnalyzableExpr).maxValue() -\n        this.getRightOperand().getFullyConverted().(AnalyzableExpr).minValue()\n  }\n\n  override float minValue() {\n    result =\n      this.getLeftOperand().getFullyConverted().(AnalyzableExpr).minValue() -\n        this.getRightOperand().getFullyConverted().(AnalyzableExpr).maxValue()\n  }\n}\n\nclass VarAnalyzableExpr extends AnalyzableExpr, VariableAccess {\n  VarAnalyzableExpr() { this.getTarget() instanceof StackVariable }\n\n  override float maxValue() {\n    exists(SsaDefinition def, Variable v |\n      def.getAUse(v) = this and\n      // if there is a defining expression, use that for\n      // computing the maximum value. Otherwise, assign the\n      // variable the largest possible value it can hold\n      if exists(def.getDefiningValue(v))\n      then result = def.getDefiningValue(v).(AnalyzableExpr).maxValue()\n      else result = upperBound(this)\n    )\n  }\n\n  override float minValue() {\n    exists(SsaDefinition def, Variable v |\n      def.getAUse(v) = this and\n      if exists(def.getDefiningValue(v))\n      then result = def.getDefiningValue(v).(AnalyzableExpr).minValue()\n      else result = lowerBound(this)\n    )\n  }\n}\n\npragma[inline]\npredicate overflows(MulExpr me, Type t) {\n  t instanceof IntegralType\n  implies\n  (\n    me.(MulAnalyzableExpr).maxValue() > exprMaxVal(me)\n    or\n    me.(MulAnalyzableExpr).minValue() < exprMinVal(me)\n  )\n}\n\nfrom MulExpr me, Type t1, Type t2\nwhere\n  t1 = me.getType().getUnderlyingType() and\n  t2 = me.getConversion().getType().getUnderlyingType() and\n  t1.getSize() < t2.getSize() and\n  (\n    t1.getUnspecifiedType() instanceof IntegralType and\n    t2.getUnspecifiedType() instanceof IntegralType\n    or\n    t1.getUnspecifiedType() instanceof FloatingPointType and\n    t2.getUnspecifiedType() instanceof FloatingPointType\n  ) and\n  // exclude explicit conversions\n  me.getConversion().isCompilerGenerated() and\n  // require the multiply to have two non-constant operands\n  // (the intuition here is that multiplying two unknowns is\n  // much more likely to produce a result that needs significantly\n  // more bits than the operands did, and thus requires a larger\n  // type).\n  getEffectiveMulOperands(me) >= 2 and\n  // exclude varargs promotions\n  not exists(FunctionCall fc, int vararg |\n    fc.getArgument(vararg) = me and\n    vararg >= fc.getTarget().getNumberOfParameters()\n  ) and\n  // exclude cases where the type was made bigger by a literal\n  // (compared to other cases such as assignment, this is more\n  // likely to be a trivial accident rather than suggesting a\n  // larger type is needed for the result).\n  not exists(Expr other, Expr e |\n    other = me.getParent().(BinaryOperation).getAnOperand() and\n    not other = me and\n    (\n      e = other or\n      e = other.(BinaryOperation).getAnOperand*()\n    ) and\n    e.(Literal).getType().getSize() = t2.getSize()\n  ) and\n  // only report if we cannot prove that the result of the\n  // multiplication will be less (resp. greater) than the\n  // maximum (resp. minimum) number we can compute.\n  overflows(me, t1)\nselect me,\n  \"Multiplication result may overflow '\" + me.getType().toString() + \"' before it is converted to '\"\n    + me.getFullyConverted().getType().toString() + \"'.\"",
        "description": "A multiplication result that is converted to a larger type can be a sign that the result can overflow the type converted from.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/IntMultToLong.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom RelationalOperation e, BinaryBitwiseOperation lhs\nwhere\n  // `lhs > 0` (or `0 < lhs`)\n  // (note that `lhs < 0`, `lhs >= 0` or `lhs <= 0` all imply that the signedness of\n  //  `lhs` is understood, so should not be flagged).\n  (e instanceof GTExpr or e instanceof LTExpr) and\n  e.getGreaterOperand() = lhs and\n  e.getLesserOperand().getValue() = \"0\" and\n  // lhs is signed\n  lhs.getActualType().(IntegralType).isSigned() and\n  // if `lhs` has the form `x & c`, with constant `c`, `c` is negative\n  forall(int op | op = lhs.(BitwiseAndExpr).getAnOperand().getValue().toInt() | op < 0) and\n  // exception for cases involving macros\n  not e.isAffectedByMacro()\nselect e, \"Potentially unsafe sign check of a bitwise operation.\"",
        "description": "Checking the sign of the result of a bitwise operation may yield unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/BitwiseSignCheck.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nprivate import semmle.code.cpp.valuenumbering.GlobalValueNumbering\nprivate import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nprivate import semmle.code.cpp.commons.Exclusions\n\nfrom RelationalOperation ro, AddExpr add, Expr expr1, Expr expr2\nwhere\n  ro.getAnOperand() = add and\n  add.getAnOperand() = expr1 and\n  ro.getAnOperand() = expr2 and\n  globalValueNumber(expr1) = globalValueNumber(expr2) and\n  add.getUnspecifiedType().(IntegralType).isSigned() and\n  not isFromMacroDefinition(ro) and\n  exprMightOverflowPositively(add) and\n  exists(Compilation c | c.getAFileCompiled() = ro.getFile() |\n    not c.getAnArgument() = \"-fwrapv\" and\n    not c.getAnArgument() = \"-fno-strict-overflow\"\n  )\nselect ro, \"Testing for signed overflow may produce undefined results.\"",
        "description": "Testing for overflow by adding a value to a variable to see if it \"wraps around\" works only for unsigned integer values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/SignedOverflowCheck.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport PointlessSelfComparison\nimport semmle.code.cpp.commons.Exclusions\n\nfrom ComparisonOperation cmp\nwhere\n  pointlessSelfComparison(cmp) and\n  not nanTest(cmp) and\n  not overflowTest(cmp) and\n  not cmp.isFromTemplateInstantiation(_) and\n  not isFromMacroDefinition(cmp)\nselect cmp, \"This expression compares an $@ to itself.\", cmp.getLeftOperand(), \"expression\"",
        "description": "Comparing a variable to itself always produces the same result, unless the purpose is to check for integer overflow or floating point NaN.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/PointlessSelfComparison.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom ComparisonOperation co, ComparisonOperation chco\nwhere\n  co.getAChild() = chco and\n  not chco.isParenthesised() and\n  not co.isFromUninstantiatedTemplate(_)\nselect co, \"Comparison as an operand to another comparison.\"",
        "description": "Using comparisons as operands of other comparisons is unusual in itself, and most readers will require parentheses to be sure of the precedence.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/ComparisonPrecedence.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ConfigurationTestFile\n\nfrom EqualityOperation ro, Expr left, Expr right\nwhere\n  left = ro.getLeftOperand() and\n  right = ro.getRightOperand() and\n  ro.getAnOperand().getExplicitlyConverted().getType().getUnderlyingType() instanceof\n    FloatingPointType and\n  not ro.getAnOperand().isConstant() and // comparisons to constants generate too many false positives\n  not left.(VariableAccess).getTarget() = right.(VariableAccess).getTarget() and // skip self comparison\n  not ro.getFile() instanceof ConfigurationTestFile // expressions in files generated during configuration are likely false positives\nselect ro, \"Equality checks on floating point values can yield unexpected results.\"",
        "description": "Comparing results of floating-point computations with '==' or '!=' is likely to yield surprising results since floating-point computation does not follow the standard rules of algebra.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/FloatComparison.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nprivate import semmle.code.cpp.commons.Exclusions\nprivate import semmle.code.cpp.rangeanalysis.PointlessComparison\nprivate import semmle.code.cpp.rangeanalysis.RangeAnalysisUtils\nimport UnsignedGEZero\n\n// Trivial comparisons of the form 1 > 0 are usually due to macro expansion.\n// For example:\n//\n// #define PRINTMSG(val,msg) { if (val >= PRINTLEVEL) printf(msg); }\n//\n// So to reduce the number of false positives, we do not report a result if\n// the comparison is in a macro expansion. Similarly for template\n// instantiations.\nfrom ComparisonOperation cmp, SmallSide ss, float left, float right, boolean value, string reason\nwhere\n  not cmp.isInMacroExpansion() and\n  not cmp.isFromTemplateInstantiation(_) and\n  not functionContainsDisabledCode(cmp.getEnclosingFunction()) and\n  reachablePointlessComparison(cmp, left, right, value, ss) and\n  // a comparison between an enum and zero is always valid because whether\n  // the underlying type of an enum is signed is compiler-dependent\n  not exists(Expr e, ConstantZero z |\n    relOpWithSwap(cmp, e.getFullyConverted(), z, _, _) and\n    e.getUnderlyingType() instanceof Enum\n  ) and\n  // Construct a reason for the message. Something like: x >= 5 and 3 >= y.\n  exists(string cmpOp, string leftReason, string rightReason |\n    (\n      ss = LeftIsSmaller() and cmpOp = \" <= \"\n      or\n      ss = RightIsSmaller() and cmpOp = \" >= \"\n    ) and\n    leftReason = cmp.getLeftOperand().toString() + cmpOp + left.toString() and\n    rightReason = right.toString() + cmpOp + cmp.getRightOperand().toString() and\n    // If either of the operands is constant, then don't include it.\n    (\n      if cmp.getLeftOperand().isConstant()\n      then not cmp.getRightOperand().isConstant() and reason = rightReason\n      else\n        if cmp.getRightOperand().isConstant()\n        then reason = leftReason\n        else reason = leftReason + \" and \" + rightReason\n    )\n  ) and\n  // Don't report results which have already been reported by UnsignedGEZero.\n  not unsignedGEZero(cmp, _)\nselect cmp, \"Comparison is always \" + value.toString() + \" because \" + reason + \".\"",
        "description": "When a comparison operation, such as x < y, always returns the same result, it means that the comparison is redundant and may mask a bug because a different check was intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/PointlessComparison.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport UnsignedGEZero\n\nfrom UnsignedGEZero ugez, string msg\nwhere unsignedGEZero(ugez, msg)\nselect ugez, msg",
        "description": "An unsigned value is always non-negative, even if it has been assigned a negative number, so the comparison is redundant and may mask a bug because a different check was intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/UnsignedGEZero.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport BadAdditionOverflowCheck\n\nfrom RelationalOperation cmp, AddExpr a\nwhere badAdditionOverflowCheck(cmp, a)\nselect cmp, \"Bad overflow check.\"",
        "description": "Checking for overflow of integer addition by comparing against one of the arguments of the addition does not work when the result of the addition is automatically promoted to a larger type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/BadAdditionOverflowCheck.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom EqualityOperation t, RemExpr lhs, Literal rhs\nwhere\n  t.getLeftOperand() = lhs and\n  t.getRightOperand() = rhs and\n  lhs.getLeftOperand().getUnspecifiedType().(IntegralType).isSigned() and\n  lhs.getRightOperand().getValue() = \"2\" and\n  rhs.getValue() = \"1\"\nselect t, \"Possibly invalid test for oddness. This will fail for negative numbers.\"",
        "description": "Using \"x % 2 == 1\" to check whether x is odd does not work for negative numbers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/BadCheckOdd.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\nimport BadAdditionOverflowCheck\nimport PointlessSelfComparison\n\nprivate predicate linearChild(Expr parent, Expr child, float multiplier) {\n  child = parent.(AddExpr).getAChild() and multiplier = 1.0\n  or\n  child = parent.(SubExpr).getLeftOperand() and multiplier = 1.0\n  or\n  child = parent.(SubExpr).getRightOperand() and multiplier = -1.0\n  or\n  child = parent.(UnaryPlusExpr).getOperand() and multiplier = 1.0\n  or\n  child = parent.(UnaryMinusExpr).getOperand() and multiplier = -1.0\n}\n\nprivate predicate cmpLinearSubExpr(ComparisonOperation cmp, Expr child, float multiplier) {\n  not convertedExprMightOverflow(child) and\n  (\n    child = cmp.getLeftOperand() and multiplier = 1.0\n    or\n    child = cmp.getRightOperand() and multiplier = -1.0\n    or\n    exists(Expr parent, float m1, float m2 |\n      cmpLinearSubExpr(cmp, parent, m1) and\n      linearChild(parent, child, m2) and\n      multiplier = m1 * m2\n    )\n  )\n}\n\nprivate predicate cmpLinearSubVariable(\n  ComparisonOperation cmp, Variable v, VariableAccess child, float multiplier\n) {\n  v = child.getTarget() and\n  not exists(child.getQualifier()) and\n  cmpLinearSubExpr(cmp, child, multiplier)\n}\n\nprivate predicate cancelingSubExprs(ComparisonOperation cmp, VariableAccess a1, VariableAccess a2) {\n  exists(Variable v |\n    exists(float m | m < 0 and cmpLinearSubVariable(cmp, v, a1, m)) and\n    exists(float m | m > 0 and cmpLinearSubVariable(cmp, v, a2, m))\n  ) and\n  not any(ClassTemplateInstantiation inst).getATemplateArgument() = cmp.getParent*()\n}\n\nfrom ComparisonOperation cmp, VariableAccess a1, VariableAccess a2\nwhere\n  cancelingSubExprs(cmp, a1, a2) and\n  // Most practical examples found by this query are instances of\n  // BadAdditionOverflowCheck or PointlessSelfComparison.\n  not badAdditionOverflowCheck(cmp, _) and\n  not pointlessSelfComparison(cmp)\nselect cmp, \"Comparison can be simplified by canceling $@ with $@.\", a1, a1.getTarget().getName(),\n  a2, a2.getTarget().getName()",
        "description": "If the same sub-expression is added to both sides of a comparison, and there is no possibility of overflow or rounding, then the sub-expression is redundant and could be removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Arithmetic/ComparisonWithCancelingSubExpr.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom FormatLiteral fl, FormattingFunctionCall ffc, int expected, int given, string ffcName\nwhere\n  ffc = fl.getUse() and\n  expected = fl.getNumArgNeeded() and\n  given = ffc.getNumFormatArgument() and\n  expected < given and\n  fl.specsAreKnown() and\n  (\n    if ffc.isInMacroExpansion()\n    then ffcName = ffc.getTarget().getName() + \" (in a macro expansion)\"\n    else ffcName = ffc.getTarget().getName()\n  )\nselect ffc,\n  \"Format for \" + ffcName + \" expects \" + expected.toString() + \" arguments but given \" +\n    given.toString()",
        "description": "A printf-like function called with too many arguments will ignore the excess arguments and output less than might have been intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Format/TooManyFormatArguments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass SyntaxError extends CompilerError {\n  SyntaxError() { this.getTag().matches(\"exp_%\") }\n\n  predicate affects(Element e) {\n    exists(Location l1, Location l2 |\n      l1 = this.getLocation() and\n      l2 = e.getLocation()\n    |\n      l1.getFile() = l2.getFile() and\n      l1.getStartLine() = l2.getStartLine()\n    )\n  }\n}\n\nfrom FormatLiteral fl, FormattingFunctionCall ffc, int expected, int given, string ffcName\nwhere\n  ffc = fl.getUse() and\n  expected = fl.getNumArgNeeded() and\n  given = ffc.getNumFormatArgument() and\n  expected > given and\n  fl.specsAreKnown() and\n  (\n    if ffc.isInMacroExpansion()\n    then ffcName = ffc.getTarget().getName() + \" (in a macro expansion)\"\n    else ffcName = ffc.getTarget().getName()\n  ) and\n  // A typical problem is that string literals are concatenated, but if one of the string\n  // literals is an undefined macro, then this just leads to a syntax error.\n  not exists(SyntaxError e | e.affects(fl)) and\n  not ffc.getArgument(_) instanceof ErrorExpr\nselect ffc,\n  \"Format for \" + ffcName + \" expects \" + expected.toString() + \" arguments but given \" +\n    given.toString()",
        "description": "Calling a printf-like function with too few arguments can be a source of security issues.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Format/WrongNumberOfFormatArguments.ql",
        "language": "cpp"
    },
    {
        "query": "import semmle.code.cpp.ir.dataflow.TaintTracking\nimport semmle.code.cpp.commons.Printf\nimport semmle.code.cpp.security.FlowSources\nimport semmle.code.cpp.ir.dataflow.internal.ModelUtil\nimport semmle.code.cpp.models.interfaces.DataFlow\nimport semmle.code.cpp.models.interfaces.Taint\nimport semmle.code.cpp.ir.IR\nimport NonConstFlow::PathGraph\n\nclass UncalledFunction extends Function {\n  UncalledFunction() {\n    not exists(Call c | c.getTarget() = this) and\n    // Ignore functions that appear to be function pointers\n    // function pointers may be seen as uncalled statically\n    not exists(FunctionAccess fa | fa.getTarget() = this)\n  }\n}\n\nclass UnsignedShort extends ShortType {\n  UnsignedShort() { this.isUnsigned() }\n}\n\npredicate cannotContainString(Type t) {\n  exists(Type unspecified |\n    unspecified = t.getUnspecifiedType() and\n    not unspecified instanceof UnknownType and\n    not unspecified instanceof CharType and\n    not unspecified instanceof WideCharType and\n    not unspecified instanceof Char8Type and\n    not unspecified instanceof Char16Type and\n    not unspecified instanceof Char32Type and\n    // C often defines `wchar_t` as `unsigned short`\n    not unspecified instanceof UnsignedShort\n  |\n    unspecified instanceof ArithmeticType or\n    unspecified instanceof BuiltInType\n  )\n}\n\npredicate dataFlowOrTaintFlowFunction(Function func, FunctionOutput output) {\n  func.(DataFlowFunction).hasDataFlow(_, output) or\n  func.(TaintFunction).hasTaintFlow(_, output)\n}\n\npredicate isNonConst(DataFlow::Node node) {\n  node instanceof FlowSource\n  or\n  // Parameters of uncalled functions that aren't const\n  exists(UncalledFunction f, Parameter p |\n    f.getAParameter() = p and\n    // We pick the indirection of the parameter since this query is focused\n    // on strings.\n    p = node.asParameter(1) and\n    // Ignore main's argv parameter as it is already considered a `FlowSource`\n    // not ignoring it will result in path redundancies\n    (f.getName() = \"main\" implies p != f.getParameter(1))\n  )\n  or\n  // Consider as an input any out arg of a function or a function's return where the function is not:\n  // 1. a function with a known dataflow or taintflow from input to output and the `node` is the output\n  // 2. a function where there is a known definition\n  // i.e., functions that with unknown bodies and are not known to define the output through its input\n  //       are considered as possible non-const sources\n  // The function's output must also not be const to be considered a non-const source\n  exists(Function func, CallInstruction call |\n    not func.hasDefinition() and\n    func = call.getStaticCallTarget()\n  |\n    // Case 1: It's a known dataflow or taintflow function with flow to the return value\n    call.getUnconvertedResultExpression() = node.asIndirectExpr() and\n    not exists(FunctionOutput output |\n      dataFlowOrTaintFlowFunction(func, output) and\n      output.isReturnValueDeref(_) and\n      node = callOutput(call, output)\n    )\n    or\n    // Case 2: It's a known dataflow or taintflow function with flow to an output parameter\n    exists(int i |\n      call.getPositionalArgumentOperand(i).getDef().getUnconvertedResultExpression() =\n        node.asDefiningArgument() and\n      not exists(FunctionOutput output |\n        dataFlowOrTaintFlowFunction(func, output) and\n        output.isParameterDeref(i, _) and\n        node = callOutput(call, output)\n      )\n    )\n  )\n}\n\npredicate isSinkImpl(DataFlow::Node sink, Expr formatString) {\n  sink.asIndirectExpr() = formatString and\n  exists(FormattingFunctionCall fc | formatString = fc.getArgument(fc.getFormatParameterIndex()))\n}\n\nmodule NonConstFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(Type t |\n      isNonConst(source) and\n      t = source.getType() and\n      not cannotContainString(t)\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSinkImpl(sink, _) }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // Ignore tracing non-const through array indices\n    exists(ArrayExpr a | a.getArrayOffset() = node.asIndirectExpr())\n    or\n    exists(Type t |\n      t = node.getType() and\n      cannotContainString(t)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    result = sink.getLocation()\n    or\n    exists(FormattingFunctionCall call, Expr formatString | result = call.getLocation() |\n      isSinkImpl(sink, formatString) and\n      call.getArgument(call.getFormatParameterIndex()) = formatString\n    )\n  }\n}\n\nmodule NonConstFlow = TaintTracking::Global<NonConstFlowConfig>;\n\nfrom\n  FormattingFunctionCall call, Expr formatString, NonConstFlow::PathNode sink,\n  NonConstFlow::PathNode source\nwhere\n  isSinkImpl(sink.getNode(), formatString) and\n  call.getArgument(call.getFormatParameterIndex()) = formatString and\n  NonConstFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"The format string argument to $@ has a source which cannot be \" +\n    \"verified to originate from a string literal.\", call, call.getTarget().getName()",
        "description": "Passing a value that is not a string literal 'format' string to a printf-like function can lead to a mismatch between the number of arguments defined by the 'format' and the number of arguments actually passed to the function. If the format string ultimately stems from an untrusted source, this can be used for exploits. This query finds format strings coming from non-literal sources. Note that format strings of type `const char*` it is still considered non-constant if the value is not coming from a string literal. For example, for a parameter with type `const char*` of an exported function that is used as a format string, there is no way to ensure the originating value was a string literal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Format/NonConstantFormat.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis\n\npredicate flowsToExpr(Expr source, Expr sink, boolean pathMightOverflow) {\n  // Might the current expression overflow?\n  exists(boolean otherMightOverflow | flowsToExprImpl(source, sink, otherMightOverflow) |\n    if convertedExprMightOverflow(sink)\n    then pathMightOverflow = true\n    else pathMightOverflow = otherMightOverflow\n  )\n}\n\npredicate flowsToExprImpl(Expr source, Expr sink, boolean pathMightOverflow) {\n  source = sink and\n  pathMightOverflow = false and\n  source.(FunctionCall).getTarget().(Snprintf).returnsFullFormatLength()\n  or\n  exists(RangeSsaDefinition def, StackVariable v |\n    flowsToDef(source, def, v, pathMightOverflow) and\n    sink = def.getAUse(v)\n  )\n  or\n  flowsToExpr(source, sink.(UnaryArithmeticOperation).getOperand(), pathMightOverflow)\n  or\n  flowsToExpr(source, sink.(BinaryArithmeticOperation).getAnOperand(), pathMightOverflow)\n  or\n  flowsToExpr(source, sink.(Assignment).getRValue(), pathMightOverflow)\n  or\n  flowsToExpr(source, sink.(AssignOperation).getLValue(), pathMightOverflow)\n  or\n  exists(FormattingFunctionCall call |\n    sink = call and\n    flowsToExpr(source, call.getArgument(call.getTarget().getSizeParameterIndex()),\n      pathMightOverflow)\n  )\n}\n\npredicate flowsToDef(Expr source, RangeSsaDefinition def, StackVariable v, boolean pathMightOverflow) {\n  // Might the current definition overflow?\n  exists(boolean otherMightOverflow | flowsToDefImpl(source, def, v, otherMightOverflow) |\n    if defMightOverflow(def, v)\n    then pathMightOverflow = true\n    else pathMightOverflow = otherMightOverflow\n  )\n}\n\npredicate flowsToDefImpl(\n  Expr source, RangeSsaDefinition def, StackVariable v, boolean pathMightOverflow\n) {\n  // Assignment or initialization: `e = v;`\n  exists(Expr e |\n    e = def.getDefiningValue(v) and\n    flowsToExpr(source, e, pathMightOverflow)\n  )\n  or\n  // `x++`\n  exists(CrementOperation crem |\n    def = crem and\n    crem.getOperand() = v.getAnAccess() and\n    flowsToExpr(source, crem.getOperand(), pathMightOverflow)\n  )\n  or\n  // Phi definition.\n  flowsToDef(source, def.getAPhiInput(v), v, pathMightOverflow)\n}\n\nfrom FormattingFunctionCall call, Expr sink\nwhere\n  flowsToExpr(call, sink, true) and\n  sink = call.getArgument(call.getTarget().getSizeParameterIndex())\nselect call,\n  \"The $@ of this snprintf call is derived from its return value, which may exceed the size of the buffer and overflow.\",\n  sink, \"size argument\"",
        "description": "Using the return value from snprintf without proper checks can cause overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Format/SnprintfOverflow.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nprivate predicate formattingFunctionCallExpectedType(\n  FormattingFunctionCall ffc, int pos, Type expected\n) {\n  ffc.getFormat().(FormatLiteral).getConversionType(pos) = expected\n}\n\nprivate predicate formattingFunctionCallAlternateType(\n  FormattingFunctionCall ffc, int pos, Type expected\n) {\n  ffc.getFormat().(FormatLiteral).getConversionTypeAlternate(pos) = expected\n}\n\npragma[noopt]\npredicate formattingFunctionCallActualType(\n  FormattingFunctionCall ffc, int pos, Expr arg, Type actual\n) {\n  exists(Expr argConverted |\n    ffc.getConversionArgument(pos) = arg and\n    argConverted = arg.getFullyConverted() and\n    actual = argConverted.getType()\n  )\n}\n\npragma[noopt]\npredicate formatOtherArgType(\n  FormattingFunctionCall ffc, int pos, Type expected, Expr arg, Type actual\n) {\n  exists(Expr argConverted |\n    (arg = ffc.getMinFieldWidthArgument(pos) or arg = ffc.getPrecisionArgument(pos)) and\n    argConverted = arg.getFullyConverted() and\n    actual = argConverted.getType() and\n    exists(IntType it | it instanceof IntType and it.isImplicitlySigned() and expected = it)\n  )\n}\n\nclass ExpectedType extends Type {\n  ExpectedType() {\n    exists(Type t |\n      (\n        formattingFunctionCallExpectedType(_, _, t) or\n        formattingFunctionCallAlternateType(_, _, t) or\n        formatOtherArgType(_, _, t, _, _)\n      ) and\n      this = t.getUnspecifiedType()\n    )\n  }\n}\n\npredicate trivialConversion(ExpectedType expected, Type actual) {\n  exists(Type exp, Type act |\n    (\n      formattingFunctionCallExpectedType(_, _, exp) or\n      formattingFunctionCallAlternateType(_, _, exp)\n    ) and\n    formattingFunctionCallActualType(_, _, _, act) and\n    expected = exp.getUnspecifiedType() and\n    actual = act.getUnspecifiedType()\n  ) and\n  (\n    // allow a pointer type to be displayed with `%p`\n    expected instanceof VoidPointerType and actual instanceof PointerType\n    or\n    // allow a function pointer type to be displayed with `%p`\n    expected instanceof VoidPointerType and\n    actual instanceof FunctionPointerType and\n    expected.getSize() = actual.getSize()\n    or\n    // allow an `enum` type to be displayed with `%i`, `%c` etc\n    expected instanceof IntegralType and actual instanceof Enum\n    or\n    // allow any `char *` type to be displayed with `%s`\n    expected instanceof CharPointerType and actual instanceof CharPointerType\n    or\n    // allow `wchar_t *`, or any pointer to an integral type of the same size, to be displayed\n    // with `%ws`\n    expected.(PointerType).getBaseType().hasName(\"wchar_t\") and\n    exists(Wchar_t t |\n      actual.getUnspecifiedType().(PointerType).getBaseType().(IntegralType).getSize() = t.getSize()\n    )\n    or\n    // allow an `int` (or anything promoted to `int`) to be displayed with `%c`\n    expected instanceof CharType and actual instanceof IntType\n    or\n    // allow an `int` (or anything promoted to `int`) to be displayed with `%wc`\n    expected instanceof Wchar_t and actual instanceof IntType\n    or\n    expected instanceof UnsignedCharType and actual instanceof IntType\n    or\n    // allow any integral type of the same size\n    // (this permits signedness changes)\n    expected.(IntegralType).getSize() = actual.(IntegralType).getSize()\n    or\n    // allow a pointer to any integral type of the same size\n    // (this permits signedness changes)\n    expected.(PointerType).getBaseType().(IntegralType).getSize() =\n      actual.(PointerType).getBaseType().(IntegralType).getSize()\n    or\n    expected = actual\n  )\n}\n\nint sizeof_IntType() { exists(IntType it | result = it.getSize()) }\n\nfrom FormattingFunctionCall ffc, int n, Expr arg, Type expected, Type actual\nwhere\n  (\n    formattingFunctionCallExpectedType(ffc, n, expected) and\n    formattingFunctionCallActualType(ffc, n, arg, actual) and\n    not exists(Type anyExpected |\n      (\n        formattingFunctionCallExpectedType(ffc, n, anyExpected) or\n        formattingFunctionCallAlternateType(ffc, n, anyExpected)\n      ) and\n      trivialConversion(anyExpected.getUnspecifiedType(), actual.getUnspecifiedType())\n    )\n    or\n    formatOtherArgType(ffc, n, expected, arg, actual) and\n    not actual.getUnspecifiedType().(IntegralType).getSize() = sizeof_IntType()\n  ) and\n  not arg.isAffectedByMacro() and\n  not arg.isFromUninstantiatedTemplate(_) and\n  not actual.stripType() instanceof ErroneousType and\n  not arg.(Call).mayBeFromImplicitlyDeclaredFunction() and\n  // Make sure that the format function definition is consistent\n  count(ffc.getTarget().getFormatParameterIndex()) = 1\nselect arg,\n  \"This format specifier for type '\" + expected.getName() + \"' does not match the argument type '\" +\n    actual.getUnspecifiedType().getName() + \"'.\"",
        "description": "Calling a printf-like function with the wrong type of arguments causes unpredictable behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Format/WrongTypeFormatArguments.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// This predicate finds the catch block enclosing a rethrow expression.\npredicate bindEnclosingCatch(ReThrowExpr te, CatchBlock cb) {\n  te.getEnclosingBlock().getEnclosingBlock*() = cb and\n  not exists(CatchBlock other |\n    te.getEnclosingBlock().getEnclosingBlock*() = other and other.getEnclosingBlock+() = cb\n  )\n}\n\n// This predicate strips references from types, i.e. T -> T, T* -> T*, T& -> T.\npredicate bindStrippedReferenceType(Type qualified, Type unqualified) {\n  not qualified instanceof ReferenceType and unqualified = qualified\n  or\n  unqualified = qualified.(ReferenceType).getBaseType()\n}\n\n// This predicate determines (to a first approximation) the type thrown by a throw or rethrow expression.\npredicate bindThrownType(ThrowExpr te, Type thrown) {\n  // For normal throws, the thrown type is easily determined as the type of the throw expression.\n  not te instanceof ReThrowExpr and thrown = te.getActualType()\n  or\n  // For rethrows, we use the unqualified version of the type caught by the enclosing catch block.\n  // Note that this is not precise, but is a reasonable first approximation.\n  exists(CatchBlock cb |\n    bindEnclosingCatch(te, cb) and\n    bindStrippedReferenceType(cb.getParameter().getUnspecifiedType(), thrown)\n  )\n}\n\n// This predicate determines the catch blocks that can catch the exceptions thrown by each throw expression.\npragma[inline]\npredicate canCatch(ThrowExpr te, CatchBlock cb) {\n  exists(Type thrown, Type caught |\n    bindThrownType(te, thrown) and\n    caught = cb.getParameter().getUnspecifiedType() and\n    not bindEnclosingCatch(te, cb) and\n    (\n      // Catching primitives by value or reference\n      bindStrippedReferenceType(caught, thrown)\n      or\n      // Catching class types by value or reference\n      exists(Class c | c = thrown and bindStrippedReferenceType(caught, c.getABaseClass*()))\n    )\n  )\n}\n\n// Find throw expressions such that there is a path in the control flow graph from the expression to\n// the end of the destructor without an intervening catch block that can catch the type thrown.\nfrom Destructor d, ThrowExpr te\nwhere\n  te.getEnclosingFunction() = d and\n  not exists(CatchBlock cb |\n    te.getASuccessor+() = cb and\n    cb.getASuccessor+() = d\n  |\n    canCatch(te, cb)\n    or\n    // Catch anything -- written as `catch(...)`.\n    not exists(cb.getParameter())\n  )\nselect te, \"Exception thrown in destructor.\"",
        "description": "Throwing an exception from a destructor may cause immediate program termination.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/OO/ThrowInDestructor.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n// find copy assignment operators that deallocate memory but do not check for self assignment\nfrom CopyAssignmentOperator cao\nwhere\n  exists(DestructorCall d | d.getEnclosingFunction() = cao) and\n  not exists(EqualityOperation eq |\n    eq.getEnclosingFunction() = cao and\n    eq.getAChild() instanceof ThisExpr and\n    eq.getAChild().(AddressOfExpr).getAddressable() = cao.getParameter(0)\n  )\nselect cao, \"Copy assignment operator does not check for self assignment.\"",
        "description": "Copy assignment operators should guard against self assignment; otherwise, self assignment is likely to cause memory corruption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/OO/SelfAssignmentCheck.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.ir.IR\nimport semmle.code.cpp.ir.dataflow.MustFlow\nimport PathGraph\n\nclass UnsafeUseOfThisConfig extends MustFlowConfiguration {\n  UnsafeUseOfThisConfig() { this = \"UnsafeUseOfThisConfig\" }\n\n  override predicate isSource(Instruction source) { isSource(source, _, _) }\n\n  override predicate isSink(Operand sink) { isSink(sink, _) }\n}\n\npredicate isSink(Operand sink, CallInstruction call) {\n  exists(PureVirtualFunction func |\n    call.getStaticCallTarget() = func and\n    call.getThisArgumentOperand() = sink and\n    // Weed out implicit calls to destructors of a base class\n    not func instanceof Destructor\n  )\n}\n\npredicate isSource(InitializeParameterInstruction source, string msg, Class c) {\n  (\n    exists(Constructor func |\n      not func instanceof CopyConstructor and\n      not func instanceof MoveConstructor and\n      func = source.getEnclosingFunction() and\n      msg = \"construction\"\n    )\n    or\n    source.getEnclosingFunction() instanceof Destructor and msg = \"destruction\"\n  ) and\n  source.getIRVariable() instanceof IRThisVariable and\n  source.getEnclosingFunction().getDeclaringType() = c\n}\n\npredicate flows(\n  MustFlowPathNode source, string msg, Class sourceClass, MustFlowPathNode sink,\n  CallInstruction call\n) {\n  exists(UnsafeUseOfThisConfig conf |\n    conf.hasFlowPath(source, sink) and\n    isSource(source.getInstruction(), msg, sourceClass) and\n    isSink(sink.getInstruction().getAUse(), call)\n  )\n}\n\nfrom\n  MustFlowPathNode source, MustFlowPathNode sink, CallInstruction call, string msg,\n  Class sourceClass\nwhere\n  flows(source, msg, sourceClass, sink, call) and\n  // Only raise an alert if there is no override of the pure virtual function in any base class.\n  not exists(Class c | c = sourceClass.getABaseClass*() |\n    c.getAMemberFunction().getAnOverriddenFunction() = call.getStaticCallTarget()\n  )\nselect call.getUnconvertedResultExpression(), source, sink,\n  \"Call to pure virtual function during \" + msg + \".\"",
        "description": "A call to a pure virtual function using a 'this' pointer of an object that is under construction may lead to undefined behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/OO/UnsafeUseOfThis.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom Class base, Destructor d1, Class derived, Destructor d2\nwhere\n  derived.getABaseClass+() = base and\n  d1.getDeclaringType() = base and\n  not d1.isVirtual() and\n  d2.getDeclaringType() = derived\nselect d1, \"This destructor should probably be virtual.\"",
        "description": "When a class and its derived class both define non-virtual destructors, the destructor of the derived class may not always be called.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/OO/NonVirtualDestructor.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nfrom FunctionCall call\nwhere\n  call.getTarget() = call.getEnclosingFunction().(Constructor).getDeclaringType().getAConstructor() and\n  call.getParent() instanceof ExprStmt\nselect call,\n  \"The constructor \" + call.getTarget().getName() +\n    \" may leave the instance uninitialized, as it tries to delegate to another constructor.\"",
        "description": "A constructor in C++ cannot delegate part of the object initialization to another by calling it. This is likely to leave part of the object uninitialized.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/OO/IncorrectConstructorDelegation.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\n\nfrom Class c\nwhere\n  exists(VirtualFunction f | f.getDeclaringType() = c) and\n  exists(Destructor d |\n    d.getDeclaringType() = c and\n    // Ignore non-public destructors, which prevent an object of the declaring class from being deleted\n    // directly (except from within the class itself). This is a common pattern in real-world code.\n    d.hasSpecifier(\"public\") and\n    not d.isVirtual() and\n    not d.isDeleted() and\n    not d.isCompilerGenerated()\n  ) and\n  exists(ClassDerivation d | d.getBaseClass() = c)\nselect c, \"A base class with a virtual function should define a virtual destructor.\"",
        "description": "All base classes with a virtual function should define a virtual destructor. If an application attempts to delete a derived class object through a base class pointer, the result is undefined if the base class destructor is non-virtual.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/OO/NonVirtualDestructorInBaseClass.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nclass Structor extends MemberFunction {\n  Structor() {\n    this instanceof Constructor or\n    this instanceof Destructor\n  }\n}\n\nfrom Structor s, FunctionCall c, VirtualFunction vf\nwhere\n  c.getEnclosingFunction() = s and\n  vf = c.getTarget() and\n  exists(VirtualFunction vff |\n    vff.overrides(vf) and\n    vff.getDeclaringType().getABaseClass+() = s.getDeclaringType()\n  )\nselect c, \"Virtual call in constructor or destructor.\"",
        "description": "Calling a virtual function from a constructor or destructor rarely has the intended effect. It is likely to either cause a bug or confuse readers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/OO/VirtualCallInStructor.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.boostorg.asio.protocols\n\npredicate isSourceImpl(DataFlow::Node source, ConstructorCall cc) {\n  exists(BoostorgAsio::SslContextClass c | c.getAConstructorCall() = cc and cc = source.asExpr())\n}\n\npredicate isSinkImpl(DataFlow::Node sink, FunctionCall fcSetOptions) {\n  exists(BoostorgAsio::SslSetOptionsFunction f |\n    f.getACallToThisFunction() = fcSetOptions and\n    fcSetOptions.getQualifier() = sink.asIndirectExpr()\n  )\n}\n\nmodule ExistsAnyFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isSourceImpl(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSinkImpl(sink, _) }\n}\n\nmodule ExistsAnyFlow = DataFlow::Global<ExistsAnyFlowConfig>;\n\nbindingset[flag]\npredicate isOptionSet(ConstructorCall cc, int flag, FunctionCall fcSetOptions) {\n  exists(\n    VariableAccess contextSetOptions, BoostorgAsio::SslSetOptionsFunction f, DataFlow::Node source,\n    DataFlow::Node sink\n  |\n    isSourceImpl(source, cc) and\n    isSinkImpl(sink, fcSetOptions) and\n    ExistsAnyFlow::flow(source, sink) and\n    f.getACallToThisFunction() = fcSetOptions and\n    contextSetOptions = fcSetOptions.getQualifier() and\n    forex(Expr optionArgument |\n      optionArgument = fcSetOptions.getArgument(0) and\n      BoostorgAsio::SslOptionFlow::flowTo(DataFlow::exprNode(optionArgument))\n    |\n      optionArgument.getValue().toInt().bitShiftRight(16).bitAnd(flag) = flag\n    )\n  )\n}\n\nbindingset[flag]\npredicate isOptionNotSet(ConstructorCall cc, int flag) { not isOptionSet(cc, flag, _) }\n\nfrom Expr protocolSource, Expr protocolSink, ConstructorCall cc, Expr e, string msg\nwhere\n  BoostorgAsio::SslContextCallTlsProtocolFlow::flow(DataFlow::exprNode(protocolSource),\n    DataFlow::exprNode(protocolSink)) and\n  cc.getArgument(0) = protocolSink and\n  (\n    BoostorgAsio::isExprSslV23BoostProtocol(protocolSource) and\n    not (\n      isOptionSet(cc, BoostorgAsio::getShiftedSslOptionsNoSsl3(), _) and\n      isOptionSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1(), _) and\n      isOptionSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1_1(), _) and\n      isOptionNotSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1_2())\n    )\n    or\n    BoostorgAsio::isExprTlsBoostProtocol(protocolSource) and\n    not BoostorgAsio::isExprSslV23BoostProtocol(protocolSource) and\n    not (\n      isOptionSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1(), _) and\n      isOptionSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1_1(), _) and\n      isOptionNotSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1_2())\n    )\n  ) and\n  (\n    BoostorgAsio::isExprSslV23BoostProtocol(protocolSource) and\n    isOptionNotSet(cc, BoostorgAsio::getShiftedSslOptionsNoSsl3()) and\n    e = cc and\n    msg = \"no_sslv3 has not been set\"\n    or\n    isOptionNotSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1()) and\n    e = cc and\n    msg = \"no_tlsv1 has not been set\"\n    or\n    isOptionNotSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1_1()) and\n    e = cc and\n    msg = \"no_tlsv1_1 has not been set\"\n    or\n    isOptionSet(cc, BoostorgAsio::getShiftedSslOptionsNoTls1_2(), e) and\n    msg = \"no_tlsv1_2 was set\"\n  )\nselect cc,\n  \"This usage of 'boost::asio::ssl::context::context' with protocol $@ is not configured correctly: The option $@.\",\n  protocolSource, protocolSource.toString(), e, msg",
        "description": "Using the TLS or SSLv23 protocol from the boost::asio library, but not disabling deprecated protocols, or disabling minimum-recommended protocols.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Protocols/TlsSettingsMisconfiguration.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.security.boostorg.asio.protocols\n\nfrom Expr protocolSource, Expr protocolSink, ConstructorCall cc\nwhere\n  BoostorgAsio::SslContextCallFlow::flow(DataFlow::exprNode(protocolSource),\n    DataFlow::exprNode(protocolSink)) and\n  not BoostorgAsio::SslContextCallTlsProtocolFlow::flow(DataFlow::exprNode(protocolSource),\n    DataFlow::exprNode(protocolSink)) and\n  cc.getArgument(0) = protocolSink and\n  BoostorgAsio::SslContextCallBannedProtocolFlow::flow(DataFlow::exprNode(protocolSource),\n    DataFlow::exprNode(protocolSink))\nselect protocolSink, \"Usage of $@ specifying a deprecated hardcoded protocol $@ in function $@.\",\n  cc, \"boost::asio::ssl::context::context\", protocolSource, protocolSource.toString(),\n  cc.getEnclosingFunction(), cc.getEnclosingFunction().toString()",
        "description": "Using a deprecated hard-coded protocol using the boost::asio library.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Likely Bugs/Protocols/UseOfDeprecatedHardcodedProtocol.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\n\nselect sum(File f | f.fromSource() | f.getMetrics().getNumberOfLinesOfCode())",
        "description": "The total number of lines of C/C++ code across all files, including system headers, libraries, and auto-generated files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Summary/LinesOfCode.ql",
        "language": "cpp"
    },
    {
        "query": "import cpp\nimport semmle.code.cpp.AutogeneratedFile\n\nselect sum(File f |\n    f.fromSource() and exists(f.getRelativePath()) and not f instanceof AutogeneratedFile\n  |\n    f.getMetrics().getNumberOfLinesOfCode()\n  )",
        "description": "The total number of lines of C/C++ code from the source code directory, excluding auto-generated files. This query counts the lines of code, excluding whitespace or comments. Note: If external libraries are included in the codebase either in a checked-in virtual environment or as vendored code, that will currently be counted as user written code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/cpp/ql/src/Summary/LinesOfUserCode.ql",
        "language": "cpp"
    },
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import semmle.go.Comments as G\n\nclass SingleLineComment extends G::Comment {\n  SingleLineComment() {\n    // suppression comments must be single-line\n    not this.getText().matches(\"%\\n%\")\n  }\n}\n\nimport AS::Make<G::Locatable, SingleLineComment>",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/AlertSuppression.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom Ident def, Ident use, Entity e\nwhere\n  use.uses(e) and\n  def.declares(e)\nselect use, def, \"V\"",
        "description": "Generates use-definition pairs that provide the data for jump-to-definition in the code viewer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/definitions.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate classify(File f, string category) {\n  // tests\n  f instanceof TestFile and\n  category = \"test\"\n  or\n  // vendored code\n  f.getRelativePath().regexpMatch(\".*/vendor/.*\") and\n  category = \"library\"\n  or\n  // generated code\n  f instanceof GeneratedFile and\n  category = \"generated\"\n}\n\nfrom File f, string category\nwhere classify(f, category)\nselect f, category",
        "description": "This query produces a list of all files in a snapshot that are classified as generated code, test code or vendored-in library code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/filters/ClassifyFiles.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom File f\nselect f, f.getNumberOfLinesOfComments() as n order by n desc",
        "description": "Files with few lines of comment might not have sufficient documentation to make them understandable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Metrics/FLinesOfComment.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom File f, int n\nwhere n = f.getNumberOfLinesOfCode()\nselect f, n order by n desc",
        "description": "Measures the number of lines of code in each file, ignoring lines that contain only comments or whitespace.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Metrics/FLinesOfCode.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport SensitiveConditionBypass\n\nfrom\n  ControlFlow::ConditionGuardNode guard, DataFlow::Node sensitiveSink,\n  SensitiveExpr::Classification classification, DataFlow::Node source, DataFlow::Node operand,\n  ComparisonExpr comp\nwhere\n  // there should be a flow between source and the operand sink\n  Flow::flow(source, operand) and\n  // both the operand should belong to the same comparison expression\n  operand.asExpr() = comp.getAnOperand() and\n  // get the ConditionGuardNode corresponding to the comparison expr.\n  guard.getCondition() = comp and\n  // the sink `sensitiveSink` should be sensitive,\n  isSensitive(sensitiveSink, classification) and\n  // the guard should control the sink\n  guard.dominates(sensitiveSink.getBasicBlock())\nselect comp, \"This sensitive comparision check can potentially be bypassed.\"",
        "description": "This query tests for user-controlled bypassing of sensitive actions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-807/SensitiveConditionBypass.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport RangeAnalysis\n\nfrom Expr expr\nwhere exprMayOverflow(expr) or exprMayUnderflow(expr)\nselect expr, \"This expression may cause an integer overflow.\"",
        "description": "Integer overflow can cause incorrect results or program crashes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/IntegerOverflow/IntegerOverflow.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport WeakCryptoAlgorithmCustomizations\nimport WeakCryptoAlgorithm::Flow::PathGraph\n\nfrom WeakCryptoAlgorithm::Flow::PathNode source, WeakCryptoAlgorithm::Flow::PathNode sink\nwhere WeakCryptoAlgorithm::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"$@ is used in a weak cryptographic algorithm.\",\n  source.getNode(), \"Sensitive data\"",
        "description": "Using weak cryptographic algorithms can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-327/WeakCryptoAlgorithm.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport SSRF\nimport ServerSideRequestForgery::Flow::PathGraph\n\nfrom\n  ServerSideRequestForgery::Flow::PathNode source, ServerSideRequestForgery::Flow::PathNode sink,\n  DataFlow::Node request\nwhere\n  ServerSideRequestForgery::Flow::flowPath(source, sink) and\n  request = sink.getNode().(ServerSideRequestForgery::Sink).getARequest()\nselect request, source, sink, \"The URL of this request depends on a user-provided value.\"",
        "description": "Sending network requests with user-controlled data allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-918/SSRF.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.InsecureFeatureFlag::InsecureFeatureFlag\n\nclass AllowedFlag extends FlagKind {\n  AllowedFlag() { this = \"allowed\" }\n\n  bindingset[result]\n  override string getAFlagName() {\n    result.regexpMatch(\"(?i).*(allow|match|check|debug|devel|insecure).*\")\n  }\n}\n\nstring headerAllowOrigin() { result = \"Access-Control-Allow-Origin\".toLowerCase() }\n\nstring headerAllowCredentials() { result = \"Access-Control-Allow-Credentials\".toLowerCase() }\n\nclass AllowOriginHeaderWrite extends Http::HeaderWrite {\n  AllowOriginHeaderWrite() { this.getHeaderName() = headerAllowOrigin() }\n}\n\nclass AllowCredentialsHeaderWrite extends Http::HeaderWrite {\n  AllowCredentialsHeaderWrite() { this.getHeaderName() = headerAllowCredentials() }\n}\n\nmodule UntrustedToAllowOriginHeaderConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  additional predicate isSinkHW(DataFlow::Node sink, AllowOriginHeaderWrite hw) {\n    sink = hw.getValue()\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    exists(ControlFlow::ConditionGuardNode cgn |\n      cgn.ensures(any(AllowedFlag f).getAFlag().getANode(), _)\n    |\n      cgn.dominates(node.getBasicBlock())\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSinkHW(sink, _) }\n}\n\nmodule UntrustedToAllowOriginConfigConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  additional predicate isSinkWrite(DataFlow::Node sink, UniversalOriginWrite w) { sink = w }\n\n  predicate isSink(DataFlow::Node sink) { isSinkWrite(sink, _) }\n}\n\nmodule UntrustedToAllowOriginHeaderFlow = TaintTracking::Global<UntrustedToAllowOriginHeaderConfig>;\n\nmodule UntrustedToAllowOriginConfigFlow = TaintTracking::Global<UntrustedToAllowOriginConfigConfig>;\n\npredicate allowCredentialsIsSetToTrue(DataFlow::ExprNode allowOriginHW) {\n  exists(AllowCredentialsHeaderWrite allowCredentialsHW |\n    allowCredentialsHW.getHeaderValue().toLowerCase() = \"true\"\n  |\n    allowOriginHW.(AllowOriginHeaderWrite).getResponseWriter() =\n      allowCredentialsHW.getResponseWriter()\n  )\n  or\n  exists(UniversalAllowCredentialsWrite allowCredentialsGin |\n    allowCredentialsGin.getExpr().getBoolValue() = true\n  |\n    allowCredentialsGin.getConfig() = allowOriginHW.(UniversalOriginWrite).getConfig() and\n    not exists(UniversalAllowAllOriginsWrite allowAllOrigins |\n      allowAllOrigins.getExpr().getBoolValue() = true and\n      allowCredentialsGin.getConfig() = allowAllOrigins.getConfig()\n    )\n    or\n    allowCredentialsGin.getBase() = allowOriginHW.(UniversalOriginWrite).getBase() and\n    not exists(UniversalAllowAllOriginsWrite allowAllOrigins |\n      allowAllOrigins.getExpr().getBoolValue() = true and\n      allowCredentialsGin.getBase() = allowAllOrigins.getBase()\n    )\n  )\n}\n\npredicate flowsFromUntrustedToAllowOrigin(DataFlow::ExprNode allowOriginHW, string message) {\n  exists(DataFlow::Node sink |\n    UntrustedToAllowOriginHeaderFlow::flowTo(sink) and\n    UntrustedToAllowOriginHeaderConfig::isSinkHW(sink, allowOriginHW)\n    or\n    UntrustedToAllowOriginConfigFlow::flowTo(sink) and\n    UntrustedToAllowOriginConfigConfig::isSinkWrite(sink, allowOriginHW)\n  |\n    message =\n      headerAllowOrigin() + \" header is set to a user-defined value, and \" +\n        headerAllowCredentials() + \" is set to `true`\"\n  )\n}\n\npredicate allowOriginIsNull(DataFlow::ExprNode allowOriginHW, string message) {\n  allowOriginHW.(AllowOriginHeaderWrite).getHeaderValue().toLowerCase() = \"null\" and\n  message =\n    headerAllowOrigin() + \" header is set to `\" +\n      allowOriginHW.(AllowOriginHeaderWrite).getHeaderValue() + \"`, and \" + headerAllowCredentials()\n      + \" is set to `true`\"\n  or\n  allowOriginHW\n      .(UniversalOriginWrite)\n      .asExpr()\n      .(SliceLit)\n      .getAnElement()\n      .getStringValue()\n      .toLowerCase() = \"null\" and\n  message =\n    headerAllowOrigin() + \" header is set to `\" + \"null\" + \"`, and \" + headerAllowCredentials() +\n      \" is set to `true`\"\n}\n\nclass MapRead extends DataFlow::ElementReadNode {\n  MapRead() { this.getBase().getType() instanceof MapType }\n}\n\nmodule FromUntrustedConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { isSinkCgn(sink, _) }\n\n  additional predicate isSinkCgn(DataFlow::Node sink, ControlFlow::ConditionGuardNode cgn) {\n    exists(IfStmt ifs |\n      exists(Expr operand |\n        operand = ifs.getCond().getAChildExpr*() and\n        (\n          exists(DataFlow::CallExpr call | call = operand |\n            call.getTarget().hasQualifiedName(\"strings\", \"HasSuffix\") and\n            sink.asExpr() = call.getArgument(0)\n          )\n          or\n          exists(MapRead mapRead |\n            operand = mapRead.asExpr() and\n            sink = mapRead.getIndex().getAPredecessor*()\n            // TODO: add _, ok : map[untrusted]; ok\n          )\n          or\n          exists(EqlExpr comp |\n            operand = comp and\n            (\n              sink.asExpr() = comp.getLeftOperand() and\n              not comp.getRightOperand().(StringLit).getStringValue() = \"\"\n              or\n              sink.asExpr() = comp.getRightOperand() and\n              not comp.getLeftOperand().(StringLit).getStringValue() = \"\"\n            )\n          )\n        )\n      )\n    |\n      cgn.getCondition() = ifs.getCond()\n    )\n  }\n}\n\nmodule FromUntrustedFlow = TaintTracking::Global<FromUntrustedConfig>;\n\npredicate flowsToGuardedByCheckOnUntrusted(DataFlow::ExprNode allowOriginHW) {\n  exists(DataFlow::Node sink, ControlFlow::ConditionGuardNode cgn |\n    FromUntrustedFlow::flowTo(sink) and FromUntrustedConfig::isSinkCgn(sink, cgn)\n  |\n    cgn.dominates(allowOriginHW.getBasicBlock())\n  )\n}\n\nfrom DataFlow::ExprNode allowOriginHW, string message\nwhere\n  allowCredentialsIsSetToTrue(allowOriginHW) and\n  (\n    flowsFromUntrustedToAllowOrigin(allowOriginHW, message)\n    or\n    allowOriginIsNull(allowOriginHW, message)\n  ) and\n  not flowsToGuardedByCheckOnUntrusted(allowOriginHW) and\n  not exists(ControlFlow::ConditionGuardNode cgn |\n    cgn.ensures(any(AllowedFlag f).getAFlag().getANode(), _)\n  |\n    cgn.dominates(allowOriginHW.getBasicBlock())\n  )\nselect allowOriginHW, message",
        "description": "If a CORS policy is configured to accept an origin value obtained from the request data, or is set to `null`, and it allows credential sharing, then the users of the application are vulnerable to the same range of attacks as in XSS (credential stealing, etc.).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-942/CorsMisconfiguration.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport WebCacheDeceptionLib\n\nfrom WebCacheDeception::Sink httpHandleFuncCall\nselect httpHandleFuncCall, httpHandleFuncCall + \" is used as wildcard endpoint.\"",
        "description": "A caching system has been detected on the application and is vulnerable to web cache deception. By manipulating the URL it is possible to force the application to cache pages that are only accessible by an authenticated user. Once cached, these pages can be accessed by an unauthenticated user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-525/WebCacheDeception.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.dataflow.internal.TaintTrackingUtil\n\npredicate divideByZeroSanitizerGuard(DataFlow::Node g, Expr e, boolean branch) {\n  exists(DataFlow::Node zero, DataFlow::Node checked |\n    zero.getNumericValue() = 0 and\n    e = checked.asExpr() and\n    checked.getType().getUnderlyingType() instanceof IntegerType and\n    (\n      g.(DataFlow::EqualityTestNode).eq(branch.booleanNot(), checked, zero) or\n      g.(DataFlow::RelationalComparisonNode).leq(branch.booleanNot(), checked, zero, 0)\n    )\n  )\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(Function f, DataFlow::CallNode cn | cn = f.getACall() |\n      f.hasQualifiedName(\"strconv\", [\"Atoi\", \"ParseInt\", \"ParseUint\", \"ParseFloat\"]) and\n      node1 = cn.getArgument(0) and\n      node2 = cn.getResult(0)\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node = DataFlow::BarrierGuard<divideByZeroSanitizerGuard/3>::getABarrierNode()\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink = DataFlow::exprNode(any(QuoExpr e).getRightOperand())\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node sink) { none() }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink\nwhere Flow::flowPath(source, sink)\nselect sink, source, sink, \"This variable might be zero leading to a division-by-zero panic.\"",
        "description": "Dividing an integer by a user-controlled value may lead to division by zero and an unexpected panic.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-369/DivideByZero.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate isInTestFile(Expr r) {\n  r.getFile().getAbsolutePath().matches(\"%test%\") and\n  not r.getFile().getAbsolutePath().matches(\"%/ql/test/%\")\n}\n\nclass PamAuthenticate extends Method {\n  PamAuthenticate() {\n    this.hasQualifiedName(\"github.com/msteinert/pam\", \"Transaction\", \"Authenticate\")\n  }\n}\n\nclass PamAcctMgmt extends Method {\n  PamAcctMgmt() { this.hasQualifiedName(\"github.com/msteinert/pam\", \"Transaction\", \"AcctMgmt\") }\n}\n\nclass PamStartFunc extends Function {\n  PamStartFunc() { this.hasQualifiedName(\"github.com/msteinert/pam\", [\"StartFunc\", \"Start\"]) }\n}\n\n// PAM auth bypass (Start to AcctMgmt)\nmodule PamStartToAcctMgmtConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(PamStartFunc p | p.getACall().getResult(0) = source)\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(PamAcctMgmt p | p.getACall().getReceiver() = sink)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) { none() }\n}\n\nmodule PamStartToAcctMgmtFlow = TaintTracking::Global<PamStartToAcctMgmtConfig>;\n\n// PAM auth bypass (Start to Authenticate)\nmodule PamStartToAuthenticateConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(PamStartFunc p | p.getACall().getResult(0) = source)\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(PamAuthenticate p | p.getACall().getReceiver() = sink)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) { none() }\n}\n\nmodule PamStartToAuthenticateFlow = TaintTracking::Global<PamStartToAuthenticateConfig>;\n\nfrom DataFlow::Node source, DataFlow::Node sink\nwhere\n  not isInTestFile(source.asExpr()) and\n  (PamStartToAuthenticateFlow::flow(source, sink) and not PamStartToAcctMgmtFlow::flow(source, _))\nselect source, \"This Pam transaction may not be secure.\"",
        "description": "Not using `pam.AcctMgmt` after `pam.Authenticate` to check the validity of a login can lead to authorization bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-285/PamAuthBypass.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof ActiveThreatModelSource\n    or\n    source = any(Field f | f.hasQualifiedName(\"net/http\", \"Request\", \"Host\")).getARead()\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(ComparisonExpr c | c.getAnOperand() = sink.asExpr())\n  }\n\n  predicate observeDiffInformedIncrementalMode() {\n    none() // can't override the locations accurately because of secondary use of config.\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nfrom\n  DataFlow::Node lhsSource, DataFlow::Node lhs, DataFlow::Node rhsSource, DataFlow::Node rhs,\n  ComparisonExpr c\nwhere\n  Flow::flow(rhsSource, rhs) and\n  rhs.asExpr() = c.getRightOperand() and\n  Flow::flow(lhsSource, lhs) and\n  lhs.asExpr() = c.getLeftOperand()\nselect c, \"This comparison of a $@ with another $@ can be bypassed by a malicious user.\", lhsSource,\n  \"user-controlled value\", rhsSource, \"user-controlled value\"",
        "description": "A check that compares two user-controlled inputs with each other can be bypassed by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-840/ConditionalBypass.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport experimental.frameworks.DecompressionBombs\nimport DecompressionBomb::Flow::PathGraph\n\nfrom DecompressionBomb::Flow::PathNode source, DecompressionBomb::Flow::PathNode sink\nwhere DecompressionBomb::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This decompression is $@.\", source.getNode(),\n  \"decompressing compressed data without managing output size\"",
        "description": "Uncontrolled data that flows into decompression library APIs without checking the compression rate is dangerous",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-522-DecompressionBombs/DecompressionBombs.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nclass DatabaseAccess extends DataFlow::MethodCallNode {\n  DatabaseAccess() {\n    exists(string name |\n      this.getTarget().hasQualifiedName(Gorm::packagePath(), \"DB\", name) and\n      // all terminating Gorm methods\n      name =\n        [\n          \"Find\", \"Take\", \"Last\", \"Scan\", \"Row\", \"Rows\", \"ScanRows\", \"Pluck\", \"Count\", \"First\",\n          \"FirstOrInit\", \"FindOrCreate\", \"Update\", \"Updates\", \"UpdateColumn\", \"UpdateColumns\",\n          \"Save\", \"Create\", \"Delete\", \"Exec\"\n        ]\n    )\n  }\n}\n\nclass CallGraphNode extends Locatable {\n  CallGraphNode() {\n    this instanceof LoopStmt\n    or\n    this instanceof CallExpr\n    or\n    this instanceof FuncDef\n  }\n}\n\npredicate callGraphEdge(CallGraphNode pred, CallGraphNode succ) {\n  // Go from a loop to an enclosed expression.\n  pred.(LoopStmt).getBody().getAChild*() = succ.(CallExpr)\n  or\n  // Go from a call to the called function.\n  pred.(CallExpr) = succ.(FuncDef).getACall().asExpr()\n  or\n  // Go from a function to an enclosed loop.\n  pred = succ.(LoopStmt).getEnclosingFunction()\n  or\n  // Go from a function to an enclosed call.\n  pred = succ.(CallExpr).getEnclosingFunction()\n}\n\nquery predicate edges(CallGraphNode pred, CallGraphNode succ) {\n  callGraphEdge(pred, succ) and\n  // Limit the range of edges to only those that are relevant.\n  // This helps to speed up the query by reducing the size of the outputted path information.\n  exists(LoopStmt loop, DatabaseAccess dbAccess |\n    // is between a loop and a db access\n    callGraphEdge*(loop, pred) and\n    callGraphEdge*(succ, dbAccess.asExpr())\n  )\n}\n\nfrom LoopStmt loop, DatabaseAccess dbAccess\nwhere edges*(loop, dbAccess.asExpr())\nselect dbAccess, loop, dbAccess.asExpr(), \"This calls \" + dbAccess.toString() + \" in a $@.\", loop,\n  \"loop\"",
        "description": "Detects database operations within loops. Doing operations in series can be slow and lead to N+1 situations.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-400/DatabaseCallInLoop.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport LDAPInjection\nimport LdapInjectionFlow::PathGraph\n\nfrom LdapInjectionFlow::PathNode source, LdapInjectionFlow::PathNode sink\nwhere LdapInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"LDAP query parameter depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-090/LDAPInjection.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.SensitiveActions\n\nprivate predicate isBadResult(DataFlow::Node e) {\n  exists(string path | path = e.asExpr().getFile().getAbsolutePath().toLowerCase() |\n    path.matches([\"%fake%\", \"%dummy%\", \"%test%\", \"%example%\"]) and not path.matches(\"%ql/test%\")\n  )\n}\n\nabstract class Sink extends DataFlow::Node { }\n\nprivate class SensitiveStringCompareSink extends Sink {\n  SensitiveStringCompareSink() {\n    // We select a comparison where a secret or password is tested.\n    exists(DataFlow::CallNode c, Expr op1, Expr nonSensitiveOperand |\n      c.getTarget().hasQualifiedName(\"strings\", \"Compare\") and\n      c.getArgument(_).asExpr() = op1 and\n      op1.(SensitiveVariableAccess).getClassification() =\n        [SensitiveExpr::secret(), SensitiveExpr::password()] and\n      c.getArgument(_).asExpr() = nonSensitiveOperand and\n      not op1 = nonSensitiveOperand and\n      not (\n        // Comparisons with `nil` should be excluded.\n        nonSensitiveOperand = Builtin::nil().getAReference()\n        or\n        // Comparisons with empty string should also be excluded.\n        nonSensitiveOperand.getStringValue().length() = 0\n      )\n    |\n      // It is important to note that the name of both the operands need not be\n      // `sensitive`. Even if one of the operands appears to be sensitive, we consider it a potential sink.\n      nonSensitiveOperand = this.asExpr()\n    )\n  }\n}\n\nprivate class SensitiveCompareSink extends Sink {\n  SensitiveCompareSink() {\n    // We select a comparison where a secret or password is tested.\n    exists(SensitiveExpr op1, Expr op2, EqualityTestExpr c |\n      op1.getClassification() = [SensitiveExpr::secret(), SensitiveExpr::password()] and\n      op1 = c.getAnOperand() and\n      op2 = c.getAnOperand() and\n      not op1 = op2 and\n      not (\n        // Comparisons with `nil` should be excluded.\n        op2 = Builtin::nil().getAReference()\n        or\n        // Comparisons with empty string should also be excluded.\n        op2.getStringValue().length() = 0\n      )\n    |\n      op2 = this.asExpr()\n    )\n  }\n}\n\nprivate class SensitiveStringSink extends Sink {\n  SensitiveStringSink() {\n    // We select a comparison where a secret or password is tested.\n    exists(StringLit op1, Expr op2, EqualityTestExpr c |\n      op1.getStringValue()\n          .regexpMatch(HeuristicNames::maybeSensitive([\n                SensitiveExpr::secret(), SensitiveExpr::password()\n              ])) and\n      op1 = c.getAnOperand() and\n      op2 = c.getAnOperand() and\n      not op1 = op2 and\n      not (\n        // Comparisons with `nil` should be excluded.\n        op2 = Builtin::nil().getAReference()\n        or\n        // Comparisons with empty string should also be excluded.\n        op2.getStringValue().length() = 0\n      )\n    |\n      op2 = this.asExpr()\n    )\n  }\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof ActiveThreatModelSource and not isBadResult(source)\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof Sink and not isBadResult(sink) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink\nwhere Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"$@ may be vulnerable to timing attacks.\", source.getNode(),\n  \"Hardcoded String\"",
        "description": "using a non-constant time comparison method to compare secrets can lead to authoriztion vulnerabilities",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-203/Timing.ql",
        "language": "go"
    },
    {
        "query": "import go\n\n\nType getFinalType(Type typ) { result = getBaseType*(typ.getUnderlyingType()).getUnderlyingType() }\n\n\nType getBaseType(Type typ) {\n  result = getBaseType*(typ.(PointerType).getBaseType*())\n  or\n  result = typ\n}\n\nclass ConversionToUnsafePointer extends DataFlow::TypeCastNode {\n  ConversionToUnsafePointer() { getFinalType(this.getResultType()) instanceof UnsafePointerType }\n}\n\nmodule UnsafeTypeCastingConfig implements DataFlow::ConfigSig {\n  additional predicate conversionIsSource(DataFlow::Node source, ConversionToUnsafePointer conv) {\n    source = conv\n  }\n\n  additional predicate typeCastNodeIsSink(DataFlow::Node sink, DataFlow::TypeCastNode ca) {\n    ca.getOperand().getType() instanceof UnsafePointerType and\n    sink = ca\n  }\n\n  predicate isSource(DataFlow::Node source) { conversionIsSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { typeCastNodeIsSink(sink, _) }\n}\n\nmodule UnsafeTypeCastingFlow = TaintTracking::Global<UnsafeTypeCastingConfig>;\n\nimport UnsafeTypeCastingFlow::PathGraph\n\n\npredicate castShortArrayToLongerArray(\n  UnsafeTypeCastingFlow::PathNode source, UnsafeTypeCastingFlow::PathNode sink, string message\n) {\n  exists(\n    DataFlow::TypeCastNode castBig, ConversionToUnsafePointer castLittle, ArrayType arrTo,\n    ArrayType arrFrom, int arrFromSize\n  |\n    UnsafeTypeCastingFlow::flowPath(source, sink) and\n    UnsafeTypeCastingConfig::conversionIsSource(source.getNode(), castLittle) and\n    UnsafeTypeCastingConfig::typeCastNodeIsSink(sink.getNode(), castBig) and\n    arrTo = getFinalType(castBig.getResultType()) and\n    (\n      // Array (whole) to array:\n      // The `unsafe.Pointer` expression is on the array\n      // (e.g. unsafe.Pointer(&someArray)),\n      // meaning that the pointer points to the start of the array:\n      arrFrom = getFinalType(castLittle.getOperand().getType()) and\n      arrFromSize = arrFrom.getLength() and\n      message = \"Dangerous array type casting to \" + arrTo.pp() + \" from \" + arrFrom.pp()\n      or\n      // Piece of array (starting from an index), to array:\n      // The `unsafe.Pointer` expression can also point to a specific\n      // element of an array\n      // (e.g. unsafe.Pointer(&someArray[2])),\n      // which will be the starting point in memory for the newly cast\n      // variable.\n      exists(DataFlow::ElementReadNode indexExpr |\n        indexExpr = castLittle.getOperand().(DataFlow::AddressOperationNode).getOperand() and\n        // The `arrFrom` is the base of the index expression:\n        arrFrom = indexExpr.getBase().getType() and\n        // Calculate the size of the `arrFrom`:\n        arrFromSize = arrFrom.getLength() - indexExpr.getIndex().getIntValue() and\n        message =\n          \"Dangerous array type casting to \" + arrTo.pp() + \" from an index expression (\" +\n            arrFrom.pp() + \")[\" + indexExpr.getIndex().getIntValue() + \"]\" +\n            \" (the destination type is \" + (arrTo.getLength() - arrFromSize) + \" elements longer)\"\n      )\n    ) and\n    arrTo.getLength() > arrFromSize\n  )\n}\n\n\npredicate castTypeToArray(\n  UnsafeTypeCastingFlow::PathNode source, UnsafeTypeCastingFlow::PathNode sink, string message\n) {\n  exists(\n    DataFlow::TypeCastNode castBig, ConversionToUnsafePointer castLittle, ArrayType arrTo,\n    Type typeFrom\n  |\n    UnsafeTypeCastingFlow::flowPath(source, sink) and\n    UnsafeTypeCastingConfig::conversionIsSource(source.getNode(), castLittle) and\n    UnsafeTypeCastingConfig::typeCastNodeIsSink(sink.getNode(), castBig) and\n    arrTo = getFinalType(castBig.getResultType()) and\n    not typeFrom.getUnderlyingType() instanceof ArrayType and\n    not typeFrom instanceof PointerType and\n    not castLittle\n        .getOperand()\n        .(DataFlow::AddressOperationNode)\n        .getOperand()\n        .(DataFlow::ElementReadNode)\n        .getBase()\n        .getType() instanceof ArrayType and\n    typeFrom = getFinalType(castLittle.getOperand().getType()) and\n    message = \"Dangerous type up-casting to \" + arrTo.pp() + \" from \" + typeFrom\n  )\n}\n\n\npredicate castDifferentBitSizeNumbers(\n  UnsafeTypeCastingFlow::PathNode source, UnsafeTypeCastingFlow::PathNode sink, string message\n) {\n  exists(\n    DataFlow::TypeCastNode castBig, ConversionToUnsafePointer castLittle, NumericType numTo,\n    NumericType numFrom\n  |\n    UnsafeTypeCastingFlow::flowPath(source, sink) and\n    UnsafeTypeCastingConfig::conversionIsSource(source.getNode(), castLittle) and\n    UnsafeTypeCastingConfig::typeCastNodeIsSink(sink.getNode(), castBig) and\n    numTo = getFinalType(castBig.getResultType()) and\n    numFrom = getFinalType(castLittle.getOperand().getType()) and\n    // TODO: also consider cast from uint to int?\n    getNumericTypeSize(numTo) != getNumericTypeSize(numFrom) and\n    // Exclude casts to UintptrType (which is still a pointer):\n    not numTo instanceof UintptrType and\n    message = \"Dangerous numeric type casting to \" + numTo.getName() + \" from \" + numFrom.getName()\n  )\n}\n\n\nint getNumericTypeSize(NumericType typ) {\n  // If the numeric types have arch-specific\n  // bit sizes, then set the size to 0 to distinguish\n  // it from others.\n  not exists(typ.getSize()) and\n  result = 0\n  or\n  result = typ.getSize()\n}\n\nfrom UnsafeTypeCastingFlow::PathNode source, UnsafeTypeCastingFlow::PathNode sink, string message\nwhere\n  castShortArrayToLongerArray(source, sink, message) or\n  castTypeToArray(source, sink, message) or\n  castDifferentBitSizeNumbers(source, sink, message)\nselect sink.getNode(), source, sink, \"$@.\", source.getNode(), message",
        "description": "Casting between types with different memory sizes can produce reads to memory locations that are after the target buffer, and/or unexpected values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/Unsafe/WrongUsageOfUnsafe.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport experimental.frameworks.JWT\n\nmodule JwtParseWithConstantKeyConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.asExpr() instanceof StringLit }\n\n  predicate isSink(DataFlow::Node sink) {\n    // first part is the JWT Parsing Functions that get a func type as an argument\n    // Find a node that has flow to a key Function argument\n    // then find the first result node of this Function which is the secret key\n    exists(FuncDef fd, DataFlow::Node n, DataFlow::ResultNode rn |\n      fd = n.asExpr()\n      or\n      n = fd.(FuncDecl).getFunction().getARead()\n    |\n      GolangJwtKeyFunc::flow(n, _) and\n      sink = rn and\n      rn.getRoot() = fd and\n      rn.getIndex() = 0\n    )\n    or\n    // second part is the JWT Parsing Functions that get a string or byte as an argument\n    sink = any(JwtParse jp).getKeyArg()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule GolangJwtKeyFuncConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source = any(Function f).getARead()\n    or\n    source.asExpr() = any(FuncDef fd)\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink = any(JwtParseWithKeyFunction parseJwt).getKeyFuncArg()\n  }\n}\n\nmodule JwtParseWithConstantKey = TaintTracking::Global<JwtParseWithConstantKeyConfig>;\n\nmodule GolangJwtKeyFunc = TaintTracking::Global<GolangJwtKeyFuncConfig>;\n\nimport JwtParseWithConstantKey::PathGraph\n\nfrom JwtParseWithConstantKey::PathNode source, JwtParseWithConstantKey::PathNode sink\nwhere JwtParseWithConstantKey::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This  $@.\", source.getNode(),\n  \"Constant Key is used as JWT Secret key\"",
        "description": "Decoding JWT Secret with a Constant value lead to authentication or authorization bypass",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-321-V2/HardCodedKeys.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport DsnInjectionCustomizations\nimport DsnInjectionFlow::PathGraph\n\nprivate class OsArgsSource extends Source {\n  OsArgsSource() { this = any(Variable c | c.hasQualifiedName(\"os\", \"Args\")).getARead() }\n}\n\nfrom DsnInjectionFlow::PathNode source, DsnInjectionFlow::PathNode sink\nwhere DsnInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This query depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an SQL data-source URI from untrusted sources can allow attacker to compromise security",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-74/DsnInjectionLocal.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport DsnInjectionCustomizations\nimport DsnInjectionFlow::PathGraph\n\nprivate class ThreatModelFlowAsSource extends Source instanceof ActiveThreatModelSource { }\n\nfrom DsnInjectionFlow::PathNode source, DsnInjectionFlow::PathNode sink\nwhere DsnInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Data-Source Name is built using $@.\", source.getNode(),\n  \"untrusted user input\"",
        "description": "Building an SQL data-source URI from untrusted sources can allow attacker to compromise security",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-74/DsnInjection.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport AuthCookie\n\nmodule NetHttpCookieTrackingFlow =\n  DataFlow::MergePathGraph<NameToNetHttpCookieTrackingFlow::PathNode,\n    BoolToNetHttpCookieTrackingFlow::PathNode, NameToNetHttpCookieTrackingFlow::PathGraph,\n    BoolToNetHttpCookieTrackingFlow::PathGraph>;\n\nmodule GorillaTrackingFlow =\n  DataFlow::MergePathGraph3<GorillaCookieStoreSaveTrackingFlow::PathNode,\n    GorillaSessionOptionsTrackingFlow::PathNode, BoolToGorillaSessionOptionsTrackingFlow::PathNode,\n    GorillaCookieStoreSaveTrackingFlow::PathGraph, GorillaSessionOptionsTrackingFlow::PathGraph,\n    BoolToGorillaSessionOptionsTrackingFlow::PathGraph>;\n\nmodule MergedFlow =\n  DataFlow::MergePathGraph3<NetHttpCookieTrackingFlow::PathNode,\n    BoolToGinSetCookieTrackingFlow::PathNode, GorillaTrackingFlow::PathNode,\n    NetHttpCookieTrackingFlow::PathGraph, BoolToGinSetCookieTrackingFlow::PathGraph,\n    GorillaTrackingFlow::PathGraph>;\n\nimport MergedFlow::PathGraph\n\npredicate isNetHttpCookieFlow(\n  NetHttpCookieTrackingFlow::PathNode source, NetHttpCookieTrackingFlow::PathNode sink\n) {\n  exists(\n    NameToNetHttpCookieTrackingFlow::PathNode sensitiveName,\n    NameToNetHttpCookieTrackingFlow::PathNode setCookieSink\n  |\n    NameToNetHttpCookieTrackingFlow::flowPath(sensitiveName, setCookieSink) and\n    (\n      not BoolToNetHttpCookieTrackingFlow::flowTo(sink.getNode()) and\n      source.asPathNode1() = sensitiveName and\n      sink.asPathNode1() = setCookieSink\n      or\n      BoolToNetHttpCookieTrackingFlow::flowPath(source.asPathNode2(), sink.asPathNode2()) and\n      source.getNode().getBoolValue() = false and\n      setCookieSink.getNode() = sink.getNode()\n    )\n  )\n}\n\npredicate isGorillaSessionsCookieFlow(\n  GorillaTrackingFlow::PathNode source, GorillaTrackingFlow::PathNode sink\n) {\n  exists(\n    GorillaCookieStoreSaveTrackingFlow::PathNode cookieStoreCreate,\n    GorillaCookieStoreSaveTrackingFlow::PathNode sessionSave\n  |\n    GorillaCookieStoreSaveTrackingFlow::flowPath(cookieStoreCreate, sessionSave) and\n    (\n      not GorillaSessionOptionsTrackingFlow::flowTo(sink.getNode()) and\n      source.asPathNode1() = cookieStoreCreate and\n      sink.asPathNode1() = sessionSave\n      or\n      exists(GorillaTrackingFlow::PathNode options, GorillaTrackingFlow::PathNode sessionSave2 |\n        GorillaSessionOptionsTrackingFlow::flowPath(options.asPathNode2(),\n          sessionSave2.asPathNode2()) and\n        (\n          not BoolToGorillaSessionOptionsTrackingFlow::flowTo(sink.getNode()) and\n          sink = sessionSave2 and\n          source = options and\n          sessionSave.getNode() = sessionSave2.getNode()\n          or\n          BoolToGorillaSessionOptionsTrackingFlow::flowPath(source.asPathNode3(), sink.asPathNode3()) and\n          source.getNode().getBoolValue() = false and\n          sink.getNode() = sessionSave.getNode()\n        )\n      )\n    )\n  )\n}\n\nfrom MergedFlow::PathNode source, MergedFlow::PathNode sink\nwhere\n  isNetHttpCookieFlow(source.asPathNode1(), sink.asPathNode1()) or\n  BoolToGinSetCookieTrackingFlow::flowPath(source.asPathNode2(), sink.asPathNode2()) or\n  isGorillaSessionsCookieFlow(source.asPathNode3(), sink.asPathNode3())\nselect sink.getNode(), source, sink, \"Cookie attribute 'HttpOnly' is not set to true.\"",
        "description": "Omitting the 'HttpOnly' attribute for security sensitive data allows malicious JavaScript to steal it in case of XSS vulnerability. Always set 'HttpOnly' to 'true' to authentication related cookie to make it not accessible by JavaScript.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-1004/CookieWithoutHttpOnly.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom DataFlow::MethodCallNode call\nwhere\n  exists(string name | call.getTarget().hasQualifiedName(Gorm::packagePath(), \"DB\", name) |\n    name != \"InstantSet\" and\n    name != \"LogMode\"\n  ) and\n  // the value from the call does not:\n  not exists(DataFlow::Node succ | TaintTracking::localTaintStep*(call, succ) |\n    // get assigned to any variables\n    succ = any(Write w).getRhs()\n    or\n    // get returned\n    succ instanceof DataFlow::ResultNode\n    or\n    // have any methods chained on it\n    exists(DataFlow::MethodCallNode m | succ = m.getReceiver())\n    or\n    // have its `Error` field read\n    exists(DataFlow::FieldReadNode fr | fr.readsField(succ, _, _, \"Error\"))\n  )\nselect call,\n  \"This call appears to interact with the database without checking whether an error was encountered.\"",
        "description": "A call that interacts with the database using the GORM library without checking whether there was an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/InconsistentCode/GORMErrorNotChecked.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom LoopStmt loop, DeferStmt defer\nwhere loop.getBody().getAChildStmt+() = defer\nselect defer, \"This defer statement is in a $@.\", loop, \"loop\"",
        "description": "A deferred statement in a loop will not execute until the end of the function. This can lead to unintentionally holding resources open like file handles or database transactions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/InconsistentCode/DeferInLoop.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport ImproperLdapAuthCustomizations\nimport ImproperLdapAuth::Flow::PathGraph\n\nfrom ImproperLdapAuth::Flow::PathNode source, ImproperLdapAuth::Flow::PathNode sink\nwhere ImproperLdapAuth::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"LDAP binding password depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "A user-controlled query carries no authentication",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/experimental/CWE-287/ImproperLdapAuth.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom ShiftExpr sh, IntegerType ltp, int maxsz, int amt, string atmost\nwhere\n  ltp = sh.getLeftOperand().getType() and\n  (if exists(ltp.getSize()) then atmost = \"\" else atmost = \"(at most) \") and\n  maxsz = max(ltp.getASize()) and\n  amt = sh.getRightOperand().getIntValue() and\n  not ltp.getASize() > amt\nselect sh,\n  \"Shifting a value of \" + atmost + maxsz + \" bits by \" + amt + \" always yields either 0 or -1.\"",
        "description": "Shifting by more than the number of bits in the type of the left-hand side always yields 0 or -1.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/ShiftOutOfRange.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nControlFlow::Node nonGuardPredecessor(ControlFlow::Node nd) {\n  exists(ControlFlow::Node pred | pred = nd.getAPredecessor() |\n    if pred instanceof ControlFlow::ConditionGuardNode\n    then result = nonGuardPredecessor(pred)\n    else result = pred\n  )\n}\n\npredicate isAllowedReturnValue(Expr retval) {\n  retval = Builtin::nil().getAReference()\n  or\n  retval = Builtin::true_().getAReference()\n  or\n  retval = Builtin::false_().getAReference()\n  or\n  retval instanceof BasicLit\n  or\n  // Allow -1 (which parses as unary-minus-of-literal) or !true, but not &somestruct,\n  // for which we would usually prefer `return nil`\n  isAllowedReturnValue(retval.(UnaryExpr).getOperand()) and\n  not retval.getType().getUnderlyingType() instanceof PointerType\n  or\n  // Allow structs composed of allowed values\n  retval instanceof StructLit and\n  forall(Expr element | element = retval.(StructLit).getAnElement() | isAllowedReturnValue(element))\n  or\n  // Allow anything of type `error`, as `abort(); return constructError(...);`\n  // is preferable to insisting on a misleading `return nil` that suggests\n  // successful return:\n  retval.getType().getEntity() = Builtin::error()\n}\n\npredicate allowlist(Stmt s) {\n  // `panic(\"unreachable\")` and similar\n  exists(CallExpr ce | ce = s.(ExprStmt).getExpr() or ce = s.(ReturnStmt).getExpr() |\n    ce.getTarget().mustPanic() or ce.getCalleeName().toLowerCase() = \"error\"\n  )\n  or\n  // `return nil` and similar\n  exists(ReturnStmt ret | ret = s |\n    forall(Expr retval | retval = ret.getAnExpr() | isAllowedReturnValue(retval))\n  )\n  or\n  // statements in an `if false { ... }` and similar\n  exists(IfStmt is, ControlFlow::ConditionGuardNode iffalse, Expr cond, boolean b |\n    iffalse.getCondition() = is.getCond() and\n    iffalse = s.getFirstControlFlowNode().getAPredecessor() and\n    cond.getBoolValue() = b and\n    iffalse.ensures(DataFlow::exprNode(cond), b.booleanNot())\n  )\n}\n\nfrom Stmt s, ControlFlow::Node fst\nwhere\n  fst = s.getFirstControlFlowNode() and\n  not exists(nonGuardPredecessor(fst)) and\n  not allowlist(s)\nselect s, \"This statement is unreachable.\"",
        "description": "Unreachable statements are often indicative of missing code or latent bugs and should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/UnreachableStatement.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom ComparisonExpr cmp, DataFlow::Node op, int ub, string d, string r\nwhere\n  (\n    exists(BuiltinFunction bf | bf = Builtin::len() or bf = Builtin::cap() |\n      op = bf.getACall() and d = \"'\" + bf.getName() + \"'\"\n    )\n    or\n    op.getType().getUnderlyingType() instanceof UnsignedIntegerType and\n    d = \"This unsigned value\"\n  ) and\n  (\n    exists(RelationalComparisonExpr rel | rel = cmp |\n      rel.getLesserOperand() = op.asExpr() and\n      rel.getGreaterOperand().getIntValue() = ub and\n      (\n        ub < 0\n        or\n        ub = 0 and rel.isStrict()\n      ) and\n      r = \"be less than\"\n    )\n    or\n    exists(EqualityTestExpr eq | eq = cmp |\n      eq.getAnOperand() = op.asExpr() and\n      eq.getAnOperand().getIntValue() = ub and\n      ub < 0 and\n      r = \"equal\"\n    )\n  )\nselect cmp, d + \" is always non-negative, and hence cannot \" + r + \" \" + ub + \".\"",
        "description": "Checking whether the result of 'len' or 'cap' is negative is pointless, since these functions always returns a non-negative number. It is also pointless checking if an unsigned integer is negative, as it can only hold non-negative values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/NegativeLengthCheck.ql",
        "language": "go"
    },
    {
        "query": "import Clones\n\nclass HashedBranch extends HashRoot, Stmt {\n  HashedBranch() { exists(IfStmt is | this = is.getThen() or this = is.getElse()) }\n}\n\nfrom IfStmt is, HashableNode thenBranch, HashableNode elseBranch\nwhere\n  thenBranch = is.getThen() and\n  elseBranch = is.getElse() and\n  thenBranch.hash() = elseBranch.hash()\nselect is.getCond(), \"The 'then' and 'else' branches of this if statement are identical.\"",
        "description": "If the 'then' and 'else' branches of an 'if' statement are identical, the conditional may be superfluous, or it may indicate a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/DuplicateBranches.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate interfaceNilCheck(DataFlow::EqualityTestNode eq, DataFlow::Node nd) {\n  nd = eq.getAnOperand() and\n  nd.getType().getUnderlyingType() instanceof InterfaceType and\n  eq.getAnOperand().getType() instanceof NilLiteralType\n}\n\npredicate flowsToInterfaceNilCheck(DataFlow::Node nd) {\n  interfaceNilCheck(_, nd) or\n  flowsToInterfaceNilCheck(nd.getASuccessor())\n}\n\npredicate nonNilWrapper(DataFlow::Node nd) {\n  flowsToInterfaceNilCheck(nd) and\n  forex(DataFlow::Node pred | pred = nd.getAPredecessor() |\n    exists(Type predtp | predtp = pred.getType().getUnderlyingType() |\n      not predtp instanceof InterfaceType and\n      not predtp instanceof NilLiteralType and\n      not predtp instanceof InvalidType\n    )\n    or\n    nonNilWrapper(pred)\n  )\n}\n\nfrom DataFlow::EqualityTestNode eq, DataFlow::Node nd\nwhere\n  interfaceNilCheck(eq, nd) and\n  nonNilWrapper(nd)\nselect nd, \"This value can never be nil, since it is a wrapped interface value.\"",
        "description": "Comparing a non-nil interface value to nil may indicate a logic error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/ImpossibleInterfaceNilCheck.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nGVN switchCaseGvn(SwitchStmt switch, int i, Expr e) {\n  e = switch.getCase(i).getExpr(0) and result = e.getGlobalValueNumber()\n}\n\nfrom SwitchStmt switch, int i, Expr e, int j, Expr f\nwhere switchCaseGvn(switch, i, e) = switchCaseGvn(switch, j, f) and i < j\nselect f, \"This case is a duplicate of an $@.\", e, \"earlier case\"",
        "description": "If two cases in a switch statement have the same label, the second case will never be executed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/DuplicateSwitchCase.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nExpr getCondition(IfStmt stmt, int i) {\n  i = 0 and result = stmt.getCond()\n  or\n  exists(IfStmt elsif | elsif = stmt.getElse() |\n    not exists(elsif.getInit()) and\n    result = getCondition(stmt.getElse(), i - 1)\n  )\n}\n\nGVN conditionGvn(IfStmt is, int i, Expr e) {\n  e = getCondition(is, i) and result = e.getGlobalValueNumber()\n}\n\nfrom IfStmt is, Expr e, Expr f, int i, int j\nwhere conditionGvn(is, i, e) = conditionGvn(is, j, f) and i < j\nselect f, \"This condition is a duplicate of an $@.\", e, \"earlier condition\"",
        "description": "If two conditions in an 'if'-'else if' chain are identical, the second condition will never hold.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/DuplicateCondition.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate inVoidContext(Expr e) {\n  e = any(ExprStmt es).getExpr()\n  or\n  exists(LogicalBinaryExpr logical | e = logical.getRightOperand() and inVoidContext(logical))\n}\n\npredicate callToStubFunction(CallExpr ce) { ce.getTarget().getBody().getNumStmt() = 0 }\n\nfrom Expr e\nwhere\n  not e.mayHaveOwnSideEffects() and\n  inVoidContext(e) and\n  // don't flag calls to functions with an empty body\n  not callToStubFunction(e)\nselect e, \"This expression has no effect.\"",
        "description": "An expression that has no effect and is used in a void context is most likely redundant and may indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/ExprHasNoEffect.ql",
        "language": "go"
    },
    {
        "query": "import Clones\n\nclass PotentialSelfAssignment extends HashRoot, AssignStmt {\n  PotentialSelfAssignment() { this.getLhs().getKind() = this.getRhs().getKind() }\n}\n\nfrom PotentialSelfAssignment assgn, HashableNode rhs\nwhere\n  rhs = assgn.getRhs() and\n  rhs.hash() = assgn.getLhs().(HashableNode).hash()\nselect assgn, \"This statement assigns an $@ to itself.\", rhs, \"expression\"",
        "description": "Assigning a variable to itself has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/SelfAssignment.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate isDeferred(DataFlow::CallNode call) {\n  exists(DeferStmt defer | defer.getCall() = call.asExpr())\n}\n\nfrom DataFlow::CallNode recoverCall, FuncDef f, string msg\nwhere\n  recoverCall.getTarget() = Builtin::recover() and\n  f = recoverCall.getRoot() and\n  (\n    isDeferred(recoverCall) and\n    msg = \"Deferred calls to 'recover' have no effect.\"\n    or\n    not isDeferred(recoverCall) and\n    exists(f.getACall()) and\n    not isDeferred(f.getACall()) and\n    msg = \"This call to 'recover' has no effect because $@ is never called using a defer statement.\"\n  )\nselect recoverCall, msg, f, \"the enclosing function\"",
        "description": "Calling 'recover' in a function which isn't called using a defer statement has no effect. Also, putting 'recover' directly in a defer statement has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/RedundantRecover.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate isSimple(IR::Instruction nd) {\n  exists(Expr e |\n    e.isConst() or\n    e.(CompositeLit).getNumElement() = 0\n  |\n    nd = IR::evalExprInstruction(e)\n  )\n  or\n  nd = IR::implicitInitInstruction(_)\n  or\n  // don't flag parameters\n  nd instanceof IR::ReadArgumentInstruction\n}\n\nfrom IR::Instruction def, SsaSourceVariable target, IR::Instruction rhs\nwhere\n  def.writes(target, rhs) and\n  not exists(SsaExplicitDefinition ssa | ssa.getInstruction() = def) and\n  // exclude assignments in dead code\n  def.getBasicBlock() instanceof ReachableBasicBlock and\n  // exclude assignments with default values or simple expressions\n  not isSimple(rhs) and\n  // exclude variables that are not used at all\n  exists(target.getAReference()) and\n  // exclude variables with indirect references\n  not target.mayHaveIndirectReferences()\nselect def, \"This definition of \" + target + \" is never used.\"",
        "description": "An assignment to a local variable that is not used later on, or whose value is always overwritten, has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/DeadStoreOfLocal.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom ComparisonExpr cmp, Expr l\nwhere\n  l = cmp.getLeftOperand() and\n  l.getGlobalValueNumber() = cmp.getRightOperand().getGlobalValueNumber() and\n  // allow floats, where self-comparison may be used for NaN checks\n  not l.getType().getUnderlyingType() instanceof FloatType and\n  // allow comparisons of symbolic constants to literal constants; these are often feature flags\n  not exists(DeclaredConstant decl |\n    cmp.getAnOperand() = decl.getAReference() and\n    cmp.getAnOperand() instanceof BasicLit\n  )\nselect cmp, \"This expression compares an $@ to itself.\", cmp.getLeftOperand(), \"expression\"",
        "description": "If the same expression occurs on both sides of a comparison operator, the operator is redundant, and probably indicates a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/CompareIdenticalValues.ql",
        "language": "go"
    },
    {
        "query": "import Clones\n\nabstract class PotentiallyRedundantExpr extends BinaryExpr, HashRoot {\n  predicate operands(Expr left, Expr right) {\n    left = this.getLeftOperand() and right = this.getRightOperand()\n  }\n}\n\nclass IdemnecantExpr extends PotentiallyRedundantExpr {\n  IdemnecantExpr() {\n    (\n      this instanceof SubExpr or\n      this instanceof DivExpr or\n      this instanceof ModExpr or\n      this instanceof XorExpr or\n      this instanceof AndNotExpr\n    ) and\n    this.getLeftOperand().getKind() = this.getRightOperand().getKind() and\n    // exclude trivial cases like `1-1`\n    not this.getLeftOperand().stripParens() instanceof BasicLit\n  }\n}\n\nclass IdempotentExpr extends PotentiallyRedundantExpr {\n  IdempotentExpr() {\n    (\n      this instanceof LogicalBinaryExpr or\n      this instanceof BitAndExpr or\n      this instanceof BitOrExpr\n    ) and\n    this.getLeftOperand().getKind() = this.getRightOperand().getKind()\n  }\n}\n\nclass AverageExpr extends PotentiallyRedundantExpr, AddExpr {\n  AverageExpr() {\n    exists(DivExpr div |\n      this = div.getLeftOperand().stripParens() and\n      div.getRightOperand().getNumericValue() = 2 and\n      this.getLeftOperand().getKind() = this.getRightOperand().getKind()\n    )\n  }\n}\n\nHashedNode hashRedundantOperand(PotentiallyRedundantExpr red, int i, HashableNode nd) {\n  exists(Expr left, Expr right | red.operands(left, right) |\n    i = 0 and nd = left\n    or\n    i = 1 and nd = right\n  ) and\n  result = nd.hash()\n}\n\nfrom PotentiallyRedundantExpr red, Expr e, Expr f\nwhere hashRedundantOperand(red, 0, e) = hashRedundantOperand(red, 1, f)\nselect red, \"The $@ and $@ operand of this operation are identical.\", e, \"left\", f, \"right\"",
        "description": "Passing identical, or seemingly identical, operands to an operator such as subtraction or conjunction may indicate a typo; even if it is intentional, it makes the code hard to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/RedundantExpr.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate escapes(DataFlow::Node nd) {\n  // if `nd` is written to something that is not an SSA variable (such as\n  // a global variable, a field or an array element), then it escapes\n  exists(Write w |\n    nd = w.getRhs() and\n    not w.definesSsaVariable(_, _)\n  )\n  or\n  // if `nd` is used as an index into an array or similar, then it escapes\n  exists(IndexExpr idx | nd.asExpr() = idx.getIndex())\n  or\n  // if `nd` is used in an (in-)equality comparison, then it escapes\n  exists(EqualityTestExpr eq | nd.asExpr() = eq.getAnOperand())\n  or\n  // if `nd` is returned from a function, then it escapes\n  nd instanceof DataFlow::ResultNode\n  or\n  // if `nd` is sent over a channel, then it escapes\n  exists(SendStmt s | nd.asExpr() = s.getValue())\n  or\n  // if `nd` is passed to a function, then it escapes\n  nd = any(DataFlow::CallNode c).getASyntacticArgument()\n  or\n  // if `nd` is the receiver of a function, then it escapes\n  nd = any(DataFlow::MethodCallNode c).getReceiver()\n  or\n  // if `nd` has its address taken, then it escapes\n  exists(AddressExpr ae | nd.asExpr() = ae.getOperand())\n  or\n  // if `nd` is used as to look up a method with a pointer receiver, then it escapes\n  exists(SelectorExpr sel | nd.asExpr() = sel.getBase() |\n    exists(Method m | sel = m.getAReference() | m.getReceiverType() instanceof PointerType)\n    or\n    // if we cannot resolve a reference, we make worst-case assumptions\n    not exists(sel.(Name).getTarget())\n  )\n  or\n  // if `nd` flows into something that escapes, then it escapes\n  escapes(nd.getASuccessor())\n}\n\nType getEmbeddedType(Type t, boolean isPtr) {\n  exists(Type embedded | t.getUnderlyingType().(StructType).hasOwnField(_, _, embedded, true) |\n    if embedded instanceof PointerType\n    then (\n      result = embedded.(PointerType).getBaseType() and\n      isPtr = true\n    ) else (\n      result = embedded and\n      isPtr = false\n    )\n  )\n}\n\nType getEmbeddedType(Type t) { result = getEmbeddedType(t, _) }\n\nType getTypeEmbeddedViaPointer(Type t) {\n  result = getEmbeddedType*(getEmbeddedType(getEmbeddedType*(t), true))\n}\n\nfrom Write w, LocalVariable v, Field f\nwhere\n  // `w` writes `f` on `v`\n  w.writesField(v.getARead(), f, _) and\n  // but `f` is never read on `v`\n  not exists(Read r | r.readsField(v.getARead(), f)) and\n  // exclude pointer-typed `v`; there may be reads through an alias\n  not v.getType().getUnderlyingType() instanceof PointerType and\n  // exclude escaping `v`; there may be reads in other functions\n  not exists(Read r | r.reads(v) | escapes(r)) and\n  // exclude fields promoted through an embedded pointer type\n  not f = getTypeEmbeddedViaPointer(v.getType()).getField(_)\nselect w, \"This assignment to \" + f + \" is useless since its value is never read.\"",
        "description": "An assignment to a field that is not used later on has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/RedundantCode/DeadStoreOfField.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.InsecureFeatureFlag::InsecureFeatureFlag\n\nclass DebugModeFlag extends FlagKind {\n  DebugModeFlag() { this = \"debugMode\" }\n\n  bindingset[result]\n  override string getAFlagName() {\n    result.regexpMatch(\"(?i).*(trace|debug|devel|((en|dis)able|print)stack).*\")\n  }\n}\n\nclass StackFunction extends Function {\n  StackFunction() { this.hasQualifiedName(\"runtime\", \"Stack\") }\n}\n\nclass DebugStackFunction extends Function {\n  DebugStackFunction() { this.hasQualifiedName(\"runtime/debug\", \"Stack\") }\n}\n\nmodule StackTraceExposureConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source.(DataFlow::PostUpdateNode).getPreUpdateNode() =\n      any(StackFunction f).getACall().getArgument(0) or\n    source = any(DebugStackFunction f).getACall().getResult()\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof Http::ResponseBody }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // Sanitise everything controlled by an is-debug-mode check.\n    // Imprecision: I don't try to guess which arm of a branch is intended\n    // to mean debug mode, and which is production mode.\n    exists(ControlFlow::ConditionGuardNode cgn |\n      cgn.ensures(any(DebugModeFlag f).getAFlag().getANode(), _)\n    |\n      cgn.dominates(node.getBasicBlock())\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule StackTraceExposureFlow = TaintTracking::Global<StackTraceExposureConfig>;\n\nimport StackTraceExposureFlow::PathGraph\n\nfrom StackTraceExposureFlow::PathNode source, StackTraceExposureFlow::PathNode sink\nwhere StackTraceExposureFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"HTTP response depends on $@ and may be exposed to an external user.\", source.getNode(),\n  \"stack trace information\"",
        "description": "Information from a stack trace propagates to an external user. Stack traces can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-209/StackTraceExposure.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.OpenUrlRedirect\nimport semmle.go.security.SafeUrlFlow\nimport OpenUrlRedirect::Flow::PathGraph\n\nfrom OpenUrlRedirect::Flow::PathNode source, OpenUrlRedirect::Flow::PathNode sink\nwhere\n  OpenUrlRedirect::Flow::flowPath(source, sink) and\n  // this excludes flow from safe parts of request URLs, for example the full URL when the\n  // doing a redirect from `http://<path>` to `https://<path>`\n  not SafeUrlFlow::Flow::flow(_, sink.getNode())\nselect sink.getNode(), source, sink, \"This path to an untrusted URL redirection depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Open URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-601/OpenUrlRedirect.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.OpenUrlRedirectCustomizations\n\nStringOps::HasPrefix checkForLeadingSlash(SsaWithFields v) {\n  exists(DataFlow::Node substr |\n    result.getBaseString() = v.getAUse() and result.getSubstring() = substr\n  |\n    substr.getStringValue() = \"/\"\n  )\n}\n\npredicate isCheckedForSecondSlash(SsaWithFields v) {\n  exists(StringOps::HasPrefix hp | hp.getBaseString() = v.getAUse() |\n    hp.getSubstring().getStringValue() = \"//\"\n  )\n  or\n  exists(DataFlow::EqualityTestNode eq, DataFlow::Node slash, DataFlow::ElementReadNode er |\n    slash.getStringValue() = \"/\" and\n    er.getBase() = v.getAUse() and\n    er.getIndex().getIntValue() = 1 and\n    eq.eq(_, er, slash)\n  )\n  or\n  // a call to path.Clean will strip away multiple leading slashes\n  isCleaned(v.getAUse())\n}\n\npredicate isCleaned(DataFlow::Node nd) {\n  exists(Function clean | clean.hasQualifiedName(\"path\", \"Clean\") |\n    nd = clean.getACall()\n    or\n    nd = clean.getACall().getArgument(0)\n  )\n  or\n  isCleaned(nd.getAPredecessor())\n  or\n  exists(FuncDef f, FunctionInput inp | nd = inp.getExitNode(f) |\n    forex(DataFlow::CallNode call | call.getACallee() = f | isCleaned(inp.getEntryNode(call)))\n  )\n}\n\npredicate isCheckedForSecondBackslash(SsaWithFields v) {\n  exists(StringOps::HasPrefix hp | hp.getBaseString() = v.getAUse() |\n    hp.getSubstring().getStringValue() = \"/\\\\\"\n  )\n  or\n  exists(DataFlow::EqualityTestNode eq, DataFlow::Node slash, DataFlow::ElementReadNode er |\n    slash.getStringValue() = \"\\\\\" and\n    er.getBase() = v.getAUse() and\n    er.getIndex().getIntValue() = 1 and\n    eq.eq(_, er, slash)\n  )\n  or\n  // if this variable comes from or is a net/url.URL.Path, backslashes are most likely sanitized,\n  // as the parse functions turn them into \"%5C\"\n  urlPath(v.getAUse())\n}\n\npredicate urlPath(DataFlow::Node nd) {\n  exists(Field f |\n    f.hasQualifiedName(\"net/url\", \"URL\", \"Path\") and\n    nd = f.getARead()\n  )\n  or\n  urlPath(nd.getAPredecessor())\n  or\n  exists(FuncDef f, FunctionInput inp | nd = inp.getExitNode(f) |\n    forex(DataFlow::CallNode call | call.getACallee() = f | urlPath(inp.getEntryNode(call)))\n  )\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isCheckedSource(source, _) }\n\n  /**\n   * Holds if `source` is the first node that flows into a use of a variable that is checked by a\n   * bad redirect check `check`..\n   */\n  additional predicate isCheckedSource(DataFlow::Node source, DataFlow::Node check) {\n    exists(SsaWithFields v |\n      DataFlow::localFlow(source, v.getAUse()) and\n      not exists(source.getAPredecessor()) and\n      isBadRedirectCheckOrWrapper(check, v)\n    )\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    // this is very over-approximate, because most filtering is done by the isSource predicate\n    exists(Write w | w.writesField(node2, _, node1))\n  }\n\n  predicate isBarrierOut(DataFlow::Node node) {\n    // assume this value is safe if something is prepended to it.\n    exists(StringOps::Concatenation conc, int i, int j | i < j |\n      node = conc.getOperand(j) and\n      exists(conc.getOperand(i))\n    )\n    or\n    exists(DataFlow::CallNode call, int i | call.getTarget().hasQualifiedName(\"path\", \"Join\") |\n      i > 0 and node = call.getSyntacticArgument(i)\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof OpenUrlRedirect::Sink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    result = source.getLocation()\n    or\n    exists(DataFlow::Node check |\n      isCheckedSource(source, check) and\n      result = check.getLocation()\n    )\n  }\n}\n\nmodule Flow = TaintTracking::Global<Config>;\n\npredicate isBadRedirectCheckOrWrapper(DataFlow::Node check, SsaWithFields v) {\n  isBadRedirectCheck(check, v)\n  or\n  exists(DataFlow::CallNode call, FuncDef f, FunctionInput input |\n    call = f.getACall() and\n    input.getEntryNode(call) = v.getAUse() and\n    isBadRedirectCheckWrapper(check, f, input)\n  )\n}\n\npredicate isBadRedirectCheck(DataFlow::Node check, SsaWithFields v) {\n  // a check for a leading slash\n  check = checkForLeadingSlash(v) and\n  // where there does not exist a check for both a second slash and a second backslash\n  // (we allow those checks to be on variables that are most likely equivalent to `v`\n  // to rule out false positives due to minor variations in data flow)\n  not (\n    isCheckedForSecondSlash(v.similar()) and\n    isCheckedForSecondBackslash(v.similar())\n  )\n}\n\npredicate isBadRedirectCheckWrapper(DataFlow::Node check, FuncDef f, FunctionInput input) {\n  exists(SsaWithFields v |\n    v.getAUse().getAPredecessor*() = input.getExitNode(f) and\n    isBadRedirectCheck(check, v)\n  )\n}\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink, DataFlow::Node check\nwhere\n  Config::isCheckedSource(source.getNode(), check) and\n  Flow::flowPath(source, sink)\nselect check, source, sink,\n  \"This is a check that $@, which flows into a $@, has a leading slash, but not that it does not have '/' or '\\\\' in its second position.\",\n  source.getNode(), \"this value\", sink.getNode(), \"redirect\"",
        "description": "A redirect check that checks for a leading slash but not two leading slashes or a leading slash followed by a backslash is incomplete.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-601/BadRedirectCheck.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.getIntValue() < 2048 }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(DataFlow::CallNode c |\n      sink = c.getArgument(1) and\n      c.getTarget().hasQualifiedName(\"crypto/rsa\", \"GenerateKey\")\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node = DataFlow::BarrierGuard<comparisonBarrierGuard/3>::getABarrierNode()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node sink) { none() }\n}\n\nmodule Flow = DataFlow::Global<Config>;\n\nimport Flow::PathGraph\n\npredicate comparisonBarrierGuard(DataFlow::Node g, Expr e, boolean branch) {\n  exists(DataFlow::Node lesser, DataFlow::Node greater, int bias |\n    g.(DataFlow::RelationalComparisonNode).leq(branch, lesser, greater, bias)\n  |\n    // Force join order: find comparisons checking x >= 2048, then take the global value\n    // number of x. Otherwise this can be realised by starting from all pairs of matching value\n    // numbers, which can be huge.\n    pragma[only_bind_into](globalValueNumber(DataFlow::exprNode(e))) = globalValueNumber(greater) and\n    lesser.getIntValue() - bias >= 2048\n  )\n}\n\nfrom Flow::PathNode source, Flow::PathNode sink\nwhere Flow::flowPath(source, sink)\nselect sink, source, sink, \"The size of this RSA key should be at least 2048 bits.\"",
        "description": "Using a weak cryptographic key can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-326/InsufficientKeySize.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.InsecureFeatureFlag::InsecureFeatureFlag\n\npredicate isInsecureTlsVersion(int val, string name, string fieldName) {\n  (fieldName = \"MinVersion\" or fieldName = \"MaxVersion\") and\n  (\n    // tls.VersionSSL30\n    val = 768 and name = \"VersionSSL30\"\n    or\n    // tls.VersionTLS10\n    val = 769 and name = \"VersionTLS10\"\n    or\n    // tls.VersionTLS11\n    val = 770 and name = \"VersionTLS11\"\n    or\n    // Zero indicates the lowest available version setting for MinVersion,\n    // or the highest available version setting for MaxVersion.\n    val = 0 and name = \"\" and fieldName = \"MinVersion\"\n  )\n}\n\nint getASecureTlsVersion() {\n  result in [771, 772] // TLS 1.2 and 1.3 respectively\n}\n\nint getATlsVersion() { result = getASecureTlsVersion() or isInsecureTlsVersion(result, _, _) }\n\nmodule TlsVersionFlowConfig implements DataFlow::ConfigSig {\n  /**\n   * Holds if `source` is a TLS version source yielding value `val`.\n   */\n  additional predicate intIsSource(DataFlow::Node source, int val) {\n    val = source.getIntValue() and\n    val = getATlsVersion() and\n    not DataFlow::isReturnedWithError(source)\n  }\n\n  /**\n   * Holds if `fieldWrite` writes `sink` to `base`.`fld`, where `fld` is a TLS version field.\n   */\n  additional predicate isSink(DataFlow::Node sink, Field fld, DataFlow::Node base, Write fieldWrite) {\n    fld.hasQualifiedName(\"crypto/tls\", \"Config\", [\"MinVersion\", \"MaxVersion\"]) and\n    fieldWrite.writesField(base, fld, sink)\n  }\n\n  predicate isSource(DataFlow::Node source) { intIsSource(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _, _, _) }\n}\n\nmodule TlsVersionFlow = TaintTracking::Global<TlsVersionFlowConfig>;\n\npredicate secureTlsVersionFlow(DataFlow::Node source, DataFlow::Node sink, Field fld) {\n  exists(int version |\n    TlsVersionFlow::flow(source, sink) and\n    TlsVersionFlowConfig::intIsSource(source, version) and\n    not isInsecureTlsVersion(version, _, fld.getName())\n  )\n}\n\npredicate secureTlsVersionFlowsToSink(DataFlow::Node sink, Field fld) {\n  secureTlsVersionFlow(_, sink, fld)\n}\n\npredicate secureTlsVersionFlowsToField(SsaWithFields accessPath, Field fld) {\n  exists(DataFlow::Node sink, DataFlow::Node base |\n    secureTlsVersionFlow(_, sink, fld) and\n    TlsVersionFlowConfig::isSink(sink, fld, base, _) and\n    accessPath.getAUse() = base\n  )\n}\n\nDataFlow::Node nodeOrDeref(DataFlow::Node node) {\n  result = node or\n  result.asInstruction() = IR::implicitDerefInstruction(node.asExpr())\n}\n\npredicate isInsecureTlsVersionFlow(\n  TlsVersionFlow::PathNode source, TlsVersionFlow::PathNode sink, string message,\n  DataFlow::Node base\n) {\n  exists(int version, Field fld |\n    TlsVersionFlow::flowPath(source, sink) and\n    TlsVersionFlowConfig::intIsSource(source.getNode(), version) and\n    TlsVersionFlowConfig::isSink(sink.getNode(), fld, base, _) and\n    isInsecureTlsVersion(version, _, fld.getName()) and\n    // Exclude cases where a secure TLS version can also flow to the same\n    // sink, or to different sinks that refer to the same base and field,\n    // which suggests a configurable security mode.\n    not secureTlsVersionFlowsToSink(sink.getNode(), fld) and\n    not exists(SsaWithFields insecureAccessPath, SsaWithFields secureAccessPath |\n      nodeOrDeref(insecureAccessPath.getAUse()) = base and\n      secureAccessPath = insecureAccessPath.similar()\n    |\n      secureTlsVersionFlowsToField(secureAccessPath, fld)\n    )\n  |\n    version = 0 and\n    message = \"Using lowest TLS version for \" + fld + \".\"\n    or\n    version != 0 and\n    exists(string name | isInsecureTlsVersion(version, name, _) |\n      message = \"Using insecure TLS version \" + name + \" for \" + fld + \".\"\n    )\n  )\n}\n\nmodule TlsInsecureCipherSuitesFlowConfig implements DataFlow::ConfigSig {\n  /**\n   * Holds if `source` reads an insecure TLS cipher suite named `suiteName`.\n   */\n  additional predicate isSourceValueEntity(DataFlow::Node source, string suiteName) {\n    exists(DataFlow::ValueEntity val |\n      val.hasQualifiedName(\"crypto/tls\", suiteName) and\n      suiteName =\n        [\n          \"TLS_RSA_WITH_RC4_128_SHA\", \"TLS_RSA_WITH_AES_128_CBC_SHA256\",\n          \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\", \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\",\n          \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\"\n        ]\n    |\n      source = val.getARead()\n    )\n  }\n\n  /**\n   * Holds if `source` represents the result of `tls.InsecureCipherSuites()`.\n   */\n  additional predicate isSourceInsecureCipherSuites(DataFlow::Node source) {\n    exists(Function insecureCipherSuites |\n      insecureCipherSuites.hasQualifiedName(\"crypto/tls\", \"InsecureCipherSuites\")\n    |\n      source = insecureCipherSuites.getACall().getResult()\n    )\n  }\n\n  predicate isSource(DataFlow::Node source) {\n    isSourceInsecureCipherSuites(source)\n    or\n    isSourceValueEntity(source, _)\n  }\n\n  /**\n   * Holds if `fieldWrite` writes `sink` to `base`.`fld`, and `fld` is `tls.Config.CipherSuites`.\n   */\n  additional predicate isSink(DataFlow::Node sink, Field fld, DataFlow::Node base, Write fieldWrite) {\n    fld.hasQualifiedName(\"crypto/tls\", \"Config\", \"CipherSuites\") and\n    fieldWrite.writesField(base, fld, sink)\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSink(sink, _, _, _) }\n\n  /**\n   * Declare sinks as out-sanitizers in order to avoid producing superfluous paths where a cipher\n   * is written to CipherSuites, then the list is further extended with either safe or tainted\n   * suites.\n   */\n  predicate isBarrierOut(DataFlow::Node node) { isSink(node) }\n}\n\nmodule TlsInsecureCipherSuitesFlow = TaintTracking::Global<TlsInsecureCipherSuitesFlowConfig>;\n\npredicate isInsecureTlsCipherFlow(\n  TlsInsecureCipherSuitesFlow::PathNode source, TlsInsecureCipherSuitesFlow::PathNode sink,\n  string message\n) {\n  TlsInsecureCipherSuitesFlow::flowPath(source, sink) and\n  (\n    exists(string name |\n      TlsInsecureCipherSuitesFlowConfig::isSourceValueEntity(source.getNode(), name)\n    |\n      message = \"Use of an insecure cipher suite: \" + name + \".\"\n    )\n    or\n    TlsInsecureCipherSuitesFlowConfig::isSourceInsecureCipherSuites(source.getNode()) and\n    message = \"Use of an insecure cipher suite.\"\n  )\n}\n\nclass LegacyTlsVersionFlag extends FlagKind {\n  LegacyTlsVersionFlag() { this = \"legacyTlsVersion\" }\n\n  bindingset[result]\n  override string getAFlagName() { result.regexpMatch(\"(?i).*(old|intermediate|legacy).*\") }\n}\n\nControlFlow::ConditionGuardNode getALegacyTlsVersionCheck() {\n  result.ensures(any(LegacyTlsVersionFlag f).getAFlag().getANode(), _)\n}\n\nFlagKind securityOrTlsVersionFlag() {\n  result = any(SecurityFeatureFlag f) or\n  result = any(LegacyTlsVersionFlag f)\n}\n\nmodule Flow =\n  DataFlow::MergePathGraph<TlsVersionFlow::PathNode, TlsInsecureCipherSuitesFlow::PathNode,\n    TlsVersionFlow::PathGraph, TlsInsecureCipherSuitesFlow::PathGraph>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink, string message\nwhere\n  (\n    isInsecureTlsVersionFlow(source.asPathNode1(), sink.asPathNode1(), message, _) or\n    isInsecureTlsCipherFlow(source.asPathNode2(), sink.asPathNode2(), message)\n  ) and\n  // Exclude sources or sinks guarded by a feature or legacy flag\n  not [getASecurityFeatureFlagCheck(), getALegacyTlsVersionCheck()]\n      .dominatesNode([source, sink].getNode().asInstruction()) and\n  // Exclude sources or sinks that occur lexically within a block related to a feature or legacy flag\n  not astNodeIsFlag([source, sink].getNode().asExpr().getParent*(), securityOrTlsVersionFlag()) and\n  // Exclude results in functions whose name documents insecurity\n  not exists(FuncDef fn | fn = sink.getNode().getRoot().getEnclosingFunction*() |\n    fn.getName() = securityOrTlsVersionFlag().getAFlagName()\n  )\nselect sink.getNode(), source, sink, message",
        "description": "If an application supports insecure TLS versions or ciphers, it may be vulnerable to machine-in-the-middle and other attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-327/InsecureTLS.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.RequestForgery\nimport semmle.go.security.SafeUrlFlow\nimport RequestForgery::Flow::PathGraph\n\nfrom\n  RequestForgery::Flow::PathNode source, RequestForgery::Flow::PathNode sink, DataFlow::Node request\nwhere\n  RequestForgery::Flow::flowPath(source, sink) and\n  request = sink.getNode().(RequestForgery::Sink).getARequest() and\n  // this excludes flow from safe parts of request URLs, for example the full URL\n  not SafeUrlFlow::Flow::flow(_, sink.getNode())\nselect request, source, sink, \"The $@ of this request depends on a $@.\", sink.getNode(),\n  sink.getNode().(RequestForgery::Sink).getKind(), source, \"user-provided value\"",
        "description": "Sending network requests with user-controlled data allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-918/RequestForgery.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.AllocationSizeOverflow\nimport AllocationSizeOverflow::Flow::PathGraph\n\nfrom\n  AllocationSizeOverflow::Flow::PathNode source, AllocationSizeOverflow::Flow::PathNode sink,\n  DataFlow::Node allocsz\nwhere\n  AllocationSizeOverflow::Flow::flowPath(source, sink) and\n  AllocationSizeOverflow::isSinkWithAllocationSize(sink.getNode(), allocsz)\nselect sink, source, sink,\n  \"This operation, which is used in an $@, involves a $@ and might overflow.\", allocsz,\n  \"allocation\", source, \"potentially large value\"",
        "description": "When computing the size of an allocation based on the size of a large object, the result may overflow and cause a runtime panic.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-190/AllocationSizeOverflow.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.SqlInjection\nimport SqlInjection::Flow::PathGraph\n\nfrom SqlInjection::Flow::PathNode source, SqlInjection::Flow::PathNode sink\nwhere SqlInjection::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This query depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-089/SqlInjection.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.StringBreak\nimport StringBreak::Flow::PathGraph\n\nfrom StringBreak::Flow::PathNode source, StringBreak::Flow::PathNode sink\nwhere StringBreak::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"If this $@ contains a \" + sink.getNode().(StringBreak::Sink).getQuote().getType() +\n    \" quote, it could break out of \" + \"the enclosing quotes.\", source.getNode(), \"JSON value\"",
        "description": "If a quoted string literal is constructed from data that may itself contain quotes, the embedded data could (accidentally or intentionally) change the structure of the overall string.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-089/StringBreak.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nbindingset[re]\npredicate isInterestingSemiAnchoredRegexpString(string re, string msg) {\n  exists(string str, string maybeGroupedStr, string regex, string anchorPart, string escapedDot |\n    // a dot that might be escaped in a regular expression, for example `regexp.Compile(\"\\\\.\")`\n    escapedDot = \"\\\\\\\\[.]\" and\n    // a string that is mostly free from special reqular expression symbols\n    str = \"(?:(?:\" + escapedDot + \")|[a-z:/.?_,@0-9 -])+\" and\n    // the string may be wrapped in parentheses\n    maybeGroupedStr = \"(?:\" + str + \"|\\\\(\" + str + \"\\\\))\" and\n    (\n      // a problematic pattern: `^a|b|...|x`\n      regex = \"(?i)(\\\\^\" + maybeGroupedStr + \")(?:\\\\|\" + maybeGroupedStr + \")+\"\n      or\n      // a problematic pattern: `a|b|...|x$`\n      regex = \"(?i)(?:\" + maybeGroupedStr + \"\\\\|)+(\" + maybeGroupedStr + \"\\\\$)\"\n    ) and\n    anchorPart = re.regexpCapture(regex, 1) and\n    anchorPart.regexpMatch(\"(?i).*[a-z].*\") and\n    msg =\n      \"Misleading operator precedence. The subexpression '\" + anchorPart +\n        \"' is anchored, but the other parts of this regular expression are not.\"\n  )\n}\n\nbindingset[re]\npredicate isInterestingUnanchoredRegexpString(string re, string msg) {\n  // a substring sequence of a protocol and subdomains, perhaps with some regex characters mixed in, followed by a known TLD\n  re.regexpMatch(\"(?i)[():|?a-z0-9-\\\\\\\\./]+[.]\" + commonTld() + \"([/#?():]\\\\S*)?\") and\n  // without any anchors\n  not re.regexpMatch(\".*(\\\\$|\\\\^|\\\\\\\\A|\\\\\\\\z).*\") and\n  msg =\n    \"When this is used as a regular expression on a URL, it may match anywhere, and arbitrary \" +\n      \"hosts may come before or after it.\"\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  additional predicate isSourceString(DataFlow::Node source, string msg) {\n    exists(Expr e | e = source.asExpr() |\n      isInterestingUnanchoredRegexpString(e.getStringValue(), msg)\n      or\n      isInterestingSemiAnchoredRegexpString(e.getStringValue(), msg)\n    )\n  }\n\n  predicate isSource(DataFlow::Node source) { isSourceString(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof RegexpPattern }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) { none() }\n}\n\nmodule Flow = DataFlow::Global<Config>;\n\nfrom DataFlow::Node source, string msg\nwhere Flow::flow(source, _) and Config::isSourceString(source, msg)\nselect source, msg",
        "description": "Regular expressions without anchors can be vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-020/MissingRegexpAnchor.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nclass DangerousScheme extends string {\n  DangerousScheme() { this = \"data\" or this = \"javascript\" or this = \"vbscript\" }\n}\n\nDataFlow::Node schemeCheck(GVN g, DangerousScheme scheme) {\n  // check of the form `nd.Scheme == scheme`\n  exists(DefinedType url, DataFlow::FieldReadNode fr, DataFlow::Node s |\n    url.hasQualifiedName(\"net/url\", \"URL\") and\n    fr.readsField(g.getANode(), url.getField(\"Scheme\")) and\n    s.getStringValue() = scheme and\n    result.(DataFlow::EqualityTestNode).eq(_, fr, s)\n  )\n  or\n  // check of the form `strings.HasPrefix(nd, \"scheme:\")`\n  exists(StringOps::HasPrefix hasPrefix | result = hasPrefix |\n    hasPrefix.getBaseString() = g.getANode() and\n    hasPrefix.getSubstring().getStringValue() = scheme + \":\"\n  )\n  or\n  // propagate through various string transformations\n  exists(string stringop, DataFlow::CallNode c |\n    stringop = \"Map\" or\n    stringop.matches(\"Replace%\") or\n    stringop.matches(\"To%\") or\n    stringop.matches(\"Trim%\")\n  |\n    c.getTarget().hasQualifiedName(\"strings\", stringop) and\n    c.getAnArgument() = g.getANode() and\n    result = schemeCheck(globalValueNumber(c), scheme)\n  )\n}\n\nDangerousScheme getAMissingScheme(GVN g) {\n  exists(schemeCheck(g, _)) and\n  not exists(schemeCheck(g, result))\n}\n\nfrom GVN g\nselect schemeCheck(g, \"javascript\"),\n  \"This check does not consider \" + strictconcat(getAMissingScheme(g), \" and \") + \".\"",
        "description": "Checking for the \"javascript:\" URL scheme without also checking for \"vbscript:\" and \"data:\" suggests a logic error or even a security vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-020/IncompleteUrlSchemeCheck.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nbindingset[pattern]\npredicate isIncompleteHostNameRegexpPattern(string pattern, string hostPart) {\n  hostPart =\n    pattern\n        .regexpCapture(\"(?i).*?\" +\n            // an unescaped single `.`\n            \"(?<!\\\\\\\\)[.]\" +\n            // immediately followed by a sequence of subdomains, perhaps with some regex characters mixed in,\n            // followed by a known TLD\n            \"(([():|?a-z0-9-]+(\\\\\\\\)?[.])?\" + commonTld() + \")\" + \".*\", 1)\n}\n\npredicate writesHttpError(ReachableBasicBlock b) {\n  forex(Http::HeaderWrite hw |\n    hw.getHeaderName() = \"status\" and hw.asInstruction().getBasicBlock() = b\n  |\n    exists(string code | code.matches(\"4__\") or code.matches(\"5__\") |\n      hw.definesHeader(\"status\", code)\n    )\n  )\n}\n\npredicate onlyErrors(BasicBlock block) {\n  writesHttpError(block)\n  or\n  forex(ReachableBasicBlock pred | pred = block.getAPredecessor() | onlyErrors(pred))\n}\n\nDataFlow::Node getASafeHandler() {\n  exists(Variable v |\n    v.hasQualifiedName(ElazarlGoproxy::packagePath(), [\"AlwaysReject\", \"RejectConnect\"])\n  |\n    result = v.getARead()\n  )\n  or\n  exists(Function f |\n    onlyErrors(f.getFuncDecl().(ControlFlow::Root).getExitNode().getBasicBlock())\n  |\n    result = f.getARead()\n  )\n}\n\npredicate regexpGuardsHandler(RegexpPattern regexp, Http::RequestHandler handler) {\n  handler.guardedBy(DataFlow::exprNode(regexp.getAUse().asExpr().getParent*()))\n}\n\npredicate regexpGuardsError(RegexpPattern regexp) {\n  exists(ControlFlow::ConditionGuardNode cond, RegexpMatchFunction match, DataFlow::CallNode call |\n    call.getTarget() = match and\n    match.getRegexp(call) = regexp\n  |\n    cond.ensures(match.getResult().getNode(call).getASuccessor*(), true) and\n    cond.dominates(any(ReachableBasicBlock b | writesHttpError(b)))\n  )\n}\n\nmodule IncompleteHostNameRegexpConfig implements DataFlow::ConfigSig {\n  additional predicate isSourceString(DataFlow::Node source, string hostPart) {\n    exists(Expr e | e = source.asExpr() |\n      isIncompleteHostNameRegexpPattern(e.getStringValue(), hostPart) and\n      // Exclude constant names to avoid duplicate results, because the string\n      // literals which they are initialised with are also considered as\n      // sources.\n      not e instanceof ConstantName\n    )\n  }\n\n  predicate isSource(DataFlow::Node source) { isSourceString(source, _) }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink instanceof RegexpPattern and\n    forall(Http::RequestHandler handler | regexpGuardsHandler(sink, handler) |\n      not handler = getASafeHandler()\n    ) and\n    not regexpGuardsError(sink)\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    StringOps::Concatenation::taintStep(node1, node2)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = DataFlow::Global<IncompleteHostNameRegexpConfig>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink, string hostPart\nwhere\n  Flow::flowPath(source, sink) and\n  IncompleteHostNameRegexpConfig::isSourceString(source.getNode(), hostPart)\nselect source, source, sink,\n  \"This regular expression has an unescaped dot before '\" + hostPart + \"', \" +\n    \"so it might match more hosts than expected when $@.\", sink, \"the regular expression is used\"",
        "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-020/IncompleteHostnameRegexp.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom UntrustedDataToExternalApiFlow::PathNode source, UntrustedDataToExternalApiFlow::PathNode sink\nwhere UntrustedDataToExternalApiFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"Call to \" + sink.getNode().(ExternalApiDataNode).getFunctionDescription() +\n    \" with untrusted data from $@.\", source, source.toString()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-020/UntrustedDataToExternalAPI.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.ExternalAPIs\nimport UntrustedDataToUnknownExternalApiFlow::PathGraph\n\nfrom\n  UntrustedDataToUnknownExternalApiFlow::PathNode source,\n  UntrustedDataToUnknownExternalApiFlow::PathNode sink\nwhere UntrustedDataToUnknownExternalApiFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"Call to \" + sink.getNode().(UnknownExternalApiDataNode).getFunctionDescription() +\n    \" with untrusted data from $@.\", source, source.toString()",
        "description": "Data provided remotely is used in this unknown external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-020/UntrustedDataToUnknownExternalAPI.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate containsEscapedCharacter(DataFlow::Node source, string character) {\n  character in [\"a\", \"b\"] and\n  exists(StringLit s | s = source.asExpr() |\n    // Search for `character` preceded by an odd number of backslashes:\n    exists(s.getText().regexpFind(\"(?<=(^|[^\\\\\\\\])\\\\\\\\(\\\\\\\\{2}){0,10})\" + character, _, _)) and\n    not s.isRaw()\n  )\n}\n\nmodule SuspiciousCharacterInRegexpConfig implements DataFlow::ConfigSig {\n  additional predicate isSourceString(DataFlow::Node source, string report) {\n    containsEscapedCharacter(source, \"a\") and\n    report =\n      \"the bell character \\\\a; did you mean \\\\\\\\a, the Vim alphabetic character class (use [[:alpha:]] instead) or \\\\\\\\A, the beginning of text?\"\n    or\n    containsEscapedCharacter(source, \"b\") and\n    report = \"a literal backspace \\\\b; did you mean \\\\\\\\b, a word boundary?\"\n  }\n\n  predicate isSource(DataFlow::Node source) { isSourceString(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof RegexpPattern }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = DataFlow::Global<SuspiciousCharacterInRegexpConfig>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink, string report\nwhere\n  Flow::flowPath(source, sink) and\n  SuspiciousCharacterInRegexpConfig::isSourceString(source.getNode(), report)\nselect source, source, sink, \"This string literal that is $@ contains \" + report, sink,\n  \"used as a regular expression\"",
        "description": "If a literal bell character or backspace appears in a regular expression, the start of text or word boundary may have been intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-020/SuspiciousCharacterInRegexp.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.ExternalAPIs\n\nfrom ExternalApiUsedWithUntrustedData externalApi\nselect externalApi, count(externalApi.getUntrustedDataNode()) as numberOfUses,\n  externalApi.getNumberOfUntrustedSources() as numberOfUntrustedSources order by\n    numberOfUntrustedSources desc",
        "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-020/ExternalAPIsUsedWithUntrustedData.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport EmailInjection::EmailInjection\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink\nwhere Flow::flowPath(source, sink)\nselect sink, source, sink, \"Email content may contain $@.\", source.getNode(), \"untrusted input\"",
        "description": "Incorporating untrusted input directly into an email message can enable content spoofing, which in turn may lead to information leaks and other security issues.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-640/EmailInjection.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.InsecureFeatureFlag::InsecureFeatureFlag\n\npredicate becomesPartOf(DataFlow::Node part, DataFlow::Node whole) {\n  DataFlow::localFlow(part, whole)\n  or\n  whole.(DataFlow::AddressOperationNode).getOperand() = part\n  or\n  exists(Write w | w.writesField(whole.(DataFlow::PostUpdateNode).getPreUpdateNode(), _, part))\n}\n\nclass InsecureCertificateFlag extends FlagKind {\n  InsecureCertificateFlag() { this = \"insecureCertificate\" }\n\n  bindingset[result]\n  override string getAFlagName() {\n    result.regexpMatch(\"(?i).*(selfcert|selfsign|validat|verif|trust).*\")\n  }\n}\n\nControlFlow::ConditionGuardNode getAnInsecureCertificateCheck() {\n  result.ensures(any(InsecureCertificateFlag f).getAFlag().getANode(), _)\n}\n\nFlagKind securityOrTlsVersionFlag() {\n  result = any(SecurityFeatureFlag f) or\n  result = any(InsecureCertificateFlag f)\n}\n\nbindingset[name]\npredicate isSecurityOrCertificateConfigFlag(string name) {\n  name = securityOrTlsVersionFlag().getAFlagName()\n}\n\nfrom Write w, DataFlow::Node base, Field f, DataFlow::Node rhs\nwhere\n  w.writesField(base, f, rhs) and\n  f.hasQualifiedName(\"crypto/tls\", \"Config\", \"InsecureSkipVerify\") and\n  rhs.getBoolValue() = true and\n  // exclude writes guarded by a feature flag\n  not [getASecurityFeatureFlagCheck(), getAnInsecureCertificateCheck()].dominatesNode(w) and\n  // exclude results in functions whose name documents the insecurity\n  not exists(FuncDef fn | fn = w.getRoot() |\n    isSecurityOrCertificateConfigFlag(fn.getEnclosingFunction*().getName())\n  ) and\n  // exclude results that flow into a field/variable whose name documents the insecurity\n  not exists(ValueEntity e, DataFlow::Node init |\n    isSecurityOrCertificateConfigFlag(e.getName()) and\n    any(Write w2).writes(e, init) and\n    becomesPartOf*(base, init)\n  ) and\n  // exclude results in test code\n  exists(File fl | fl = w.getFile() | not fl instanceof TestFile)\nselect w, \"InsecureSkipVerify should not be used in production code.\"",
        "description": "If an application disables TLS certificate checking, it may be vulnerable to man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-295/DisabledCertificateCheck.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.MissingJwtSignatureCheck\nimport MissingJwtSignatureCheck::Flow::PathGraph\n\nfrom MissingJwtSignatureCheck::Flow::PathNode source, MissingJwtSignatureCheck::Flow::PathNode sink\nwhere MissingJwtSignatureCheck::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This JWT is parsed without verification and received from $@.\", source.getNode(),\n  \"this user-controlled source\"",
        "description": "Failing to check the JSON Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-347/MissingJwtSignatureCheck.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.UncontrolledAllocationSize\nimport UncontrolledAllocationSize::Flow::PathGraph\n\nfrom\n  UncontrolledAllocationSize::Flow::PathNode source, UncontrolledAllocationSize::Flow::PathNode sink\nwhere UncontrolledAllocationSize::Flow::flowPath(source, sink)\nselect sink, source, sink, \"This memory allocation depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-770/UncontrolledAllocationSize.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nprivate string cryptoSshPackage() { result = package(\"golang.org/x/crypto\", \"ssh\") }\n\nclass InsecureIgnoreHostKey extends Function {\n  InsecureIgnoreHostKey() { this.hasQualifiedName(cryptoSshPackage(), \"InsecureIgnoreHostKey\") }\n}\n\nclass HostKeyCallbackFunc extends DataFlow::Node {\n  HostKeyCallbackFunc() {\n    exists(DefinedType dt | dt.hasQualifiedName(cryptoSshPackage(), \"HostKeyCallback\") |\n      this.getType().getUnderlyingType() = dt.getUnderlyingType()\n    ) and\n    // Restrict possible sources to either function definitions or\n    // the result of some external function call (e.g. InsecureIgnoreHostKey())\n    // Otherwise we also consider typecasts, variables and other such intermediates\n    // as sources.\n    (\n      this instanceof DataFlow::FunctionNode\n      or\n      exists(DataFlow::CallNode call | not exists(call.getACallee().getBody()) |\n        this = call.getAResult()\n      )\n    )\n  }\n}\n\nclass InsecureHostKeyCallbackFunc extends HostKeyCallbackFunc {\n  InsecureHostKeyCallbackFunc() {\n    // Either a call to InsecureIgnoreHostKey(), which we know returns an insecure callback.\n    this = any(InsecureIgnoreHostKey f).getACall().getAResult()\n    or\n    // Or a callback function in the source code (named or anonymous) that always returns nil.\n    forex(DataFlow::ResultNode returnValue |\n      returnValue = this.(DataFlow::FunctionNode).getAResult()\n    |\n      returnValue = Builtin::nil().getARead()\n    )\n  }\n}\n\nmodule Config implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof HostKeyCallbackFunc }\n\n  /**\n   * Holds if `sink` is a value written by `write` to a field `ClientConfig.HostKeyCallback`.\n   */\n  additional predicate writeIsSink(DataFlow::Node sink, Write write) {\n    exists(Field f |\n      f.hasQualifiedName(cryptoSshPackage(), \"ClientConfig\", \"HostKeyCallback\") and\n      write.writesField(_, f, sink)\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { writeIsSink(sink, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = DataFlow::Global<Config>;\n\nimport Flow::PathGraph\n\npredicate hostCheckReachesSink(Flow::PathNode sink) {\n  exists(Flow::PathNode source |\n    not source.getNode() instanceof InsecureHostKeyCallbackFunc and\n    (\n      Flow::flowPath(source, sink)\n      or\n      exists(\n        Flow::PathNode otherSink, Write sinkWrite, Write otherSinkWrite,\n        SsaWithFields sinkAccessPath, SsaWithFields otherSinkAccessPath\n      |\n        Flow::flowPath(source, otherSink) and\n        Config::writeIsSink(sink.getNode(), sinkWrite) and\n        Config::writeIsSink(otherSink.getNode(), otherSinkWrite) and\n        sinkWrite.writesField(sinkAccessPath.getAUse(), _, sink.getNode()) and\n        otherSinkWrite.writesField(otherSinkAccessPath.getAUse(), _, otherSink.getNode()) and\n        otherSinkAccessPath = sinkAccessPath.similar()\n      )\n    )\n  )\n}\n\nfrom Flow::PathNode source, Flow::PathNode sink\nwhere\n  Flow::flowPath(source, sink) and\n  source.getNode() instanceof InsecureHostKeyCallbackFunc and\n  // Exclude cases where a good access-path function reaches the same or a similar sink\n  // (these probably indicate optional host-checking)\n  not hostCheckReachesSink(sink)\nselect sink, source, sink,\n  \"Configuring SSH ClientConfig with insecure HostKeyCallback implementation from $@.\",\n  source.getNode(), \"this source\"",
        "description": "Detects insecure SSL client configurations with an implementation of the `HostKeyCallback` that accepts all host keys.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-322/InsecureHostKeyCallback.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.LogInjection\nimport LogInjection::Flow::PathGraph\n\nfrom LogInjection::Flow::PathNode source, LogInjection::Flow::PathNode sink\nwhere LogInjection::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This log entry depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-117/LogInjection.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.CleartextLogging\nimport CleartextLogging::Flow::PathGraph\n\nfrom CleartextLogging::Flow::PathNode source, CleartextLogging::Flow::PathNode sink\nwhere CleartextLogging::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"$@ flows to a logging call.\", source.getNode(),\n  \"Sensitive data returned by \" + source.getNode().(CleartextLogging::Source).describe()",
        "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-312/CleartextLogging.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.HardcodedCredentials\nimport semmle.go.security.SensitiveActions\n\npredicate isSensitive(DataFlow::Node sink, SensitiveExpr::Classification type) {\n  exists(Write write, string name |\n    pragma[only_bind_out](write).getRhs() = sink and\n    name = pragma[only_bind_out](write).getLhs().getName() and\n    // allow obvious test password variables\n    not name.regexpMatch(HeuristicNames::notSensitive())\n  |\n    name.regexpMatch(HeuristicNames::maybeSensitive(type))\n  )\n}\n\npredicate sensitiveAssignment(\n  DataFlow::Node source, DataFlow::Node sink, SensitiveExpr::Classification type\n) {\n  exists(string val | val = source.getStringValue() and val != \"\" |\n    DataFlow::localFlow(source, sink) and\n    isSensitive(sink, type) and\n    // allow obvious dummy/test values\n    not PasswordHeuristics::isDummyPassword(val) and\n    not sink.asExpr().(Ident).getName().regexpMatch(HeuristicNames::notSensitive())\n  )\n}\n\npredicate hardcodedPrivateKey(DataFlow::Node node, SensitiveExpr::Classification type) {\n  node.getStringValue()\n      .regexpMatch(\"(?s)-+BEGIN\\\\b.*\\\\bPRIVATE KEY-+.+-+END\\\\b.*\\\\bPRIVATE KEY-+\\n?\") and\n  type = SensitiveExpr::certificate()\n}\n\nfrom DataFlow::Node source, string message, DataFlow::Node sink, SensitiveExpr::Classification type\nwhere\n  sensitiveAssignment(source, sink, type) and\n  message = \"Hard-coded $@.\"\n  or\n  hardcodedPrivateKey(source, type) and\n  source = sink and\n  message = \"Hard-coded private key.\"\n  or\n  HardcodedCredentials::Flow::flow(source, sink) and\n  type = SensitiveExpr::secret() and\n  message = \"Hard-coded $@.\"\nselect sink, message, source, type.toString()",
        "description": "Hard-coding credentials in source code may enable an attacker to gain unauthorized access.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-798/HardcodedCredentials.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nclass AuthCodeUrl extends Method {\n  AuthCodeUrl() {\n    this.hasQualifiedName(package(\"golang.org/x/oauth2\", \"\"), \"Config\", \"AuthCodeURL\")\n  }\n}\n\nmodule ConstantStateFlowConfig implements DataFlow::ConfigSig {\n  additional predicate isSinkCall(DataFlow::Node sink, DataFlow::CallNode call) {\n    exists(AuthCodeUrl m | call = m.getACall() | sink = call.getArgument(0))\n  }\n\n  predicate isSource(DataFlow::Node source) {\n    source.isConst() and\n    not DataFlow::isReturnedWithError(source) and\n    // Avoid duplicate paths by not considering reads from constants as sources themselves:\n    (\n      source.asExpr() instanceof StringLit\n      or\n      source.asExpr() instanceof AddExpr\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSinkCall(sink, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Flow = DataFlow::Global<ConstantStateFlowConfig>;\n\nimport Flow::PathGraph\n\npredicate isUrlTaintingConfigStep(DataFlow::Node pred, DataFlow::Node succ) {\n  exists(Write w, Field f |\n    f.hasQualifiedName(package(\"golang.org/x/oauth2\", \"\"), \"Config\", \"RedirectURL\")\n  |\n    w.writesField(succ.(DataFlow::PostUpdateNode).getPreUpdateNode(), f, pred)\n  )\n}\n\nbindingset[result]\nstring getAnOobOauth2Url() {\n  // The following are pseudo-URLs seen in the wild to indicate the authenticating site\n  // should display a code for the user to manually convey, rather than directing:\n  result in [\"urn:ietf:wg:oauth:2.0:oob\", \"urn:ietf:wg:oauth:2.0:oob:auto\", \"oob\", \"code\"] or\n  // Alternatively some non-web tools will create a temporary local webserver to handle the\n  // OAuth2 redirect:\n  result.matches(\"%://localhost%\") or\n  result.matches(\"%://127.0.0.1%\")\n}\n\nmodule PrivateUrlFlowsToAuthCodeUrlCallConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source.getStringValue() = getAnOobOauth2Url() and\n    // Avoid duplicate paths by excluding constant variable references from\n    // themselves being sources:\n    (\n      source.asExpr() instanceof StringLit\n      or\n      source.asExpr() instanceof AddExpr\n    )\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    // Propagate from a RedirectURL field to a whole Config\n    isUrlTaintingConfigStep(pred, succ)\n    or\n    // Propagate across deref and address-taking steps\n    TaintTracking::referenceStep(pred, succ)\n    or\n    // Propagate across Sprintf and similar calls\n    exists(DataFlow::CallNode cn |\n      cn.getACalleeIncludingExternals().asFunction() instanceof Fmt::AppenderOrSprinterFunc\n    |\n      pred = cn.getASyntacticArgument() and succ = cn.getResult()\n    )\n  }\n\n  additional predicate isSinkCall(DataFlow::Node sink, DataFlow::CallNode call) {\n    exists(AuthCodeUrl m | call = m.getACall() | sink = call.getReceiver())\n  }\n\n  predicate isSink(DataFlow::Node sink) { isSinkCall(sink, _) }\n}\n\nmodule PrivateUrlFlowsToAuthCodeUrlCallFlow =\n  DataFlow::Global<PrivateUrlFlowsToAuthCodeUrlCallConfig>;\n\npredicate privateUrlFlowsToAuthCodeUrlCall(DataFlow::CallNode call) {\n  exists(DataFlow::Node receiver |\n    PrivateUrlFlowsToAuthCodeUrlCallFlow::flowTo(receiver) and\n    PrivateUrlFlowsToAuthCodeUrlCallConfig::isSinkCall(receiver, call)\n  )\n}\n\nmodule FlowToPrintConfig implements DataFlow::ConfigSig {\n  additional predicate isSinkCall(DataFlow::Node sink, DataFlow::CallNode call) {\n    exists(LoggerCall logCall | call = logCall |\n      sink = logCall.getAValueFormattedMessageComponent()\n    )\n  }\n\n  predicate isSource(DataFlow::Node source) { source = any(AuthCodeUrl m).getACall().getResult() }\n\n  predicate isSink(DataFlow::Node sink) { isSinkCall(sink, _) }\n}\n\nmodule FlowToPrintFlow = DataFlow::Global<FlowToPrintConfig>;\n\npredicate resultFlowsToPrinter(DataFlow::CallNode authCodeUrlCall) {\n  FlowToPrintFlow::flow(authCodeUrlCall.getResult(), _)\n}\n\nDataFlow::Node getAStdinNode() {\n  exists(ValueEntity v |\n    v.hasQualifiedName(\"os\", \"Stdin\") and result = globalValueNumber(v.getARead()).getANode()\n  )\n}\n\nDataFlow::CallNode getAScannerCall() {\n  result = any(Fmt::Scanner f).getACall()\n  or\n  exists(Fmt::FScanner f |\n    result = f.getACall() and f.getReader().getNode(result) = getAStdinNode()\n  )\n  or\n  exists(Bufio::NewScanner f |\n    result = f.getACall() and f.getReader().getNode(result) = getAStdinNode()\n  )\n}\n\npredicate containsCallToStdinScanner(FuncDef funcDef) { getAScannerCall().getRoot() = funcDef }\n\npredicate seemsLikeDoneWithinATerminal(DataFlow::CallNode authCodeUrlCall) {\n  resultFlowsToPrinter(authCodeUrlCall) and\n  containsCallToStdinScanner(authCodeUrlCall.getRoot())\n}\n\nfrom Flow::PathNode source, Flow::PathNode sink, DataFlow::CallNode sinkCall\nwhere\n  Flow::flowPath(source, sink) and\n  ConstantStateFlowConfig::isSinkCall(sink.getNode(), sinkCall) and\n  // Exclude cases that seem to be oauth flows done from within a terminal:\n  not seemsLikeDoneWithinATerminal(sinkCall) and\n  not privateUrlFlowsToAuthCodeUrlCall(sinkCall)\nselect sink.getNode(), source, sink, \"Using a constant $@ to create oauth2 URLs.\", source.getNode(),\n  \"state string\"",
        "description": "Using a constant value for the `state` in the OAuth 2.0 URL makes the application susceptible to CSRF attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-352/ConstantOauth2State.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.InsecureRandomness\nimport InsecureRandomness::Flow::PathGraph\n\nfrom InsecureRandomness::Flow::PathNode source, InsecureRandomness::Flow::PathNode sink, string kind\nwhere\n  InsecureRandomness::Flow::flowPath(source, sink) and\n  InsecureRandomness::isSinkWithKind(sink.getNode(), kind) and\n  (\n    kind != \"A password-related function\"\n    or\n    sink =\n      min(InsecureRandomness::Flow::PathNode sink2, int line |\n        InsecureRandomness::Flow::flowPath(_, sink2) and\n        sink2.getNode().getRoot() = sink.getNode().getRoot() and\n        line = sink2.getLocation().getStartLine()\n      |\n        sink2 order by line\n      )\n  )\nselect sink.getNode(), source, sink,\n  kind + \" depends on a $@ generated with a cryptographically weak RNG.\", source.getNode(),\n  \"random number\"",
        "description": "Using insufficient randomness as the key of a cryptographic algorithm can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-338/InsecureRandomness.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.UnsafeUnzipSymlink\nimport UnsafeUnzipSymlink::Flow::PathGraph\n\nfrom UnsafeUnzipSymlink::Flow::PathNode source, UnsafeUnzipSymlink::Flow::PathNode sink\nwhere UnsafeUnzipSymlink::Flow::flowPath(source, sink)\nselect source.getNode(), source, sink,\n  \"Unresolved path from an archive header, which may point outside the archive root, is used in $@.\",\n  sink.getNode(), \"symlink creation\"",
        "description": "Extracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten. Extracting symbolic links in particular requires resolving previously extracted links to ensure the destination directory is not escaped.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-022/UnsafeUnzipSymlink.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.ZipSlip\nimport ZipSlip::Flow::PathGraph\n\nfrom ZipSlip::Flow::PathNode source, ZipSlip::Flow::PathNode sink\nwhere ZipSlip::Flow::flowPath(source, sink)\nselect source.getNode(), source, sink,\n  \"Unsanitized archive entry, which may contain '..', is used in a $@.\", sink.getNode(),\n  \"file system operation\"",
        "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-022/ZipSlip.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.TaintedPath\nimport TaintedPath::Flow::PathGraph\n\nfrom TaintedPath::Flow::PathNode source, TaintedPath::Flow::PathNode sink\nwhere TaintedPath::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-022/TaintedPath.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.CommandInjection\n\nmodule Flow =\n  DataFlow::MergePathGraph<CommandInjection::Flow::PathNode,\n    CommandInjection::DoubleDashSanitizingFlow::PathNode, CommandInjection::Flow::PathGraph,\n    CommandInjection::DoubleDashSanitizingFlow::PathGraph>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink\nwhere\n  CommandInjection::Flow::flowPath(source.asPathNode1(), sink.asPathNode1()) or\n  CommandInjection::DoubleDashSanitizingFlow::flowPath(source.asPathNode2(), sink.asPathNode2())\nselect sink.getNode(), source, sink, \"This command depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a system command from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-078/CommandInjection.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.StoredCommand\nimport StoredCommand::Flow::PathGraph\n\nfrom StoredCommand::Flow::PathNode source, StoredCommand::Flow::PathNode sink\nwhere StoredCommand::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This command depends on a $@.\", source.getNode(),\n  \"stored value\"",
        "description": "Building a system command from stored data that is user-controlled can lead to execution of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-078/StoredCommand.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.IncorrectIntegerConversionLib\nimport Flow::PathGraph\n\nfrom\n  Flow::PathNode source, Flow::PathNode sink, DataFlow::CallNode call, DataFlow::Node sinkConverted\nwhere\n  Flow::flowPath(source, sink) and\n  call.getResult(0) = source.getNode() and\n  sinkConverted = sink.getNode().getASuccessor()\nselect sinkConverted, source, sink,\n  \"Incorrect conversion of \" + describeBitSize2(source.getNode()) +\n    \" from $@ to a lower bit size type \" + sinkConverted.getType().getUnderlyingType().getName() +\n    \" without an upper bound check.\", source, call.getTarget().getQualifiedName()",
        "description": "Converting the result of `strconv.Atoi`, `strconv.ParseInt`, and `strconv.ParseUint` to integer types of smaller bit size can produce unexpected values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-681/IncorrectIntegerConversionQuery.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.XPathInjection\nimport XPathInjection::Flow::PathGraph\n\npredicate isStringOrByte(XPathInjection::Flow::PathNode node) {\n  exists(Type t | t = node.getNode().getType().getUnderlyingType() |\n    t instanceof StringType or t instanceof ByteSliceType\n  )\n}\n\nfrom XPathInjection::Flow::PathNode source, XPathInjection::Flow::PathNode sink\nwhere XPathInjection::Flow::flowPath(source, sink) and isStringOrByte(sink)\nselect sink.getNode(), source, sink, \"XPath expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-643/XPathInjection.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.ReflectedXss\nimport ReflectedXss::Flow::PathGraph\n\nfrom\n  ReflectedXss::Flow::PathNode source, ReflectedXss::Flow::PathNode sink, string msg, string part,\n  Locatable partloc\nwhere\n  ReflectedXss::Flow::flowPath(source, sink) and\n  (\n    exists(string kind | kind = sink.getNode().(SharedXss::Sink).getSinkKind() |\n      kind = \"rawtemplate\" and\n      msg = \"Cross-site scripting vulnerability due to $@. The value is $@.\" and\n      part = \"instantiated as a raw template\"\n    )\n    or\n    not exists(sink.getNode().(SharedXss::Sink).getSinkKind()) and\n    msg = \"Cross-site scripting vulnerability due to $@.\" and\n    part = \"\"\n  ) and\n  partloc = sink.getNode().(SharedXss::Sink).getAssociatedLoc()\nselect sink.getNode(), source, sink, msg, source.getNode(), \"user-provided value\", partloc, part",
        "description": "Writing user input directly to an HTTP response allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-079/ReflectedXss.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nclass UnescapedType extends Type {\n  UnescapedType() {\n    this.hasQualifiedName(\"html/template\",\n      [\"CSS\", \"HTML\", \"HTMLAttr\", \"JS\", \"JSStr\", \"Srcset\", \"URL\"])\n  }\n}\n\npredicate isSinkToTemplateExec(DataFlow::Node sink) {\n  exists(Method fn, string methodName, DataFlow::CallNode call |\n    fn.hasQualifiedName(\"html/template\", \"Template\", methodName) and\n    call = fn.getACall()\n  |\n    methodName = \"Execute\" and sink = call.getArgument(1)\n    or\n    methodName = \"ExecuteTemplate\" and sink = call.getArgument(2)\n  )\n}\n\nmodule UntrustedToTemplateExecWithConversionConfig implements DataFlow::StateConfigSig {\n  private newtype TConversionState =\n    TUnconverted() or\n    TConverted(UnescapedType unescapedType)\n\n  /**\n   * The flow state for tracking whether a conversion to an unescaped type has\n   * occurred.\n   */\n  class FlowState extends TConversionState {\n    predicate isBeforeConversion() { this instanceof TUnconverted }\n\n    predicate isAfterConversion(UnescapedType unescapedType) { this = TConverted(unescapedType) }\n\n    /** Gets a textual representation of this element. */\n    string toString() {\n      this.isBeforeConversion() and result = \"Unconverted\"\n      or\n      exists(UnescapedType unescapedType | this.isAfterConversion(unescapedType) |\n        result = \"Converted to \" + unescapedType.getQualifiedName()\n      )\n    }\n  }\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    state.isBeforeConversion() and source instanceof ActiveThreatModelSource\n  }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    state.isAfterConversion(_) and isSinkToTemplateExec(sink)\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node instanceof SharedXss::Sanitizer and not node instanceof SharedXss::HtmlTemplateSanitizer\n    or\n    node.getType() instanceof NumericType\n  }\n\n  /**\n   * When a conversion to a passthrough type is encountered, transition the flow state.\n   */\n  predicate isAdditionalFlowStep(\n    DataFlow::Node pred, FlowState predState, DataFlow::Node succ, FlowState succState\n  ) {\n    exists(ConversionExpr conversion, UnescapedType unescapedType |\n      // If not yet converted, look for a conversion to a passthrough type\n      predState.isBeforeConversion() and\n      succState.isAfterConversion(unescapedType) and\n      succ.(DataFlow::TypeCastNode).getExpr() = conversion and\n      pred.asExpr() = conversion.getOperand() and\n      conversion.getType().getUnderlyingType*() = unescapedType\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule UntrustedToTemplateExecWithConversionFlow =\n  TaintTracking::GlobalWithState<UntrustedToTemplateExecWithConversionConfig>;\n\nimport UntrustedToTemplateExecWithConversionFlow::PathGraph\n\nfrom\n  UntrustedToTemplateExecWithConversionFlow::PathNode untrustedSource,\n  UntrustedToTemplateExecWithConversionFlow::PathNode templateExecCall, UnescapedType unescapedType\nwhere\n  UntrustedToTemplateExecWithConversionFlow::flowPath(untrustedSource, templateExecCall) and\n  templateExecCall.getState().isAfterConversion(unescapedType)\nselect templateExecCall.getNode(), untrustedSource, templateExecCall,\n  \"Data from an $@ will not be auto-escaped because it was converted to template.\" +\n    unescapedType.getName(), untrustedSource.getNode(), \"untrusted source\"",
        "description": "Converting user input to a special type that avoids escaping when fed into an HTML template allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-079/HtmlTemplateEscapingBypassXss.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.security.StoredXss\nimport StoredXss::Flow::PathGraph\n\nfrom StoredXss::Flow::PathNode source, StoredXss::Flow::PathNode sink\nwhere StoredXss::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Stored cross-site scripting vulnerability due to $@.\",\n  source.getNode(), \"stored value\"",
        "description": "Using uncontrolled stored values in HTML allows for a stored cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Security/CWE-079/StoredXss.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.dataflow.ExternalFlow\n\nfrom string package, int pkgs, string kind, string part, int n\nwhere modelCoverage(package, pkgs, kind, part, n)\nselect package, pkgs, kind, part, n",
        "description": "The number of API endpoints covered by MaD models sorted by package and source-, sink-, and summary-kind.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/meta/frameworks/Coverage.ql",
        "language": "go"
    },
    {
        "query": "import go\nimport semmle.go.DiagnosticsReporting\n\nfrom string msg, int sev\nwhere reportableDiagnostics(_, msg, sev)\nselect msg, sev",
        "description": "List all extraction errors for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Diagnostics/ExtractionErrors.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom File f\nwhere exists(f.getRelativePath())\nselect f, \"\"",
        "description": "List all files that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Diagnostics/SuccessfullyExtractedFiles.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nclass AssocNestedExpr extends BinaryExpr {\n  AssocNestedExpr() {\n    exists(BinaryExpr parent, int idx | this = parent.getChildExpr(idx) |\n      // +, *, &&, || and the bitwise operations are associative\n      (\n        this instanceof AddExpr or\n        this instanceof MulExpr or\n        this instanceof BitwiseExpr or\n        this instanceof LogicalBinaryExpr\n      ) and\n      parent.getOperator() = this.getOperator()\n      or\n      // (x*y)/z = x*(y/z)\n      this instanceof MulExpr and parent instanceof DivExpr and idx = 0\n      or\n      // (x/y)%z = x/(y%z)\n      this instanceof DivExpr and parent instanceof ModExpr and idx = 0\n      or\n      // (x+y)-z = x+(y-z)\n      this instanceof AddExpr and parent instanceof SubExpr and idx = 0\n    )\n  }\n}\n\nclass HarmlessNestedExpr extends BinaryExpr {\n  HarmlessNestedExpr() {\n    exists(BinaryExpr parent | this = parent.getAChildExpr() |\n      parent instanceof ComparisonExpr and\n      (this instanceof ArithmeticExpr or this instanceof ShiftExpr)\n      or\n      parent instanceof LogicalExpr and this instanceof ComparisonExpr\n    )\n  }\n}\n\npredicate interestingNesting(BinaryExpr inner, BinaryExpr outer) {\n  inner = outer.getAChildExpr() and\n  not inner instanceof AssocNestedExpr and\n  not inner instanceof HarmlessNestedExpr\n}\n\nint getWhitespaceAroundOperator(BinaryExpr be, string op) {\n  exists(Location left, Location right |\n    be.getLeftOperand().getLocation() = left and\n    be.getRightOperand().getLocation() = right and\n    left.getFile() = right.getFile() and\n    left.getStartLine() = right.getStartLine()\n  |\n    op = be.getOperator() and\n    result = (right.getStartColumn() - left.getEndColumn() - op.length() - 1) / 2\n  )\n}\n\nfrom BinaryExpr inner, BinaryExpr outer, string innerOp, string outerOp\nwhere\n  interestingNesting(inner, outer) and\n  getWhitespaceAroundOperator(inner, innerOp) > getWhitespaceAroundOperator(outer, outerOp)\nselect outer,\n  innerOp + \" is evaluated before \" + outerOp + \", but whitespace suggests the opposite.\"",
        "description": "Nested expressions where the formatting contradicts the grouping enforced by operator precedence are difficult to read and may indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/WhitespaceContradictsPrecedence.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate bounds(RelationalComparisonExpr test, Variable v, string direction) {\n  test.getLesserOperand() = v.getAReference() and direction = \"upward\"\n  or\n  test.getGreaterOperand() = v.getAReference() and direction = \"downward\"\n}\n\npredicate updates(IncDecStmt upd, Variable v, string direction) {\n  upd.getOperand() = v.getAReference() and\n  (\n    upd instanceof IncStmt and direction = \"upward\"\n    or\n    upd instanceof DecStmt and direction = \"downward\"\n  )\n}\n\nfrom ForStmt l, Variable v, string d1, string d2\nwhere\n  bounds(l.getCond(), v, d1) and\n  updates(l.getPost(), v, d2) and\n  d1 != d2 and\n  // `for u = n; u <= n; u--` is a somewhat common idiom\n  not (v.getType().getUnderlyingType() instanceof UnsignedIntegerType and d2 = \"downward\")\nselect l.getPost(), \"This loop counts \" + d2 + \", but its variable is $@ \" + d1 + \".\", l.getCond(),\n  \"bounded\"",
        "description": "A 'for' loop that increments its loop variable but checks it against a lower bound, or decrements its loop variable but checks it against an upper bound, will either stop iterating immediately or keep iterating indefinitely, and is usually indicative of a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/InconsistentLoopOrientation.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nfrom\n  ForStmt fs, Variable i, DataFlow::ElementReadNode idx, GVN a,\n  ControlFlow::ConditionGuardNode cond, DataFlow::CallNode lenA\nwhere\n  // `i` is incremented in `fs`\n  fs.getPost().(IncStmt).getOperand() = i.getAReference() and\n  // `idx` reads `a[i]`\n  idx.reads(a.getANode(), i.getARead()) and\n  // `lenA` is `len(a)`\n  lenA = Builtin::len().getACall() and\n  lenA.getArgument(0) = a.getANode() and\n  // and is checked against a constant\n  exists(DataFlow::Node const | exists(const.getIntValue()) |\n    cond.ensuresNeq(lenA, const) or\n    cond.ensuresLeq(const, lenA, _)\n  ) and\n  cond.dominates(idx.getBasicBlock()) and\n  // and that check happens inside the loop body\n  cond.getCondition().getParent+() = fs\nselect cond.getCondition(), \"This checks the length against a constant, but it $@.\", idx,\n  \"is indexed using a variable\"",
        "description": "Comparing the length of an array to a constant before indexing it using a loop variable may indicate a logic error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/ConstantLengthComparison.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nstring packagePath() { result = package(\"github.com/pkg/errors\", \"\") }\n\npredicate nilTestGuard(DataFlow::Node g, Expr e, boolean outcome) {\n  exists(DataFlow::EqualityTestNode eq, DataFlow::Node otherNode |\n    g = eq and\n    eq.getAnOperand() = Builtin::nil().getARead() and\n    otherNode = eq.getAnOperand() and\n    not otherNode = Builtin::nil().getARead() and\n    e = otherNode.asExpr() and\n    outcome = eq.getPolarity()\n  )\n}\n\nDataFlow::ExprNode getNilFromLocalVariable() {\n  exists(SsaVariable ssa, Write w |\n    w.definesSsaVariable(ssa, Builtin::nil().getARead()) and\n    result.asInstruction() = ssa.getAUse()\n  )\n}\n\nfrom DataFlow::Node n\nwhere\n  n = any(Function f | f.hasQualifiedName(packagePath(), \"Wrap\")).getACall().getArgument(0) and\n  (\n    // ```go\n    // errors.Wrap(nil, \"\")\n    // ```\n    n = Builtin::nil().getARead()\n    or\n    // ```go\n    // var localVar error = nil\n    // errors.Wrap(localVar, \"\")\n    // ```\n    n = getNilFromLocalVariable()\n    or\n    // ```go\n    // if err != nil {\n    // \treturn ...\n    // }\n    // if ok2, _ := f2(input); !ok2 {\n    // \treturn errors.Wrap(err, \"\")\n    // }\n    n = DataFlow::BarrierGuard<nilTestGuard/3>::getABarrierNode()\n  )\nselect n, \"The first argument to 'errors.Wrap' is always nil.\"",
        "description": "Finds calls to `Wrap` from `pkg/errors` where the error argument is always nil.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/WrappedErrorAlwaysNil.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate isNil(DataFlow::Node node) { node = Builtin::nil().getARead() }\n\npredicate calleeMayReturnNilWithError(DataFlow::CallNode call) {\n  not exists(call.getACallee())\n  or\n  exists(FuncDef callee | callee = call.getACallee() |\n    not exists(callee.getBody())\n    or\n    exists(IR::ReturnInstruction ret, DataFlow::Node ptrReturn, DataFlow::Node errReturn |\n      callee = ret.getRoot() and\n      ptrReturn = DataFlow::instructionNode(ret.getResult(0)) and\n      errReturn = DataFlow::instructionNode(ret.getResult(1)) and\n      isNil(ptrReturn) and\n      not isNil(errReturn)\n    )\n  )\n}\n\npredicate isDereferenceableType(Type maybePointer) {\n  exists(Type t | t = maybePointer.getUnderlyingType() |\n    t instanceof PointerType or t instanceof SliceType or t instanceof InterfaceType\n  )\n}\n\npredicate checksValue(IR::Instruction instruction, DataFlow::SsaNode value) {\n  exists(DataFlow::InstructionNode instNode | instNode.asInstruction() = instruction |\n    instNode.(DataFlow::CallNode).getAnArgument() = value.getAUse() or\n    instNode.(DataFlow::EqualityTestNode).getAnOperand() = value.getAUse()\n  )\n  or\n  value.getAUse().asInstruction() = instruction and\n  (\n    exists(ExpressionSwitchStmt s | instruction.(IR::EvalInstruction).getExpr() = s.getExpr())\n    or\n    // This case accounts for both a type-switch or cast used to check `value`\n    exists(TypeAssertExpr e | instruction.(IR::EvalInstruction).getExpr() = e.getExpr())\n  )\n}\n\npredicate returnUncheckedAtNode(\n  DataFlow::CallNode call, ControlFlow::Node node, DataFlow::SsaNode ptr, DataFlow::SsaNode err\n) {\n  (\n    // Base case: check that `ptr` and `err` have appropriate types, and that the callee may return\n    // a nil pointer with an error.\n    ptr.getAPredecessor() = call.getResult(0) and\n    err.getAPredecessor() = call.getResult(1) and\n    call.asInstruction() = node and\n    isDereferenceableType(ptr.getType()) and\n    err.getType() instanceof ErrorType and\n    calleeMayReturnNilWithError(call)\n    or\n    // Recursive case: check that some predecessor is missing a check, and `node` does not itself\n    // check either `ptr` or `err`.\n    // localFlow is used to permit checks via either an SSA phi node or ordinary assignment.\n    returnUncheckedAtNode(call, node.getAPredecessor(), ptr, err) and\n    not exists(DataFlow::SsaNode checked |\n      DataFlow::localFlow(ptr, checked) or DataFlow::localFlow(err, checked)\n    |\n      checksValue(node, checked)\n    )\n  )\n}\n\nfrom\n  DataFlow::CallNode call, DataFlow::SsaNode ptr, DataFlow::SsaNode err,\n  DataFlow::PointerDereferenceNode deref, ControlFlow::Node derefNode\nwhere\n  // `derefNode` is a control-flow node corresponding to `deref`\n  deref.getOperand().asInstruction() = derefNode and\n  // neither `ptr` nor `err`, the return values of `call`, have been checked as of `derefNode`\n  returnUncheckedAtNode(call, derefNode, ptr, err) and\n  // `deref` dereferences `ptr`\n  deref.getOperand() = ptr.getAUse()\nselect deref.getOperand(),\n  \"$@ may be nil at this dereference because $@ may not have been checked.\", ptr,\n  ptr.getSourceVariable().toString(), err, err.getSourceVariable().toString()",
        "description": "When a function returns a pointer alongside an error value, one should normally assume that the pointer may be nil until either the pointer or error has been checked.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/MissingErrorCheck.ql",
        "language": "go"
    },
    {
        "query": "import go\n\npredicate isWritable(Entity flag) {\n  flag.hasQualifiedName(\"os\", \"O_WRONLY\") or\n  flag.hasQualifiedName(\"os\", \"O_RDWR\")\n}\n\nQualifiedName getConstants(ValueExpr expr) {\n  result = expr or\n  result = getConstants(expr.getAChild())\n}\n\nclass OpenFileFun extends Function {\n  OpenFileFun() { this.hasQualifiedName(\"os\", \"OpenFile\") }\n}\n\nclass CloseFileFun extends Method {\n  CloseFileFun() { this.hasQualifiedName(\"os\", \"File\", \"Close\") }\n}\n\nclass SyncFileFun extends Method {\n  SyncFileFun() { this.hasQualifiedName(\"os\", \"File\", \"Sync\") }\n}\n\npredicate unhandledCall(DataFlow::CallNode call) {\n  exists(DeferStmt defer | defer.getCall() = call.asExpr()) or\n  exists(ExprStmt stmt | stmt.getExpr() = call.asExpr())\n}\n\npredicate isWritableFileHandle(DataFlow::Node source, DataFlow::CallNode call) {\n  exists(OpenFileFun f, DataFlow::Node flags, QualifiedName flag |\n    // check that the source is a result of the call\n    source = call.getAResult() and\n    // find a call to the os.OpenFile function\n    f.getACall() = call and\n    // get the flags expression used for opening the file\n    call.getArgument(1) = flags and\n    // extract individual flags from the argument\n    // flag = flag.getAChild*() and\n    flag = getConstants(flags.asExpr()) and\n    // check for one which signals that the handle will be writable\n    // note that we are underestimating here, since the flags may be\n    // specified elsewhere\n    isWritable(flag.getTarget())\n  )\n}\n\npredicate isCloseSink(DataFlow::Node sink, DataFlow::CallNode closeCall) {\n  // find calls to the os.File.Close function\n  closeCall = any(CloseFileFun f).getACall() and\n  // that are unhandled\n  unhandledCall(closeCall) and\n  // where the function is called on the sink\n  closeCall.getReceiver() = sink and\n  // and check that it is not dominated by a call to `os.File.Sync`.\n  // TODO: fix this logic when `closeCall` is in a defer statement.\n  not exists(IR::Instruction syncInstr, DataFlow::Node syncReceiver, DataFlow::CallNode syncCall |\n    // match the instruction corresponding to an `os.File.Sync` call with the predecessor\n    syncCall.asInstruction() = syncInstr and\n    // check that the call to `os.File.Sync` is handled\n    isHandledSync(syncReceiver, syncCall) and\n    // find a predecessor to `closeCall` in the control flow graph which dominates the call to\n    // `os.File.Close`\n    syncInstr.dominatesNode(closeCall.asInstruction()) and\n    // check that `os.File.Sync` is called on the same object as `os.File.Close`\n    exists(DataFlow::SsaNode ssa | ssa.getAUse() = sink and ssa.getAUse() = syncReceiver)\n  )\n}\n\npredicate isHandledSync(DataFlow::Node sink, DataFlow::CallNode syncCall) {\n  // find a call of the `os.File.Sync` function\n  syncCall = any(SyncFileFun f).getACall() and\n  // match the sink with the object on which the method is called\n  syncCall.getReceiver() = sink and\n  // check that the result is neither deferred nor discarded\n  not unhandledCall(syncCall)\n}\n\nmodule UnhandledFileCloseConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { isWritableFileHandle(source, _) }\n\n  predicate isSink(DataFlow::Node sink) { isCloseSink(sink, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    exists(DataFlow::CallNode openCall | result = openCall.getLocation() |\n      isWritableFileHandle(source, openCall)\n    )\n  }\n}\n\nmodule UnhandledFileCloseFlow = DataFlow::Global<UnhandledFileCloseConfig>;\n\nimport UnhandledFileCloseFlow::PathGraph\n\nfrom\n  UnhandledFileCloseFlow::PathNode source, DataFlow::CallNode openCall,\n  UnhandledFileCloseFlow::PathNode sink, DataFlow::CallNode closeCall\nwhere\n  // find data flow from an `os.OpenFile` call to an `os.File.Close` call\n  // where the handle is writable\n  UnhandledFileCloseFlow::flowPath(source, sink) and\n  isWritableFileHandle(source.getNode(), openCall) and\n  // get the `CallNode` corresponding to the sink\n  isCloseSink(sink.getNode(), closeCall)\nselect sink, source, sink,\n  \"File handle may be writable as a result of data flow from a $@ and closing it may result in data loss upon failure, which is not handled explicitly.\",\n  openCall, openCall.toString()",
        "description": "Errors which occur when closing a writable file handle may result in data loss if the data could not be successfully flushed. Such errors should be handled explicitly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/UnhandledCloseWritableHandle.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nnewtype TIndex =\n  VariableIndex(DataFlow::SsaNode v) { v.getAUse() = any(DataFlow::ElementReadNode e).getIndex() } or\n  ConstantIndex(int v) { v = any(DataFlow::ElementReadNode e).getIndex().getIntValue() + [-1 .. 1] }\n\nclass Index extends TIndex {\n  string toString() {\n    exists(DataFlow::SsaNode v | this = VariableIndex(v) | result = v.getSourceVariable().getName())\n    or\n    exists(int v | this = ConstantIndex(v) | result = v.toString())\n  }\n}\n\nDataFlow::Node getAUse(Index i) {\n  i = VariableIndex(any(DataFlow::SsaNode v | result = v.getAUse()))\n  or\n  i = ConstantIndex(result.getIntValue())\n}\n\nDataFlow::CallNode arrayLen(DataFlow::SsaNode array) {\n  result = Builtin::len().getACall() and\n  result.getArgument(0) = array.getAUse()\n}\n\nControlFlow::ConditionGuardNode getLengthLEGuard(Index index, DataFlow::SsaNode array) {\n  result.ensuresLeq(getAUse(index), arrayLen(array), 0)\n  or\n  exists(int i, int bias | index = ConstantIndex(i) |\n    result.ensuresLeq(getAUse(ConstantIndex(i + bias)), arrayLen(array), bias)\n  )\n}\n\nControlFlow::ConditionGuardNode getLengthNEGuard(Index index, DataFlow::SsaNode array) {\n  result.ensuresNeq(getAUse(index), arrayLen(array))\n}\n\npredicate elementRead(\n  DataFlow::ElementReadNode ea, DataFlow::SsaNode array, Index index, BasicBlock bb\n) {\n  ea.reads(array.getAUse(), getAUse(index)) and\n  not array.getType().getUnderlyingType() instanceof MapType and\n  bb = ea.getBasicBlock()\n}\n\npredicate isRegexpMethodCall(DataFlow::MethodCallNode c) {\n  exists(DefinedType regexp, Type recvtp |\n    regexp.getName() = \"Regexp\" and recvtp = c.getReceiver().getType()\n  |\n    lookThroughPointerType(recvtp) = regexp\n  )\n}\n\nfrom\n  ControlFlow::ConditionGuardNode cond, DataFlow::SsaNode array, Index index,\n  DataFlow::ElementReadNode ea, BasicBlock bb\nwhere\n  // there is a comparison `index <= len(array)`\n  cond = getLengthLEGuard(index, array) and\n  // there is a read from `array[index]`\n  elementRead(ea, array, index, bb) and\n  // and the read is guarded by the comparison\n  cond.dominates(bb) and\n  // but the read is not guarded by another check that `index != len(array)`\n  not getLengthNEGuard(index, array).dominates(bb) and\n  // and it is not additionally guarded by a stronger index check\n  not exists(Index index2, int i, int i2 |\n    index = ConstantIndex(i) and index2 = ConstantIndex(i2) and i < i2\n  |\n    getLengthLEGuard(index2, array).dominates(bb)\n  ) and\n  not isRegexpMethodCall(array.getInit())\nselect cond.getCondition(),\n  \"Off-by-one index comparison against length may lead to out-of-bounds $@.\", ea, \"read\"",
        "description": "An array index is compared with the length of the array, and then used in an indexing operation that could be out of bounds.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/LengthComparisonOffByOne.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nprivate Expr getConstantInitialiser(Expr e) {\n  exists(DeclaredConstant c | e = c.getAReference() | result = c.getInit())\n}\n\npredicate maybeXorBitPattern(Expr e) {\n  // 0 makes no sense as an xor bit pattern\n  not e.getNumericValue() = 0 and\n  // include octal and hex literals\n  [e, getConstantInitialiser(e)].(IntLit).getText().matches(\"0%\")\n  or\n  e.getNumericValue() = 1\n}\n\nfrom XorExpr xe, Expr lhs, Expr rhs\nwhere\n  lhs = xe.getLeftOperand() and\n  rhs = xe.getRightOperand() and\n  exists(lhs.getNumericValue()) and\n  not maybeXorBitPattern(lhs) and\n  (\n    not maybeXorBitPattern(rhs) and\n    rhs.getIntValue() >= 0\n    or\n    exists(Ident id | id = xe.getRightOperand() |\n      id.getName().regexpMatch(\"(?i)_*((exp(onent)?)|pow(er)?)\")\n    )\n  ) and\n  // exclude the right hand side of assignments to variables that have \"mask\" in their name\n  not exists(Assignment assign, Ident id | assign.getRhs() = xe.getParent*() |\n    id.getName().regexpMatch(\"(?i).*mask.*\") and\n    (\n      assign.getLhs() = id or\n      assign.getLhs().(SelectorExpr).getSelector() = id\n    )\n  )\nselect xe,\n  \"This expression uses the bitwise exclusive-or operator when exponentiation was likely meant.\"",
        "description": "Using ^ as exponentiation is a mistake, as it is the bitwise exclusive-or operator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/InconsistentCode/MistypedExponentiation.ql",
        "language": "go"
    },
    {
        "query": "import go\n\nselect sum(GoFile f | | f.getNumberOfLinesOfCode())",
        "description": "The total number of lines of Go code across all extracted files, including auto-generated files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/go/ql/src/Summary/LinesOfCode.ql",
        "language": "go"
    },
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import semmle.code.java.Javadoc\n\nclass SingleLineComment extends Javadoc {\n  SingleLineComment() {\n    isEolComment(this)\n    or\n    isNormalComment(this) and exists(int line | this.hasLocationInfo(_, line, _, line, _))\n  }\n\n  string getText() { result = this.getChild(0).getText() }\n}\n\nimport AS::Make<Top, SingleLineComment>",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/AlertSuppression.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Metrics.Internal.Extents\n\nbindingset[s]\nstring getAnnotationText(string s) {\n  // match `lgtm[...]` or `codeql[...]` anywhere in the comment\n  result = s.regexpFind(\"(?i)\\\\b(lgtm|codeql)\\\\s*\\\\[[^\\\\]]*\\\\]\", _, _).trim()\n}\n\nclass SuppressionAnnotation extends SuppressWarningsAnnotation {\n  string text;\n\n  SuppressionAnnotation() {\n    text = this.getASuppressedWarning() and\n    exists(getAnnotationText(text))\n  }\n\n  /**\n   * Gets the text of this suppression annotation.\n   */\n  string getText() { result = text }\n\n  private Annotation getASiblingAnnotation() {\n    result = this.getAnnotatedElement().(Annotatable).getAnAnnotation() and\n    (\n      this.getAnnotatedElement() instanceof Callable or\n      this.getAnnotatedElement() instanceof RefType\n    )\n  }\n\n  private Annotation firstAnnotation() {\n    result =\n      min(this.getASiblingAnnotation() as m\n        order by\n          m.getLocation().getStartLine(), m.getLocation().getStartColumn()\n      )\n  }\n\n  /**\n   * Holds if this annotation applies to the range from column `startcolumn` of line `startline`\n   * to column `endcolumn` of line `endline` in file `filepath`.\n   */\n  predicate covers(string filepath, int startline, int startcolumn, int endline, int endcolumn) {\n    if this.firstAnnotation().hasLocationInfo(filepath, _, _, _, _)\n    then\n      this.getAnnotatedElement().hasLocationInfo(filepath, _, _, endline, endcolumn) and\n      this.firstAnnotation().hasLocationInfo(filepath, startline, startcolumn, _, _)\n    else\n      this.getAnnotatedElement()\n          .hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n\n  /** Gets the scope of this suppression. */\n  SuppressionScope getScope() { this = result.getSuppressionAnnotation() }\n}\n\nclass SuppressionScope extends @annotation instanceof SuppressionAnnotation {\n  /** Gets a suppression annotation with this scope. */\n  SuppressionAnnotation getSuppressionAnnotation() { result = this }\n\n  /**\n   * Holds if this element is at the specified location.\n   * The location spans column `startcolumn` of line `startline` to\n   * column `endcolumn` of line `endline` in file `filepath`.\n   * For more information, see\n   * [Locations](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    super.covers(filepath, startline, startcolumn, endline, endcolumn)\n  }\n\n  /** Gets a textual representation of this element. */\n  string toString() { result = \"suppression range\" }\n}\n\nfrom SuppressionAnnotation c, string text, string annotationText\nwhere\n  text = c.getText() and\n  annotationText = getAnnotationText(text)\nselect c, // suppression entity\n  text, // full text of suppression string\n  annotationText.regexpReplaceAll(\"(?i)^codeql\", \"lgtm\"), // LGTM suppression annotation text\n  c.getScope() // scope of suppression",
        "description": "Generates information about alert suppressions using 'SuppressWarnings' annotations.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/AlertSuppressionAnnotations.ql",
        "language": "java"
    },
    {
        "query": "import definitions\n\nfrom Element e, Element def, string kind\nwhere def = definitionOf(e, kind)\nselect e, def, kind",
        "description": "Generates use-definition pairs that provide the data for jump-to-definition in the code viewer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/definitions.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass IdentifierElement extends Element {\n  IdentifierElement() {\n    this instanceof CompilationUnit or\n    this.(RefType).isSourceDeclaration() or\n    this.(Callable).isSourceDeclaration() or\n    this instanceof Variable\n  }\n}\n\nfrom IdentifierElement e, string msg\nwhere\n  e.getCompilationUnit().isJavaSourceFile() and\n  not e.(Constructor).isDefaultConstructor() and\n  (\n    e.getName() = \"_\" and\n    msg = \".\"\n    or\n    e.(CompilationUnit).getPackage().getName().splitAt(\".\") = \"_\" and\n    msg = \" in package name '\" + e.(CompilationUnit).getPackage().getName() + \"'.\"\n  )\nselect e, \"Use of underscore as a one-character identifier\" + msg",
        "description": "Use of a single underscore character as an identifier results in a compiler error with Java source level 9 or later.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Compatibility/JDK9/UnderscoreIdentifier.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport JdkInternals\nimport JdkInternalsReplacement\n\npredicate importedType(Import i, RefType t) {\n  i.(ImportType).getImportedType() = t or\n  i.(ImportStaticTypeMember).getTypeHoldingImport() = t or\n  i.(ImportStaticOnDemand).getTypeHoldingImport() = t or\n  i.(ImportOnDemandFromType).getTypeHoldingImport() = t\n}\n\npredicate importedPackage(Import i, Package p) {\n  i.(ImportOnDemandFromPackage).getPackageHoldingImport() = p\n}\n\npredicate typeReplacement(RefType t, string repl) {\n  exists(string old | jdkInternalReplacement(old, repl) | t.getQualifiedName() = old)\n}\n\npredicate packageReplacementForType(RefType t, string repl) {\n  exists(string old, string pkgName |\n    jdkInternalReplacement(old, repl) and t.getPackage().getName() = pkgName\n  |\n    pkgName = old or\n    pkgName.prefix(old.length() + 1) = old + \".\"\n  )\n}\n\npredicate packageReplacement(Package p, string repl) {\n  exists(string old | jdkInternalReplacement(old, repl) |\n    p.getName() = old or\n    p.getName().prefix(old.length() + 1) = old + \".\"\n  )\n}\n\npredicate replacement(RefType t, string repl) {\n  typeReplacement(t, repl)\n  or\n  not typeReplacement(t, _) and packageReplacementForType(t, repl)\n}\n\nabstract class JdkInternalAccess extends Element {\n  abstract string getAccessedApi();\n\n  abstract string getReplacement();\n}\n\nclass JdkInternalTypeAccess extends JdkInternalAccess, TypeAccess {\n  JdkInternalTypeAccess() { jdkInternalApi(this.getType().(RefType).getPackage().getName()) }\n\n  override string getAccessedApi() { result = this.getType().(RefType).getQualifiedName() }\n\n  override string getReplacement() {\n    exists(RefType t | this.getType() = t |\n      (\n        replacement(t, result)\n        or\n        not replacement(t, _) and result = \"unknown\"\n      )\n    )\n  }\n}\n\nclass JdkInternalImport extends JdkInternalAccess, Import {\n  JdkInternalImport() {\n    exists(RefType t | importedType(this, t) | jdkInternalApi(t.getPackage().getName()))\n    or\n    exists(Package p | importedPackage(this, p) | jdkInternalApi(p.getName()))\n  }\n\n  override string getAccessedApi() {\n    exists(RefType t | result = t.getQualifiedName() | importedType(this, t))\n    or\n    exists(Package p | result = p.getName() | importedPackage(this, p))\n  }\n\n  override string getReplacement() {\n    exists(RefType t |\n      importedType(this, t) and\n      (\n        replacement(t, result)\n        or\n        not replacement(t, _) and result = \"unknown\"\n      )\n    )\n    or\n    exists(Package p |\n      importedPackage(this, p) and\n      (\n        packageReplacement(p, result)\n        or\n        not packageReplacement(p, _) and result = \"unknown\"\n      )\n    )\n  }\n}\n\npredicate jdkPackage(Package p) {\n  exists(string pkgName |\n    p.getName() = pkgName or\n    p.getName().prefix(pkgName.length() + 1) = pkgName + \".\"\n  |\n    pkgName =\n      [\n        \"com.sun\", \"sun\", \"java\", \"javax\", \"com.oracle.net\", \"genstubs\", \"jdk\", \"build.tools\",\n        \"org.omg.CORBA\", \"org.ietf.jgss\"\n      ]\n  )\n}\n\nfrom JdkInternalAccess ta, string repl, string msg\nwhere\n  repl = ta.getReplacement() and\n  (if repl = \"unknown\" then msg = \"\" else msg = \" (\" + repl + \")\") and\n  not jdkInternalApi(ta.getCompilationUnit().getPackage().getName()) and\n  not jdkPackage(ta.getCompilationUnit().getPackage())\nselect ta, \"Access to unsupported JDK-internal API '\" + ta.getAccessedApi() + \"'.\" + msg",
        "description": "Use of unsupported JDK-internal APIs may cause compatibility issues when upgrading to newer versions of Java, in particular Java 9.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Compatibility/JDK9/JdkInternalAccess.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate classify(File f, string tag) {\n  f instanceof GeneratedFile and tag = \"generated\"\n  or\n  exists(GeneratedClass gc | gc.getFile() = f | tag = \"generated\")\n  or\n  exists(TestClass tc | tc.getFile() = f | tag = \"test\")\n  or\n  exists(TestMethod tm | tm.getFile() = f | tag = \"test\")\n}\n\nfrom File f, string tag\nwhere classify(f, tag)\nselect f, tag",
        "description": "This query produces a list of all files in a snapshot that are classified as generated code or test code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/filters/ClassifyFiles.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getEfferentSourceCoupling() as n order by n desc",
        "description": "The number of source types on which a type depends.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TEfferentSourceCoupling.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getLackOfCohesionHS() as n order by n desc",
        "description": "Lack of cohesion for a type as defined by Henderson-Sellers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TLackOfCohesionHS.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getNumberOfExplicitFields() as n order by n desc",
        "description": "The number of fields in a class, excluding enum constants.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TNumberOfFields.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t, int n\nwhere\n  t.fromSource() and\n  n = count(Stmt s | s.getEnclosingCallable() = t.getACallable())\nselect t, n order by n desc",
        "description": "The number of statements in the methods and constructors of a type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TNumberOfStatements.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getNumberOfCallables() as n order by n desc",
        "description": "The number of methods and constructors in a reference type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TNumberOfCallables.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getResponse() as n order by n desc",
        "description": "The number of unique methods or constructors that can be called by all the methods or constructors of a class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TResponse.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getNumberOfLinesOfCode() as n order by n desc",
        "description": "The number of lines of code in a type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TLinesOfCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t, float n\nwhere\n  t.fromSource() and\n  n = 100 * t.getMetrics().getEfferentSourceCoupling() / t.getMetrics().getEfferentCoupling()\nselect t, n",
        "description": "The percentage of the types on which a type depends for which we have the source code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TSelfContainedness.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getNumberOfCommentLines() as n order by n desc",
        "description": "The number of lines of comment in a type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TLinesOfComment.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getAfferentCoupling() as n order by n desc",
        "description": "The number of types that depend on a type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TAfferentCoupling.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getEfferentCoupling() as n order by n desc",
        "description": "The number of types on which a class depends.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TEfferentCoupling.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npragma[noopt]\nint complexCallableLines(MetricCallable c, RefType owner) {\n  c.getDeclaringType() = owner and\n  exists(int cc | c.getCyclomaticComplexity() = cc and cc > 18) and\n  result = c.getNumberOfLinesOfCode()\n}\n\nfrom MetricRefType t, int ccLoc, int loc\nwhere\n  t.fromSource() and\n  not t instanceof GeneratedClass and\n  ccLoc = sum(Callable c, int cLoc | cLoc = complexCallableLines(c, t) | cLoc) and\n  loc = t.getNumberOfLinesOfCode() and\n  loc != 0\nselect t, (ccLoc.(float) * 100) / loc as n order by n desc",
        "description": "The percentage of a type's code that is part of a complex method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TPercentageOfComplexCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getInheritanceDepth() as n order by n desc",
        "description": "The depth of a reference type in the inheritance hierarchy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TInheritanceDepth.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t, int n\nwhere\n  t.fromSource() and\n  n =\n    (100 * t.getMetrics().getNumberOfCommentLines()) /\n      (t.getMetrics().getNumberOfCommentLines() + t.getMetrics().getNumberOfLinesOfCode())\nselect t, n order by n desc",
        "description": "The percentage of a type's lines that are comment rather than code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TPercentageOfComments.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere\n  t.fromSource() and\n  (t instanceof ParameterizedType implies t instanceof GenericType) and\n  not t instanceof AnonymousClass\nselect t, t.getMetrics().getSpecialisationIndex() as n order by n desc",
        "description": "The extent to which a subclass overrides the behavior of its superclasses.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TSpecialisationIndex.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Class c, int n\nwhere\n  c.fromSource() and\n  c.isPublic() and\n  n = count(Method m | c.getAMethod() = m and m.isPublic())\nselect c, n order by n desc",
        "description": "The number of public methods in a public class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TSizeOfAPI.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere t.fromSource()\nselect t, t.getMetrics().getLackOfCohesionCK() as n order by n desc",
        "description": "Lack of cohesion for a class as defined by Chidamber and Kemerer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/RefTypes/TLackOfCohesionCK.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit u, int num\nwhere\n  num =\n    strictcount(string s | exists(Documentable d | d.getAuthor() = s and d.getCompilationUnit() = u))\nselect u, num",
        "description": "The number of different authors (by Javadoc tag) of a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Authors/AuthorsPerFile.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.DependencyCounts\n\n\nfrom File sourceFile, int total, string entity\nwhere fileJarDependencyCount(sourceFile, total, entity)\nselect entity, total order by total desc",
        "description": "Count the number of dependencies a Java source file has on jar files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Dependencies/ExternalDependencies.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.DependencyCounts\n\n\nfrom File sourceFile, string entity\nwhere fileJarDependencyCount(sourceFile, _, entity)\nselect entity, sourceFile",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Dependencies/ExternalDependenciesSourceLinks.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate realParent(Stmt inner, Stmt outer) {\n  if skipParent(inner) then realParent(inner.getParent(), outer) else outer = inner.getParent()\n}\n\npredicate skipParent(Stmt s) {\n  exists(Stmt parent | parent = s.getParent() |\n    s instanceof IfStmt and parent.(IfStmt).getElse() = s\n    or\n    parent instanceof BlockStmt\n  )\n}\n\npredicate nestingDepth(Stmt s, int depth) {\n  depth = count(Stmt enclosing | realParent+(s, enclosing))\n}\n\nfrom Method m, int depth\nwhere\n  depth =\n    max(Stmt s, int aDepth | s.getEnclosingCallable() = m and nestingDepth(s, aDepth) | aDepth)\nselect m, depth order by depth",
        "description": "The maximum level of nesting of statements (for example 'if', 'for', 'while') in a method. Blocks are not counted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Callables/StatementNestingDepth.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Callable c\nwhere c.fromSource()\nselect c, c.getMetrics().getNumberOfCommentLines() as n order by n desc",
        "description": "The number of comment lines in a method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Callables/CLinesOfComment.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Callable c\nwhere c.fromSource()\nselect c, c.getMetrics().getNumberOfLinesOfCode() as n order by n desc",
        "description": "The number of lines of code in a method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Callables/CLinesOfCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Callable c\nwhere c.fromSource()\nselect c, c.getMetrics().getNumberOfParameters() as n order by n desc",
        "description": "The number of parameters of a method or constructor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Callables/CNumberOfParameters.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Callable c, int n\nwhere\n  c.fromSource() and\n  n = count(Call call | call.getEnclosingCallable() = c)\nselect c, n order by n desc",
        "description": "The number of calls that is made by a method or constructor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Callables/CNumberOfCalls.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Callable c, int n\nwhere\n  c.fromSource() and\n  n = count(Stmt s | s.getEnclosingCallable() = c)\nselect c, n order by n desc",
        "description": "The number of statements in a method or constructor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Callables/CNumberOfStatements.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Callable c\nwhere c.fromSource()\nselect c, c.getMetrics().getCyclomaticComplexity() as n order by n desc",
        "description": "The number of possible execution paths through a method or constructor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Callables/CCyclomaticComplexity.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.ExternalFlow\n\nfrom string packageAndType, int rows\nwhere\n  exists(string package, string type |\n    packageAndType = package + \";\" + type and\n    rows = strictsum(int n, string kind | modelCoverage(package, _, kind, type, n) | n)\n  )\nselect packageAndType, rows",
        "description": "Expose metrics for the number of API endpoints covered by CSV models.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Summaries/FrameworkCoverage.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nselect sum(CompilationUnit f |\n    f.fromSource() and f.isKotlinSourceFile()\n  |\n    f.getNumberOfLinesOfCode()\n  )",
        "description": "The total number of lines of code across all Kotlin files. This is a useful metric of the size of a database. For all Kotlin files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Summaries/LinesOfCodeKotlin.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport GeneratedVsManualCoverageQuery\n\nfrom\n  string package, int generatedOnly, int both, int manualOnly, int non, int all, float coverage,\n  float generatedCoverage, float manualCoverage, float manualCoveredByGenerated,\n  float generatedCoveredByManual, float match\nwhere\n  modelCoverageGenVsMan(package, generatedOnly, both, manualOnly, non, all, coverage,\n    generatedCoverage, manualCoverage, manualCoveredByGenerated, generatedCoveredByManual, match,\n    \"allApis\")\nselect package, generatedOnly, both, manualOnly, non, all, coverage, generatedCoverage,\n  manualCoverage, manualCoveredByGenerated, generatedCoveredByManual, match order by package",
        "description": "Expose metrics for the number of API endpoints covered by generated versus manual MaD models.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Summaries/GeneratedVsManualCoverage.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nselect sum(CompilationUnit f | f.fromSource() | f.getNumberOfLinesOfCode())",
        "description": "The total number of lines of code across all Java and Kotlin files. This is a useful metric of the size of a database. For all source files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Summaries/LinesOfCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nselect sum(CompilationUnit f | f.fromSource() and f.isJavaSourceFile() | f.getNumberOfLinesOfCode())",
        "description": "The total number of lines of code across all Java files. This is a useful metric of the size of a database. For all Java files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Summaries/LinesOfCodeJava.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom File f, int n\nwhere n = f.getTotalNumberOfLines()\nselect f, n order by n desc",
        "description": "The number of lines in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FLines.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, float comments, float loc, float ratio\nwhere\n  f.getTotalNumberOfLines() > 0 and\n  comments = f.getNumberOfCommentLines() and\n  loc = f.getTotalNumberOfLines() and\n  ratio = 100.0 * comments / loc\nselect f, ratio order by ratio desc",
        "description": "The percentage of comment lines in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FCommentRatio.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, int n\nwhere n = count(Interface i | i.fromSource() and i.getCompilationUnit() = f)\nselect f, n order by n desc",
        "description": "The number of interfaces in a compilation unit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FNumberOfInterfaces.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom File f, int n\nwhere n = f.getNumberOfCommentLines()\nselect f, n order by n desc",
        "description": "The number of lines of comment in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FLinesOfComment.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom File f, int n\nwhere none()\nselect f, n order by n desc",
        "description": "The number of lines in a file, including code, comment and whitespace lines, which are duplicated in at least one other place.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FLinesOfDuplicatedCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, float selfContaindness, int efferentSourceCoupling, int efferentCoupling\nwhere\n  efferentSourceCoupling =\n    count(CompilationUnit g |\n      exists(RefType c | c.fromSource() and c.getCompilationUnit() = g |\n        exists(RefType d | d.fromSource() and d.getCompilationUnit() = f | depends(d, c))\n      )\n    ) and\n  efferentCoupling =\n    count(CompilationUnit g |\n      exists(RefType c | c.getCompilationUnit() = g |\n        exists(RefType d | d.fromSource() and d.getCompilationUnit() = f | depends(d, c))\n      )\n    ) and\n  if efferentCoupling = 0\n  then selfContaindness = 100\n  else selfContaindness = 100 * efferentSourceCoupling.(float) / efferentCoupling\nselect f, selfContaindness order by selfContaindness desc",
        "description": "The percentage of the types on which a compilation unit depends for which we have the source code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FSelfContainedness.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, int n\nwhere n = count(Class c | c.fromSource() and c.getCompilationUnit() = f)\nselect f, n order by n desc",
        "description": "The number of classes in a compilation unit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FNumberOfClasses.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom File f, int n\nwhere n = f.getNumberOfLinesOfCode()\nselect f, n order by n desc",
        "description": "The number of lines of code in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FLinesOfCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, int n\nwhere n = strictcount(TestMethod test | test.fromSource() and test.getCompilationUnit() = f)\nselect f, n order by n desc",
        "description": "The number of test methods defined in a compilation unit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FNumberOfTests.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, float n\nwhere\n  n =\n    avg(Callable c, int toAvg |\n      c.getCompilationUnit() = f and toAvg = c.getMetrics().getCyclomaticComplexity()\n    |\n      toAvg\n    )\nselect f, n",
        "description": "The average cyclomatic complexity of the methods in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FCyclomaticComplexity.ql",
        "language": "java"
    },
    {
        "query": "import Violations_of_Best_Practice.Comments.CommentedCode\n\nfrom File f, int n\nwhere n = sum(CommentedOutCode comment | comment.getFile() = f | comment.getCodeLines())\nselect f, n order by n desc",
        "description": "The number of lines of commented-out code in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FLinesOfCommentedCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom File f, int n\nwhere none()\nselect f, n order by n desc",
        "description": "The number of lines in a file, including code, comment and whitespace lines, which are similar to lines in at least one other place.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FLinesOfSimilarCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, int n\nwhere\n  n =\n    count(File g |\n      exists(Class c | c.fromSource() and c.getCompilationUnit() = f |\n        exists(Class d | d.fromSource() and d.getCompilationUnit() = g | depends(d, c))\n      )\n    )\nselect f, n order by n desc",
        "description": "The number of compilation units that depend on a compilation unit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FAfferentCoupling.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CompilationUnit f, int n\nwhere\n  n =\n    count(File g |\n      exists(Class c | c.fromSource() and c.getCompilationUnit() = g |\n        exists(Class d | d.fromSource() and d.getCompilationUnit() = f | depends(d, c))\n      )\n    )\nselect f, n order by n desc",
        "description": "The number of compilation units on which a compilation unit depends.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Metrics/Files/FEfferentCoupling.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.Maps\n\npredicate isRmiOrJmxServerCreateConstructor(Constructor constructor) {\n  constructor\n      .getDeclaringType()\n      .hasQualifiedName(\"javax.management.remote.rmi\", \"RMIConnectorServer\")\n}\n\npredicate isRmiOrJmxServerCreateMethod(Method method) {\n  method.getName() = \"newJMXConnectorServer\" and\n  method.getDeclaringType().hasQualifiedName(\"javax.management.remote\", \"JMXConnectorServerFactory\")\n}\n\nmodule SafeFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { putsCredentialtypesKey(source.asExpr()) }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(Call c |\n      isRmiOrJmxServerCreateConstructor(c.getCallee()) or\n      isRmiOrJmxServerCreateMethod(c.getCallee())\n    |\n      sink.asExpr() = c.getArgument(1)\n    )\n  }\n\n  /**\n   * Holds if a `put` call on `qualifier` puts a key match\n   * into the map.\n   */\n  private predicate putsCredentialtypesKey(Expr qualifier) {\n    exists(MapPutCall put |\n      put.getKey().(CompileTimeConstantExpr).getStringValue() =\n        [\n          \"jmx.remote.rmi.server.credential.types\",\n          \"jmx.remote.rmi.server.credentials.filter.pattern\"\n        ]\n      or\n      put.getKey()\n          .(FieldAccess)\n          .getField()\n          .hasQualifiedName(\"javax.management.remote.rmi\", \"RMIConnectorServer\",\n            [\"CREDENTIAL_TYPES\", \"CREDENTIALS_FILTER_PATTERN\"])\n    |\n      put.getQualifier() = qualifier and\n      put.getMethod().(MapMethod).getReceiverKeyType() instanceof TypeString and\n      put.getMethod().(MapMethod).getReceiverValueType() instanceof TypeObject\n    )\n  }\n}\n\nmodule SafeFlow = DataFlow::Global<SafeFlowConfig>;\n\nstring getRmiResult(Expr e) {\n  // We got a Map so we have a source and a sink node\n  if e instanceof NullLiteral\n  then\n    result =\n      \"RMI/JMX server initialized with a null environment. Missing type restriction in RMI authentication method exposes the application to deserialization attacks.\"\n  else\n    result =\n      \"RMI/JMX server initialized with insecure environment $@, which never restricts accepted client objects to 'java.lang.String'. This exposes to deserialization attacks against the RMI authentication method.\"\n}\n\ndeprecated query predicate problems(Call c, string message1, Expr envArg, string message2) {\n  (isRmiOrJmxServerCreateConstructor(c.getCallee()) or isRmiOrJmxServerCreateMethod(c.getCallee())) and\n  envArg = c.getArgument(1) and\n  not SafeFlow::flowToExpr(envArg) and\n  message1 = getRmiResult(envArg) and\n  message2 = envArg.toString()\n}",
        "description": "This query detects if a JMX/RMI server is created with a potentially dangerous environment, which could lead to code execution through insecure deserialization.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-665/InsecureRmiJmxEnvironmentConfiguration.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\ndeprecated import NonConstantTimeCheckOnSignatureQuery\ndeprecated import NonConstantTimeCryptoComparisonFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, NonConstantTimeCryptoComparisonFlow::PathNode source,\n  NonConstantTimeCryptoComparisonFlow::PathNode sink, string message1,\n  NonConstantTimeCryptoComparisonFlow::PathNode source0, string message2\n) {\n  NonConstantTimeCryptoComparisonFlow::flowPath(source, sink) and\n  (\n    source.getNode().(CryptoOperationSource).includesUserInput() and\n    sinkNode.(NonConstantTimeComparisonSink).includesUserInput()\n  ) and\n  sinkNode = sink.getNode() and\n  message1 = \"Timing attack against $@ validation.\" and\n  source = source0 and\n  message2 = source.getNode().(CryptoOperationSource).getCall().getResultType()\n}",
        "description": "When checking a signature over a message, a constant-time algorithm should be used. Otherwise, an attacker may be able to forge a valid signature for an arbitrary message by running a timing attack if they can send to the validation procedure both the message and the signature. A successful attack can result in authentication bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-208/TimingAttackAgainstSignature.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\ndeprecated import NonConstantTimeCheckOnSignatureQuery\ndeprecated import NonConstantTimeCryptoComparisonFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, NonConstantTimeCryptoComparisonFlow::PathNode source,\n  NonConstantTimeCryptoComparisonFlow::PathNode sink, string message1,\n  NonConstantTimeCryptoComparisonFlow::PathNode source0, string message2\n) {\n  NonConstantTimeCryptoComparisonFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Possible timing attack against $@ validation.\" and\n  source = source0 and\n  message2 = source.getNode().(CryptoOperationSource).getCall().getResultType()\n}",
        "description": "When checking a signature over a message, a constant-time algorithm should be used. Otherwise, there is a risk of a timing attack that allows an attacker to forge a valid signature for an arbitrary message. For a successful attack, the attacker has to be able to send to the validation procedure both the message and the signature.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-208/PossibleTimingAttackAgainstSignature.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\nimport NonConstantTimeComparisonFlow::PathGraph\n\nprivate class NonConstantTimeComparisonCall extends StaticMethodCall {\n  NonConstantTimeComparisonCall() {\n    this.getMethod()\n        .hasQualifiedName(\"org.apache.commons.lang3\", \"StringUtils\",\n          [\"equals\", \"equalsAny\", \"equalsAnyIgnoreCase\", \"equalsIgnoreCase\"])\n  }\n}\n\nprivate class NonConstantTimeEqualsCall extends MethodCall {\n  NonConstantTimeEqualsCall() {\n    this.getMethod()\n        .hasQualifiedName(\"java.lang\", \"String\", [\"equals\", \"contentEquals\", \"equalsIgnoreCase\"])\n  }\n}\n\nprivate predicate isNonConstantEqualsCallArgument(Expr e) {\n  exists(NonConstantTimeEqualsCall call | e = [call.getQualifier(), call.getArgument(0)])\n}\n\nprivate predicate isNonConstantComparisonCallArgument(Expr p) {\n  exists(NonConstantTimeComparisonCall call | p = [call.getArgument(0), call.getArgument(1)])\n}\n\nclass ClientSuppliedIpTokenCheck extends DataFlow::Node {\n  ClientSuppliedIpTokenCheck() {\n    exists(MethodCall ma |\n      ma.getMethod().hasName(\"getHeader\") and\n      ma.getArgument(0).(CompileTimeConstantExpr).getStringValue().toLowerCase() in [\n          \"x-auth-token\", \"x-csrf-token\", \"http_x_csrf_token\", \"x-csrf-param\", \"x-csrf-header\",\n          \"http_x_csrf_token\", \"x-api-key\", \"authorization\", \"proxy-authorization\"\n        ] and\n      ma = this.asExpr()\n    )\n  }\n}\n\nmodule NonConstantTimeComparisonConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ClientSuppliedIpTokenCheck }\n\n  predicate isSink(DataFlow::Node sink) {\n    isNonConstantEqualsCallArgument(sink.asExpr()) or\n    isNonConstantComparisonCallArgument(sink.asExpr())\n  }\n}\n\nmodule NonConstantTimeComparisonFlow = TaintTracking::Global<NonConstantTimeComparisonConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, NonConstantTimeComparisonFlow::PathNode source,\n  NonConstantTimeComparisonFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  NonConstantTimeComparisonFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Possible timing attack against $@ validation.\" and\n  sourceNode = source.getNode() and\n  message2 = \"client-supplied token\"\n}",
        "description": "Use of a non-constant-time verification routine to check the value of an HTTP header, possibly allowing a timing attack to infer the header's expected value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-208/TimingAttackAgainstHeader.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.frameworks.Servlets\nimport semmle.code.xml.WebXML\nimport UncaughtServletExceptionFlow::PathGraph\n\nprivate predicate exceptionIsCaught(TryStmt t, RefType exType) {\n  exists(CatchClause cc, LocalVariableDeclExpr v |\n    t.getACatchClause() = cc and\n    cc.getVariable() = v and\n    v.getType().(RefType).getADescendant() = exType and // Detect the case that a subclass exception is thrown but its parent class is declared in the catch clause.\n    not exists(\n      ThrowStmt ts // Detect the edge case that exception is caught then rethrown without processing in a catch clause\n    |\n      ts.getEnclosingStmt() = cc.getBlock() and\n      ts.getExpr() = v.getAnAccess()\n    )\n  )\n}\n\nprivate predicate isServletMethod(Callable c) {\n  c.getDeclaringType() instanceof ServletClass and\n  c.getNumberOfParameters() = 2 and\n  c.getParameter(1).getType() instanceof ServletResponse and\n  c.getName() in [\n      \"doGet\", \"doPost\", \"doPut\", \"doDelete\", \"doHead\", \"doOptions\", \"doTrace\", \"service\"\n    ]\n}\n\nprivate predicate hasErrorPage() {\n  exists(WebErrorPage wep | wep.getPageLocation().getValue() != \"\")\n}\n\nclass UncaughtServletExceptionSink extends DataFlow::ExprNode {\n  UncaughtServletExceptionSink() {\n    exists(Method m, MethodCall ma | ma.getMethod() = m |\n      isServletMethod(ma.getEnclosingCallable()) and\n      exists(m.getAThrownExceptionType()) and // The called method might plausibly throw an exception.\n      ma.getAnArgument() = this.getExpr() and\n      not exists(TryStmt t |\n        t.getBlock() = ma.getAnEnclosingStmt() and\n        exceptionIsCaught(t, m.getAThrownExceptionType())\n      )\n    )\n  }\n}\n\nmodule UncaughtServletExceptionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof UncaughtServletExceptionSink }\n}\n\nmodule UncaughtServletExceptionFlow = TaintTracking::Global<UncaughtServletExceptionConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, UncaughtServletExceptionFlow::PathNode source,\n  UncaughtServletExceptionFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  UncaughtServletExceptionFlow::flowPath(source, sink) and\n  not hasErrorPage() and\n  sinkNode = sink.getNode() and\n  message1 = \"This value depends on a $@ and can throw uncaught exception.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "Uncaught exceptions in a servlet could leave a system in an unexpected state, possibly resulting in denial-of-service attacks or the exposure of sensitive information disclosed in stack traces.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-600/UncaughtServletException.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass SetSystemPropertyMethod extends Method {\n  SetSystemPropertyMethod() {\n    this.hasName(\"setProperty\") and\n    this.getDeclaringType().hasQualifiedName(\"java.lang\", \"System\")\n  }\n}\n\nclass TypeHashtable extends Class {\n  TypeHashtable() { this.getSourceDeclaration().hasQualifiedName(\"java.util\", \"Hashtable\") }\n}\n\nclass SetPropertyMethod extends Method {\n  SetPropertyMethod() {\n    this.getDeclaringType().getAnAncestor() instanceof TypeHashtable and\n    this.hasName([\"put\", \"setProperty\"])\n  }\n}\n\nclass SetSystemPropertiesMethod extends Method {\n  SetSystemPropertiesMethod() {\n    this.hasName(\"setProperties\") and\n    this.getDeclaringType().hasQualifiedName(\"java.lang\", \"System\")\n  }\n}\n\npredicate isPropertyDisableLdapEndpointId(Expr expr) {\n  expr.(CompileTimeConstantExpr).getStringValue() =\n    \"com.sun.jndi.ldap.object.disableEndpointIdentification\"\n  or\n  exists(Field f |\n    expr = f.getAnAccess() and\n    f.getAnAssignedValue().(StringLiteral).getValue() =\n      \"com.sun.jndi.ldap.object.disableEndpointIdentification\"\n  )\n}\n\npredicate isBooleanTrue(Expr expr) {\n  expr.(CompileTimeConstantExpr).getStringValue() = \"true\" // \"true\"\n  or\n  expr.(BooleanLiteral).getBooleanValue() = true // true\n  or\n  exists(MethodCall ma |\n    expr = ma and\n    ma.getMethod() instanceof ToStringMethod and\n    ma.getQualifier().(FieldAccess).getField().hasName(\"TRUE\") and\n    ma.getQualifier()\n        .(FieldAccess)\n        .getField()\n        .getDeclaringType()\n        .hasQualifiedName(\"java.lang\", \"Boolean\") // Boolean.TRUE.toString()\n  )\n}\n\npredicate isTestMethod(MethodCall ma) {\n  ma.getEnclosingCallable() instanceof TestMethod or\n  ma.getEnclosingCallable().getDeclaringType() instanceof TestClass or\n  ma.getEnclosingCallable().getDeclaringType().getPackage().getName().matches(\"%test%\") or\n  ma.getEnclosingCallable().getDeclaringType().getName().toLowerCase().matches(\"%test%\")\n}\n\npredicate isInsecureSslEndpoint(MethodCall ma) {\n  (\n    ma.getMethod() instanceof SetSystemPropertyMethod and\n    isPropertyDisableLdapEndpointId(ma.getArgument(0)) and\n    isBooleanTrue(ma.getArgument(1)) //com.sun.jndi.ldap.object.disableEndpointIdentification=true\n    or\n    ma.getMethod() instanceof SetSystemPropertiesMethod and\n    exists(MethodCall ma2 |\n      ma2.getMethod() instanceof SetPropertyMethod and\n      isPropertyDisableLdapEndpointId(ma2.getArgument(0)) and\n      isBooleanTrue(ma2.getArgument(1)) and //com.sun.jndi.ldap.object.disableEndpointIdentification=true\n      ma2.getQualifier().(VarAccess).getVariable().getAnAccess() = ma.getArgument(0) // systemProps.setProperties(properties)\n    )\n  )\n}\n\ndeprecated query predicate problems(MethodCall ma, string message) {\n  isInsecureSslEndpoint(ma) and\n  not isTestMethod(ma) and\n  message = \"LDAPS configuration allows insecure endpoint identification.\"\n}",
        "description": "Java application configured to disable LDAPS endpoint identification does not validate the SSL certificate to properly ensure that it is actually associated with that host.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-297/InsecureLdapEndpoint.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.Encryption\n\nprivate class HostnameVerificationCall extends MethodCall {\n  HostnameVerificationCall() {\n    this.getMethod() instanceof HostnameVerifierVerify and\n    not this.getCaller() instanceof HostnameVerifierVerify\n  }\n\n  /** Holds if the result of the call is not used. */\n  predicate isIgnored() { this instanceof ValueDiscardingExpr }\n}\n\ndeprecated query predicate problems(HostnameVerificationCall verification, string message) {\n  verification.isIgnored() and\n  message = \"Ignored result of hostname verification.\"\n}",
        "description": "The method HostnameVerifier.verify() returns a result of hostname verification. A caller has to check the result and drop the connection if the verification failed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-297/IgnoredHostnameVerification.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import RevocationCheckingLib\ndeprecated import DisabledRevocationCheckingFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sourceNode, DisabledRevocationCheckingFlow::PathNode source,\n  DisabledRevocationCheckingFlow::PathNode sink, string message\n) {\n  DisabledRevocationCheckingFlow::flowPath(source, sink) and\n  sourceNode = source.getNode() and\n  message = \"This disables revocation checking.\"\n}",
        "description": "Using revoked certificates is dangerous. Therefore, revocation status of certificates in a chain should be checked.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-299/DisabledRevocationChecking.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.dataflow.FlowSources\nimport ScriptInjectionFlow::PathGraph\n\nclass ScriptEngineMethod extends Method {\n  ScriptEngineMethod() {\n    this.getDeclaringType().getAnAncestor().hasQualifiedName(\"javax.script\", \"ScriptEngine\") and\n    this.hasName(\"eval\")\n    or\n    this.getDeclaringType().getAnAncestor().hasQualifiedName(\"javax.script\", \"Compilable\") and\n    this.hasName(\"compile\")\n    or\n    this.getDeclaringType().getAnAncestor().hasQualifiedName(\"javax.script\", \"ScriptEngineFactory\") and\n    this.hasName([\"getProgram\", \"getMethodCallSyntax\"])\n  }\n}\n\nclass RhinoContext extends RefType {\n  RhinoContext() { this.hasQualifiedName(\"org.mozilla.javascript\", \"Context\") }\n}\n\nclass RhinoEvaluateExpressionMethod extends Method {\n  RhinoEvaluateExpressionMethod() {\n    this.getDeclaringType().getAnAncestor*() instanceof RhinoContext and\n    this.hasName([\n        \"evaluateString\", \"evaluateReader\", \"compileFunction\", \"compileReader\", \"compileString\"\n      ])\n  }\n}\n\nclass RhinoCompileClassMethod extends Method {\n  RhinoCompileClassMethod() {\n    this.getDeclaringType()\n        .getAnAncestor()\n        .hasQualifiedName(\"org.mozilla.javascript.optimizer\", \"ClassCompiler\") and\n    this.hasName(\"compileToClassFiles\")\n  }\n}\n\nclass RhinoDefineClassMethod extends Method {\n  RhinoDefineClassMethod() {\n    this.getDeclaringType()\n        .getAnAncestor()\n        .hasQualifiedName(\"org.mozilla.javascript\", \"GeneratedClassLoader\") and\n    this.hasName(\"defineClass\")\n  }\n}\n\npredicate isScriptArgument(MethodCall ma, Expr sink) {\n  exists(ScriptEngineMethod m |\n    m = ma.getMethod() and\n    if m.getDeclaringType().getAnAncestor().hasQualifiedName(\"javax.script\", \"ScriptEngineFactory\")\n    then sink = ma.getArgument(_) // all arguments allow script injection\n    else sink = ma.getArgument(0)\n  )\n}\n\npredicate evaluatesRhinoExpression(MethodCall ma, Expr sink) {\n  exists(RhinoEvaluateExpressionMethod m | m = ma.getMethod() |\n    (\n      if ma.getMethod().getName() = \"compileReader\"\n      then sink = ma.getArgument(0) // The first argument is the input reader\n      else sink = ma.getArgument(1) // The second argument is the JavaScript or Java input\n    ) and\n    not exists(MethodCall ca |\n      ca.getMethod().hasName([\"initSafeStandardObjects\", \"setClassShutter\"]) and // safe mode or `ClassShutter` constraint is enforced\n      ma.getQualifier() = ca.getQualifier().(VarAccess).getVariable().getAnAccess()\n    )\n  )\n}\n\npredicate compilesScript(MethodCall ma, Expr sink) {\n  exists(RhinoCompileClassMethod m | m = ma.getMethod() | sink = ma.getArgument(0))\n}\n\npredicate definesRhinoClass(MethodCall ma, Expr sink) {\n  exists(RhinoDefineClassMethod m | m = ma.getMethod() | sink = ma.getArgument(1))\n}\n\nclass ScriptInjectionSink extends DataFlow::ExprNode {\n  MethodCall methodAccess;\n\n  ScriptInjectionSink() {\n    isScriptArgument(methodAccess, this.getExpr()) or\n    evaluatesRhinoExpression(methodAccess, this.getExpr()) or\n    compilesScript(methodAccess, this.getExpr()) or\n    definesRhinoClass(methodAccess, this.getExpr())\n  }\n\n  /** An access to the method associated with this sink. */\n  MethodCall getMethodCall() { result = methodAccess }\n}\n\nmodule ScriptInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof ScriptInjectionSink }\n}\n\nmodule ScriptInjectionFlow = TaintTracking::Global<ScriptInjectionConfig>;\n\ndeprecated query predicate problems(\n  MethodCall sinkCall, ScriptInjectionFlow::PathNode source, ScriptInjectionFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  ScriptInjectionFlow::flowPath(source, sink) and\n  sinkCall = sink.getNode().(ScriptInjectionSink).getMethodCall() and\n  message1 = \"Java Script Engine evaluate $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user input\"\n}",
        "description": "Evaluation of user-controlled data using the Java Script Engine may lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/ScriptInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\ndeprecated import SpringViewManipulationLib\ndeprecated import SpringViewManipulationFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, SpringViewManipulationFlow::PathNode source,\n  SpringViewManipulationFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  thymeleafIsUsed() and\n  SpringViewManipulationFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Potential Spring Expression Language injection from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "Untrusted input in a Spring View can lead to RCE.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/SpringViewManipulation.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import JShellInjection\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\ndeprecated import JShellInjectionFlow::PathGraph\n\ndeprecated module JShellInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof JShellInjectionSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    exists(SourceCodeAnalysisAnalyzeCompletionCall scaacc |\n      scaacc.getArgument(0) = pred.asExpr() and scaacc = succ.asExpr()\n    )\n    or\n    exists(CompletionInfoSourceOrRemainingCall cisorc |\n      cisorc.getQualifier() = pred.asExpr() and cisorc = succ.asExpr()\n    )\n  }\n}\n\ndeprecated module JShellInjectionFlow = TaintTracking::Global<JShellInjectionConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, JShellInjectionFlow::PathNode source, JShellInjectionFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  JShellInjectionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"JShell injection from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "Evaluation of a user-controlled JShell expression may lead to arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/JShellInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import JakartaExpressionInjectionLib\ndeprecated import JakartaExpressionInjectionFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, JakartaExpressionInjectionFlow::PathNode source,\n  JakartaExpressionInjectionFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  JakartaExpressionInjectionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Jakarta Expression Language injection from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "Evaluation of a user-controlled expression may lead to arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/JakartaExpressionInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.frameworks.spring.SpringController\nimport CodeInjectionFlow::PathGraph\n\nclass PythonInterpreter extends RefType {\n  PythonInterpreter() { this.hasQualifiedName(\"org.python.util\", \"PythonInterpreter\") }\n}\n\nclass InterpretExprMethod extends Method {\n  InterpretExprMethod() {\n    this.getDeclaringType().getAnAncestor*() instanceof PythonInterpreter and\n    this.getName().matches([\"exec%\", \"run%\", \"eval\", \"compile\"])\n  }\n}\n\nclass BytecodeLoader extends RefType {\n  BytecodeLoader() { this.hasQualifiedName(\"org.python.core\", \"BytecodeLoader\") }\n}\n\npredicate runsCode(MethodCall ma, Expr sink) {\n  exists(Method m | m = ma.getMethod() |\n    m instanceof InterpretExprMethod and\n    sink = ma.getArgument(0)\n  )\n}\n\nclass LoadClassMethod extends Method {\n  LoadClassMethod() {\n    this.getDeclaringType().getAnAncestor*() instanceof BytecodeLoader and\n    this.hasName([\"makeClass\", \"makeCode\"])\n  }\n}\n\npredicate loadsClass(MethodCall ma, Expr sink) {\n  exists(Method m, int i | m = ma.getMethod() |\n    m instanceof LoadClassMethod and\n    m.getParameter(i).getType() instanceof Array and // makeClass(java.lang.String name, byte[] data, ...)\n    sink = ma.getArgument(i)\n  )\n}\n\nclass Py extends RefType {\n  Py() { this.hasQualifiedName(\"org.python.core\", \"Py\") }\n}\n\nclass PyCompileMethod extends Method {\n  PyCompileMethod() {\n    this.getDeclaringType().getAnAncestor*() instanceof Py and\n    this.getName().matches(\"compile%\")\n  }\n}\n\npredicate compile(MethodCall ma, Expr sink) {\n  exists(Method m | m = ma.getMethod() |\n    m instanceof PyCompileMethod and\n    sink = ma.getArgument(0)\n  )\n}\n\nclass CodeInjectionSink extends DataFlow::ExprNode {\n  MethodCall methodAccess;\n\n  CodeInjectionSink() {\n    runsCode(methodAccess, this.getExpr()) or\n    loadsClass(methodAccess, this.getExpr()) or\n    compile(methodAccess, this.getExpr())\n  }\n\n  MethodCall getMethodCall() { result = methodAccess }\n}\n\nmodule CodeInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof CodeInjectionSink }\n}\n\nmodule CodeInjectionFlow = TaintTracking::Global<CodeInjectionConfig>;\n\ndeprecated query predicate problems(\n  MethodCall sinkCall, CodeInjectionFlow::PathNode source, CodeInjectionFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  CodeInjectionFlow::flowPath(source, sink) and\n  sinkCall = sink.getNode().(CodeInjectionSink).getMethodCall() and\n  message1 = \"Jython evaluate $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user input\"\n}",
        "description": "Evaluation of a user-controlled malicious expression in Java Python interpreter may lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/JythonInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\ndeprecated import InsecureDexLoading\ndeprecated import InsecureDexFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, InsecureDexFlow::PathNode source, InsecureDexFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  InsecureDexFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Potential arbitrary code execution due to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"a value loaded from a world-writable source.\"\n}",
        "description": "Loading a DEX library located in a world-writable location such as an SD card can lead to arbitrary code execution vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/InsecureDexLoading.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import SpringViewManipulationLib\n\ndeprecated private predicate canResultInImplicitViewConversion(Method m) {\n  m.getReturnType() instanceof VoidType\n  or\n  m.getReturnType() instanceof MapType\n  or\n  m.getReturnType().(RefType).hasQualifiedName(\"org.springframework.ui\", \"Model\")\n}\n\nprivate predicate maybeATestMethod(Method m) {\n  exists(string s |\n    s = m.getName() or\n    s = m.getFile().getRelativePath() or\n    s = m.getDeclaringType().getName()\n  |\n    s.matches([\"%test%\", \"%example%\", \"%exception%\"])\n  )\n}\n\ndeprecated private predicate mayBeExploitable(Method m) {\n  // There should be a attacker controlled parameter in the URI for the attack to be exploitable.\n  // This is possible only when there exists a parameter with the Spring `@PathVariable` annotation\n  // applied to it.\n  exists(Parameter p |\n    p = m.getAParameter() and\n    p.hasAnnotation(\"org.springframework.web.bind.annotation\", \"PathVariable\") and\n    // Having a parameter of say type `Long` is non exploitable as Java type\n    // checking rules are applied prior to view name resolution, rendering the exploit useless.\n    // hence, here we check for the param type to be a Java `String`.\n    p.getType() instanceof TypeString and\n    // Exclude cases where a regex check is applied on a parameter to prevent false positives.\n    not m.(SpringRequestMappingMethod).getValue().matches(\"%{%:[%]%}%\")\n  ) and\n  not maybeATestMethod(m)\n}\n\ndeprecated query predicate problems(SpringRequestMappingMethod m, string message) {\n  thymeleafIsUsed() and\n  mayBeExploitable(m) and\n  canResultInImplicitViewConversion(m) and\n  // If there's a parameter of type`HttpServletResponse`, Spring Framework does not interpret\n  // it as a view name, but just returns this string in HTTP Response preventing exploitation\n  // This also applies to `@ResponseBody` annotation.\n  not m.getParameterType(_) instanceof HttpServletResponse and\n  // A spring request mapping method which does not have response body annotation applied to it\n  m.getAnAnnotation().getType() instanceof SpringRequestMappingAnnotationType and\n  not m.getAnAnnotation().getType() instanceof SpringResponseBodyAnnotationType and\n  // `@RestController` inherits `@ResponseBody` internally so it should be ignored.\n  not m.getDeclaringType() instanceof SpringRestController and\n  message = \"This method may be vulnerable to spring view manipulation vulnerabilities.\"\n}",
        "description": "Untrusted input in a Spring View Controller can lead to RCE.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/SpringImplicitViewManipulation.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import BeanShellInjection\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\ndeprecated import BeanShellInjectionFlow::PathGraph\n\ndeprecated module BeanShellInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof BeanShellInjectionSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node prod, DataFlow::Node succ) {\n    exists(ClassInstanceExpr cie |\n      cie.getConstructedType()\n          .hasQualifiedName(\"org.springframework.scripting.support\", \"StaticScriptSource\") and\n      cie.getArgument(0) = prod.asExpr() and\n      cie = succ.asExpr()\n    )\n    or\n    exists(MethodCall ma |\n      ma.getMethod().hasName(\"setScript\") and\n      ma.getMethod()\n          .getDeclaringType()\n          .hasQualifiedName(\"org.springframework.scripting.support\", \"StaticScriptSource\") and\n      ma.getArgument(0) = prod.asExpr() and\n      ma.getQualifier() = succ.asExpr()\n    )\n  }\n}\n\ndeprecated module BeanShellInjectionFlow = TaintTracking::Global<BeanShellInjectionConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, BeanShellInjectionFlow::PathNode source,\n  BeanShellInjectionFlow::PathNode sink, string message1, DataFlow::Node sourceNode, string message2\n) {\n  BeanShellInjectionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"BeanShell injection from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "Evaluation of a user-controlled BeanShell expression may lead to arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-094/BeanShellInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\ndeprecated import XQueryInjectionLib\ndeprecated import XQueryInjectionFlow::PathGraph\n\ndeprecated module XQueryInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink.asExpr() = any(XQueryPreparedExecuteCall xpec).getPreparedExpression() or\n    sink.asExpr() = any(XQueryExecuteCall xec).getExecuteQueryArgument() or\n    sink.asExpr() = any(XQueryExecuteCommandCall xecc).getExecuteCommandArgument()\n  }\n\n  /**\n   * Holds if taint from the input `pred` to a `prepareExpression` call flows to the returned prepared expression `succ`.\n   */\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    exists(XQueryParserCall parser | pred.asExpr() = parser.getInput() and succ.asExpr() = parser)\n  }\n}\n\ndeprecated module XQueryInjectionFlow = TaintTracking::Global<XQueryInjectionConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, XQueryInjectionFlow::PathNode source, XQueryInjectionFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  XQueryInjectionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"XQuery query might include code from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "Building an XQuery query from user-controlled sources is vulnerable to insertion of malicious XQuery code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-652/XQueryInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.controlflow.Guards\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.security.PathSanitizer\ndeprecated import AndroidWebResourceResponse\ndeprecated import InsecureWebResourceResponseFlow::PathGraph\n\ndeprecated module InsecureWebResourceResponseConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node src) { src instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof WebResourceResponseSink }\n\n  predicate isBarrier(DataFlow::Node node) { node instanceof PathInjectionSanitizer }\n}\n\ndeprecated module InsecureWebResourceResponseFlow =\n  TaintTracking::Global<InsecureWebResourceResponseConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, InsecureWebResourceResponseFlow::PathNode source,\n  InsecureWebResourceResponseFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  InsecureWebResourceResponseFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Leaking arbitrary content in Android from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "An insecure implementation of Android `WebResourceResponse` may lead to leakage of arbitrary sensitive content.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-200/InsecureWebResourceResponse.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.controlflow.Guards\ndeprecated import AndroidFileIntentSink\ndeprecated import AndroidFileIntentSource\ndeprecated import AndroidFileLeakFlow::PathGraph\n\nprivate predicate startsWithSanitizer(Guard g, Expr e, boolean branch) {\n  exists(MethodCall ma |\n    g = ma and\n    ma.getMethod().hasName(\"startsWith\") and\n    e = [ma.getQualifier(), ma.getQualifier().(MethodCall).getQualifier()] and\n    branch = false\n  )\n}\n\ndeprecated module AndroidFileLeakConfig implements DataFlow::ConfigSig {\n  /**\n   * Holds if `src` is a read of some Intent-typed variable guarded by a check like\n   * `requestCode == someCode`, where `requestCode` is the first\n   * argument to `Activity.onActivityResult` and `someCode` is\n   * any request code used in a call to `startActivityForResult(intent, someCode)`.\n   */\n  predicate isSource(DataFlow::Node src) {\n    exists(\n      OnActivityForResultMethod oafr, ConditionBlock cb, CompileTimeConstantExpr cc,\n      VarAccess intentVar\n    |\n      cb.getCondition()\n          .(ValueOrReferenceEqualsExpr)\n          .hasOperands(oafr.getParameter(0).getAnAccess(), cc) and\n      cc.getIntValue() = any(AndroidFileIntentInput fi).getRequestCode() and\n      intentVar.getType() instanceof TypeIntent and\n      cb.controls(intentVar.getBasicBlock(), true) and\n      src.asExpr() = intentVar\n    )\n  }\n\n  /** Holds if it is a sink of file access in Android. */\n  predicate isSink(DataFlow::Node sink) { sink instanceof AndroidFileSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node prev, DataFlow::Node succ) {\n    exists(MethodCall aema, AsyncTaskRunInBackgroundMethod arm |\n      // fileAsyncTask.execute(params) will invoke doInBackground(params) of FileAsyncTask\n      aema.getQualifier().getType() = arm.getDeclaringType() and\n      aema.getMethod() instanceof ExecuteAsyncTaskMethod and\n      prev.asExpr() = aema.getArgument(aema.getMethod().(ExecuteAsyncTaskMethod).getParamIndex()) and\n      succ.asParameter() = arm.getParameter(0)\n    )\n    or\n    exists(MethodCall csma, ServiceOnStartCommandMethod ssm, ClassInstanceExpr ce |\n      // An intent passed to startService will later be passed to the onStartCommand event of the corresponding service\n      csma.getMethod() instanceof ContextStartServiceMethod and\n      ce.getConstructedType() instanceof TypeIntent and // Intent intent = new Intent(context, FileUploader.class);\n      ce.getArgument(1).(TypeLiteral).getReferencedType() = ssm.getDeclaringType() and\n      DataFlow::localExprFlow(ce, csma.getArgument(0)) and // context.startService(intent);\n      prev.asExpr() = csma.getArgument(0) and\n      succ.asParameter() = ssm.getParameter(0) // public int onStartCommand(Intent intent, int flags, int startId) {...} in FileUploader\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node = DataFlow::BarrierGuard<startsWithSanitizer/3>::getABarrierNode()\n  }\n}\n\ndeprecated module AndroidFileLeakFlow = TaintTracking::Global<AndroidFileLeakConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, AndroidFileLeakFlow::PathNode source, AndroidFileLeakFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  AndroidFileLeakFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Leaking arbitrary Android file from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "Using a path specified in an Android Intent without validation could leak arbitrary Android configuration file and sensitive user data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-200/SensitiveAndroidFileLeak.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import experimental.semmle.code.java.security.SpringUrlRedirect\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.controlflow.Guards\ndeprecated import SpringUrlRedirectFlow::PathGraph\n\nprivate predicate startsWithSanitizer(Guard g, Expr e, boolean branch) {\n  g.(MethodCall).getMethod().hasName(\"startsWith\") and\n  g.(MethodCall).getMethod().getDeclaringType() instanceof TypeString and\n  g.(MethodCall).getMethod().getNumberOfParameters() = 1 and\n  e = g.(MethodCall).getQualifier() and\n  branch = true\n}\n\ndeprecated module SpringUrlRedirectFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof SpringUrlRedirectSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node fromNode, DataFlow::Node toNode) {\n    springUrlRedirectTaintStep(fromNode, toNode)\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // Exclude the case where the left side of the concatenated string is not `redirect:`.\n    // E.g: `String url = \"/path?token=\" + request.getParameter(\"token\");`\n    // Note this is quite a broad sanitizer (it will also sanitize the right-hand side of `url = \"http://\" + request.getParameter(\"token\")`);\n    // Consider making this stricter in future.\n    exists(AddExpr ae |\n      ae.getRightOperand() = node.asExpr() and\n      not ae instanceof RedirectBuilderExpr\n    )\n    or\n    exists(MethodCall ma, int index |\n      ma.getMethod().hasName(\"format\") and\n      ma.getMethod().getDeclaringType() instanceof TypeString and\n      ma.getArgument(index) = node.asExpr() and\n      (\n        index != 0 and\n        not ma.getArgument(0).(CompileTimeConstantExpr).getStringValue().regexpMatch(\"^%s.*\")\n      )\n    )\n    or\n    nonLocationHeaderSanitizer(node)\n    or\n    node = DataFlow::BarrierGuard<startsWithSanitizer/3>::getABarrierNode()\n  }\n}\n\ndeprecated module SpringUrlRedirectFlow = TaintTracking::Global<SpringUrlRedirectFlowConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, SpringUrlRedirectFlow::PathNode source,\n  SpringUrlRedirectFlow::PathNode sink, string message1, DataFlow::Node sourceNode, string message2\n) {\n  SpringUrlRedirectFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Potentially untrusted URL redirection due to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "Spring url redirection based on unvalidated user-input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-601/SpringUrlRedirect.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.WebXML\n\nprivate class DefaultTomcatServlet extends WebServletClass {\n  DefaultTomcatServlet() {\n    this.getTextValue() = \"org.apache.catalina.servlets.DefaultServlet\" //Default servlet of Tomcat and other servlet containers derived from Tomcat like Glassfish\n  }\n}\n\nclass DirectoryListingInitParam extends WebXmlElement {\n  DirectoryListingInitParam() {\n    this.getName() = \"init-param\" and\n    this.getAChild(\"param-name\").getTextValue() = \"listings\" and\n    exists(WebServlet servlet |\n      this.getParent() = servlet and\n      servlet.getAChild(\"servlet-class\") instanceof DefaultTomcatServlet\n    )\n  }\n\n  /**\n   * Check the `<param-value>` element (true - enabled, false - disabled)\n   */\n  predicate isListingEnabled() {\n    this.getAChild(\"param-value\").getTextValue().toLowerCase() = \"true\"\n  }\n}\n\ndeprecated query predicate problems(DirectoryListingInitParam initp, string message) {\n  initp.isListingEnabled() and\n  message = \"Directory listing should be disabled to mitigate filename and path disclosure.\"\n}",
        "description": "A directory listing provides an attacker with the complete index of all the resources located inside of the complete web directory, which could yield files containing sensitive information like source code and credentials to the attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-548/InsecureDirectoryConfig.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import SslLib\ndeprecated import UnsafeTlsVersionFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, UnsafeTlsVersionFlow::PathNode source,\n  UnsafeTlsVersionFlow::PathNode sink, string message1, DataFlow::Node sourceNode, string message2\n) {\n  UnsafeTlsVersionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"$@ is unsafe.\" and\n  sourceNode = source.getNode() and\n  message2 = source.getNode().asExpr().(StringLiteral).getValue()\n}",
        "description": "SSL and older TLS versions are known to be vulnerable. TLS 1.3 or at least TLS 1.2 should be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-327/UnsafeTlsVersion.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\n\npredicate isCreatingOutdatedAzureClientSideEncryptionObject(Call call, Class c) {\n  exists(string package, string type, Constructor constructor |\n    c.hasQualifiedName(package, type) and\n    c.getAConstructor() = constructor and\n    call.getCallee() = constructor and\n    (\n      type = \"EncryptedBlobClientBuilder\" and\n      package = \"com.azure.storage.blob.specialized.cryptography\" and\n      constructor.hasNoParameters()\n      or\n      type = \"BlobEncryptionPolicy\" and package = \"com.microsoft.azure.storage.blob\"\n    )\n  )\n}\n\npredicate isCreatingAzureClientSideEncryptionObjectNewVersion(Call call, Class c, Expr versionArg) {\n  exists(string package, string type, Constructor constructor |\n    c.hasQualifiedName(package, type) and\n    c.getAConstructor() = constructor and\n    call.getCallee() = constructor and\n    type = \"EncryptedBlobClientBuilder\" and\n    package = \"com.azure.storage.blob.specialized.cryptography\" and\n    versionArg = call.getArgument(0)\n  )\n}\n\nprivate module EncryptedBlobClientBuilderSafeEncryptionVersionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(FieldRead fr, Field f | fr = source.asExpr() |\n      f.getAnAccess() = fr and\n      f.hasQualifiedName(\"com.azure.storage.blob.specialized.cryptography\", \"EncryptionVersion\",\n        \"V2\")\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    isCreatingAzureClientSideEncryptionObjectNewVersion(_, _, sink.asExpr())\n  }\n}\n\nprivate module EncryptedBlobClientBuilderSafeEncryptionVersionFlow =\n  DataFlow::Global<EncryptedBlobClientBuilderSafeEncryptionVersionConfig>;\n\npredicate isCreatingSafeAzureClientSideEncryptionObject(Call call, Class c, Expr versionArg) {\n  isCreatingAzureClientSideEncryptionObjectNewVersion(call, c, versionArg) and\n  exists(DataFlow::Node sink | sink.asExpr() = versionArg |\n    EncryptedBlobClientBuilderSafeEncryptionVersionFlow::flowTo(sink)\n  )\n}\n\ndeprecated query predicate problems(Expr e, string message) {\n  exists(Class c |\n    exists(Expr argVersion |\n      isCreatingAzureClientSideEncryptionObjectNewVersion(e, c, argVersion) and\n      not isCreatingSafeAzureClientSideEncryptionObject(e, c, argVersion)\n    )\n    or\n    isCreatingOutdatedAzureClientSideEncryptionObject(e, c)\n  ) and\n  message = \"Unsafe usage of v1 version of Azure Storage client-side encryption.\"\n}",
        "description": "Unsafe usage of v1 version of Azure Storage client-side encryption, please refer to http://aka.ms/azstorageclientencryptionblog",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-327/Azure/UnsafeUsageOfClientSideEncryptionVersion.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.security.SensitiveActions\nimport SensitiveGetQueryFlow::PathGraph\n\nclass SensitiveInfoExpr extends Expr {\n  SensitiveInfoExpr() {\n    exists(Variable v | this = v.getAnAccess() |\n      v.getName().regexpMatch(getCommonSensitiveInfoRegex()) and\n      not v.getName().matches(\"token%\") // exclude ^token.* since sensitive tokens are usually in the form of accessToken, authToken, ...\n    )\n  }\n}\n\nprivate predicate isGetServletMethod(Method m) {\n  isServletRequestMethod(m) and m.getName() = \"doGet\"\n}\n\nclass DoGetServletMethod extends Method {\n  DoGetServletMethod() { isGetServletMethod(this) }\n}\n\npredicate isReachableFromServletDoGet(MethodCall ma) {\n  ma.getEnclosingCallable() instanceof DoGetServletMethod\n  or\n  exists(Method pm, MethodCall pma |\n    ma.getEnclosingCallable() = pm and\n    pma.getMethod() = pm and\n    isReachableFromServletDoGet(pma)\n  )\n}\n\nclass RequestGetParamSource extends DataFlow::ExprNode {\n  RequestGetParamSource() {\n    exists(MethodCall ma |\n      isRequestGetParamMethod(ma) and\n      ma = this.asExpr() and\n      isReachableFromServletDoGet(ma)\n    )\n  }\n}\n\nmodule SensitiveGetQueryConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RequestGetParamSource }\n\n  predicate isSink(DataFlow::Node sink) { sink.asExpr() instanceof SensitiveInfoExpr }\n\n  /** Holds if the node is in a servlet method other than `doGet`. */\n  predicate isBarrier(DataFlow::Node node) {\n    isServletRequestMethod(node.getEnclosingCallable()) and\n    not isGetServletMethod(node.getEnclosingCallable())\n  }\n}\n\nmodule SensitiveGetQueryFlow = TaintTracking::Global<SensitiveGetQueryConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, SensitiveGetQueryFlow::PathNode source,\n  SensitiveGetQueryFlow::PathNode sink, string message1, DataFlow::Node sourceNode, string message2\n) {\n  SensitiveGetQueryFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"$@ uses the GET request method to transmit sensitive information.\" and\n  sourceNode = source.getNode() and\n  message2 = \"This request\"\n}",
        "description": "Use of GET request method with sensitive query strings.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-598/SensitiveGetQuery.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport HashWithoutSaltFlow::PathGraph\n\nstring getPasswordRegex() { result = \"(?i).*pass(wd|word|code|phrase).*\" }\n\nclass PasswordVarExpr extends VarAccess {\n  PasswordVarExpr() {\n    exists(string name | name = this.getVariable().getName().toLowerCase() |\n      name.regexpMatch(getPasswordRegex()) and not name.matches(\"%hash%\") // Exclude variable names such as `passwordHash` since their values were already hashed\n    )\n  }\n}\n\npredicate hasAddExprAncestor(AddExpr ae, Expr e) { ae.getAnOperand+() = e }\n\nclass MessageDigest extends RefType {\n  MessageDigest() { this.hasQualifiedName(\"java.security\", \"MessageDigest\") }\n}\n\nclass MDDigestMethod extends Method {\n  MDDigestMethod() {\n    this.getDeclaringType() instanceof MessageDigest and\n    this.hasName(\"digest\")\n  }\n}\n\nclass MDUpdateMethod extends Method {\n  MDUpdateMethod() {\n    this.getDeclaringType() instanceof MessageDigest and\n    this.hasName(\"update\")\n  }\n}\n\nclass MDHashMethodCall extends MethodCall {\n  MDHashMethodCall() {\n    (\n      this.getMethod() instanceof MDDigestMethod or\n      this.getMethod() instanceof MDUpdateMethod\n    ) and\n    this.getNumArgument() != 0\n  }\n}\n\npredicate isHashAccess(MethodCall ma) {\n  ma instanceof MDHashMethodCall\n  or\n  exists(MethodCall mca |\n    ma.getMethod().calls(mca.getMethod()) and\n    isHashAccess(mca) and\n    DataFlow::localExprFlow(ma.getMethod().getAParameter().getAnAccess(), mca.getAnArgument())\n  )\n}\n\npredicate hasAnotherHashCall(MethodCall ma) {\n  isHashAccess(ma) and\n  exists(MethodCall ma2, VarAccess va |\n    ma2 != ma and\n    isHashAccess(ma2) and\n    not va.getVariable().getType() instanceof PrimitiveType and\n    (\n      ma.getQualifier() = va and\n      ma2.getQualifier() = va.getVariable().getAnAccess()\n      or\n      ma.getQualifier() = va and\n      ma2.getAnArgument() = va.getVariable().getAnAccess()\n      or\n      ma.getAnArgument() = va and\n      ma2.getQualifier() = va.getVariable().getAnAccess()\n      or\n      ma.getAnArgument() = va and\n      ma2.getAnArgument() = va.getVariable().getAnAccess()\n    )\n  )\n}\n\npredicate hasHashAncestor(MethodCall ma) {\n  exists(MethodCall mpa |\n    mpa.getMethod().calls(ma.getMethod()) and\n    isHashAccess(mpa) and\n    DataFlow::localExprFlow(mpa.getMethod().getAParameter().getAnAccess(), ma.getAnArgument())\n  )\n}\n\npredicate isSingleHashMethodCall(MethodCall ma) { isHashAccess(ma) and not hasAnotherHashCall(ma) }\n\npredicate isSink(MethodCall ma) { isSingleHashMethodCall(ma) and not hasHashAncestor(ma) }\n\nclass HashWithoutSaltSink extends DataFlow::ExprNode {\n  HashWithoutSaltSink() {\n    exists(MethodCall ma |\n      this.asExpr() = ma.getAnArgument() and\n      isSink(ma)\n    )\n  }\n}\n\nmodule HashWithoutSaltConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.asExpr() instanceof PasswordVarExpr }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof HashWithoutSaltSink }\n\n  /**\n   * Holds if a password is concatenated with a salt then hashed together through the call `System.arraycopy(password.getBytes(), ...)`, for example,\n   *  `System.arraycopy(password.getBytes(), 0, allBytes, 0, password.getBytes().length);`\n   *  `System.arraycopy(salt, 0, allBytes, password.getBytes().length, salt.length);`\n   *  `byte[] messageDigest = md.digest(allBytes);`\n   * Or the password is concatenated with a salt as a string.\n   */\n  predicate isBarrier(DataFlow::Node node) {\n    exists(MethodCall ma |\n      ma.getMethod().getDeclaringType().hasQualifiedName(\"java.lang\", \"System\") and\n      ma.getMethod().hasName(\"arraycopy\") and\n      ma.getArgument(0) = node.asExpr()\n    ) // System.arraycopy(password.getBytes(), ...)\n    or\n    hasAddExprAncestor(_, node.asExpr()) // password+salt\n    or\n    exists(ConditionalExpr ce | ce.getAChildExpr() = node.asExpr()) // useSalt?password+\":\"+salt:password\n    or\n    exists(MethodCall ma |\n      ma.getMethod().getDeclaringType().hasQualifiedName(\"java.lang\", \"StringBuilder\") and\n      ma.getMethod().hasName(\"append\") and\n      ma.getArgument(0) = node.asExpr() // stringBuilder.append(password).append(salt)\n    )\n    or\n    exists(MethodCall ma |\n      ma.getQualifier().(VarAccess).getVariable().getType() instanceof Interface and\n      ma.getAnArgument() = node.asExpr() // Method access of interface type variables requires runtime determination thus not handled\n    )\n  }\n}\n\nmodule HashWithoutSaltFlow = TaintTracking::Global<HashWithoutSaltConfig>;\n\ndeprecated query predicate problems(\n  HashWithoutSaltFlow::PathNode sink, HashWithoutSaltFlow::PathNode source,\n  HashWithoutSaltFlow::PathNode sink0, string message1, HashWithoutSaltFlow::PathNode source0,\n  string message2\n) {\n  HashWithoutSaltFlow::flowPath(source, sink) and\n  sink = sink0 and\n  source = source0 and\n  message1 = \"$@ is hashed without a salt.\" and\n  message2 = \"The password\"\n}",
        "description": "Hashed passwords without a salt are vulnerable to dictionary attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-759/HashWithoutSalt.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nbindingset[value]\npredicate isNotPassword(string value) {\n  value = \"\" // Empty string\n  or\n  value.regexpMatch(\"\\\\$\\\\{.*\\\\}\") // Variable placeholder ${password}\n  or\n  value.matches(\"%=\") // A basic check of encrypted passwords ending with padding characters, which could be improved to be more accurate.\n}\n\nbindingset[value]\npredicate hasEmbeddedPassword(string value) {\n  exists(string password |\n    password = value.regexpCapture(\"(?is).*(pwd|password)\\\\s*=([^;:,]*).*\", 2).trim() and\n    not isNotPassword(password)\n  )\n}\n\ndeprecated query predicate problems(XmlAttribute nameAttr, string message) {\n  (\n    nameAttr.getName().toLowerCase() in [\"password\", \"pwd\"] and\n    not isNotPassword(nameAttr.getValue().trim()) // Attribute name \"password\" or \"pwd\"\n    or\n    exists(\n      XmlAttribute valueAttr // name/value pair like <property name=\"password\" value=\"mysecret\"/>\n    |\n      valueAttr.getElement() = nameAttr.getElement() and\n      nameAttr.getName().toLowerCase() = \"name\" and\n      nameAttr.getValue().toLowerCase() in [\"password\", \"pwd\"] and\n      valueAttr.getName().toLowerCase() = \"value\" and\n      not isNotPassword(valueAttr.getValue().trim())\n    )\n    or\n    hasEmbeddedPassword(nameAttr.getValue().trim()) // Attribute value matches password pattern\n  ) and\n  message = \"Avoid plaintext passwords in configuration files.\"\n}",
        "description": "Finds passwords in configuration files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-555/PasswordInConfigurationFile.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import experimental.semmle.code.java.frameworks.CredentialsInPropertiesFile\n\ndeprecated predicate isNonProdCredentials(CredentialsConfig cc) {\n  cc.getFile().getAbsolutePath().matches([\"%dev%\", \"%test%\", \"%sample%\"])\n}\n\ndeprecated query predicate problems(CredentialsConfig cc, string message) {\n  not isNonProdCredentials(cc) and\n  message = cc.getConfigDesc()\n}",
        "description": "Finds cleartext credentials in Java properties files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-555/CredentialsInPropertiesFile.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import experimental.semmle.code.xml.StrutsXML\n\nbindingset[path]\npredicate isLikelyDemoProject(string path) { path.regexpMatch(\"(?i).*(demo|test|example).*\") }\n\ndeprecated query predicate problems(ConstantParameter c, string message) {\n  c.getNameValue() = \"struts.devMode\" and\n  c.getValueValue() = \"true\" and\n  not isLikelyDemoProject(c.getFile().getRelativePath()) and\n  message = \"Enabling development mode in production environments is dangerous.\"\n}",
        "description": "Enabling struts development mode in production environment can lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-489/devMode.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.Servlets\ndeprecated import TestLib\n\nclass ServletFilterClass extends Class {\n  ServletFilterClass() { this.getAnAncestor().hasQualifiedName(\"javax.servlet\", \"Filter\") }\n}\n\nclass ServletListenerClass extends Class {\n  // Various listener classes of Java EE such as ServletContextListener. They all have a name ending with the word \"Listener\".\n  ServletListenerClass() {\n    this.getAnAncestor()\n        .getQualifiedName()\n        .regexpMatch([\n            \"javax\\\\.servlet\\\\.[a-zA-Z]+Listener\", \"javax\\\\.servlet\\\\.http\\\\.[a-zA-Z]+Listener\"\n          ])\n  }\n}\n\ndeprecated class WebComponentMainMethod extends Method {\n  WebComponentMainMethod() {\n    (\n      this.getDeclaringType() instanceof ServletClass or\n      this.getDeclaringType() instanceof ServletFilterClass or\n      this.getDeclaringType() instanceof ServletListenerClass or\n      this.getDeclaringType().getAnAncestor().hasQualifiedName(\"org.apache.struts.action\", \"Action\") or // Struts actions\n      this.getDeclaringType()\n          .getAStrictAncestor()\n          .hasQualifiedName(\"com.opensymphony.xwork2\", \"ActionSupport\") or // Struts 2 actions\n      this.getDeclaringType()\n          .getAStrictAncestor()\n          .hasQualifiedName(\"org.springframework.web.struts\", \"ActionSupport\") or // Spring/Struts 2 actions\n      this.getDeclaringType()\n          .getAStrictAncestor()\n          .hasQualifiedName(\"org.springframework.webflow.execution\", \"Action\") // Spring actions\n    ) and\n    this instanceof MainMethod and\n    not isTestMethod(this)\n  }\n}\n\ndeprecated query predicate problems(WebComponentMainMethod sm, string message) {\n  exists(sm) and message = \"Web application has a main method.\"\n}",
        "description": "Java EE web applications with a main method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-489/WebComponentMain.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.J2EE\ndeprecated import TestLib\n\ndeprecated class EnterpriseBeanMainMethod extends Method {\n  EnterpriseBeanMainMethod() {\n    this.getDeclaringType() instanceof EnterpriseBean and\n    this instanceof MainMethod and\n    not isTestMethod(this)\n  }\n}\n\ndeprecated query predicate problems(EnterpriseBeanMainMethod sm, string message) {\n  exists(sm) and message = \"Java EE application has a main method.\"\n}",
        "description": "Java EE applications with a main method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-489/EJBMain.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import MyBatisAnnotationSqlInjectionLib\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\nprivate import semmle.code.java.security.Sanitizers\ndeprecated import MyBatisAnnotationSqlInjectionFlow::PathGraph\n\ndeprecated private module MyBatisAnnotationSqlInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof MyBatisAnnotatedMethodCallArgument }\n\n  predicate isBarrier(DataFlow::Node node) { node instanceof SimpleTypeSanitizer }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(MethodCall ma |\n      ma.getMethod().getDeclaringType() instanceof TypeObject and\n      ma.getMethod().getName() = \"toString\" and\n      ma.getQualifier() = node1.asExpr() and\n      ma = node2.asExpr()\n    )\n  }\n}\n\ndeprecated private module MyBatisAnnotationSqlInjectionFlow =\n  TaintTracking::Global<MyBatisAnnotationSqlInjectionConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, MyBatisAnnotationSqlInjectionFlow::PathNode source,\n  MyBatisAnnotationSqlInjectionFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2, IbatisSqlOperationAnnotation isoa, string message3\n) {\n  exists(MethodCall ma, string unsafeExpression |\n    MyBatisAnnotationSqlInjectionFlow::flowPath(source, sink) and\n    ma.getAnArgument() = sinkNode.asExpr() and\n    myBatisSqlOperationAnnotationFromMethod(ma.getMethod(), isoa) and\n    unsafeExpression = getAMybatisAnnotationSqlValue(isoa) and\n    (\n      isMybatisXmlOrAnnotationSqlInjection(sinkNode, ma, unsafeExpression) or\n      isMybatisCollectionTypeSqlInjection(sinkNode, ma, unsafeExpression)\n    )\n  ) and\n  sinkNode = sink.getNode() and\n  message1 = \"MyBatis annotation SQL injection might include code from $@ to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\" and\n  message3 = \"this SQL operation\"\n}",
        "description": "Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisAnnotationSqlInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import MyBatisCommonLib\ndeprecated import MyBatisMapperXmlSqlInjectionLib\nimport semmle.code.java.dataflow.FlowSources\nprivate import semmle.code.java.security.Sanitizers\ndeprecated import MyBatisMapperXmlSqlInjectionFlow::PathGraph\n\ndeprecated private module MyBatisMapperXmlSqlInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof MyBatisMapperMethodCallAnArgument }\n\n  predicate isBarrier(DataFlow::Node node) { node instanceof SimpleTypeSanitizer }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(MethodCall ma |\n      ma.getMethod().getDeclaringType() instanceof TypeObject and\n      ma.getMethod().getName() = \"toString\" and\n      ma.getQualifier() = node1.asExpr() and\n      ma = node2.asExpr()\n    )\n  }\n}\n\ndeprecated private module MyBatisMapperXmlSqlInjectionFlow =\n  TaintTracking::Global<MyBatisMapperXmlSqlInjectionConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, MyBatisMapperXmlSqlInjectionFlow::PathNode source,\n  MyBatisMapperXmlSqlInjectionFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2, MyBatisMapperXmlElement mmxe, string message3\n) {\n  exists(MethodCall ma, string unsafeExpression |\n    MyBatisMapperXmlSqlInjectionFlow::flowPath(source, sink) and\n    ma.getAnArgument() = sinkNode.asExpr() and\n    myBatisMapperXmlElementFromMethod(ma.getMethod(), mmxe) and\n    unsafeExpression = getAMybatisXmlSetValue(mmxe) and\n    (\n      isMybatisXmlOrAnnotationSqlInjection(sinkNode, ma, unsafeExpression)\n      or\n      mmxe instanceof MyBatisMapperForeach and\n      isMybatisCollectionTypeSqlInjection(sinkNode, ma, unsafeExpression)\n    )\n  ) and\n  sinkNode = sink.getNode() and\n  message1 = \"MyBatis Mapper XML SQL injection might include code from $@ to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\" and\n  message3 = \"this SQL operation\"\n}",
        "description": "Constructing a dynamic SQL statement with input that comes from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\ndeprecated import MatchRegexFlow::PathGraph\ndeprecated import PermissiveDotRegexQuery\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, MatchRegexFlow::PathNode source, MatchRegexFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  MatchRegexFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Potentially authentication bypass due to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "URLs validated with a permissive `.` in regular expressions may be vulnerable to an authorization bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-625/PermissiveDotRegex.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.dataflow.ExternalFlow\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.TaintedPathQuery\ndeprecated import JFinalController\nimport semmle.code.java.security.PathSanitizer\nprivate import semmle.code.java.security.Sanitizers\nimport InjectFilePathFlow::PathGraph\n\noverlay[local?]\ndeprecated private class ActivateModels extends ActiveExperimentalModels {\n  ActivateModels() { this = \"file-path-injection\" }\n}\n\nclass PathNormalizeSanitizer extends MethodCall {\n  PathNormalizeSanitizer() {\n    exists(RefType t |\n      t instanceof TypePath or\n      t.hasQualifiedName(\"kotlin.io\", \"FilesKt\")\n    |\n      this.getMethod().getDeclaringType() = t and\n      this.getMethod().hasName(\"normalize\")\n    )\n    or\n    this.getMethod().getDeclaringType() instanceof TypeFile and\n    this.getMethod().hasName([\"getCanonicalPath\", \"getCanonicalFile\"])\n  }\n}\n\nclass NormalizedPathNode extends DataFlow::Node {\n  NormalizedPathNode() {\n    TaintTracking::localExprTaint(this.asExpr(), any(PathNormalizeSanitizer ma))\n  }\n}\n\nmodule InjectFilePathConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink instanceof TaintedPathSink and\n    not sink instanceof NormalizedPathNode\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node instanceof SimpleTypeSanitizer\n    or\n    node instanceof PathInjectionSanitizer\n  }\n}\n\nmodule InjectFilePathFlow = TaintTracking::Global<InjectFilePathConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, InjectFilePathFlow::PathNode source, InjectFilePathFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  InjectFilePathFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"External control of file name or path due to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "Loading files based on unvalidated user-input may cause file information disclosure and uploading files with unvalidated file types to an arbitrary directory may lead to Remote Command Execution (RCE).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-073/FilePathInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import experimental.semmle.code.java.security.DecompressionBombQuery\ndeprecated import DecompressionBombsFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, DecompressionBombsFlow::PathNode source,\n  DecompressionBombsFlow::PathNode sink, string message1, DataFlow::Node sourceNode, string message2\n) {\n  DecompressionBombsFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"This file extraction depends on a $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"potentially untrusted source\"\n}",
        "description": "Decompressing user-controlled files without checking the compression ratio may allow attackers to perform denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-522-DecompressionBombs/DecompressionBomb.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.ExternalFlow\nprivate import semmle.code.java.security.Sanitizers\nimport Log4jInjectionFlow::PathGraph\n\noverlay[local?]\ndeprecated private class ActivateModels extends ActiveExperimentalModels {\n  ActivateModels() { this = \"log4j-injection\" }\n}\n\nclass Log4jInjectionSink extends DataFlow::Node {\n  Log4jInjectionSink() { sinkNode(this, \"log4j\") }\n}\n\nclass Log4jInjectionSanitizer extends DataFlow::Node instanceof SimpleTypeSanitizer { }\n\nmodule Log4jInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof Log4jInjectionSink }\n\n  predicate isBarrier(DataFlow::Node node) { node instanceof Log4jInjectionSanitizer }\n}\n\nmodule Log4jInjectionFlow = TaintTracking::Global<Log4jInjectionConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, Log4jInjectionFlow::PathNode source, Log4jInjectionFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  Log4jInjectionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Log4j log entry depends on a $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "Building Log4j log entries from user-controlled data may allow attackers to inject malicious code through JNDI lookups when using Log4J versions vulnerable to CVE-2021-44228.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-020/Log4jJndiInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import ThreadResourceAbuse\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.dataflow.FlowSources\ndeprecated import ThreadResourceAbuseFlow::PathGraph\n\nclass GetInitParameter extends Method {\n  GetInitParameter() {\n    (\n      this.getDeclaringType()\n          .getAnAncestor()\n          .hasQualifiedName([\"javax.servlet\", \"jakarta.servlet\"],\n            [\"FilterConfig\", \"Registration\", \"ServletConfig\", \"ServletContext\"]) or\n      this.getDeclaringType()\n          .getAnAncestor()\n          .hasQualifiedName([\"javax.faces.context\", \"jakarta.faces.context\"], \"ExternalContext\")\n    ) and\n    this.getName() = \"getInitParameter\"\n  }\n}\n\nclass GetInitParameterAccess extends MethodCall {\n  GetInitParameterAccess() { this.getMethod() instanceof GetInitParameter }\n}\n\nclass InitParameterInput extends LocalUserInput {\n  InitParameterInput() { this.asExpr() instanceof GetInitParameterAccess }\n}\n\ndeprecated module ThreadResourceAbuseConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof LocalUserInput }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof PauseThreadSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    any(AdditionalValueStep r).step(pred, succ)\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    exists(\n      MethodCall ma // Math.min(sleepTime, MAX_INTERVAL)\n    |\n      ma.getMethod().hasQualifiedName(\"java.lang\", \"Math\", \"min\") and\n      node.asExpr() = ma.getAnArgument()\n    )\n    or\n    node instanceof LessThanSanitizer // if (sleepTime > 0 && sleepTime < 5000) { ... }\n  }\n}\n\ndeprecated module ThreadResourceAbuseFlow = TaintTracking::Global<ThreadResourceAbuseConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, ThreadResourceAbuseFlow::PathNode source,\n  ThreadResourceAbuseFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  ThreadResourceAbuseFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Possible uncontrolled resource consumption due to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"local user-provided value\"\n}",
        "description": "Using user input directly to control a thread's sleep time could lead to performance problems or even resource exhaustion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-400/LocalThreadResourceAbuse.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import ThreadResourceAbuse\nimport semmle.code.java.dataflow.FlowSources\ndeprecated import ThreadResourceAbuseFlow::PathGraph\n\ndeprecated module ThreadResourceAbuseConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof PauseThreadSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    any(ThreadResourceAbuseAdditionalTaintStep c).step(pred, succ)\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    exists(\n      MethodCall ma // Math.min(sleepTime, MAX_INTERVAL)\n    |\n      ma.getMethod().hasQualifiedName(\"java.lang\", \"Math\", \"min\") and\n      node.asExpr() = ma.getAnArgument()\n    )\n    or\n    node instanceof LessThanSanitizer // if (sleepTime > 0 && sleepTime < 5000) { ... }\n  }\n}\n\ndeprecated module ThreadResourceAbuseFlow = TaintTracking::Global<ThreadResourceAbuseConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, ThreadResourceAbuseFlow::PathNode source,\n  ThreadResourceAbuseFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  ThreadResourceAbuseFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Vulnerability of uncontrolled resource consumption due to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "Using user input directly to control a thread's sleep time could lead to performance problems or even resource exhaustion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-400/ThreadResourceAbuse.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.Encryption\nimport semmle.code.java.dataflow.DataFlow\n\n\nprivate predicate isSafeJxBrowserVersion() {\n  exists(Method m | m.getDeclaringType() instanceof JxBrowser | m.hasName(\"addBoundsListener\"))\n}\n\nprivate class JxBrowser extends RefType {\n  JxBrowser() { this.hasQualifiedName(\"com.teamdev.jxbrowser.chromium\", \"Browser\") }\n}\n\nprivate class JxBrowserSetLoadHandler extends Method {\n  JxBrowserSetLoadHandler() {\n    this.hasName(\"setLoadHandler\") and this.getDeclaringType() instanceof JxBrowser\n  }\n}\n\nprivate class JxBrowserLoadHandler extends RefType {\n  JxBrowserLoadHandler() { this.hasQualifiedName(\"com.teamdev.jxbrowser.chromium\", \"LoadHandler\") }\n}\n\nprivate predicate isOnCertificateErrorMethodSafe(Method m) {\n  forex(ReturnStmt rs | rs.getEnclosingCallable() = m |\n    rs.getResult().(CompileTimeConstantExpr).getBooleanValue() = true\n  )\n}\n\nprivate class JxBrowserSafeLoadHandler extends RefType {\n  JxBrowserSafeLoadHandler() {\n    this.getASupertype() instanceof JxBrowserLoadHandler and\n    exists(Method m | m.hasName(\"onCertificateError\") and m.getDeclaringType() = this |\n      isOnCertificateErrorMethodSafe(m)\n    )\n  }\n}\n\nprivate module JxBrowserFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node src) {\n    exists(ClassInstanceExpr newJxBrowser | newJxBrowser.getConstructedType() instanceof JxBrowser |\n      newJxBrowser = src.asExpr()\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall ma | ma.getMethod() instanceof JxBrowserSetLoadHandler |\n      ma.getArgument(0).getType() instanceof JxBrowserSafeLoadHandler and\n      ma.getQualifier() = sink.asExpr()\n    )\n  }\n}\n\nprivate module JxBrowserFlow = DataFlow::Global<JxBrowserFlowConfig>;\n\ndeprecated query predicate problems(DataFlow::Node src, string message) {\n  JxBrowserFlowConfig::isSource(src) and\n  not JxBrowserFlow::flow(src, _) and\n  not isSafeJxBrowserVersion() and\n  message = \"This JxBrowser instance may not check HTTPS certificates.\"\n}",
        "description": "Insecure configuration of JxBrowser disables certificate validation making the app vulnerable to man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-295/JxBrowserWithoutCertValidation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.ExternalFlow\nimport RemoteUrlToOpenStreamFlow::PathGraph\n\noverlay[local?]\ndeprecated private class ActivateModels extends ActiveExperimentalModels {\n  ActivateModels() { this = \"openstream-called-on-tainted-url\" }\n}\n\nclass UrlConstructor extends ClassInstanceExpr {\n  UrlConstructor() { this.getConstructor().getDeclaringType() instanceof TypeUrl }\n\n  Expr stringArg() {\n    // Query only in URL's that were constructed by calling the single parameter string constructor.\n    this.getConstructor().getNumberOfParameters() = 1 and\n    this.getConstructor().getParameter(0).getType() instanceof TypeString and\n    result = this.getArgument(0)\n  }\n}\n\nmodule RemoteUrlToOpenStreamFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall m |\n      sink.asExpr() = m.getQualifier() and m.getMethod() instanceof UrlOpenStreamMethod\n    )\n    or\n    sinkNode(sink, \"url-open-stream\")\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(UrlConstructor u |\n      node1.asExpr() = u.stringArg() and\n      node2.asExpr() = u\n    )\n  }\n}\n\nmodule RemoteUrlToOpenStreamFlow = TaintTracking::Global<RemoteUrlToOpenStreamFlowConfig>;\n\ndeprecated query predicate problems(\n  MethodCall call, RemoteUrlToOpenStreamFlow::PathNode source,\n  RemoteUrlToOpenStreamFlow::PathNode sink, string message\n) {\n  sink.getNode().asExpr() = call.getQualifier() and\n  RemoteUrlToOpenStreamFlow::flowPath(source, sink) and\n  message = \"URL on which openStream is called may have been constructed from remote source.\"\n}",
        "description": "Calling openStream on URLs created from remote source can lead to local file disclosure.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-036/OpenStream.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\ndeprecated import JwtAuth0 as JwtAuth0\n\ndeprecated module JwtDecodeConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof RemoteFlowSource and\n    not FlowToJwtVerify::flow(source, _)\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink.asExpr() = any(JwtAuth0::GetPayload a) }\n\n  predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    // Decode Should be one of the middle nodes\n    exists(JwtAuth0::Decode a |\n      nodeFrom.asExpr() = a.getArgument(0) and\n      nodeTo.asExpr() = a\n    )\n    or\n    exists(JwtAuth0::Verify a |\n      nodeFrom.asExpr() = a.getArgument(0) and\n      nodeTo.asExpr() = a\n    )\n    or\n    exists(JwtAuth0::GetPayload a |\n      nodeFrom.asExpr() = a.getQualifier() and\n      nodeTo.asExpr() = a\n    )\n  }\n}\n\ndeprecated module FlowToJwtVerifyConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }\n\n  predicate isSink(DataFlow::Node sink) { sink.asExpr() = any(JwtAuth0::Verify a).getArgument(0) }\n}\n\ndeprecated module JwtDecode = TaintTracking::Global<JwtDecodeConfig>;\n\ndeprecated module FlowToJwtVerify = TaintTracking::Global<FlowToJwtVerifyConfig>;\n\ndeprecated import JwtDecode::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, JwtDecode::PathNode source, JwtDecode::PathNode sink, string message1,\n  DataFlow::Node sourceNode, string message2\n) {\n  JwtDecode::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"This parses a $@, but the signature is not verified.\" and\n  sourceNode = source.getNode() and\n  message2 = \"JWT\"\n}",
        "description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-347/Auth0NoVerifier.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.frameworks.Servlets\nimport semmle.code.java.dataflow.TaintTracking\nimport CorsOriginFlow::PathGraph\n\nprivate predicate setsAllowCredentials(MethodCall header) {\n  (\n    header.getMethod() instanceof ResponseSetHeaderMethod or\n    header.getMethod() instanceof ResponseAddHeaderMethod\n  ) and\n  header.getArgument(0).(CompileTimeConstantExpr).getStringValue().toLowerCase() =\n    \"access-control-allow-credentials\" and\n  header.getArgument(1).(CompileTimeConstantExpr).getStringValue().toLowerCase() = \"true\"\n}\n\nprivate class CorsProbableCheckAccess extends MethodCall {\n  CorsProbableCheckAccess() {\n    this.getMethod().hasName(\"contains\") and\n    this.getMethod().getDeclaringType().getASourceSupertype*() instanceof CollectionType\n    or\n    this.getMethod().hasName(\"containsKey\") and\n    this.getMethod().getDeclaringType().getASourceSupertype*() instanceof MapType\n    or\n    this.getMethod().hasName(\"equals\") and\n    this.getQualifier().getType() instanceof TypeString\n  }\n}\n\nprivate Expr getAccessControlAllowOriginHeaderName() {\n  result.(CompileTimeConstantExpr).getStringValue().toLowerCase() = \"access-control-allow-origin\"\n}\n\nmodule CorsSourceReachesCheckConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { CorsOriginFlow::flow(source, _) }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink.asExpr() = any(CorsProbableCheckAccess check).getAnArgument()\n  }\n}\n\nmodule CorsSourceReachesCheckFlow = TaintTracking::Global<CorsSourceReachesCheckConfig>;\n\nprivate module CorsOriginConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall corsHeader, MethodCall allowCredentialsHeader |\n      (\n        corsHeader.getMethod() instanceof ResponseSetHeaderMethod or\n        corsHeader.getMethod() instanceof ResponseAddHeaderMethod\n      ) and\n      getAccessControlAllowOriginHeaderName() = corsHeader.getArgument(0) and\n      setsAllowCredentials(allowCredentialsHeader) and\n      corsHeader.getEnclosingCallable() = allowCredentialsHeader.getEnclosingCallable() and\n      sink.asExpr() = corsHeader.getArgument(1)\n    )\n  }\n}\n\nprivate module CorsOriginFlow = TaintTracking::Global<CorsOriginConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, CorsOriginFlow::PathNode source, CorsOriginFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  CorsOriginFlow::flowPath(source, sink) and\n  not CorsSourceReachesCheckFlow::flow(sourceNode, _) and\n  sinkNode = sink.getNode() and\n  message1 = \"CORS header is being set using user controlled value $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "CORS header is derived from untrusted input, allowing a remote user to control which origins are trusted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-346/UnvalidatedCors.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.Sanitizers\ndeprecated import ClientSuppliedIpUsedInSecurityCheckLib\ndeprecated import ClientSuppliedIpUsedInSecurityCheckFlow::PathGraph\n\ndeprecated module ClientSuppliedIpUsedInSecurityCheckConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof ClientSuppliedIpUsedInSecurityCheck\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof ClientSuppliedIpUsedInSecurityCheckSink }\n\n  /**\n   * Splitting a header value by `,` and taking an entry other than the first is sanitizing, because\n   * later entries may originate from more-trustworthy intermediate proxies, not the original client.\n   */\n  predicate isBarrier(DataFlow::Node node) {\n    exists(ArrayAccess aa, MethodCall ma | aa.getArray() = ma |\n      ma.getQualifier() = node.asExpr() and\n      ma.getMethod() instanceof SplitMethod and\n      not aa.getIndexExpr().(CompileTimeConstantExpr).getIntValue() = 0\n    )\n    or\n    node instanceof SimpleTypeSanitizer\n  }\n}\n\ndeprecated module ClientSuppliedIpUsedInSecurityCheckFlow =\n  TaintTracking::Global<ClientSuppliedIpUsedInSecurityCheckConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, ClientSuppliedIpUsedInSecurityCheckFlow::PathNode source,\n  ClientSuppliedIpUsedInSecurityCheckFlow::PathNode sink, string message1,\n  DataFlow::Node sourceNode, string message2\n) {\n  ClientSuppliedIpUsedInSecurityCheckFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"IP address spoofing might include code from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "A remote endpoint identifier is read from an HTTP header. Attackers can modify the value of the identifier to forge the client ip.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-348/ClientSuppliedIpUsedInSecurityCheck.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass AndroidRString extends RefType {\n  AndroidRString() { this.hasQualifiedName(_, \"R$string\") }\n}\n\nclass Uri extends RefType {\n  Uri() {\n    this.hasQualifiedName(\"android.net\", \"Uri\") or\n    this.hasQualifiedName(\"java.net\", \"URL\")\n  }\n}\n\nclass UriGetHostMethod extends Method {\n  UriGetHostMethod() {\n    this.getDeclaringType() instanceof Uri and\n    this.hasName(\"getHost\") and\n    this.getNumberOfParameters() = 0\n  }\n}\n\nclass HostVerificationMethodCall extends MethodCall {\n  HostVerificationMethodCall() {\n    (\n      this.getMethod().hasName(\"endsWith\") or\n      this.getMethod().hasName(\"contains\") or\n      this.getMethod().hasName(\"indexOf\")\n    ) and\n    this.getMethod().getNumberOfParameters() = 1 and\n    (\n      this.getArgument(0).(StringLiteral).getValue().charAt(0) != \".\" //string constant comparison e.g. uri.getHost().endsWith(\"example.com\")\n      or\n      this.getArgument(0)\n          .(AddExpr)\n          .getLeftOperand()\n          .(VarAccess)\n          .getVariable()\n          .getAnAssignedValue()\n          .(StringLiteral)\n          .getValue()\n          .charAt(0) != \".\" //var1+var2, check var1 starts with \".\" e.g. String domainName = \"example\"; Uri.parse(url).getHost().endsWith(domainName+\".com\")\n      or\n      this.getArgument(0).(AddExpr).getLeftOperand().(StringLiteral).getValue().charAt(0) != \".\" //\".\"+var2, check string constant \".\" e.g. String domainName = \"example.com\";  Uri.parse(url).getHost().endsWith(\"www.\"+domainName)\n      or\n      exists(MethodCall ma, Method m, Field f |\n        this.getArgument(0) = ma and\n        ma.getMethod() = m and\n        m.hasQualifiedName(\"android.content.res\", \"Resources\", \"getString\") and\n        ma.getArgument(0).(FieldRead).getField() = f and\n        f.getDeclaringType() instanceof AndroidRString\n      ) //Check resource properties in /res/values/strings.xml in Android mobile applications using res.getString(R.string.key)\n      or\n      this.getArgument(0)\n          .(VarAccess)\n          .getVariable()\n          .getAnAssignedValue()\n          .(StringLiteral)\n          .getValue()\n          .charAt(0) != \".\" //check variable starts with \".\" e.g. String domainName = \"example.com\";  Uri.parse(url).getHost().endsWith(domainName)\n    )\n  }\n}\n\ndeprecated query predicate problems(\n  HostVerificationMethodCall hma, string message1, Expr arg, string message2\n) {\n  exists(UriGetHostMethod um, MethodCall uma | hma.getQualifier() = uma and uma.getMethod() = um) and\n  message1 = \"Method has potentially $@.\" and\n  arg = hma.getArgument(0) and\n  message2 = \"improper URL verification\"\n}",
        "description": "Apps that rely on URL parsing to verify that a given URL is pointing to a trusted server are susceptible to wrong ways of URL parsing and verification.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-939/IncorrectURLVerification.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.deadcode.WebEntryPoints\nimport semmle.code.java.security.XSS\ndeprecated import JsonpInjectionLib\ndeprecated import RequestResponseFlow::PathGraph\n\ndeprecated module RequestResponseFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof ActiveThreatModelSource and\n    any(RequestGetMethod m).polyCalls*(source.getEnclosingCallable())\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink instanceof XssSink and\n    any(RequestGetMethod m).polyCalls*(sink.getEnclosingCallable())\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    exists(MethodCall ma |\n      isRequestGetParamMethod(ma) and pred.asExpr() = ma.getQualifier() and succ.asExpr() = ma\n    )\n  }\n}\n\ndeprecated module RequestResponseFlow = TaintTracking::Global<RequestResponseFlowConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, RequestResponseFlow::PathNode source, RequestResponseFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  RequestResponseFlow::flowPath(source, sink) and\n  JsonpInjectionFlow::flowTo(sink.getNode()) and\n  sinkNode = sink.getNode() and\n  message1 = \"Jsonp response might include code from $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"this user input\"\n}",
        "description": "User-controlled callback function names that are not verified are vulnerable to jsonp injection attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-352/JsonpInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.android.Intent\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.NumberFormatException\nimport NfeLocalDoSFlow::PathGraph\n\nmodule NfeLocalDoSConfig implements DataFlow::ConfigSig {\n  /** Holds if source is a remote flow source */\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  /** Holds if NFE is thrown but not caught */\n  predicate isSink(DataFlow::Node sink) {\n    exists(Expr e |\n      e.getEnclosingCallable().getDeclaringType().(ExportableAndroidComponent).isExported() and\n      throwsNfe(e) and\n      not exists(TryStmt t |\n        t.getBlock() = e.getAnEnclosingStmt() and\n        catchesNfe(t)\n      ) and\n      sink.asExpr() = e\n    )\n  }\n}\n\nmodule NfeLocalDoSFlow = TaintTracking::Global<NfeLocalDoSConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, NfeLocalDoSFlow::PathNode source, NfeLocalDoSFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  NfeLocalDoSFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Uncaught NumberFormatException in an exported Android component due to $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "NumberFormatException thrown but not caught by an Android application that allows external inputs can crash the application, constituting a local Denial of Service (DoS) attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-755/NFEAndroidDoS.ql",
        "language": "java"
    },
    {
        "query": "import java\ndeprecated import UnsafeSpringExporterLib\n\nprivate predicate isConfiguration(RefType type) {\n  type.hasAnnotation(\"org.springframework.context.annotation\", \"Configuration\") or\n  isConfigurationAnnotation(type.getAnAnnotation())\n}\n\nprivate predicate isConfigurationAnnotation(Annotation annotation) {\n  isConfiguration(annotation.getType()) or\n  isConfigurationAnnotation(annotation.getType().getAnAnnotation())\n}\n\ndeprecated private class UnsafeBeanInitMethod extends Method {\n  string identifier;\n\n  UnsafeBeanInitMethod() {\n    isRemoteInvocationSerializingExporter(this.getReturnType()) and\n    isConfiguration(this.getDeclaringType()) and\n    exists(Annotation a | this.getAnAnnotation() = a |\n      a.getType().hasQualifiedName(\"org.springframework.context.annotation\", \"Bean\") and\n      if a.getValue(\"name\") instanceof StringLiteral\n      then identifier = a.getValue(\"name\").(StringLiteral).getValue()\n      else identifier = this.getName()\n    )\n  }\n\n  /**\n   * Gets this bean's name if given by the `Bean` annotation, or this method's identifier otherwise.\n   */\n  string getBeanIdentifier() { result = identifier }\n}\n\ndeprecated query predicate problems(UnsafeBeanInitMethod method, string message) {\n  message = \"Unsafe deserialization in a Spring exporter bean '\" + method.getBeanIdentifier() + \"'.\"\n}",
        "description": "A Spring bean, which is based on RemoteInvocationSerializingExporter, initializes an endpoint that uses ObjectInputStream to deserialize incoming data. In the worst case, that may lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-502/UnsafeSpringExporterInConfigurationClass.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.SpringBean\ndeprecated import UnsafeSpringExporterLib\n\ndeprecated query predicate problems(SpringBean bean, string message) {\n  isRemoteInvocationSerializingExporter(bean.getClass()) and\n  message = \"Unsafe deserialization in a Spring exporter bean '\" + bean.getBeanIdentifier() + \"'.\"\n}",
        "description": "A Spring bean, which is based on RemoteInvocationSerializingExporter, initializes an endpoint that uses ObjectInputStream to deserialize incoming data. In the worst case, that may lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-502/UnsafeSpringExporterInXMLConfiguration.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.frameworks.Rmi\nimport BindingUnsafeRemoteObjectFlow::PathGraph\n\nprivate class BindMethod extends Method {\n  BindMethod() {\n    (\n      this.getDeclaringType().hasQualifiedName(\"java.rmi\", \"Naming\") or\n      this.getDeclaringType().hasQualifiedName(\"java.rmi.registry\", \"Registry\")\n    ) and\n    this.hasName([\"bind\", \"rebind\"])\n  }\n}\n\nprivate predicate hasVulnerableMethod(RefType type) {\n  exists(RemoteCallableMethod m, Type parameterType |\n    m.getDeclaringType() = type and parameterType = m.getAParamType()\n  |\n    not parameterType instanceof PrimitiveType and\n    not parameterType instanceof TypeString and\n    not parameterType instanceof TypeObjectInputStream\n  )\n}\n\nprivate module BindingUnsafeRemoteObjectConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    exists(ConstructorCall cc | cc = source.asExpr() |\n      hasVulnerableMethod(cc.getConstructedType().getAnAncestor())\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall ma | ma.getArgument(1) = sink.asExpr() | ma.getMethod() instanceof BindMethod)\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node fromNode, DataFlow::Node toNode) {\n    exists(MethodCall ma, Method m | m = ma.getMethod() |\n      m.getDeclaringType().hasQualifiedName(\"java.rmi.server\", \"UnicastRemoteObject\") and\n      m.hasName(\"exportObject\") and\n      not m.getParameterType([2, 4]).(RefType).hasQualifiedName(\"java.io\", \"ObjectInputFilter\") and\n      ma.getArgument(0) = fromNode.asExpr() and\n      ma = toNode.asExpr()\n    )\n  }\n}\n\nprivate module BindingUnsafeRemoteObjectFlow =\n  TaintTracking::Global<BindingUnsafeRemoteObjectConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, BindingUnsafeRemoteObjectFlow::PathNode source,\n  BindingUnsafeRemoteObjectFlow::PathNode sink, string message\n) {\n  BindingUnsafeRemoteObjectFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message = \"Unsafe deserialization in a remote object.\"\n}",
        "description": "If a registered remote object has a method that accepts a complex object, an attacker can take advantage of the unsafe deserialization mechanism which is used to pass parameters in RMI. In the worst case, it results in remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-502/UnsafeDeserializationRmi.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.controlflow.Guards\nimport semmle.code.java.dataflow.SSA\nimport semmle.code.java.frameworks.android.Intent\n\nclass CheckSignaturesGuard extends Guard instanceof EqualityTest {\n  MethodCall checkSignatures;\n\n  CheckSignaturesGuard() {\n    this.getAnOperand() = checkSignatures and\n    checkSignatures\n        .getMethod()\n        .hasQualifiedName(\"android.content.pm\", \"PackageManager\", \"checkSignatures\") and\n    exists(Expr signatureCheckResult |\n      this.getAnOperand() = signatureCheckResult and signatureCheckResult != checkSignatures\n    |\n      signatureCheckResult.(CompileTimeConstantExpr).getIntValue() = 0 or\n      signatureCheckResult\n          .(FieldRead)\n          .getField()\n          .hasQualifiedName(\"android.content.pm\", \"PackageManager\", \"SIGNATURE_MATCH\")\n    )\n  }\n\n  Expr getCheckedExpr() { result = checkSignatures.getArgument(0) }\n}\n\npredicate signatureChecked(Expr safe) {\n  exists(CheckSignaturesGuard g, SsaVariable v |\n    v.getAUse() = g.getCheckedExpr() and\n    safe = v.getAUse() and\n    g.controls(safe.getBasicBlock(), g.(EqualityTest).polarity())\n  )\n}\n\nmodule InsecureLoadingConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node src) {\n    exists(Method m | m = src.asExpr().(MethodCall).getMethod() |\n      m.getDeclaringType().getASourceSupertype*() instanceof TypeContext and\n      m.hasName(\"createPackageContext\") and\n      not signatureChecked(src.asExpr().(MethodCall).getArgument(0))\n    )\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(MethodCall ma |\n      ma.getMethod().hasQualifiedName(\"java.lang\", \"ClassLoader\", \"loadClass\")\n    |\n      sink.asExpr() = ma.getQualifier()\n    )\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(MethodCall ma, Method m |\n      ma.getMethod() = m and\n      m.getDeclaringType().getASourceSupertype*() instanceof TypeContext and\n      m.hasName(\"getClassLoader\")\n    |\n      node1.asExpr() = ma.getQualifier() and\n      node2.asExpr() = ma\n    )\n  }\n}\n\nmodule InsecureLoadFlow = TaintTracking::Global<InsecureLoadingConfig>;\n\nimport InsecureLoadFlow::PathGraph\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, InsecureLoadFlow::PathNode source, InsecureLoadFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  InsecureLoadFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"Class loaded from a $@ without signature check\" and\n  sourceNode = source.getNode() and\n  message2 = \"third party library\"\n}",
        "description": "Loading classes or code from third-party packages without checking the package signature could make the application susceptible to package namespace squatting attacks, potentially leading to arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-470/LoadClassNoSignatureCheck.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DataFlow\ndeprecated import UnsafeReflectionLib\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.controlflow.Guards\ndeprecated import UnsafeReflectionFlow::PathGraph\n\nprivate predicate containsSanitizer(Guard g, Expr e, boolean branch) {\n  g.(MethodCall).getMethod().hasName(\"contains\") and\n  e = g.(MethodCall).getArgument(0) and\n  branch = true\n}\n\nprivate predicate equalsSanitizer(Guard g, Expr e, boolean branch) {\n  g.(MethodCall).getMethod().hasName(\"equals\") and\n  e = [g.(MethodCall).getArgument(0), g.(MethodCall).getQualifier()] and\n  branch = true\n}\n\ndeprecated module UnsafeReflectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof UnsafeReflectionSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    // Argument -> return of Class.forName, ClassLoader.loadClass\n    exists(ReflectiveClassIdentifierMethodCall rcimac |\n      rcimac.getArgument(0) = pred.asExpr() and rcimac = succ.asExpr()\n    )\n    or\n    // Qualifier -> return of Class.getDeclaredConstructors/Methods and similar\n    exists(MethodCall ma |\n      (\n        ma instanceof ReflectiveGetConstructorsCall or\n        ma instanceof ReflectiveGetMethodsCall\n      ) and\n      ma.getQualifier() = pred.asExpr() and\n      ma = succ.asExpr()\n    )\n    or\n    // Qualifier -> return of Object.getClass\n    exists(MethodCall ma |\n      ma.getMethod().hasName(\"getClass\") and\n      ma.getMethod().getDeclaringType().hasQualifiedName(\"java.lang\", \"Object\") and\n      ma.getQualifier() = pred.asExpr() and\n      ma = succ.asExpr()\n    )\n    or\n    // Argument -> return of methods that look like Class.forName\n    looksLikeResolveClassStep(pred, succ)\n    or\n    // Argument -> return of methods that look like `Object getInstance(Class c)`\n    looksLikeInstantiateClassStep(pred, succ)\n    or\n    // Qualifier -> return of Constructor.newInstance, Class.newInstance\n    exists(NewInstance ni |\n      ni.getQualifier() = pred.asExpr() and\n      ni = succ.asExpr()\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node = DataFlow::BarrierGuard<containsSanitizer/3>::getABarrierNode() or\n    node = DataFlow::BarrierGuard<equalsSanitizer/3>::getABarrierNode()\n  }\n}\n\ndeprecated module UnsafeReflectionFlow = TaintTracking::Global<UnsafeReflectionConfig>;\n\ndeprecated private Expr getAMethodArgument(MethodCall reflectiveCall) {\n  result = reflectiveCall.(NewInstance).getAnArgument()\n  or\n  result = reflectiveCall.(MethodInvokeCall).getAnArgument()\n}\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, UnsafeReflectionFlow::PathNode source,\n  UnsafeReflectionFlow::PathNode sink, string message1, DataFlow::Node sourceNode, string message2\n) {\n  exists(MethodCall reflectiveCall |\n    UnsafeReflectionFlow::flowPath(source, sink) and\n    sinkNode.asExpr() = reflectiveCall.getQualifier() and\n    UnsafeReflectionFlow::flowToExpr(getAMethodArgument(reflectiveCall))\n  ) and\n  sinkNode = sink.getNode() and\n  message1 = \"Unsafe reflection of $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user input\"\n}",
        "description": "Use external input with reflection function to select the class or code to be used, which brings serious security risks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-470/UnsafeReflection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.WebXML\n\nprivate class HttpOnlyConfig extends WebContextParameter {\n  HttpOnlyConfig() { this.getParamName().getValue() = \"useHttpOnly\" }\n\n  string getParamValueElementValue() { result = this.getParamValue().getValue() }\n\n  predicate isHttpOnlySet() { this.getParamValueElementValue().toLowerCase() = \"false\" }\n}\n\ndeprecated query predicate problems(HttpOnlyConfig config, string message) {\n  config.isHttpOnlySet() and\n  message =\n    \"'httpOnly' should be enabled in tomcat config file to help mitigate cross-site scripting (XSS) attacks.\"\n}",
        "description": "Disabling 'HttpOnly' leaves session cookies vulnerable to an XSS attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-1004/InsecureTomcatConfig.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSteps\nimport semmle.code.java.frameworks.Servlets\nimport semmle.code.java.dataflow.TaintTracking\nimport MissingHttpOnlyFlow::PathGraph\n\nstring getSensitiveCookieNameRegex() { result = \"(?i).*(auth|session|token|key|credential).*\" }\n\nstring getCsrfCookieNameRegex() { result = \"(?i).*(csrf).*\" }\n\npredicate isSensitiveCookieNameExpr(Expr expr) {\n  exists(string s | s = expr.(CompileTimeConstantExpr).getStringValue() |\n    s.regexpMatch(getSensitiveCookieNameRegex()) and not s.regexpMatch(getCsrfCookieNameRegex())\n  )\n  or\n  isSensitiveCookieNameExpr(expr.(AddExpr).getAnOperand())\n}\n\nclass SensitiveCookieNameExpr extends Expr {\n  SensitiveCookieNameExpr() { isSensitiveCookieNameExpr(this) }\n}\n\nclass SetCookieMethodCall extends MethodCall {\n  SetCookieMethodCall() {\n    (\n      this.getMethod() instanceof ResponseAddHeaderMethod or\n      this.getMethod() instanceof ResponseSetHeaderMethod\n    ) and\n    this.getArgument(0).(CompileTimeConstantExpr).getStringValue().toLowerCase() = \"set-cookie\"\n  }\n}\n\nmodule MatchesHttpOnlyConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source.asExpr().(CompileTimeConstantExpr).getStringValue().toLowerCase().matches(\"%httponly%\")\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink.asExpr() = any(SetCookieMethodCall ma).getArgument(1)\n  }\n}\n\nmodule MatchesHttpOnlyFlow = TaintTracking::Global<MatchesHttpOnlyConfig>;\n\nclass CookieClass extends RefType {\n  CookieClass() { this.getAnAncestor().hasQualifiedName(\"javax.servlet.http\", \"Cookie\") }\n}\n\n// Inlined because this could be a very large result set if computed out of context\npragma[inline]\npredicate mayBeBooleanTrue(Expr expr) {\n  expr.getType() instanceof BooleanType and\n  not expr.(CompileTimeConstantExpr).getBooleanValue() = false\n}\n\npredicate setsCookieHttpOnly(MethodCall ma) {\n  ma.getMethod().getName() = \"setHttpOnly\" and\n  // any use of setHttpOnly(x) where x isn't false is probably safe\n  mayBeBooleanTrue(ma.getArgument(0))\n}\n\npredicate removesCookie(MethodCall ma) {\n  ma.getMethod().getName() = \"setMaxAge\" and\n  ma.getArgument(0).(IntegerLiteral).getIntValue() = 0\n}\n\npredicate isTestMethod(MethodCall ma) {\n  exists(Method m |\n    m = ma.getEnclosingCallable() and\n    (\n      m.getDeclaringType().getName().toLowerCase().matches(\"%test%\") or // Simple check to exclude test classes to reduce FPs\n      m.getDeclaringType().getPackage().getName().toLowerCase().matches(\"%test%\") or // Simple check to exclude classes in test packages to reduce FPs\n      exists(m.getLocation().getFile().getAbsolutePath().indexOf(\"/src/test/java\")) or //  Match test directory structure of build tools like maven\n      m instanceof TestMethod // Test method of a test case implementing a test framework such as JUnit or TestNG\n    )\n  )\n}\n\nmodule SetHttpOnlyOrRemovesCookieConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source.asExpr() =\n      any(MethodCall ma | setsCookieHttpOnly(ma) or removesCookie(ma)).getQualifier()\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink.asExpr() =\n      any(MethodCall ma | ma.getMethod() instanceof ResponseAddCookieMethod).getArgument(0)\n  }\n}\n\nmodule SetHttpOnlyOrRemovesCookieFlow = TaintTracking::Global<SetHttpOnlyOrRemovesCookieConfig>;\n\nclass CookieResponseSink extends DataFlow::ExprNode {\n  CookieResponseSink() {\n    exists(MethodCall ma |\n      (\n        ma.getMethod() instanceof ResponseAddCookieMethod and\n        this.getExpr() = ma.getArgument(0) and\n        not SetHttpOnlyOrRemovesCookieFlow::flowTo(this)\n        or\n        ma instanceof SetCookieMethodCall and\n        this.getExpr() = ma.getArgument(1) and\n        not MatchesHttpOnlyFlow::flowTo(this) // response.addHeader(\"Set-Cookie\", \"token=\" +authId + \";HttpOnly;Secure\")\n      ) and\n      not isTestMethod(ma) // Test class or method\n    )\n  }\n}\n\npredicate setsHttpOnlyInNewCookie(ClassInstanceExpr cie) {\n  cie.getConstructedType().hasQualifiedName([\"javax.ws.rs.core\", \"jakarta.ws.rs.core\"], \"NewCookie\") and\n  (\n    cie.getNumArgument() = 6 and\n    mayBeBooleanTrue(cie.getArgument(5)) // NewCookie(Cookie cookie, String comment, int maxAge, Date expiry, boolean secure, boolean httpOnly)\n    or\n    cie.getNumArgument() = 8 and\n    cie.getArgument(6).getType() instanceof BooleanType and\n    mayBeBooleanTrue(cie.getArgument(7)) // NewCookie(String name, String value, String path, String domain, String comment, int maxAge, boolean secure, boolean httpOnly)\n    or\n    cie.getNumArgument() = 10 and\n    mayBeBooleanTrue(cie.getArgument(9)) // NewCookie(String name, String value, String path, String domain, int version, String comment, int maxAge, Date expiry, boolean secure, boolean httpOnly)\n  )\n}\n\nmodule MissingHttpOnlyConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source.asExpr() instanceof SensitiveCookieNameExpr }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof CookieResponseSink }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // JAX-RS's `new NewCookie(\"session-access-key\", accessKey, \"/\", null, null, 0, true, true)` and similar\n    setsHttpOnlyInNewCookie(node.asExpr())\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    exists(\n      ConstructorCall cc // new Cookie(...)\n    |\n      cc.getConstructedType() instanceof CookieClass and\n      pred.asExpr() = cc.getAnArgument() and\n      succ.asExpr() = cc\n    )\n    or\n    exists(\n      MethodCall ma // cookie.toString()\n    |\n      ma.getMethod().getName() = \"toString\" and\n      ma.getQualifier().getType() instanceof CookieClass and\n      pred.asExpr() = ma.getQualifier() and\n      succ.asExpr() = ma\n    )\n  }\n}\n\nmodule MissingHttpOnlyFlow = TaintTracking::Global<MissingHttpOnlyConfig>;\n\ndeprecated query predicate problems(\n  DataFlow::Node sinkNode, MissingHttpOnlyFlow::PathNode source, MissingHttpOnlyFlow::PathNode sink,\n  string message1, DataFlow::Node sourceNode, string message2\n) {\n  MissingHttpOnlyFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  message1 = \"$@ doesn't have the HttpOnly flag set.\" and\n  sourceNode = source.getNode() and\n  message2 = \"This sensitive cookie\"\n}",
        "description": "Sensitive cookies without the 'HttpOnly' flag set leaves session cookies vulnerable to an XSS attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-1004/SensitiveCookieNotHttpOnly.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.CommandLineQuery\nimport InputToArgumentToExecFlow::PathGraph\nprivate import semmle.code.java.dataflow.ExternalFlow\n\noverlay[local?]\ndeprecated private class ActivateModels extends ActiveExperimentalModels {\n  ActivateModels() { this = \"jsch-os-injection\" }\n}\n\n// This is a clone of query `java/command-line-injection` that also includes experimental sinks.\ndeprecated query predicate problems(\n  Expr execArg, InputToArgumentToExecFlow::PathNode source,\n  InputToArgumentToExecFlow::PathNode sink, string message1, DataFlow::Node sourceNode,\n  string message2\n) {\n  execIsTainted(source, sink, execArg) and\n  message1 = \"This command line depends on a $@.\" and\n  sourceNode = source.getNode() and\n  message2 = \"user-provided value\"\n}",
        "description": "Using externally controlled strings in a command line is vulnerable to malicious changes in the strings (includes experimental sinks).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-078/ExecTainted.ql",
        "language": "java"
    },
    {
        "query": "deprecated import CommandInjectionRuntimeExec\ndeprecated import ExecUserFlow::PathGraph\n\ndeprecated class ThreatModelSource extends Source instanceof ActiveThreatModelSource { }\n\ndeprecated query predicate problems(\n  ExecUserFlow::PathNode sink, ExecUserFlow::PathNode source, ExecUserFlow::PathNode sink0,\n  string message1, DataFlow::Node sourceCmd, string message2, DataFlow::Node sourceNode,\n  string message3\n) {\n  callIsTaintedByUserInputAndDangerousCommand(source, sink, sourceCmd, _) and\n  sink0 = sink and\n  message1 =\n    \"Call to dangerous java.lang.Runtime.exec() with command '$@' with arg from untrusted input '$@'\" and\n  message2 = sourceCmd.toString() and\n  sourceNode = source.getNode() and\n  message3 = source.toString()\n}",
        "description": "High sensitvity and precision version of java/command-line-injection, designed to find more cases of command injection in rare cases that the default query does not find",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-078/CommandInjectionRuntimeExec.ql",
        "language": "java"
    },
    {
        "query": "deprecated import CommandInjectionRuntimeExec\ndeprecated import ExecUserFlow::PathGraph\n\ndeprecated class LocalSource extends Source instanceof LocalUserInput { }\n\ndeprecated query predicate problems(\n  ExecUserFlow::PathNode sink, ExecUserFlow::PathNode source, ExecUserFlow::PathNode sink0,\n  string message1, DataFlow::Node sourceCmd, string message2, DataFlow::Node sourceNode,\n  string message3\n) {\n  callIsTaintedByUserInputAndDangerousCommand(source, sink, sourceCmd, _) and\n  sink0 = sink and\n  message1 =\n    \"Call to dangerous java.lang.Runtime.exec() with command '$@' with arg from untrusted input '$@'\" and\n  message2 = sourceCmd.toString() and\n  sourceNode = source.getNode() and\n  message3 = source.toString()\n}",
        "description": "High sensitvity and precision version of java/command-line-injection, designed to find more cases of command injection in rare cases that the default query does not find",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/Security/CWE/CWE-078/CommandInjectionRuntimeExecLocal.ql",
        "language": "java"
    },
    {
        "query": "import experimental.quantum.Language\n\nquery predicate nodes(Crypto::NodeBase node, string key, string value) {\n  Crypto::nodes_graph_impl(node, key, value)\n}\n\nquery predicate edges(Crypto::NodeBase source, Crypto::NodeBase target, string key, string value) {\n  Crypto::edges_graph_impl(source, target, key, value)\n}\n\nquery predicate graphProperties(string key, string value) {\n  key = \"semmle.graphKind\" and value = \"graph\"\n}",
        "description": "Outputs a graph representation of the cryptographic bill of materials. This query only supports DGML output, as CodeQL DOT output omits properties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/PrintCBOMGraph.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::KeyDerivationOperationNode op, Element e, string msg\nwhere\n  e = op.getIterationCount().asElement() and\n  not e instanceof Literal and\n  msg = \"Key derivation operation with unknown iteration: $@\"\n  or\n  not exists(op.getIterationCount()) and\n  e = op.asElement() and\n  msg = \"Key derivation operation with no iteration configuration.\"\nselect op, msg, e, e.toString()",
        "description": "Detects key derivation operations with an unknown iteration count.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Analysis/UnknownKDFIterationCount.ql",
        "language": "java"
    },
    {
        "query": "import experimental.quantum.Language\n\npredicate isInsecureNonceSource(Crypto::NonceArtifactNode n, Crypto::NodeBase src) {\n  src = n.getSourceNode() and\n  not src.asElement() instanceof SecureRandomnessInstance\n}\n\nfrom Crypto::KeyOperationNode op, Crypto::NodeBase src\nwhere isInsecureNonceSource(op.getANonce(), src)\nselect op, \"Operation uses insecure nonce source $@\", src, src.toString()",
        "description": "A nonce is generated from a source that is not secure. This can lead to vulnerabilities such as replay attacks or key recovery.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Analysis/InsecureNonceSource.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport ArtifactReuse\n\nfrom Crypto::NonceArtifactNode nonce1, Crypto::NonceArtifactNode nonce2\nwhere isArtifactReuse(nonce1, nonce2)\nselect nonce1, \"Reuse with nonce $@\", nonce2, nonce2.toString()",
        "description": "Reuse of nonce in cryptographic operations can lead to vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Analysis/ReusedNonce.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::KeyDerivationOperationNode op, Literal l\nwhere\n  op.getIterationCount().asElement() = l and\n  l.getValue().toInt() < 100000\nselect op, \"Key derivation operation configures iteration count below 100k: $@\", l,\n  l.getValue().toString()",
        "description": "Detects key derivation operations with a known weak iteration count.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Analysis/KnownWeakKDFIterationCount.ql",
        "language": "java"
    },
    {
        "query": "//THIS QUERY IS A REPLICA OF: https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-327/BrokenCryptoAlgorithm.ql\n//but uses the **NEW MODELING**\nimport experimental.quantum.Language\n\nstring getAnInsecureAlgorithmName() {\n  result =\n    [\n      \"DES\", \"RC2\", \"RC4\", \"RC5\",\n      // ARCFOUR is a variant of RC4\n      \"ARCFOUR\",\n      // Encryption mode ECB like AES/ECB/NoPadding is vulnerable to replay and other attacks\n      \"ECB\",\n      // CBC mode of operation with PKCS#5 or PKCS#7 padding is vulnerable to padding oracle attacks\n      \"AES/CBC/PKCS[57]Padding\"\n    ]\n}\n\nprivate string rankedInsecureAlgorithm(int i) {\n  result = rank[i](string s | s = getAnInsecureAlgorithmName())\n}\n\nprivate string insecureAlgorithmString(int i) {\n  i = 1 and result = rankedInsecureAlgorithm(i)\n  or\n  result = rankedInsecureAlgorithm(i) + \"|\" + insecureAlgorithmString(i - 1)\n}\n\nstring getInsecureAlgorithmRegex() {\n  result = algorithmRegex(insecureAlgorithmString(max(int i | exists(rankedInsecureAlgorithm(i)))))\n}\n\nbindingset[algorithmString]\nprivate string algorithmRegex(string algorithmString) {\n  // Algorithms usually appear in names surrounded by characters that are not\n  // alphabetical characters in the same case. This handles the upper and lower\n  // case cases.\n  result =\n    \"((^|.*[^A-Z])(\" + algorithmString + \")([^A-Z].*|$))\" +\n      // or...\n      \"|\" +\n      // For lowercase, we want to be careful to avoid being confused by camelCase\n      // hence we require two preceding uppercase letters to be sure of a case switch,\n      // or a preceding non-alphabetic character\n      \"((^|.*[A-Z]{2}|.*[^a-zA-Z])(\" + algorithmString.toLowerCase() + \")([^a-z].*|$))\"\n}\n\nfrom Crypto::AlgorithmNode alg\nwhere\n  alg.getAlgorithmName().regexpMatch(getInsecureAlgorithmRegex()) and\n  // Exclude RSA/ECB/.* ciphers.\n  not alg.getAlgorithmName().regexpMatch(\"RSA/ECB.*\") and\n  // Exclude German and French sentences.\n  not alg.getAlgorithmName().regexpMatch(\".*\\\\p{IsLowercase} des \\\\p{IsLetter}.*\")\nselect alg, \"Cryptographic algorithm $@ is weak and should not be used.\", alg,\n  alg.getAlgorithmName()",
        "description": "Using broken or weak cryptographic algorithms can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Examples/BrokenCrypto.ql",
        "language": "java"
    },
    {
        "query": "import experimental.quantum.Language\n\nfrom\n  Crypto::KeyOperationNode op, Crypto::KeyOperationAlgorithmNode a,\n  Crypto::ModeOfOperationAlgorithmNode m, Crypto::PaddingAlgorithmNode p,\n  Crypto::NonceArtifactNode nonce, Crypto::KeyArtifactNode k\nwhere\n  a = op.getAKnownAlgorithm() and\n  m = a.getModeOfOperation() and\n  p = a.getPaddingAlgorithm() and\n  nonce = op.getANonce() and\n  k = op.getAKey()\nselect op, op.getKeyOperationSubtype(), a, a.getRawAlgorithmName(), m, m.getRawAlgorithmName(), p,\n  p.getRawAlgorithmName(), nonce, k",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Examples/TestCipher.ql",
        "language": "java"
    },
    {
        "query": "import experimental.quantum.Language\n\nclass AESGCMAlgorithmNode extends Crypto::KeyOperationAlgorithmNode {\n  AESGCMAlgorithmNode() {\n    this.getAlgorithmType() = Crypto::KeyOpAlg::TSymmetricCipher(Crypto::KeyOpAlg::AES()) and\n    this.getModeOfOperation().getModeType() = Crypto::KeyOpAlg::GCM()\n  }\n}\n\nfrom Crypto::KeyOperationNode op, Crypto::NonceArtifactNode nonce\nwhere op.getAKnownAlgorithm() instanceof AESGCMAlgorithmNode and nonce = op.getANonce()\nselect op, nonce.getSourceNode()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Examples/TestAESGCMNonce.ql",
        "language": "java"
    },
    {
        "query": "import experimental.quantum.Language\n\nfrom Crypto::HashOperationNode op, Crypto::HashAlgorithmNode alg\nwhere alg = op.getAKnownAlgorithm()\nselect op, op.getDigest(), alg, alg.getRawAlgorithmName()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/Examples/TestHash.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::AsymmetricAlgorithmNode a\nselect a, a.asAlgorithmNode().getAlgorithmName()",
        "description": "Outputs operations where the algorithm used is a known asymmetric cipher algorithm.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownAsymmetricAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\n//TODO: can we have an unknown node concept?\nfrom Crypto::OperationNode op, Element e, string msg\nwhere\n  not exists(op.getAnAlgorithmOrGenericSource()) and\n  e = op.asElement() and\n  msg = \"Operation with unconfigured algorithm (no known sources).\"\n  or\n  exists(Crypto::GenericSourceNode n |\n    n = op.getAnAlgorithmOrGenericSource() and\n    e = n.asElement()\n  ) and\n  msg = \"Operation with unknown algorithm source: $@\"\nselect op, msg, e, e.toString()",
        "description": "Outputs operations where the algorithm applied is unknown",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/UnknownOperationAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::HashOperationNode op\nselect op",
        "description": "Outputs known hashing operations.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownHashingOperation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::KeyOperationAlgorithmNode a\nwhere a.getAlgorithmType() instanceof Crypto::KeyOpAlg::AsymmetricCipherAlgorithmType\nselect a, a.getAlgorithmName()",
        "description": "Outputs known asymmetric cipher algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownAsymmetricCipherAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::HashAlgorithmNode a\nselect a, a.getAlgorithmName()",
        "description": "Outputs known hashing algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownHashingAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Callable f, Parameter p, Crypto::OperationNode op\nwhere\n  op.asElement().(Expr).getEnclosingCallable() = f and\n  op.getAnAlgorithmOrGenericSource().asElement() = p\nselect f,\n  \"Likely crypto API function: Operation $@ configured by parameter $@ with no known configuring call\",\n  op, op.toString(), p, p.toString()",
        "description": "Outputs functions that take in crypto configuration parameters but calls are not detected in source.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/LikelyCryptoAPIFunction.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::KeyOperationAlgorithmNode a\nwhere a.getAlgorithmType() instanceof Crypto::KeyOpAlg::SymmetricCipherAlgorithmType\nselect a, a.getAlgorithmName()",
        "description": "Outputs known symmetric cipher algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownSymmetricCipherAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::OperationNode op, Crypto::AsymmetricAlgorithmNode a\nwhere a = op.getAKnownAlgorithm()\nselect op, a.asAlgorithmNode().getAlgorithmName()",
        "description": "Outputs operations where the algorithm used is a known asymmetric algorithm.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownAsymmetricOperationAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::OperationNode op, Crypto::HashAlgorithmNode a\nwhere a = op.getAKnownAlgorithm()\nselect op, a.getAlgorithmName()",
        "description": "Outputs operations where the algorithm used is a known hashing algorithm.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownHashingOperationAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::KeyDerivationAlgorithmNode alg\nselect alg, alg.getAlgorithmName()",
        "description": "Outputs known key derivation algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownKeyDerivationAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::EllipticCurveNode a\nselect a, a.getAlgorithmName()",
        "description": "Outputs known elliptic curve algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownEllipticCurveAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\n// TODO: should there be a cipher algorithm node?\nfrom Crypto::KeyOperationAlgorithmNode a\nwhere\n  a.getAlgorithmType() instanceof Crypto::KeyOpAlg::AsymmetricCipherAlgorithmType or\n  a.getAlgorithmType() instanceof Crypto::KeyOpAlg::SymmetricCipherAlgorithmType\nselect a, a.getAlgorithmName()",
        "description": "Outputs known cipher algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownCipherAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::KeyDerivationOperationNode op\nselect op",
        "description": "Outputs known key derivation operations.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownKeyDerivationOperation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport experimental.quantum.Language\n\nfrom Crypto::OperationNode op, Crypto::KeyDerivationAlgorithmNode a\nwhere a = op.getAKnownAlgorithm()\nselect op, a.getAlgorithmName()",
        "description": "Outputs operations where the algorithm used is a known key derivation algorithm.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/experimental/quantum/InventorySlices/KnownKeyDerivationOperationAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.UnsafeHostnameVerificationQuery\nimport TrustAllHostnameVerifierFlow::PathGraph\n\nfrom\n  TrustAllHostnameVerifierFlow::PathNode source, TrustAllHostnameVerifierFlow::PathNode sink,\n  RefType verifier\nwhere\n  TrustAllHostnameVerifierFlow::flowPath(source, sink) and\n  not isNodeGuardedByFlag(sink.getNode()) and\n  verifier = source.getNode().asExpr().(ClassInstanceExpr).getConstructedType()\nselect sink, source, sink,\n  \"The $@ defined by $@ always accepts any certificate, even if the hostname does not match.\",\n  source, \"hostname verifier\", verifier, \"this type\"",
        "description": "Marking a certificate as valid for a host without checking the certificate hostname allows an attacker to perform a machine-in-the-middle attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-297/UnsafeHostnameVerification.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.Mail\n\nfrom MethodCall ma\nwhere\n  ma.getMethod() instanceof MailSessionGetInstanceMethod and\n  isInsecureMailPropertyConfig(ma.getArgument(0).(VarAccess).getVariable())\n  or\n  enablesEmailSsl(ma) and not hasSslCertificateCheck(ma.getQualifier().(VarAccess).getVariable())\nselect ma, \"Java mailing has insecure SSL configuration.\"",
        "description": "Configuring a Java application to use authenticated mail session over SSL without certificate validation makes the session susceptible to a man-in-the-middle attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-297/InsecureJavaMail.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.InsecureBeanValidationQuery\nimport BeanValidationFlow::PathGraph\n\nfrom BeanValidationFlow::PathNode source, BeanValidationFlow::PathNode sink\nwhere\n  (\n    not exists(SetMessageInterpolatorCall c)\n    or\n    exists(SetMessageInterpolatorCall c | not c.isSafe())\n  ) and\n  BeanValidationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Custom constraint error message contains an unsanitized $@.\",\n  source, \"user-provided value\"",
        "description": "User-controlled data may be evaluated as a Java EL expression, leading to arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-094/InsecureBeanValidation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.GroovyInjectionQuery\nimport GroovyInjectionFlow::PathGraph\n\nfrom GroovyInjectionFlow::PathNode source, GroovyInjectionFlow::PathNode sink\nwhere GroovyInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Groovy script depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Evaluation of a user-controlled Groovy script may lead to arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-094/GroovyInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.TemplateInjectionQuery\nimport TemplateInjectionFlow::PathGraph\n\nfrom TemplateInjectionFlow::PathNode source, TemplateInjectionFlow::PathNode sink\nwhere TemplateInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Template, which may contain code, depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Untrusted input interpreted as a template can lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-094/TemplateInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.MvelInjectionQuery\nimport MvelInjectionFlow::PathGraph\n\nfrom MvelInjectionFlow::PathNode source, MvelInjectionFlow::PathNode sink\nwhere MvelInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"MVEL expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Evaluation of a user-controlled MVEL expression may lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-094/MvelInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.ArbitraryApkInstallationQuery\nimport ApkInstallationFlow::PathGraph\n\nfrom ApkInstallationFlow::PathNode source, ApkInstallationFlow::PathNode sink\nwhere ApkInstallationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Arbitrary Android APK installation.\"",
        "description": "Creating an intent with a URI pointing to a untrusted file can lead to the installation of an untrusted application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-094/ArbitraryApkInstallation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.JexlInjectionQuery\nimport JexlInjectionFlow::PathGraph\n\nfrom JexlInjectionFlow::PathNode source, JexlInjectionFlow::PathNode sink\nwhere JexlInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"JEXL expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Evaluation of a user-controlled JEXL expression may lead to arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-094/JexlInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.SpelInjectionQuery\nimport semmle.code.java.dataflow.DataFlow\nimport SpelInjectionFlow::PathGraph\n\nfrom SpelInjectionFlow::PathNode source, SpelInjectionFlow::PathNode sink\nwhere SpelInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"SpEL expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Evaluation of a user-controlled Spring Expression Language (SpEL) expression may lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-094/SpelInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.SensitiveDataExposureThroughErrorMessageQuery\n\nfrom Expr externalExpr, Expr errorInformation\nwhere\n  getMessageFlowsExternally(DataFlow::exprNode(externalExpr), DataFlow::exprNode(errorInformation))\nselect externalExpr, \"$@ can be exposed to an external user.\", errorInformation, \"Error information\"",
        "description": "Information from an error message propagates to an external user. Error messages can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-209/SensitiveDataExposureThroughErrorMessage.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.StackTraceExposureQuery\n\nfrom Expr externalExpr, Expr errorInformation\nwhere\n  printsStackExternally(externalExpr, errorInformation) or\n  stringifiedStackFlowsExternally(DataFlow::exprNode(externalExpr), errorInformation)\nselect externalExpr, \"$@ can be exposed to an external user.\", errorInformation, \"Error information\"",
        "description": "Information from a stack trace propagates to an external user. Stack traces can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-209/StackTraceExposure.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.TaintedPermissionsCheckQuery\nimport TaintedPermissionsCheckFlow::PathGraph\n\nfrom\n  TaintedPermissionsCheckFlow::PathNode source, TaintedPermissionsCheckFlow::PathNode sink,\n  PermissionsConstruction p\nwhere sink.getNode().asExpr() = p.getInput() and TaintedPermissionsCheckFlow::flowPath(source, sink)\nselect p, source, sink, \"Permissions check depends on a $@.\", source.getNode(),\n  \"user-controlled value\"",
        "description": "Using user-controlled data in a permissions check may result in inappropriate permissions being granted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-807/TaintedPermissionsCheck.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.ConditionalBypassQuery\nimport ConditionalBypassFlow::PathGraph\n\nfrom\n  ConditionalBypassFlow::PathNode source, ConditionalBypassFlow::PathNode sink, MethodCall m, Expr e\nwhere\n  conditionControlsMethod(m, e) and\n  sink.getNode().asExpr() = e and\n  ConditionalBypassFlow::flowPath(source, sink)\nselect m, source, sink,\n  \"Sensitive method may not be executed depending on a $@, which flows from $@.\", e,\n  \"this condition\", source.getNode(), \"user-controlled value\"",
        "description": "User-controlled bypassing of sensitive methods may allow attackers to avoid passing through authentication systems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-807/ConditionalBypass.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport java\nimport semmle.code.java.security.SensitiveUiQuery\nimport TextFieldTracking::PathGraph\n\nfrom TextFieldTracking::PathNode source, TextFieldTracking::PathNode sink\nwhere TextFieldTracking::flowPath(source, sink)\nselect sink, source, sink, \"This $@ is exposed in a text view.\", source, \"sensitive information\"",
        "description": "Sensitive information displayed in UI text views should be properly masked.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-200/AndroidSensitiveTextField.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.TempDirUtils\nimport semmle.code.java.security.TempDirLocalInformationDisclosureQuery\n\nmodule InsecureMethodPathGraph implements DataFlow::PathGraphSig<MethodCallInsecureFileCreation> {\n  predicate edges(\n    MethodCallInsecureFileCreation n1, MethodCallInsecureFileCreation n2, string key, string value\n  ) {\n    none()\n  }\n\n  predicate nodes(MethodCallInsecureFileCreation n, string key, string val) {\n    key = \"semmle.label\" and val = n.toString()\n  }\n\n  predicate subpaths(\n    MethodCallInsecureFileCreation n1, MethodCallInsecureFileCreation n2,\n    MethodCallInsecureFileCreation n3, MethodCallInsecureFileCreation n4\n  ) {\n    none()\n  }\n}\n\nmodule Flow =\n  DataFlow::MergePathGraph<TempDirSystemGetPropertyToCreate::PathNode,\n    MethodCallInsecureFileCreation, TempDirSystemGetPropertyToCreate::PathGraph,\n    InsecureMethodPathGraph>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink, string message\nwhere\n  (\n    TempDirSystemGetPropertyToCreate::flowPath(source.asPathNode1(), sink.asPathNode1()) and\n    message =\n      \"Local information disclosure vulnerability from $@ due to use of file or directory readable by other local users.\"\n    or\n    source = sink and\n    // Note this message has no \"$@\" placeholder, so the \"system temp directory\" template parameter below is not used.\n    message =\n      \"Local information disclosure vulnerability due to use of \" +\n        source.asPathNode2().getFileSystemEntityType() + \" readable by other local users.\"\n  ) and\n  not isPermissionsProtectedTempDirUse(sink.getNode())\nselect source.getNode(), source, sink, message, source.getNode(), \"system temp directory\"",
        "description": "Writing information without explicit permissions to a shared temporary directory may disclose it to other users.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-200/TempDirLocalInformationDisclosure.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport java\nimport semmle.code.java.security.SensitiveUiQuery\nimport NotificationTracking::PathGraph\n\nfrom NotificationTracking::PathNode source, NotificationTracking::PathNode sink\nwhere NotificationTracking::flowPath(source, sink)\nselect sink, source, sink, \"This $@ is exposed in a system notification.\", source,\n  \"sensitive information\"",
        "description": "Sensitive information exposed in a system notification can be read by an unauthorized application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-200/AndroidSensitiveNotifications.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.frameworks.android.WebView\n\nprivate class TypeWebViewOrSubclass extends RefType {\n  TypeWebViewOrSubclass() { this.getASupertype*() instanceof TypeWebView }\n}\n\nprivate class PrivateGetterMethodCall extends MethodCall {\n  PrivateGetterMethodCall() {\n    this.getMethod() instanceof GetterMethod and\n    this.getMethod().isPrivate()\n  }\n}\n\nclass WebViewSource extends DataFlow::Node {\n  WebViewSource() {\n    this.getType() instanceof TypeWebViewOrSubclass and\n    // To reduce duplicate results, we only consider WebView objects from\n    // constructor and method calls, or method accesses which are cast to WebView.\n    (\n      this.asExpr() instanceof ClassInstanceExpr or\n      this.asExpr() instanceof MethodCall or\n      this.asExpr().(CastExpr).getAChildExpr() instanceof MethodCall\n    ) and\n    // Avoid duplicate results from Kotlin member accesses.\n    not this.asExpr() instanceof PrivateGetterMethodCall\n  }\n}\n\nclass WebSettingsDisallowContentAccessSink extends DataFlow::Node {\n  WebSettingsDisallowContentAccessSink() {\n    exists(MethodCall ma |\n      ma.getQualifier() = this.asExpr() and\n      ma.getMethod() instanceof AllowContentAccessMethod and\n      ma.getArgument(0).(CompileTimeConstantExpr).getBooleanValue() = false\n    )\n  }\n}\n\nprivate newtype WebViewOrSettings =\n  IsWebView() or\n  IsSettings()\n\nmodule WebViewDisallowContentAccessConfig implements DataFlow::StateConfigSig {\n  class FlowState = WebViewOrSettings;\n\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    node instanceof WebViewSource and state instanceof IsWebView\n  }\n\n  /**\n   * Holds if the step from `node1` to `node2` is a dataflow step that gets the `WebSettings` object\n   * from the `getSettings` method of a `WebView` object.\n   *\n   * This step is only valid when `state1` is empty and `state2` indicates that the `WebSettings` object\n   * has been accessed.\n   */\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    state1 instanceof IsWebView and\n    state2 instanceof IsSettings and\n    // settings = webView.getSettings()\n    // ^node2   = ^node1\n    exists(MethodCall ma |\n      ma = node2.asExpr() and\n      ma.getQualifier() = node1.asExpr() and\n      ma.getMethod() instanceof WebViewGetSettingsMethod\n    )\n  }\n\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state instanceof IsSettings and\n    node instanceof WebSettingsDisallowContentAccessSink\n  }\n\n  predicate observeDiffInformedIncrementalMode() {\n    none() // only used negatively\n  }\n}\n\nmodule WebViewDisallowContentAccessFlow =\n  TaintTracking::GlobalWithState<WebViewDisallowContentAccessConfig>;\n\nfrom Expr e\nwhere\n  // explicit: setAllowContentAccess(true)\n  exists(MethodCall ma |\n    ma = e and\n    ma.getMethod() instanceof AllowContentAccessMethod and\n    ma.getArgument(0).(CompileTimeConstantExpr).getBooleanValue() = true\n  )\n  or\n  // implicit: no setAllowContentAccess(false)\n  exists(WebViewSource source |\n    source.asExpr() = e and\n    not WebViewDisallowContentAccessFlow::flow(source, _)\n  )\nselect e,\n  \"Sensitive information may be exposed via a malicious link due to access to content:// links being allowed in this WebView.\"",
        "description": "Access to content providers in a WebView can allow access to protected information by loading content:// links.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-200/AndroidWebViewSettingsAllowsContentAccess.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.android.WebView\n\nfrom MethodCall ma\nwhere\n  ma.getMethod() instanceof CrossOriginAccessMethod and\n  ma.getArgument(0).(CompileTimeConstantExpr).getBooleanValue() = true\nselect ma,\n  \"WebView setting \" + ma.getMethod().getName() +\n    \" may allow for unauthorized access of sensitive information.\"",
        "description": "Enabling access to the file system in a WebView allows attackers to view sensitive information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-200/AndroidWebViewSettingsFileAccess.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.SpringSecurity\nimport semmle.code.java.security.SpringBootActuatorsQuery\n\nfrom SpringPermitAllCall permitAllCall\nwhere permitsSpringBootActuators(permitAllCall)\nselect permitAllCall, \"Unauthenticated access to Spring Boot actuator is allowed.\"",
        "description": "Exposing Spring Boot actuators may lead to information leak from the internal application, or even to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-200/SpringBootActuators.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.MavenPom\nimport semmle.code.java.security.SpringBootActuatorsConfigQuery\n\nfrom SpringBootStarterActuatorDependency d, JavaPropertyOption jpOption\nwhere exposesSensitiveEndpoint(d, jpOption)\nselect d, \"Insecure Spring Boot actuator $@ exposes sensitive endpoints.\", jpOption, \"configuration\"",
        "description": "Exposing Spring Boot actuators through configuration files may lead to information leak from the internal application, or even to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-200/SpringBootActuatorsConfig/SpringBootActuatorsConfig.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.UrlRedirectQuery\nimport UrlRedirectFlow::PathGraph\n\nfrom UrlRedirectFlow::PathNode source, UrlRedirectFlow::PathNode sink\nwhere UrlRedirectFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Untrusted URL redirection depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "URL redirection based on unvalidated user-input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-601/UrlRedirect.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.ImplicitlyExportedAndroidComponent\n\nfrom ImplicitlyExportedAndroidComponent impExpAndroidComp\nselect impExpAndroidComp, \"This component is implicitly exported.\"",
        "description": "Android components with an '<intent-filter>' and no 'android:exported' attribute are implicitly exported, which can allow for improper access to the components themselves and to their data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-926/ImplicitlyExportedAndroidComponent.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.AndroidManifest\n\nfrom AndroidProviderXmlElement provider\nwhere\n  not provider.getFile().(AndroidManifestXmlFile).isInBuildDirectory() and\n  provider.isExported() and\n  provider.hasIncompletePermissions()\nselect provider, \"Exported provider has incomplete permissions.\"",
        "description": "Android content providers which do not configure both read and write permissions can allow permission bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-926/ContentProviderIncompletePermissions.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.RsaWithoutOaepQuery\nimport RsaWithoutOaepFlow::PathGraph\n\nfrom RsaWithoutOaepFlow::PathNode source, RsaWithoutOaepFlow::PathNode sink\nwhere RsaWithoutOaepFlow::flowPath(source, sink)\nselect source, source, sink, \"This specification is used to $@ without OAEP padding.\", sink,\n  \"initialize an RSA cipher\"",
        "description": "Using RSA encryption without OAEP padding can result in a padding oracle attack, leading to a weaker encryption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-780/RsaWithoutOaep.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.InsufficientKeySizeQuery\nimport KeySizeFlow::PathGraph\n\nfrom KeySizeFlow::PathNode source, KeySizeFlow::PathNode sink\nwhere KeySizeFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This $@ is less than the recommended key size of \" + source.getState() + \" bits.\",\n  source.getNode(), \"key size\"",
        "description": "Using cryptographic algorithms with too small a key size can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-326/InsufficientKeySize.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.MavenPom\n\npredicate isBintrayRepositoryUsage(DeclaredRepository repository) {\n  repository.getRepositoryUrl().matches(\"%.bintray.com%\")\n}\n\nfrom DeclaredRepository repository\nwhere isBintrayRepositoryUsage(repository)\nselect repository,\n  \"Downloading or uploading artifacts to deprecated repository \" + repository.getRepositoryUrl()",
        "description": "Using a deprecated artifact repository may eventually give attackers access for a supply chain attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-1104/MavenPomDependsOnBintray.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.OgnlInjectionQuery\nimport OgnlInjectionFlow::PathGraph\n\nfrom OgnlInjectionFlow::PathNode source, OgnlInjectionFlow::PathNode sink\nwhere OgnlInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"OGNL Expression Language statement depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Evaluation of OGNL Expression Language statement with user-controlled input can lead to execution of arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-917/OgnlInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.HttpsUrlsQuery\nimport HttpStringToUrlOpenMethodFlow::PathGraph\n\nfrom HttpStringToUrlOpenMethodFlow::PathNode source, HttpStringToUrlOpenMethodFlow::PathNode sink\nwhere HttpStringToUrlOpenMethodFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"URL may have been constructed with HTTP protocol, using $@.\",\n  source.getNode(), \"this HTTP URL\"",
        "description": "Non-HTTPS connections can be intercepted by third parties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-319/HttpsUrls.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.Encryption\n\nclass NetworkClass extends Class {\n  NetworkClass() {\n    this.getAnAncestor()\n        .getPackage()\n        .getName()\n        .regexpMatch(\"(java\\\\.net|java\\\\.rmi|javax\\\\.net)(\\\\..*)?\")\n  }\n}\n\nclass SocketFactoryType extends RefType {\n  SocketFactoryType() {\n    this.hasQualifiedName(\"java.rmi.server\", \"RMIServerSocketFactory\") or\n    this.hasQualifiedName(\"java.rmi.server\", \"RMIClientSocketFactory\") or\n    this.hasQualifiedName(\"javax.net\", \"SocketFactory\") or\n    this.hasQualifiedName(\"java.net\", \"SocketImplFactory\")\n  }\n}\n\npragma[nomagic]\npredicate usesFactory(Method m, int p) {\n  m.getParameter(p).getType().(RefType).getAnAncestor() instanceof SocketFactoryType\n}\n\npredicate overloadUsesFactories(Method m, Method overload) {\n  overload.getAParamType().(RefType).getAnAncestor() instanceof SocketFactoryType and\n  overloads(m, overload)\n}\n\npredicate overloads(Method m1, Method m2) {\n  m1 != m2 and\n  exists(RefType t, string name |\n    methodInfo(m1, t, name) and\n    methodInfo(m2, t, name)\n  )\n}\n\npredicate methodInfo(Method m, RefType t, string name) {\n  m.getDeclaringType() = t and\n  m.getName() = name\n}\n\npredicate query(MethodCall m, Method def, int paramNo, string message, Element evidence) {\n  m.getMethod() = def and\n  // Using a networking method.\n  def.getDeclaringType() instanceof NetworkClass and\n  (\n    // Either the method has a factory parameter that is used, but not with\n    // an SSL factory, ...\n    usesFactory(def, paramNo) and\n    evidence = m.getArgument(paramNo) and\n    not evidence.(Expr).getType() instanceof SslClass and\n    message = \"has a non-SSL factory argument \"\n    or\n    // ... or there is an overloaded method on the same type that does take a factory,\n    // which could be used for SSL.\n    overloadUsesFactories(def, evidence) and\n    paramNo = 0 and\n    message = \"could use custom factories via overloaded method \"\n  )\n}\n\nfrom MethodCall m, Method def, int param, string message, Element evidence\nwhere query(m, def, param, message, evidence)\nselect m, \"Method \" + message + \": use an SSL factory.\"",
        "description": "Connections that are specified by non-SSL socket factories can be intercepted by third parties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-319/UseSSLSocketFactories.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.TypeFlow\nimport semmle.code.java.security.Encryption\n\nclass UrlConnection extends RefType {\n  UrlConnection() {\n    this.getAnAncestor().hasQualifiedName(\"java.net\", \"URLConnection\") and\n    not this.hasName(\"JarURLConnection\")\n  }\n}\n\nclass Socket extends RefType {\n  Socket() { this.getAnAncestor().hasQualifiedName(\"java.net\", \"Socket\") }\n}\n\nfrom MethodCall m, Class c, string type\nwhere\n  m.getQualifier().getType() = c and\n  (\n    c instanceof UrlConnection and type = \"connection\"\n    or\n    c instanceof Socket and type = \"socket\"\n  ) and\n  not c instanceof SslClass and\n  not exists(RefType t |\n    exprTypeFlow(m.getQualifier(), t, _) and\n    t instanceof SslClass\n  ) and\n  (\n    m.getMethod().getName() = \"getInputStream\" or\n    m.getMethod().getName() = \"getOutputStream\"\n  )\nselect m, \"Stream using vulnerable non-SSL \" + type + \".\"",
        "description": "Non-SSL connections can be intercepted by third parties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-319/UseSSL.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\n\noverlay[local?]\nabstract private class InsecureNettyObjectCreation extends ClassInstanceExpr {\n  int vulnerableArgumentIndex;\n\n  InsecureNettyObjectCreation() {\n    DataFlow::localExprFlow(any(CompileTimeConstantExpr ctce | ctce.getBooleanValue() = false),\n      this.getArgument(vulnerableArgumentIndex))\n  }\n\n  abstract string splittingType();\n}\n\noverlay[local?]\nabstract private class RequestOrResponseSplittingInsecureNettyObjectCreation extends InsecureNettyObjectCreation\n{\n  override string splittingType() { result = \"Request splitting or response splitting\" }\n}\n\noverlay[local?]\nabstract private class RequestSplittingInsecureNettyObjectCreation extends InsecureNettyObjectCreation\n{\n  override string splittingType() { result = \"Request splitting\" }\n}\n\noverlay[local?]\nabstract private class ResponseSplittingInsecureNettyObjectCreation extends InsecureNettyObjectCreation\n{\n  override string splittingType() { result = \"Response splitting\" }\n}\n\noverlay[local?]\nprivate class InsecureDefaultHttpHeadersClassInstantiation extends RequestOrResponseSplittingInsecureNettyObjectCreation\n{\n  InsecureDefaultHttpHeadersClassInstantiation() {\n    this.getConstructedType()\n        .hasQualifiedName(\"io.netty.handler.codec.http\",\n          [\"DefaultHttpHeaders\", \"CombinedHttpHeaders\"]) and\n    vulnerableArgumentIndex = 0\n  }\n}\n\noverlay[local?]\nprivate class InsecureDefaultHttpResponseClassInstantiation extends ResponseSplittingInsecureNettyObjectCreation\n{\n  InsecureDefaultHttpResponseClassInstantiation() {\n    this.getConstructedType().hasQualifiedName(\"io.netty.handler.codec.http\", \"DefaultHttpResponse\") and\n    vulnerableArgumentIndex = 2\n  }\n}\n\noverlay[local?]\nprivate class InsecureDefaultHttpRequestClassInstantiation extends RequestSplittingInsecureNettyObjectCreation\n{\n  InsecureDefaultHttpRequestClassInstantiation() {\n    this.getConstructedType().hasQualifiedName(\"io.netty.handler.codec.http\", \"DefaultHttpRequest\") and\n    vulnerableArgumentIndex = 3\n  }\n}\n\noverlay[local?]\nprivate class InsecureDefaultFullHttpResponseClassInstantiation extends ResponseSplittingInsecureNettyObjectCreation\n{\n  InsecureDefaultFullHttpResponseClassInstantiation() {\n    this.getConstructedType()\n        .hasQualifiedName(\"io.netty.handler.codec.http\", \"DefaultFullHttpResponse\") and\n    vulnerableArgumentIndex = [2, 3]\n  }\n}\n\noverlay[local?]\nprivate class InsecureDefaultFullHttpRequestClassInstantiation extends RequestSplittingInsecureNettyObjectCreation\n{\n  InsecureDefaultFullHttpRequestClassInstantiation() {\n    this.getConstructedType()\n        .hasQualifiedName(\"io.netty.handler.codec.http\", \"DefaultFullHttpRequest\") and\n    vulnerableArgumentIndex = [3, 4]\n  }\n}\n\nfrom InsecureNettyObjectCreation new\nselect new, new.splittingType() + \" vulnerability due to header value verification being disabled.\"",
        "description": "Disabling HTTP header validation makes code vulnerable to attack by header splitting if user input is written directly to an HTTP header.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-113/NettyResponseSplitting.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.ResponseSplittingQuery\nimport ResponseSplittingFlow::PathGraph\n\nfrom ResponseSplittingFlow::PathNode source, ResponseSplittingFlow::PathNode sink\nwhere ResponseSplittingFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This header depends on a $@, which may cause a response-splitting vulnerability.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Writing user input directly to an HTTP header makes code vulnerable to attack by header splitting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-113/ResponseSplitting.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.SensitiveKeyboardCacheQuery\n\nfrom AndroidEditableXmlElement el\nwhere el = getASensitiveCachedInput()\nselect el, \"This input field may contain sensitive information that is saved to the keyboard cache.\"",
        "description": "Allowing the keyboard to cache sensitive information may result in information leaks to other applications.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-524/SensitiveKeyboardCache.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.Encryption\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.frameworks.Properties\nimport semmle.code.java.security.MaybeBrokenCryptoAlgorithmQuery\nimport InsecureCryptoFlow::PathGraph\n\nfrom InsecureCryptoFlow::PathNode source, InsecureCryptoFlow::PathNode sink, CryptoAlgoSpec c\nwhere\n  sink.getNode().asExpr() = c.getAlgoSpec() and\n  InsecureCryptoFlow::flowPath(source, sink)\nselect c, source, sink,\n  \"Cryptographic algorithm $@ may not be secure. Consider using a different algorithm.\", source,\n  source.getNode().asExpr().(InsecureAlgorithm).getStringValue()",
        "description": "Using broken or weak cryptographic algorithms can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-327/MaybeBrokenCryptoAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.Encryption\nimport semmle.code.java.security.BrokenCryptoAlgorithmQuery\nimport InsecureCryptoFlow::PathGraph\n\nfrom\n  InsecureCryptoFlow::PathNode source, InsecureCryptoFlow::PathNode sink, CryptoAlgoSpec spec,\n  BrokenAlgoLiteral algo, string reason\nwhere\n  sink.getNode().asExpr() = spec.getAlgoSpec() and\n  source.getNode().asExpr() = algo and\n  reason = getInsecureAlgorithmReason(algo.getValue()) and\n  InsecureCryptoFlow::flowPath(source, sink)\nselect spec, source, sink, \"Cryptographic algorithm $@ is insecure. \" + reason, algo,\n  algo.getValue()",
        "description": "Using broken or weak cryptographic algorithms can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-327/BrokenCryptoAlgorithm.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.RequestForgeryConfig\nimport RequestForgeryFlow::PathGraph\n\nfrom RequestForgeryFlow::PathNode source, RequestForgeryFlow::PathNode sink\nwhere RequestForgeryFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Potential server-side request forgery due to a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Making web requests based on unvalidated user-input may cause the server to communicate with malicious servers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-918/RequestForgery.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.SensitiveResultReceiverQuery\nimport SensitiveResultReceiverFlow::PathGraph\n\nfrom\n  SensitiveResultReceiverFlow::PathNode src, SensitiveResultReceiverFlow::PathNode sink,\n  DataFlow::Node recSrc\nwhere isSensitiveResultReceiver(src, sink, recSrc)\nselect sink, src, sink, \"This $@ is sent to a ResultReceiver obtained from $@.\", src,\n  \"sensitive information\", recSrc, \"this untrusted source\"",
        "description": "Sending sensitive data to a 'ResultReceiver' obtained from an untrusted source can allow malicious actors access to your information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-927/SensitiveResultReceiver.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.AndroidSensitiveCommunicationQuery\nimport SensitiveCommunicationFlow::PathGraph\n\nfrom SensitiveCommunicationFlow::PathNode source, SensitiveCommunicationFlow::PathNode sink\nwhere SensitiveCommunicationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This call may leak $@.\", source.getNode(),\n  \"sensitive information\"",
        "description": "An Android application uses implicit Intents containing sensitive data in a way that exposes it to arbitrary applications on the device.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-927/SensitiveCommunication.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.ImplicitPendingIntentsQuery\nimport ImplicitPendingIntentStartFlow::PathGraph\n\nfrom ImplicitPendingIntentStartFlow::PathNode source, ImplicitPendingIntentStartFlow::PathNode sink\nwhere ImplicitPendingIntentStartFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"$@ and sent to an unspecified third party through a PendingIntent.\", source.getNode(),\n  \"An implicit Intent is created\"",
        "description": "Sending an implicit and mutable 'PendingIntent' to an unspecified third party component may provide an attacker with access to internal components of the application or cause other unintended effects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-927/ImplicitPendingIntents.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.InsecureBasicAuthQuery\nimport InsecureBasicAuthFlow::PathGraph\n\nfrom InsecureBasicAuthFlow::PathNode source, InsecureBasicAuthFlow::PathNode sink\nwhere InsecureBasicAuthFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Insecure basic authentication from a $@.\", source.getNode(),\n  \"HTTP URL\"",
        "description": "Basic authentication only obfuscates username/password in Base64 encoding, which can be easily recognized and reversed. Transmitting sensitive information without using HTTPS makes the data vulnerable to packet sniffing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-522/InsecureBasicAuth.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.InsecureLdapAuthQuery\nimport InsecureLdapUrlFlow::PathGraph\n\nfrom InsecureLdapUrlFlow::PathNode source, InsecureLdapUrlFlow::PathNode sink\nwhere\n  InsecureLdapUrlFlow::flowPath(source, sink) and\n  BasicAuthFlow::flowTo(sink.getNode()) and\n  not RequiresSslFlow::flowTo(sink.getNode())\nselect sink.getNode(), source, sink, \"Insecure LDAP authentication from $@.\", source.getNode(),\n  \"LDAP connection string\"",
        "description": "LDAP authentication with credentials sent in cleartext makes sensitive information vulnerable to remote attackers",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-522/InsecureLdapAuth.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.FileReadWrite\nimport semmle.code.java.security.FileWritable\n\nfrom Variable fileVariable, FileReadExpr readFrom, SetFileWorldWritable setWorldWritable\nwhere\n  // The file variable must be both read from and set to world writable. This is not flow-sensitive.\n  fileVariable.getAnAccess() = readFrom.getFileVarAccess() and\n  fileVariable.getAnAccess() = setWorldWritable.getFileVarAccess() and\n  // If the file variable is a parameter, the result should be reported in the caller.\n  not fileVariable instanceof Parameter\nselect setWorldWritable, \"This sets a file is as world writable, but is read from $@.\", readFrom,\n  \"statement\"",
        "description": "Reading from a file which is set as world writable is dangerous because the file may be modified or removed by external actors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-732/ReadingFromWorldWritableFile.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.ArithmeticCommon\nimport semmle.code.java.security.ArithmeticWithExtremeValuesQuery\nimport Flow::PathGraph\n\nmodule Flow =\n  DataFlow::MergePathGraph<MaxValueFlow::PathNode, MinValueFlow::PathNode, MaxValueFlow::PathGraph,\n    MinValueFlow::PathGraph>;\n\npredicate query(\n  Flow::PathNode source, Flow::PathNode sink, ArithExpr exp, string effect, Type srctyp\n) {\n  (\n    MaxValueFlow::flowPath(source.asPathNode1(), sink.asPathNode1()) and\n    overflowSink(exp, sink.getNode().asExpr()) and\n    effect = \"overflow\"\n    or\n    MinValueFlow::flowPath(source.asPathNode2(), sink.asPathNode2()) and\n    underflowSink(exp, sink.getNode().asExpr()) and\n    effect = \"underflow\"\n  ) and\n  srctyp = source.getNode().asExpr().getType()\n}\n\nfrom\n  Flow::PathNode source, Flow::PathNode sink, ArithExpr exp, Variable v, ExtremeSource s,\n  string effect, Type srctyp\nwhere\n  query(source, sink, exp, effect, srctyp) and\n  // Exclude widening conversions of extreme values due to binary numeric promotion (JLS 5.6.2)\n  // unless there is an enclosing cast down to a narrower type.\n  narrowerThanOrEqualTo(exp, srctyp) and\n  v = sink.getNode().asExpr().(VarAccess).getVariable() and\n  s = source.getNode().asExpr()\nselect exp, source, sink,\n  \"Variable \" + v.getName() + \" is assigned an extreme value $@, and may cause an \" + effect + \".\",\n  s, s.getVariable().getName()",
        "description": "If a variable is assigned the maximum or minimum value for that variable's type and is then used in an arithmetic expression, this may result in an overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-190/ArithmeticWithExtremeValues.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.ArithmeticCommon\nimport semmle.code.java.security.ArithmeticTaintedQuery\n\nmodule Flow =\n  DataFlow::MergePathGraph<ArithmeticOverflow::PathNode, ArithmeticUnderflow::PathNode,\n    ArithmeticOverflow::PathGraph, ArithmeticUnderflow::PathGraph>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink, ArithExpr exp, string effect\nwhere\n  ArithmeticOverflow::flowPath(source.asPathNode1(), sink.asPathNode1()) and\n  overflowSink(exp, sink.getNode().asExpr()) and\n  effect = \"overflow\"\n  or\n  ArithmeticUnderflow::flowPath(source.asPathNode2(), sink.asPathNode2()) and\n  underflowSink(exp, sink.getNode().asExpr()) and\n  effect = \"underflow\"\nselect exp, source, sink,\n  \"This arithmetic expression depends on a $@, potentially causing an \" + effect + \".\",\n  source.getNode(), \"user-provided value\"",
        "description": "Arithmetic operations on user-controlled data that is not validated can cause overflows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-190/ArithmeticTainted.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.arithmetic.Overflow\n\nint widthRank(Expr e) { result = e.getType().(NumType).getWidthRank() }\n\npredicate wideningComparison(ComparisonExpr c, Expr lesserOperand, Expr greaterOperand) {\n  lesserOperand = c.getLesserOperand() and\n  greaterOperand = c.getGreaterOperand() and\n  widthRank(lesserOperand) < widthRank(greaterOperand)\n}\n\nfrom ComparisonExpr c, LoopStmt l, Expr lesserOperand, Expr greaterOperand\nwhere\n  wideningComparison(c, lesserOperand, greaterOperand) and\n  not c.getAnOperand().isCompileTimeConstant() and\n  l.getCondition().getAChildExpr*() = c\nselect c,\n  \"Comparison between $@ of type \" + lesserOperand.getType().getName() + \" and $@ of wider type \" +\n    greaterOperand.getType().getName() + \".\", lesserOperand, \"expression\", greaterOperand,\n  \"expression\"",
        "description": "Comparisons between types of different widths in a loop condition can cause the loop to behave unexpectedly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-190/ComparisonWithWiderType.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.ArithmeticCommon\nimport semmle.code.java.security.ArithmeticUncontrolledQuery\n\nmodule Flow =\n  DataFlow::MergePathGraph<ArithmeticUncontrolledOverflowFlow::PathNode,\n    ArithmeticUncontrolledUnderflowFlow::PathNode, ArithmeticUncontrolledOverflowFlow::PathGraph,\n    ArithmeticUncontrolledUnderflowFlow::PathGraph>;\n\nimport Flow::PathGraph\n\nfrom Flow::PathNode source, Flow::PathNode sink, ArithExpr exp, string effect\nwhere\n  ArithmeticUncontrolledOverflowFlow::flowPath(source.asPathNode1(), sink.asPathNode1()) and\n  overflowSink(exp, sink.getNode().asExpr()) and\n  effect = \"overflow\"\n  or\n  ArithmeticUncontrolledUnderflowFlow::flowPath(source.asPathNode2(), sink.asPathNode2()) and\n  underflowSink(exp, sink.getNode().asExpr()) and\n  effect = \"underflow\"\nselect exp, source, sink,\n  \"This arithmetic expression depends on an $@, potentially causing an \" + effect + \".\",\n  source.getNode(), \"uncontrolled value\"",
        "description": "Arithmetic operations on uncontrolled data that is not validated can cause overflows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-190/ArithmeticUncontrolled.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Concurrency\nimport semmle.code.java.controlflow.Guards\n\npredicate commonSynchronization(Expr e1, Expr e2, Variable monitor) {\n  exists(SynchronizedStmt s |\n    locallySynchronizedOn(e1, s, monitor) and\n    locallySynchronizedOn(e2, s, monitor)\n  )\n}\n\npredicate synchCallOn(MethodCall m, Variable receiver) {\n  m.getCallee() instanceof SynchronizedCallable and\n  m.getQualifier() = receiver.getAnAccess()\n}\n\nclass PossiblyConcurrentCallable extends Callable {\n  PossiblyConcurrentCallable() {\n    this instanceof SynchronizedCallable\n    or\n    exists(SynchronizedStmt s | s.getEnclosingCallable() = this)\n    or\n    exists(FieldAccess f | f.getVariable().isVolatile() | f.getEnclosingCallable() = this)\n    or\n    exists(VarAccess v |\n      v.getVariable().getType().(RefType).hasQualifiedName(\"java.lang\", \"ThreadLocal\")\n    |\n      v.getEnclosingCallable() = this\n    )\n  }\n}\n\nprivate VarAccess getANonInitializationAccess(Field f) {\n  result = f.getAnAccess() and\n  exists(Callable c | c = result.getEnclosingCallable() |\n    not (\n      c = f.getDeclaringType().getACallable() and\n      (c instanceof Constructor or c instanceof InitializerMethod)\n    )\n  )\n}\n\npredicate alwaysLocked(Field f) {\n  exists(Variable lock |\n    forex(VarAccess access | access = getANonInitializationAccess(f) |\n      locallySynchronizedOn(access, _, lock)\n    )\n  )\n  or\n  exists(RefType thisType |\n    forex(VarAccess access | access = getANonInitializationAccess(f) |\n      locallySynchronizedOnThis(access, thisType)\n    )\n  )\n  or\n  exists(RefType classType |\n    forex(VarAccess access | access = getANonInitializationAccess(f) |\n      locallySynchronizedOnClass(access, classType)\n    )\n  )\n}\n\npredicate probablyNeverEscapes(LocalVariableDecl v) {\n  // Not passed into another function.\n  not exists(Call c | c.getAnArgument() = v.getAnAccess()) and\n  // Not assigned directly to another variable.\n  not exists(Assignment a | a.getSource() = v.getAnAccess()) and\n  // Not returned.\n  not exists(ReturnStmt r | r.getResult() = v.getAnAccess()) and\n  // All assignments are to new instances of a class.\n  forex(Expr e | e = v.getAnAssignedValue() | e instanceof ClassInstanceExpr)\n}\n\n// Loop conditions tend to be uninteresting, so are not included.\nfrom IfStmt check, MethodCall call1, MethodCall call2, Variable r\nwhere\n  check.getCondition().getAChildExpr*() = call1 and\n  // This can happen if there are loops, etc.\n  not call1 = call2 and\n  // The use is controlled by one of the branches of the condition, i.e. whether it\n  // is reached actually depends on that condition.\n  call1.getBasicBlock().(ConditionBlock).controls(call2.getBasicBlock(), _) and\n  // Two calls to synchronized methods on the same variable.\n  synchCallOn(call1, r) and\n  synchCallOn(call2, r) and\n  // Not jointly synchronized on that variable.\n  // (If the caller synchronizes on `r` then it takes the same monitor as the `synchronized` callees do.)\n  not commonSynchronization(call1, call2, r) and\n  // Only include cases that look like they may be intended for concurrent usage.\n  check.getEnclosingCallable() instanceof PossiblyConcurrentCallable and\n  // Ignore fields that look like they're consistently guarded with some other lock.\n  not alwaysLocked(r) and\n  // Ignore local variables whose value probably never escapes, as they can't be accessed concurrently.\n  not probablyNeverEscapes(r) and\n  // The synchronized methods on `Throwable` are not interesting.\n  not call1.getCallee().getDeclaringType() instanceof TypeThrowable\nselect call2, \"This uses the state of $@ which $@. But these are not jointly synchronized.\", r,\n  r.getName(), call1, \"is checked at a previous call\"",
        "description": "Using a resource after an unsynchronized state check can lead to a race condition, if the state may be changed between the check and use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-367/TOCTOURace.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.TrustBoundaryViolationQuery\nimport TrustBoundaryFlow::PathGraph\n\nfrom TrustBoundaryFlow::PathNode source, TrustBoundaryFlow::PathNode sink\nwhere TrustBoundaryFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This servlet reads data from a $@ and writes it to a session variable.\", source, \"remote source\"",
        "description": "Modifying the HTTP session attributes based on data from an untrusted source may violate a trust boundary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-501/TrustBoundaryViolation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.UrlForwardQuery\nimport UrlForwardFlow::PathGraph\n\nfrom UrlForwardFlow::PathNode source, UrlForwardFlow::PathNode sink\nwhere UrlForwardFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Untrusted URL forward depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "URL forward based on unvalidated user input may cause file information disclosure.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-552/UrlForward.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.RandomQuery\n\nfrom GetRandomData da, VarRead use, PredictableSeedExpr source\nwhere\n  da.getQualifier() = use and\n  unsafelySeeded(use, source)\nselect da, \"Usage of a SecureRandom number generator seeded with a $@.\", source, \"predictable value\"",
        "description": "Using a predictable seed in a pseudo-random number generator can lead to predictability of the numbers generated by it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-335/PredictableSeed.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.AndroidManifest\n\nfrom AndroidApplicationXmlElement androidAppElem\nwhere\n  androidAppElem.isDebuggable() and\n  not androidAppElem.getFile().(AndroidManifestXmlFile).isInBuildDirectory()\nselect androidAppElem.getAttribute(\"debuggable\"), \"The 'android:debuggable' attribute is enabled.\"",
        "description": "An enabled debugger can allow for entry points in the application or reveal sensitive information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-489/DebuggableAttributeEnabled.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.WebviewDebuggingEnabledQuery\nimport WebviewDebugEnabledFlow::PathGraph\n\nfrom WebviewDebugEnabledFlow::PathNode source, WebviewDebugEnabledFlow::PathNode sink\nwhere WebviewDebugEnabledFlow::flowPath(source, sink)\nselect sink, source, sink, \"Webview debugging is enabled.\"",
        "description": "Enabling Webview debugging in production builds can expose entry points or leak sensitive information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-489/WebviewDebuggingEnabled.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.StaticInitializationVectorQuery\nimport StaticInitializationVectorFlow::PathGraph\n\nfrom StaticInitializationVectorFlow::PathNode source, StaticInitializationVectorFlow::PathNode sink\nwhere StaticInitializationVectorFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"A $@ should not be used for encryption.\", source.getNode(),\n  \"static initialization vector\"",
        "description": "An initialization vector (IV) used for ciphers of certain modes (such as CBC or GCM) should be unique and unpredictable, to maximize encryption and prevent dictionary attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-1204/StaticInitializationVector.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.Servlets\nimport semmle.code.java.security.InsecureCookieQuery\n\nfrom MethodCall add\nwhere\n  add.getMethod() instanceof ResponseAddCookieMethod and\n  not SecureCookieFlow::flowToExpr(add.getArgument(0))\nselect add, \"Cookie is added to response without the 'secure' flag being set.\"",
        "description": "Insecure cookies may be sent in cleartext, which makes them vulnerable to interception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-614/InsecureCookie.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.SqlConcatenatedLib\nimport semmle.code.java.security.SqlInjectionQuery\nimport semmle.code.java.security.SqlConcatenatedQuery\n\nfrom QueryInjectionSink query, Expr uncontrolled\nwhere\n  (\n    builtFromUncontrolledConcat(query.asExpr(), uncontrolled)\n    or\n    exists(StringBuilderVar sbv |\n      uncontrolledStringBuilderQuery(sbv, uncontrolled) and\n      UncontrolledStringBuilderSourceFlow::flow(DataFlow::exprNode(sbv.getToStringCall()), query)\n    )\n  ) and\n  not queryIsTaintedBy(query, _, _)\nselect query, \"Query built by concatenation with $@, which may be untrusted.\", uncontrolled,\n  \"this expression\"",
        "description": "Building a SQL or Java Persistence query by concatenating a possibly-untrusted string is vulnerable to insertion of malicious code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-089/SqlConcatenated.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.SqlInjectionQuery\nimport QueryInjectionFlow::PathGraph\n\nfrom\n  QueryInjectionSink query, QueryInjectionFlow::PathNode source, QueryInjectionFlow::PathNode sink\nwhere queryIsTaintedBy(query, source, sink)\nselect query, source, sink, \"This query depends on a $@.\", source.getNode(), \"user-provided value\"",
        "description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-089/SqlTainted.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.SensitiveActions\nimport semmle.code.java.controlflow.Dominance\nimport semmle.code.java.controlflow.Guards\n\nabstract class ConnectionMethod extends Method { }\n\n\nclass ServerSocketAcceptMethod extends ConnectionMethod {\n  ServerSocketAcceptMethod() {\n    this.getName() = \"accept\" and\n    this.getDeclaringType().hasQualifiedName(\"java.net\", \"ServerSocket\")\n  }\n}\n\nclass ServerSocketChannelAcceptMethod extends ConnectionMethod {\n  ServerSocketChannelAcceptMethod() {\n    this.getName() = \"accept\" and\n    this.getDeclaringType().hasQualifiedName(\"java.nio.channels\", \"ServerSocketChannel\")\n  }\n}\n\npredicate controlledByAuth(Expr controlled, Expr condition) {\n  exists(ConditionBlock b |\n    condition = b.getCondition() and\n    b.controls(controlled.getBasicBlock(), _) and\n    condition.(MethodCall).getMethod() instanceof AuthMethod\n  )\n}\n\n\nfrom MethodCall connection, Expr condition\nwhere\n  connection.getMethod() instanceof ConnectionMethod and\n  controlledByAuth(connection, condition)\nselect connection,\n  \"This connection occurs after the authentication in $@, rather than authentication over the new connection.\",\n  condition, \"this condition\"",
        "description": "Opening a socket after authenticating via a different channel may allow an attacker to connect to the port first.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-421/SocketAuthRace.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.JndiInjectionQuery\nimport JndiInjectionFlow::PathGraph\n\nfrom JndiInjectionFlow::PathNode source, JndiInjectionFlow::PathNode sink\nwhere JndiInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"JNDI lookup might include name from $@.\", source.getNode(),\n  \"this user input\"",
        "description": "Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted object and to execution of arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-074/JndiInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.XsltInjectionQuery\nimport XsltInjectionFlow::PathGraph\n\nfrom XsltInjectionFlow::PathNode source, XsltInjectionFlow::PathNode sink\nwhere XsltInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"XSLT transformation might include stylesheet from $@.\",\n  source.getNode(), \"this user input\"",
        "description": "Performing an XSLT transformation with user-controlled stylesheets can lead to information disclosure or execution of arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-074/XsltInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.dataflow.TaintTracking\nimport semmle.code.java.security.ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom UntrustedDataToExternalApiFlow::PathNode source, UntrustedDataToExternalApiFlow::PathNode sink\nwhere UntrustedDataToExternalApiFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"Call to \" + sink.getNode().(ExternalApiDataNode).getMethodDescription() +\n    \" with untrusted data from $@.\", source, source.toString()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-020/UntrustedDataToExternalAPI.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.ExternalAPIs\nimport semmle.code.java.dataflow.DataFlow\n\nfrom ExternalApiUsedWithUntrustedData externalApi\nselect externalApi, count(externalApi.getUntrustedDataNode()) as numberOfUses,\n  externalApi.getNumberOfUntrustedSources() as numberOfUntrustedSources order by\n    numberOfUntrustedSources desc",
        "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-020/ExternalAPIsUsedWithUntrustedData.ql",
        "language": "java"
    },
    {
        "query": "private import semmle.code.java.regex.RegexTreeView::RegexTreeView as TreeView\nimport codeql.regex.OverlyLargeRangeQuery::Make<TreeView>\n\nTreeView::RegExpCharacterClass potentialMisparsedCharClass() {\n  // nested char classes are currently misparsed\n  result.getAChild().(TreeView::RegExpNormalChar).getValue() = \"[\"\n}\n\nfrom TreeView::RegExpCharacterRange range, string reason\nwhere\n  problem(range, reason) and\n  not range.getParent() = potentialMisparsedCharClass()\nselect range, \"Suspicious character range that \" + reason + \".\"",
        "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-020/OverlyLargeRange.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate dangerousMethod(string pack, string type, string name) {\n  pack = \"java.lang\" and type = \"Thread\" and name = \"stop\"\n}\n\nfrom MethodCall call, Method target, string pack, string type, string name\nwhere\n  call.getCallee() = target and\n  target.hasQualifiedName(pack, type, name) and\n  dangerousMethod(pack, type, name)\nselect call, \"Call to \" + pack + \".\" + type + \".\" + name + \" is potentially dangerous.\"",
        "description": "Certain standard library routines are dangerous to call.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-676/PotentiallyDangerousFunction.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.FlowSources\nimport semmle.code.java.security.LdapInjectionQuery\nimport LdapInjectionFlow::PathGraph\n\nfrom LdapInjectionFlow::PathNode source, LdapInjectionFlow::PathNode sink\nwhere LdapInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This LDAP query depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-090/LdapInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass LockVariable extends Variable {\n  LockVariable() {\n    this.getType().(RefType).hasQualifiedName(\"java.util.concurrent.locks\", \"ReentrantLock\")\n  }\n\n  /** An access to method `lock` on this variable. */\n  MethodCall getLockAction() {\n    exists(MethodCall ma | ma.getQualifier() = this.getAnAccess() |\n      ma.getMethod().hasName(\"lock\") and\n      result = ma\n    )\n  }\n}\n\nclass Synched extends Top {\n  Synched() {\n    this instanceof SynchronizedStmt\n    or\n    exists(Method m | m.isSynchronized() and not m.isStatic() |\n      m = this\n      or\n      exists(MethodCall ma, VarAccess qual | ma = this and qual = ma.getQualifier() |\n        ma.getMethod() = m\n      )\n    )\n  }\n\n  /** A synchronizing statement nested within this element. */\n  Synched getInnerSynch() {\n    result = this.(Method).getBody().getAChild*()\n    or\n    result = this.(SynchronizedStmt).getAChild+()\n    or\n    exists(MethodCall ma | ma = result |\n      ma.getEnclosingStmt().getEnclosingStmt*() = this or ma.getEnclosingCallable() = this\n    )\n  }\n\n  /** The variable on which synchronization is performed, provided this element is a `SynchronizedStmt`. */\n  Variable getLockVar() {\n    exists(VarAccess va | va = this.(SynchronizedStmt).getExpr() and not exists(va.getQualifier()) |\n      result = va.getVariable()\n    )\n  }\n\n  /**\n   * The type of the instance on which synchronization is performed, provided this element is a\n   * synchronized method or method access.\n   */\n  RefType getLockType() {\n    result = this.(Method).getDeclaringType().getSourceDeclaration() or\n    result = this.(MethodCall).getMethod().getDeclaringType().getSourceDeclaration()\n  }\n}\n\npredicate badReentrantLockOrder(MethodCall first, MethodCall second, MethodCall otherFirst) {\n  exists(LockVariable v1, LockVariable v2, MethodCall otherSecond |\n    first = v1.getLockAction() and\n    otherSecond = v1.getLockAction() and\n    second = v2.getLockAction() and\n    otherFirst = v2.getLockAction() and\n    first.getControlFlowNode().getASuccessor+() = second.getControlFlowNode() and\n    otherFirst.getControlFlowNode().getASuccessor+() = otherSecond.getControlFlowNode()\n  |\n    v1 != v2\n  )\n}\n\npredicate badSynchronizedStmtLockOrder(Expr outerExpr, Expr innerExpr, Expr otherOuterExpr) {\n  exists(Synched outer, Synched inner, Synched otherOuter |\n    outer.(SynchronizedStmt).getExpr() = outerExpr and\n    inner.(SynchronizedStmt).getExpr() = innerExpr and\n    otherOuter.(SynchronizedStmt).getExpr() = otherOuterExpr and\n    inner = outer.getInnerSynch() and\n    exists(Variable v1, Variable v2 |\n      v1 = outer.getLockVar() and v2 = inner.getLockVar() and v1 != v2\n    |\n      exists(Synched otherInner | otherInner = otherOuter.getInnerSynch() |\n        v2 = otherOuter.getLockVar() and\n        v1 = otherInner.getLockVar()\n      )\n    )\n  )\n}\n\npredicate qualifiedMethodCall(MethodCall ma, Method m, Variable vQual, int i, Variable vArg) {\n  ma.getMethod() = m and\n  ma.getQualifier().(VarAccess).getVariable() = vQual and\n  ma.getArgument(i).(VarAccess).getVariable() = vArg\n}\n\npredicate inDifferentBranches(MethodCall ma1, MethodCall ma2) {\n  exists(IfStmt cond |\n    ma1.getEnclosingStmt() = cond.getThen().getAChild*() and\n    ma2.getEnclosingStmt() = cond.getElse().getAChild*() and\n    not cond.getEnclosingCallable().isSynchronized()\n  )\n}\n\npredicate inRunnable(MethodCall ma, Method runnable) {\n  runnable.getName() = \"run\" and\n  runnable.getDeclaringType().getAStrictAncestor().hasQualifiedName(\"java.lang\", \"Runnable\") and\n  ma.getEnclosingCallable() = runnable\n}\n\npredicate inDifferentRunnables(MethodCall ma1, MethodCall ma2) {\n  exists(Method runnable1, Method runnable2 |\n    inRunnable(ma1, runnable1) and\n    inRunnable(ma2, runnable2) and\n    runnable1 != runnable2\n  )\n}\n\npredicate badMethodCallLockOrder(MethodCall outerAccess, MethodCall innerAccess, MethodCall other) {\n  exists(Synched outer, Synched inner |\n    inner = innerAccess and\n    inner = outer.getInnerSynch() and\n    inner.getLockType() = outer.getLockType() and\n    exists(Parameter p, int i | outer.(Method).getAParameter() = p and p.getPosition() = i |\n      inner.(MethodCall).getQualifier().(VarAccess).getVariable() = p and\n      exists(MethodCall ma1, MethodCall ma2, Variable v1, Variable v2 |\n        qualifiedMethodCall(ma1, outer, v1, i, v2) and\n        qualifiedMethodCall(ma2, outer, v2, i, v1) and\n        v1 != v2 and\n        (\n          inDifferentBranches(ma1, ma2) or\n          inDifferentRunnables(ma1, ma2)\n        ) and\n        ma1 = outerAccess and\n        ma2 = other\n      )\n    )\n  )\n}\n\nfrom Expr first, Expr second, Expr other\nwhere\n  badReentrantLockOrder(first, second, other) or\n  badSynchronizedStmtLockOrder(first, second, other) or\n  badMethodCallLockOrder(first, second, other)\nselect first,\n  \"Synchronization here and $@ may be performed in reverse order starting $@ and result in deadlock.\",\n  second, \"here\", other, \"here\"",
        "description": "Acquiring multiple locks in a different order may cause deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-833/LockOrderInconsistency.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.IntentUriPermissionManipulationQuery\nimport semmle.code.java.dataflow.DataFlow\nimport IntentUriPermissionManipulationFlow::PathGraph\n\nfrom\n  IntentUriPermissionManipulationFlow::PathNode source,\n  IntentUriPermissionManipulationFlow::PathNode sink\nwhere IntentUriPermissionManipulationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This Intent can be set with arbitrary flags from a $@, \" +\n    \"and used to give access to internal content providers.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Returning an externally provided Intent via 'setResult' may allow a malicious application to access arbitrary content providers of the vulnerable application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-266/IntentUriPermissionManipulation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.AndroidWebViewCertificateValidationQuery\n\nfrom OnReceivedSslErrorMethod m\nwhere trustsAllCerts(m)\nselect m, \"This handler accepts all SSL certificates.\"",
        "description": "Trusting all certificates allows an attacker to perform a machine-in-the-middle attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-295/ImproperWebViewCertificateValidation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.AndroidCertificatePinningQuery\n\nfrom DataFlow::Node node, string domain, string msg\nwhere\n  missingPinning(node, domain) and\n  if domain = \"\"\n  then msg = \"(no explicitly trusted domains)\"\n  else msg = \"(\" + domain + \" is not trusted by a pin)\"\nselect node, \"This network call does not implement certificate pinning. \" + msg",
        "description": "Network connections that do not use certificate pinning may allow attackers to eavesdrop on communications.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-295/AndroidMissingCertificatePinning.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.InsecureTrustManagerQuery\nimport InsecureTrustManagerFlow::PathGraph\n\nfrom InsecureTrustManagerFlow::PathNode source, InsecureTrustManagerFlow::PathNode sink\nwhere InsecureTrustManagerFlow::flowPath(source, sink)\nselect sink, source, sink, \"This uses $@, which is defined in $@ and trusts any certificate.\",\n  source, \"TrustManager\",\n  source.getNode().asExpr().(ClassInstanceExpr).getConstructedType() as type, type.getNestedName()",
        "description": "Trusting all certificates allows an attacker to perform a machine-in-the-middle attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-295/InsecureTrustManager.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Likely_Bugs.Comparison.UselessComparisonTest\n\npredicate loopCondition(LoopStmt loop, Expr cond, boolean polarity) {\n  polarity = true and cond = loop.getCondition()\n  or\n  exists(IfStmt ifstmt, Stmt exit |\n    ifstmt.getEnclosingStmt*() = loop.getBody() and\n    ifstmt.getCondition() = cond and\n    (\n      exit.(BreakStmt).getTarget() = loop or\n      exit.(ReturnStmt).getEnclosingStmt*() = loop.getBody()\n    ) and\n    (\n      polarity = false and exit.getEnclosingStmt*() = ifstmt.getThen()\n      or\n      polarity = true and exit.getEnclosingStmt*() = ifstmt.getElse()\n    )\n  )\n}\n\npredicate subCondition(Expr cond, Expr subcond, boolean negated) {\n  cond = subcond and negated = false\n  or\n  subCondition(cond.(AndLogicalExpr).getAnOperand(), subcond, negated)\n  or\n  subCondition(cond.(OrLogicalExpr).getAnOperand(), subcond, negated)\n  or\n  subCondition(cond.(LogNotExpr).getExpr(), subcond, negated.booleanNot())\n}\n\nfrom\n  LoopStmt loop, BinaryExpr test, boolean testIsTrue, Expr cond, boolean polarity, boolean negated\nwhere\n  loopCondition(loop, cond, polarity) and\n  not loop instanceof EnhancedForStmt and\n  subCondition(cond, test, negated) and\n  uselessTest(_, test, testIsTrue) and\n  testIsTrue = polarity.booleanXor(negated)\nselect loop,\n  \"Loop might not terminate, as termination depends in part on $@ being \" + testIsTrue.booleanNot() +\n    \" but it is always \" + testIsTrue + \".\", test, \"this test\"",
        "description": "An iteration or loop with an exit condition that cannot be reached is an indication of faulty logic and can likely lead to infinite looping.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-835/InfiniteLoop.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.AndroidIntentRedirectionQuery\nimport IntentRedirectionFlow::PathGraph\n\nfrom IntentRedirectionFlow::PathNode source, IntentRedirectionFlow::PathNode sink\nwhere IntentRedirectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Arbitrary Android activities or services can be started from a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Starting Android components with user-provided Intents can provide access to internal components of the application, increasing the attack surface and potentially causing unintended effects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-940/AndroidIntentRedirection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.MissingJWTSignatureCheckQuery\nimport MissingJwtSignatureCheckFlow::PathGraph\n\nfrom MissingJwtSignatureCheckFlow::PathNode source, MissingJwtSignatureCheckFlow::PathNode sink\nwhere MissingJwtSignatureCheckFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This parser sets a $@, but the signature is not verified.\",\n  source.getNode(), \"JWT signing key\"",
        "description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-347/MissingJWTSignatureCheck.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.ImproperIntentVerificationQuery\n\nfrom AndroidReceiverXmlElement reg, Method orm, SystemActionName sa\nwhere unverifiedSystemReceiver(reg, orm, sa)\nselect orm, \"This reciever doesn't verify intents it receives, and $@ to receive $@.\", reg,\n  \"it is registered\", sa, \"the system action \" + sa.getName()",
        "description": "A broadcast receiver that does not verify intents it receives may be susceptible to unintended behavior by third party applications sending it explicit intents.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-925/ImproperIntentVerification.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.LogInjectionQuery\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode source, LogInjectionFlow::PathNode sink\nwhere LogInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This log entry depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled data may allow insertion of forged log entries by malicious users.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-117/LogInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.internal.ArraySizing\nimport semmle.code.java.security.ImproperValidationOfArrayIndexQuery\nimport ImproperValidationOfArrayIndexFlow::PathGraph\n\nfrom\n  ImproperValidationOfArrayIndexFlow::PathNode source,\n  ImproperValidationOfArrayIndexFlow::PathNode sink, CheckableArrayAccess arrayAccess\nwhere\n  arrayAccess.canThrowOutOfBounds(sink.getNode().asExpr()) and\n  ImproperValidationOfArrayIndexFlow::flowPath(source, sink)\nselect arrayAccess.getIndexExpr(), source, sink,\n  \"This index depends on a $@ which can cause an ArrayIndexOutOfBoundsException.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using external input as an index to an array, without proper validation, can lead to index out of bound exceptions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-129/ImproperValidationOfArrayIndex.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.internal.ArraySizing\nimport semmle.code.java.security.internal.BoundingChecks\nimport semmle.code.java.security.ImproperValidationOfArrayIndexCodeSpecifiedQuery\nimport BoundedFlowSourceFlow::PathGraph\n\nfrom\n  BoundedFlowSourceFlow::PathNode source, BoundedFlowSourceFlow::PathNode sink,\n  BoundedFlowSource boundedsource, CheckableArrayAccess arrayAccess\nwhere\n  arrayAccess.canThrowOutOfBounds(sink.getNode().asExpr()) and\n  boundedsource = source.getNode() and\n  BoundedFlowSourceFlow::flowPath(source, sink) and\n  boundedsource != sink.getNode() and\n  not (\n    (\n      // The input has a lower bound.\n      boundedsource.lowerBound() >= 0\n      or\n      // There is a condition dominating this expression ensuring that the index is >= 0.\n      lowerBound(arrayAccess.getIndexExpr()) >= 0\n    ) and\n    (\n      // The input has an upper bound, and the array has a fixed size, and that fixed size is less.\n      boundedsource.upperBound() < fixedArraySize(arrayAccess)\n      or\n      // There is a condition dominating this expression that ensures the index is less than the length.\n      lessthanLength(arrayAccess)\n    )\n  ) and\n  // Exclude cases where the array is assigned multiple times. The checks for bounded flow sources\n  // can use fixed sizes for arrays, but this doesn't work well when the array is initialized to zero\n  // and subsequently reassigned or grown.\n  count(arrayAccess.getArray().(VarAccess).getVariable().getAnAssignedValue()) = 1\nselect arrayAccess.getIndexExpr(), source, sink,\n  \"$@ flows to the index used in this array access, and may cause the operation to throw an ArrayIndexOutOfBoundsException.\",\n  boundedsource, boundedsource.getDescription()",
        "description": "Using a code-specified value as an index to an array, without proper validation, can lead to index out of bound exceptions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-129/ImproperValidationOfArrayIndexCodeSpecified.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.internal.ArraySizing\nimport semmle.code.java.security.ImproperValidationOfArrayConstructionCodeSpecifiedQuery\nimport BoundedFlowSourceFlow::PathGraph\n\nfrom\n  BoundedFlowSourceFlow::PathNode source, BoundedFlowSourceFlow::PathNode sink,\n  BoundedFlowSource boundedsource, Expr sizeExpr, ArrayCreationExpr arrayCreation,\n  CheckableArrayAccess arrayAccess\nwhere\n  arrayAccess.canThrowOutOfBoundsDueToEmptyArray(sizeExpr, arrayCreation) and\n  sizeExpr = sink.getNode().asExpr() and\n  boundedsource = source.getNode() and\n  BoundedFlowSourceFlow::flowPath(source, sink)\nselect arrayAccess.getIndexExpr(), source, sink,\n  \"This accesses the $@, but the array is initialized using $@ which may be zero.\", arrayCreation,\n  \"array\", boundedsource, boundedsource.getDescription().toLowerCase()",
        "description": "Using a code-specified value that may be zero as the argument to a construction of an array can lead to index out of bound exceptions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-129/ImproperValidationOfArrayConstructionCodeSpecified.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.internal.ArraySizing\nimport semmle.code.java.security.ImproperValidationOfArrayConstructionQuery\nimport ImproperValidationOfArrayConstructionFlow::PathGraph\n\nfrom\n  ImproperValidationOfArrayConstructionFlow::PathNode source,\n  ImproperValidationOfArrayConstructionFlow::PathNode sink, Expr sizeExpr,\n  ArrayCreationExpr arrayCreation, CheckableArrayAccess arrayAccess\nwhere\n  arrayAccess.canThrowOutOfBoundsDueToEmptyArray(sizeExpr, arrayCreation) and\n  sizeExpr = sink.getNode().asExpr() and\n  ImproperValidationOfArrayConstructionFlow::flowPath(source, sink)\nselect arrayAccess.getIndexExpr(), source, sink,\n  \"This accesses the $@, but the array is initialized using a $@ which may be zero.\", arrayCreation,\n  \"array\", source.getNode(), \"user-provided value\"",
        "description": "Using unvalidated external input as the argument to a construction of an array can lead to index out of bound exceptions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-129/ImproperValidationOfArrayConstruction.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.AndroidManifest\n\nfrom AndroidApplicationXmlElement androidAppElem\nwhere androidAppElem.allowsBackup()\nselect androidAppElem, \"Backups are allowed in this Android application.\"",
        "description": "Allowing application backups may allow an attacker to extract sensitive data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-312/AllowBackupAttributeEnabled.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CleartextStorageCookieQuery\n\nfrom SensitiveSource data, Cookie s, Expr input, Expr store\nwhere\n  input = s.getAnInput() and\n  store = s.getAStore() and\n  data.flowsTo(input)\nselect store, \"This stores cookie $@ containing $@ which was $@.\", s, s.toString(), data,\n  \"sensitive data\", input, \"added to the cookie\"",
        "description": "Storing sensitive information in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-312/CleartextStorageCookie.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CleartextStoragePropertiesQuery\n\nfrom SensitiveSource data, Properties s, Expr input, Expr store\nwhere\n  input = s.getAnInput() and\n  store = s.getAStore() and\n  data.flowsTo(input)\nselect store, \"This stores 'Properties' class $@ containing $@ which was $@.\", s, s.toString(),\n  data, \"sensitive data\", input, \"previously added\"",
        "description": "Storing sensitive information in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-312/CleartextStorageProperties.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CleartextStorageClassQuery\n\nfrom SensitiveSource data, ClassStore s, Expr input, Expr store\nwhere\n  input = s.getAnInput() and\n  store = s.getAStore() and\n  data.flowsTo(input)\nselect store, \"This stores the storable class $@ containing $@ which was $@.\", s, s.toString(),\n  data, \"sensitive data\", input, \"previously added\"",
        "description": "Storing sensitive information in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-312/CleartextStorageClass.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CleartextStorageAndroidFilesystemQuery\n\nfrom SensitiveSource data, LocalFileOpenCall s, Expr input, Expr store\nwhere\n  input = s.getAnInput() and\n  store = s.getAStore() and\n  data.flowsTo(input)\nselect store, \"This stores the local file $@ containing $@ which was $@.\", s, s.toString(), data,\n  \"sensitive data\", input, \"previously added\"",
        "description": "Cleartext storage of sensitive information in the Android filesystem allows access for users with root privileges or unexpected exposure from chained vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-312/CleartextStorageAndroidFilesystem.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CleartextStorageSharedPrefsQuery\n\nfrom SensitiveSource data, SharedPreferencesEditorMethodCall s, Expr input, Expr store\nwhere\n  input = s.getAnInput() and\n  store = s.getAStore() and\n  data.flowsTo(input)\nselect store, \"This stores the 'SharedPreferences' class $@ containing $@ which $@.\", s,\n  s.toString(), data, \"sensitive data\", input, \"was set as a shared preference\"",
        "description": "Cleartext Storage of Sensitive Information using SharedPreferences on Android allows access for users with root privileges or unexpected exposure from chained vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-312/CleartextStorageSharedPrefs.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CleartextStorageAndroidDatabaseQuery\n\nfrom SensitiveSource data, LocalDatabaseOpenMethodCall s, Expr input, Expr store\nwhere\n  input = s.getAnInput() and\n  store = s.getAStore() and\n  data.flowsTo(input)\nselect store, \"This stores data in a SQLite database $@ containing $@ which was $@.\", s,\n  s.toString(), data, \"sensitive data\", input, \"previously added\"",
        "description": "Cleartext Storage of Sensitive Information using a local database on Android allows access for users with root privileges or unexpected exposure from chained vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-312/CleartextStorageAndroidDatabase.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.UnsafeAndroidAccessQuery\nimport FetchUntrustedResourceFlow::PathGraph\n\nfrom FetchUntrustedResourceFlow::PathNode source, FetchUntrustedResourceFlow::PathNode sink\nwhere FetchUntrustedResourceFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Unsafe resource fetching in Android WebView due to $@.\",\n  source.getNode(), sink.getNode().(UrlResourceSink).getSinkType()",
        "description": "JavaScript rendered inside WebViews can access protected application files and web resources from any origin exposing them to attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-749/UnsafeAndroidAccess.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.InsecureRandomnessQuery\nimport InsecureRandomnessFlow::PathGraph\n\nfrom InsecureRandomnessFlow::PathNode source, InsecureRandomnessFlow::PathNode sink\nwhere InsecureRandomnessFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Potential Insecure randomness due to a $@.\", source.getNode(),\n  \"Insecure randomness source.\"",
        "description": "Using a cryptographically Insecure pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-330/InsecureRandomness.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.HardcodedPasswordField\n\nfrom PasswordVariable f, CompileTimeConstantExpr e\nwhere passwordFieldAssignedHardcodedValue(f, e)\nselect f, \"Sensitive field is assigned a hard-coded $@.\", e, \"value\"",
        "description": "Hard-coding a password string may compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-798/HardcodedPasswordField.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.HardcodedCredentialsSourceCallQuery\nimport HardcodedCredentialSourceCallFlow::PathGraph\n\nfrom\n  HardcodedCredentialSourceCallFlow::PathNode source,\n  HardcodedCredentialSourceCallFlow::PathNode sink\nwhere HardcodedCredentialSourceCallFlow::flowPath(source, sink)\nselect source.getNode(), source, sink, \"Hard-coded value flows to $@.\", sink.getNode(),\n  \"sensitive call\"",
        "description": "Using a hard-coded credential in a sensitive call may compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-798/HardcodedCredentialsSourceCall.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.HardcodedCredentialsComparison\n\nfrom EqualsCall sink, HardcodedExpr source, PasswordVariable p\nwhere isHardcodedCredentialsComparison(sink, source, p)\nselect source, \"Hard-coded value is $@ with password variable $@.\", sink, \"compared\", p, p.getName()",
        "description": "Comparing a parameter to a hard-coded credential may compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-798/HardcodedCredentialsComparison.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.security.HardcodedCredentialsApiCallQuery\nimport HardcodedCredentialApiCallFlow::PathGraph\n\nfrom HardcodedCredentialApiCallFlow::PathNode source, HardcodedCredentialApiCallFlow::PathNode sink\nwhere HardcodedCredentialApiCallFlow::flowPath(source, sink)\nselect source.getNode(), source, sink, \"Hard-coded value flows to $@.\", sink.getNode(),\n  \"sensitive API call\"",
        "description": "Using a hard-coded credential in a call to a sensitive Java API may compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-798/HardcodedCredentialsApiCall.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.ExternallyControlledFormatStringQuery\nimport semmle.code.java.StringFormat\nimport ExternallyControlledFormatStringFlow::PathGraph\n\nfrom\n  ExternallyControlledFormatStringFlow::PathNode source,\n  ExternallyControlledFormatStringFlow::PathNode sink, StringFormat formatCall\nwhere\n  ExternallyControlledFormatStringFlow::flowPath(source, sink) and\n  sink.getNode().asExpr() = formatCall.getFormatArgument()\nselect formatCall.getFormatArgument(), source, sink, \"Format string depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Using external input in format strings can lead to exceptions or information leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-134/ExternallyControlledFormatString.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CsrfUnprotectedRequestTypeQuery\n\nquery predicate edges(CallPathNode pred, CallPathNode succ) { relevantEdge(pred, succ) }\n\nfrom CallPathNode source, CallPathNode sink\nwhere unprotectedStateChange(source, sink)\nselect source.asMethod(), source, sink,\n  \"Potential CSRF vulnerability due to using an HTTP request type which is not default-protected from CSRF for an apparent $@.\",\n  sink, \"state-changing action\"",
        "description": "Using an HTTP request type that is not default-protected from CSRF for a state-changing action makes the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-352/CsrfUnprotectedRequestType.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.SpringCsrfProtection\n\nfrom MethodCall call\nwhere disablesSpringCsrfProtection(call)\nselect call, \"CSRF vulnerability due to protection being disabled.\"",
        "description": "Disabling CSRF protection makes the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-352/SpringCSRFProtection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.SensitiveLoggingQuery\nimport SensitiveLoggerFlow::PathGraph\n\nfrom SensitiveLoggerFlow::PathNode source, SensitiveLoggerFlow::PathNode sink\nwhere SensitiveLoggerFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This $@ is written to a log file.\", source.getNode(),\n  \"potentially sensitive information\"",
        "description": "Writing sensitive information to log files can allow that information to be leaked to an attacker more easily.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-532/SensitiveInfoLog.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.apache.Lang\n\nprivate class PredictableApacheRandomStringUtilsMethod extends Method {\n  PredictableApacheRandomStringUtilsMethod() {\n    this.getDeclaringType() instanceof TypeApacheRandomStringUtils and\n    // The one valid use of this type that uses SecureRandom as a source of data.\n    not this.getName() = \"random\"\n  }\n}\n\nprivate class PredictableApacheRandomStringUtilsMethodCall extends MethodCall {\n  PredictableApacheRandomStringUtilsMethodCall() {\n    this.getMethod() instanceof PredictableApacheRandomStringUtilsMethod\n  }\n}\n\nprivate class VulnerableJHipsterRandomUtilClass extends Class {\n  VulnerableJHipsterRandomUtilClass() {\n    // The package name that JHipster generated the 'RandomUtil' class in was dynamic. Thus 'hasQualifiedName' can not be used here.\n    this.getName() = \"RandomUtil\"\n  }\n}\n\nprivate class VulnerableJHipsterRandomUtilMethod extends Method {\n  VulnerableJHipsterRandomUtilMethod() {\n    this.getDeclaringType() instanceof VulnerableJHipsterRandomUtilClass and\n    this.getName().matches(\"generate%\") and\n    this.getReturnType() instanceof TypeString and\n    exists(ReturnStmt s |\n      s = this.getBody().(SingletonBlock).getStmt() and\n      s.getResult() instanceof PredictableApacheRandomStringUtilsMethodCall\n    )\n  }\n}\n\nfrom VulnerableJHipsterRandomUtilMethod method\nselect method,\n  \"Weak random number generator used in security sensitive method (JHipster CVE-2019-16303).\"",
        "description": "Using a vulnerable version of JHipster to generate random numbers makes it easier for attackers to take over accounts.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-338/JHipsterGeneratedPRNG.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.UnsafeDeserializationQuery\nimport UnsafeDeserializationFlow::PathGraph\n\nfrom UnsafeDeserializationFlow::PathNode source, UnsafeDeserializationFlow::PathNode sink\nwhere UnsafeDeserializationFlow::flowPath(source, sink)\nselect sink.getNode().(UnsafeDeserializationSink).getMethodCall(), source, sink,\n  \"Unsafe deserialization depends on a $@.\", source.getNode(), \"user-provided value\"",
        "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-502/UnsafeDeserialization.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.regexp.RegexInjectionQuery\nimport RegexInjectionFlow::PathGraph\n\nfrom RegexInjectionFlow::PathNode source, RegexInjectionFlow::PathNode sink\nwhere RegexInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This regular expression is constructed from a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-730/RegexInjection.ql",
        "language": "java"
    },
    {
        "query": "private import semmle.code.java.regex.RegexTreeView::RegexTreeView as TreeView\nimport codeql.regex.nfa.ExponentialBackTracking::Make<TreeView> as ExponentialBackTracking\n\nfrom TreeView::RegExpTerm t, string pump, ExponentialBackTracking::State s, string prefixMsg\nwhere\n  ExponentialBackTracking::hasReDoSResult(t, pump, s, prefixMsg) and\n  // exclude verbose mode regexes for now\n  not t.getRegex().getAMode() = \"VERBOSE\"\nselect t,\n  \"This part of the regular expression may cause exponential backtracking on strings \" + prefixMsg +\n    \"containing many repetitions of '\" + pump + \"'.\"",
        "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-730/ReDoS.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.regexp.PolynomialReDoSQuery\nimport PolynomialRedosFlow::PathGraph\n\nfrom\n  PolynomialRedosFlow::PathNode source, PolynomialRedosFlow::PathNode sink,\n  SuperlinearBackTracking::PolynomialBackTrackingTerm regexp\nwhere\n  PolynomialRedosFlow::flowPath(source, sink) and\n  regexp.getRootTerm() = sink.getNode().(PolynomialRedosSink).getRegExp()\nselect sink, source, sink,\n  \"This $@ that depends on a $@ may run slow on strings \" + regexp.getPrefixMessage() +\n    \"with many repetitions of '\" + regexp.getPumpString() + \"'.\", regexp, \"regular expression\",\n  source.getNode(), \"user-provided value\"",
        "description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-730/PolynomialReDoS.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.FragmentInjection\n\nfrom IsValidFragmentMethod m\nwhere m.isUnsafe()\nselect m,\n  \"The 'isValidFragment' method always returns true. This makes the exported Activity $@ vulnerable to Fragment Injection.\",\n  m.getDeclaringType(), m.getDeclaringType().getName()",
        "description": "An insecure implementation of the 'isValidFragment' method of the 'PreferenceActivity' class may allow a malicious application to bypass access controls, exposing the application to unintended effects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-470/FragmentInjectionInPreferenceActivity.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.FragmentInjectionQuery\nimport FragmentInjectionTaintFlow::PathGraph\n\nfrom FragmentInjectionTaintFlow::PathNode source, FragmentInjectionTaintFlow::PathNode sink\nwhere FragmentInjectionTaintFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Fragment depends on a $@, which may allow a malicious application to bypass access controls.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Instantiating an Android fragment from a user-provided value may allow a malicious application to bypass access controls,  exposing the application to unintended effects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-470/FragmentInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.ZipSlipQuery\nimport ZipSlipFlow::PathGraph\n\nfrom ZipSlipFlow::PathNode source, ZipSlipFlow::PathNode sink\nwhere ZipSlipFlow::flowPath(source, sink)\nselect source.getNode(), source, sink,\n  \"Unsanitized archive entry, which may contain '..', is used in a $@.\", sink.getNode(),\n  \"file system operation\"",
        "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-022/ZipSlip.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.TaintedPathQuery\nimport TaintedPathFlow::PathGraph\n\nfrom TaintedPathFlow::PathNode source, TaintedPathFlow::PathNode sink\nwhere TaintedPathFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-022/TaintedPath.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.UnsafeContentUriResolutionQuery\nimport UnsafeContentResolutionFlow::PathGraph\n\nfrom UnsafeContentResolutionFlow::PathNode src, UnsafeContentResolutionFlow::PathNode sink\nwhere UnsafeContentResolutionFlow::flowPath(src, sink)\nselect sink.getNode(), src, sink,\n  \"This ContentResolver method that resolves a URI depends on a $@.\", src.getNode(),\n  \"user-provided value\"",
        "description": "Resolving externally-provided content URIs without validation can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-441/UnsafeContentUriResolution.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport semmle.code.java.security.XxeRemoteQuery\nimport XxeFlow::PathGraph\n\nfrom XxeFlow::PathNode source, XxeFlow::PathNode sink\nwhere XxeFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against external entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-611/XXE.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CommandLineQuery\nimport semmle.code.java.security.ExternalProcess\n\npredicate saneString(Expr expr) {\n  expr instanceof StringLiteral\n  or\n  expr instanceof NullLiteral\n  or\n  exists(Variable var | var.getAnAccess() = expr and exists(var.getAnAssignedValue()) |\n    forall(Expr other | var.getAnAssignedValue() = other | saneString(other))\n  )\n}\n\npredicate builtFromUncontrolledConcat(Expr expr) {\n  exists(AddExpr concatExpr | concatExpr = expr |\n    builtFromUncontrolledConcat(concatExpr.getAnOperand())\n  )\n  or\n  exists(AddExpr concatExpr | concatExpr = expr |\n    exists(Expr arg | arg = concatExpr.getAnOperand() | not saneString(arg))\n  )\n  or\n  exists(Expr other | builtFromUncontrolledConcat(other) |\n    exists(Variable var | var.getAnAssignedValue() = other and var.getAnAccess() = expr)\n  )\n}\n\nfrom StringArgumentToExec argument\nwhere\n  builtFromUncontrolledConcat(argument) and\n  not execIsTainted(_, _, argument)\nselect argument, \"Command line is built with string concatenation.\"",
        "description": "Using concatenated strings in a command line is vulnerable to malicious insertion of special characters in the strings.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-078/ExecUnescaped.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.Expr\nimport semmle.code.java.security.RelativePaths\nimport semmle.code.java.security.ExternalProcess\n\nfrom ArgumentToExec argument, string command\nwhere\n  (\n    relativePath(argument, command) or\n    arrayStartingWithRelative(argument, command)\n  ) and\n  not shellBuiltin(command)\nselect argument, \"Command with a relative path '\" + command + \"' is executed.\"",
        "description": "Executing a command with a relative path is vulnerable to malicious changes in the PATH environment variable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-078/ExecRelative.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.CommandLineQuery\nimport InputToArgumentToExecFlow::PathGraph\n\nfrom\n  InputToArgumentToExecFlow::PathNode source, InputToArgumentToExecFlow::PathNode sink, Expr execArg\nwhere execIsTainted(source, sink, execArg)\nselect execArg, source, sink, \"This command line depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using externally controlled strings in a command line is vulnerable to malicious changes in the strings.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-078/ExecTainted.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.TaintedEnvironmentVariableQuery\nimport ExecTaintedEnvironmentFlow::PathGraph\n\nfrom ExecTaintedEnvironmentFlow::PathNode source, ExecTaintedEnvironmentFlow::PathNode sink\nwhere ExecTaintedEnvironmentFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This command will be execute with a tainted environment variable.\"",
        "description": "Passing environment variables containing externally controlled strings to a command line is vulnerable to malicious changes to the environment of a subprocess.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-078/ExecTaintedEnvironment.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.NumericCastTaintedQuery\nimport NumericCastFlow::PathGraph\n\nfrom NumericCastFlow::PathNode source, NumericCastFlow::PathNode sink, NumericNarrowingCastExpr exp\nwhere\n  sink.getNode().asExpr() = exp.getExpr() and\n  NumericCastFlow::flowPath(source, sink)\nselect exp, source, sink,\n  \"This cast to a narrower type depends on a $@, potentially causing truncation.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Casting user-controlled numeric data to a narrower type without validation can cause unexpected truncation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-681/NumericCastTainted.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.security.PartialPathTraversal\n\nfrom PartialPathTraversalMethodCall ma\nselect ma, \"Partial Path Traversal Vulnerability due to insufficient guard against path traversal.\"",
        "description": "A prefix used to check that a canonicalised path falls within another must be slash-terminated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-023/PartialPathTraversal.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.security.PartialPathTraversalQuery\nimport PartialPathTraversalFromRemoteFlow::PathGraph\n\nfrom\n  PartialPathTraversalFromRemoteFlow::PathNode source,\n  PartialPathTraversalFromRemoteFlow::PathNode sink\nwhere PartialPathTraversalFromRemoteFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Partial Path Traversal Vulnerability due to insufficient guard against path traversal from $@.\",\n  source, \"user-supplied data\"",
        "description": "A prefix used to check that a canonicalised path falls within another must be slash-terminated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-023/PartialPathTraversalFromRemote.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.XPathInjectionQuery\nimport XPathInjectionFlow::PathGraph\n\nfrom XPathInjectionFlow::PathNode source, XPathInjectionFlow::PathNode sink\nwhere XPathInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"XPath expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-643/XPathInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.MavenPom\n\npredicate isInsecureRepositoryUsage(DeclaredRepository repository) {\n  repository.getRepositoryUrl().regexpMatch(\"(?i)^(http|ftp)://(?!localhost[:/]).*\") and\n  not repository.isDisabled()\n}\n\nfrom DeclaredRepository repository\nwhere isInsecureRepositoryUsage(repository)\nselect repository,\n  \"Downloading or uploading artifacts over insecure protocol (eg. http or ftp) to/from repository \" +\n    repository.getRepositoryUrl()",
        "description": "Non-HTTPS connections can be intercepted by third parties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-829/InsecureDependencyResolution.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.android.WebView\n\nfrom MethodCall ma\nwhere\n  ma.getMethod() instanceof AllowJavaScriptMethod and\n  ma.getArgument(0).(CompileTimeConstantExpr).getBooleanValue() = true\nselect ma, \"JavaScript execution enabled in WebView.\"",
        "description": "Enabling JavaScript execution in a WebView can result in cross-site scripting attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-079/AndroidWebViewSettingsEnabledJavaScript.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.XssQuery\nimport XssFlow::PathGraph\n\nfrom XssFlow::PathNode source, XssFlow::PathNode sink\nwhere XssFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Cross-site scripting vulnerability due to a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-079/XSS.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.android.WebView\n\nfrom MethodCall ma\nwhere ma.getMethod() instanceof WebViewAddJavascriptInterfaceMethod\nselect ma, \"JavaScript interface to Java object added in Android WebView.\"",
        "description": "Exposing a Java object in a WebView with a JavaScript interface can lead to malicious JavaScript controlling the application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-079/AndroidWebViewAddJavascriptInterface.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.AndroidLocalAuthQuery\n\nfrom InsecureBiometricKeyParamCall call\nwhere usesLocalAuth()\nselect call, \"This key is not secure for biometric authentication.\"",
        "description": "Generation of keys with insecure parameters for local biometric authentication can allow attackers with physical access to bypass authentication checks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-287/AndroidInsecureKeys.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.AndroidLocalAuthQuery\n\nfrom AuthenticationSuccessCallback c\nwhere not exists(c.getAResultUse())\nselect c, \"This authentication callback does not use its result for a cryptographic operation.\"",
        "description": "Local authentication that does not make use of a `CryptoObject` can be bypassed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-287/AndroidInsecureLocalAuthentication.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.UnsafeCertTrustQuery\n\nfrom Expr unsafeTrust\nwhere\n  unsafeTrust instanceof RabbitMQEnableHostnameVerificationNotSet or\n  SslEndpointIdentificationFlow::flowTo(DataFlow::exprNode(unsafeTrust))\nselect unsafeTrust, \"Unsafe configuration of trusted certificates.\"",
        "description": "SSLSocket/SSLEngine ignores all SSL certificate validation errors when establishing an HTTPS connection, thereby making the app vulnerable to man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Security/CWE/CWE-273/UnsafeCertTrust.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate nontrivialLogicalOperator(BinaryExpr e) {\n  e instanceof LogicExpr and\n  (\n    not e.getParent().(Expr).getKind() = e.getKind() or\n    e.isParenthesized()\n  )\n}\n\nExpr getSimpleParent(Expr e) {\n  result = e.getParent() and\n  not result instanceof MethodCall\n}\n\nfrom Expr e\nwhere\n  not e.getParent() instanceof Expr and\n  strictcount(BinaryExpr op | getSimpleParent*(op) = e and nontrivialLogicalOperator(op)) > 5\nselect e, \"Complex condition: too many logical operations in this expression.\"",
        "description": "Very complex conditions are difficult to read and may include defects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Complexity/ComplexCondition.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ComplexStmt extends Stmt {\n  ComplexStmt() {\n    this instanceof LoopStmt or\n    this instanceof SwitchStmt\n  }\n}\n\nfrom BlockStmt b, int n\nwhere n = count(ComplexStmt s | s = b.getAStmt()) and n > 3\nselect b, \"Block with too many statements (\" + n.toString() + \" complex statements in the block).\"",
        "description": "A block that contains too many complex statements becomes unreadable and unmaintainable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Complexity/BlockWithTooManyStatements.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.SSA\n\npredicate noToString(SsaVariable v) { not exists(v.toString()) }\n\npredicate multipleToString(SsaVariable v) { 1 < count(v.toString()) }\n\nfrom SsaVariable ssa, ControlFlowNode n, Variable v, string problem\nwhere\n  (\n    noToString(ssa) and problem = \"SSA variable without 'toString()' for \"\n    or\n    multipleToString(ssa) and problem = \"SSA variable with multiple 'toString()' results for \"\n  ) and\n  n = ssa.getCfgNode() and\n  v = ssa.getSourceVariable().getVariable()\nselect n, problem + v",
        "description": "An ambiguous 'toString()' indicates overlap in the defining sub-classes of 'SsaVariable'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/meta/ssa/AmbiguousToString.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.SSA\n\npredicate live(SsaVariable v) {\n  exists(v.getAUse())\n  or\n  exists(SsaPhiNode phi | live(phi) and phi.getAPhiInput() = v)\n  or\n  exists(SsaUncertainImplicitUpdate upd | live(upd) and upd.getPriorDef() = v)\n}\n\nfrom SsaUncertainImplicitUpdate upd\nwhere\n  live(upd) and\n  not exists(upd.getPriorDef())\nselect upd, \"No prior definition of \" + upd",
        "description": "An uncertain SSA update may retain its previous value and should therefore have a prior definition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/meta/ssa/UncertainDefWithoutPrior.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.SSA\n\nclass SsaConvertibleReadAccess extends VarRead {\n  SsaConvertibleReadAccess() {\n    this.getEnclosingCallable().getBody().getBasicBlock().getASuccessor*() = this.getBasicBlock() and\n    (\n      not exists(this.getQualifier())\n      or\n      this.getVariable() instanceof LocalScopeVariable\n      or\n      this.getVariable().(Field).isStatic()\n      or\n      exists(Expr q | q = this.getQualifier() |\n        q instanceof ThisAccess or\n        q instanceof SuperAccess or\n        q instanceof SsaConvertibleReadAccess\n      )\n    )\n  }\n}\n\npredicate accessWithoutSourceVariable(SsaConvertibleReadAccess va) {\n  not exists(SsaSourceVariable v | v.getAnAccess() = va)\n}\n\npredicate readAccessWithoutSsaVariable(SsaConvertibleReadAccess va) {\n  not exists(SsaVariable v | v.getAUse() = va)\n}\n\npredicate readAccessWithAmbiguousSsaVariable(SsaConvertibleReadAccess va) {\n  1 < strictcount(SsaVariable v | v.getAUse() = va)\n}\n\nfrom SsaConvertibleReadAccess va, string problem\nwhere\n  accessWithoutSourceVariable(va) and problem = \"No source variable\"\n  or\n  readAccessWithoutSsaVariable(va) and problem = \"No SSA variable\"\n  or\n  readAccessWithAmbiguousSsaVariable(va) and problem = \"Multiple SSA variables\"\nselect va, problem",
        "description": "Every variable use that is sufficiently trackable should have a unique associated SSA variable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/meta/ssa/UseWithoutUniqueSsaVariable.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.SSA\n\nfrom SsaPhiNode phi, int inputs\nwhere\n  inputs = count(SsaVariable v | v = phi.getAPhiInput()) and\n  inputs < 2\nselect phi, \"Phi node for \" + phi.getSourceVariable() + \" has only \" + inputs + \" inputs.\"",
        "description": "A phi node should have at least two inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/meta/ssa/TooFewPhiInputs.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.ExternalFlow\n\nfrom string package, int pkgs, string kind, string part, int n\nwhere modelCoverage(package, pkgs, kind, part, n)\nselect package, pkgs, kind, part, n",
        "description": "The number of API endpoints covered by MaD models sorted by package and source-, sink-, and summary-kind.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/meta/frameworks/Coverage.ql",
        "language": "java"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string noflow\nwhere noflow = captureNeutral(api)\nselect noflow order by noflow",
        "description": "Finds neutral models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/CaptureNeutralModels.ql",
        "language": "java"
    },
    {
        "query": "import internal.CaptureTypeBasedSummaryModels\n\nfrom TypeBasedFlowTargetApi api, string flow\nwhere flow = captureFlow(api)\nselect flow order by flow",
        "description": "Finds applicable summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/CaptureTypeBasedSummaryModels.ql",
        "language": "java"
    },
    {
        "query": "import internal.CaptureModels\nimport SinkModels\n\nfrom DataFlowSinkTargetApi api, string sink\nwhere sink = Heuristic::captureSink(api)\nselect sink order by sink",
        "description": "Finds public methods that act as sinks as they flow into a known sink.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/CaptureSinkModels.ql",
        "language": "java"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = ContentSensitive::captureFlow(api, _, _, _, _)\nselect flow order by flow",
        "description": "Finds applicable content based summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/CaptureContentSummaryModels.ql",
        "language": "java"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = captureFlow(api, _)\nselect flow order by flow",
        "description": "Finds applicable summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/CaptureSummaryModels.ql",
        "language": "java"
    },
    {
        "query": "import internal.CaptureModels\nimport SourceModels\n\nfrom DataFlowSourceTargetApi api, string source\nwhere source = Heuristic::captureSource(api)\nselect source order by source",
        "description": "Finds APIs that act as sources as they expose already known sources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/CaptureSourceModels.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport utils.modelgenerator.internal.CaptureModels\nimport SummaryModels\nimport PartialFlow::PartialPathGraph\n\nint explorationLimit() { result = 3 }\n\nmodule PartialFlow = Heuristic::PropagateTaintFlow::FlowExplorationFwd<explorationLimit/0>;\n\nfrom\n  PartialFlow::PartialPathNode source, PartialFlow::PartialPathNode sink,\n  DataFlowSummaryTargetApi api, DataFlow::ParameterNode p\nwhere\n  PartialFlow::partialFlow(source, sink, _) and\n  p = source.getNode() and\n  p.asParameter() = api.getAParameter()\nselect sink.getNode(), source, sink, \"There is flow from a $@ to $@.\", source.getNode(),\n  \"parameter\", sink.getNode(), \"intermediate value\"",
        "description": "Capture Summary Models Partial Path",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/debug/CaptureSummaryModelsPartialPath.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\nimport utils.modelgenerator.internal.CaptureModels\nimport SummaryModels\nimport Heuristic::PropagateTaintFlow::PathGraph\n\nfrom\n  Heuristic::PropagateTaintFlow::PathNode source, Heuristic::PropagateTaintFlow::PathNode sink,\n  DataFlowSummaryTargetApi api, DataFlow::Node p, DataFlow::Node returnNodeExt\nwhere\n  Heuristic::PropagateTaintFlow::flowPath(source, sink) and\n  p = source.getNode() and\n  returnNodeExt = sink.getNode() and\n  Heuristic::captureThroughFlow0(api, p, returnNodeExt)\nselect sink.getNode(), source, sink, \"There is flow from $@ to the $@.\", source.getNode(),\n  \"parameter\", sink.getNode(), \"return value\"",
        "description": "Capture Summary Models Path",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelgenerator/debug/CaptureSummaryModelsPath.ql",
        "language": "java"
    },
    {
        "query": "private import java\nprivate import FrameworkModeEndpointsQuery\nprivate import ModelEditor\n\nfrom PublicEndpointFromSource endpoint, boolean supported, string type\nwhere\n  supported = isSupported(endpoint) and\n  type = supportedType(endpoint)\nselect endpoint, endpoint.getPackageName(), endpoint.getTypeName(), endpoint.getName(),\n  endpoint.getParameterTypes(), supported,\n  endpoint.getCompilationUnit().getParentContainer().getBaseName(), type",
        "description": "A list of endpoints accessible (methods) for consumers of the library. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modeleditor/FrameworkModeEndpoints.ql",
        "language": "java"
    },
    {
        "query": "private import java\nprivate import ApplicationModeEndpointsQuery\nprivate import ModelEditor\n\nprivate Call aUsage(ExternalEndpoint endpoint) {\n  result.getCallee().getSourceDeclaration() = endpoint\n}\n\nfrom ExternalEndpoint endpoint, boolean supported, Call usage, string type, string classification\nwhere\n  supported = isSupported(endpoint) and\n  usage = aUsage(endpoint) and\n  type = supportedType(endpoint) and\n  classification = usageClassification(usage)\nselect usage, endpoint.getPackageName(), endpoint.getTypeName(), endpoint.getName(),\n  endpoint.getParameterTypes(), supported, endpoint.jarContainer(), endpoint.jarVersion(), type,\n  classification",
        "description": "A list of 3rd party endpoints (methods) used in the codebase. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modeleditor/ApplicationModeEndpoints.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.ExternalFlow\n\nfrom\n  string package, string type, boolean subtypes, string name, string signature, string ext,\n  string input, string output, string kind, string provenance\nwhere\n  summaryModel(package, type, subtypes, name, signature, ext, input, output, kind, provenance, _) and\n  not provenance.matches(\"%generated\")\nselect package, type, subtypes, name, signature, ext, input, output, kind, provenance order by\n    package, type, name, signature, input, output, kind",
        "description": "This extracts the Models as data summary model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelconverter/ExtractSummaries.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.ExternalFlow\n\nfrom string package, string type, string name, string signature, string kind, string provenance\nwhere\n  neutralModel(package, type, name, signature, kind, provenance) and\n  not provenance.matches(\"%generated\")\nselect package, type, name, signature, kind, provenance order by\n    package, type, name, signature, kind",
        "description": "This extracts the Models as data neutral model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelconverter/ExtractNeutrals.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.ExternalFlow\n\nfrom\n  string package, string type, boolean subtypes, string name, string signature, string ext,\n  string output, string kind, string provenance\nwhere\n  sourceModel(package, type, subtypes, name, signature, ext, output, kind, provenance, _) and\n  not provenance.matches(\"%generated\")\nselect package, type, subtypes, name, signature, ext, output, kind, provenance order by\n    package, type, name, signature, output, kind",
        "description": "This extracts the Models as data source model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelconverter/ExtractSources.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.ExternalFlow\n\nfrom\n  string package, string type, boolean subtypes, string name, string signature, string ext,\n  string input, string kind, string provenance\nwhere\n  sinkModel(package, type, subtypes, name, signature, ext, input, kind, provenance, _) and\n  not provenance.matches(\"%generated\")\nselect package, type, subtypes, name, signature, ext, input, kind, provenance order by\n    package, type, name, signature, input, kind",
        "description": "This extracts the Models as data sink model rows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/modelconverter/ExtractSinks.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Stubs\n\nclass UsedInSource extends GeneratedDeclaration {\n  UsedInSource() {\n    (\n      this = any(Variable v | v.fromSource()).getType()\n      or\n      this = any(Expr e | e.getEnclosingCallable().fromSource()).getType()\n      or\n      this = any(RefType t | t.fromSource())\n      or\n      this = any(TypeAccess ta | ta.fromSource())\n      or\n      this = any(Annotation a | a.getAnnotatedElement().fromSource()).getType()\n    )\n  }\n}\n\nfrom GeneratedTopLevel t\nwhere not t.fromSource()\nselect t.getQualifiedName(), t.stubFile()\n\nmodule Consistency {\n  query predicate noGeneratedStubs(string s) {\n    exists(GeneratedTopLevel t | s = t.getQualifiedName() |\n      not t.fromSource() and\n      not exists(t.stubFile())\n    )\n  }\n\n  query predicate multipleGeneratedStubs(string s) {\n    exists(GeneratedTopLevel t | s = t.getQualifiedName() |\n      not t.fromSource() and\n      strictcount(t.stubFile()) > 1\n    )\n  }\n}\n\nimport Consistency",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/utils/stub-generator/MinimalStubsFromSource.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.NumberFormatException\n\nfrom Expr e\nwhere\n  throwsNfe(e) and\n  not exists(TryStmt t |\n    t.getBlock() = e.getEnclosingStmt().getEnclosingStmt*() and\n    catchesNfe(t)\n  ) and\n  not exists(Callable c |\n    e.getEnclosingCallable() = c and\n    c.getAThrownExceptionType().getADescendant() instanceof NumberFormatException\n  )\nselect e, \"Potential uncaught 'java.lang.NumberFormatException'.\"",
        "description": "Calling a string to number conversion method without handling 'NumberFormatException' may cause unexpected runtime exceptions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Exception Handling/NumberFormatException.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CatchClause cc\nwhere\n  not exists(cc.getBlock().getAStmt()) and\n  not cc.getBlock().getNumberOfCommentLines() > 0 and\n  not cc.getEnclosingCallable().getDeclaringType() instanceof TestClass\nselect cc, \"Exceptions should not be dropped.\"",
        "description": "Dropping an exception may allow an unusual program state to continue without recovery.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Exception Handling/DroppedExceptions.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass SpecialMethod extends Method {\n  predicate isMethod(string pack, string clss, string name, int numparam) {\n    this.hasName(name) and\n    this.getNumberOfParameters() = numparam and\n    this.getDeclaringType().getAnAncestor().getSourceDeclaration().hasQualifiedName(pack, clss)\n  }\n}\n\npredicate unboundedQueue(RefType t) {\n  exists(string pack, string clss |\n    t.getAnAncestor().getSourceDeclaration().hasQualifiedName(pack, clss)\n  |\n    pack = \"java.util\" and clss = \"ArrayDeque\"\n    or\n    pack = \"java.util\" and clss = \"LinkedList\"\n    or\n    pack = \"java.util\" and clss = \"PriorityQueue\"\n    or\n    pack = \"java.util.concurrent\" and clss = \"ConcurrentLinkedQueue\"\n    or\n    pack = \"java.util.concurrent\" and clss = \"ConcurrentLinkedDeque\"\n    or\n    pack = \"java.util.concurrent\" and clss = \"DelayQueue\"\n    or\n    pack = \"java.util.concurrent\" and clss = \"LinkedTransferQueue\"\n    or\n    pack = \"java.util.concurrent\" and clss = \"PriorityBlockingQueue\"\n  )\n}\n\nfrom MethodCall ma, SpecialMethod m\nwhere\n  ma instanceof ValueDiscardingExpr and\n  m = ma.getMethod() and\n  (\n    m.isMethod(\"java.util\", \"Queue\", \"offer\", 1) and not unboundedQueue(m.getDeclaringType())\n    or\n    m.isMethod(\"java.util.concurrent\", \"BlockingQueue\", \"offer\", 3) and\n    not unboundedQueue(m.getDeclaringType())\n    or\n    m.isMethod(\"java.util.concurrent.locks\", \"Condition\", \"await\", 2)\n    or\n    m.isMethod(\"java.util.concurrent.locks\", \"Condition\", \"awaitUntil\", 1)\n    or\n    m.isMethod(\"java.util.concurrent.locks\", \"Condition\", \"awaitNanos\", 1)\n    or\n    m.isMethod(\"java.io\", \"File\", \"createNewFile\", 0)\n    or\n    m.isMethod(\"java.io\", \"File\", \"mkdir\", 0)\n    or\n    m.isMethod(\"java.io\", \"File\", \"renameTo\", 1)\n    or\n    m.isMethod(\"java.io\", \"File\", \"setLastModified\", 1)\n    or\n    m.isMethod(\"java.io\", \"File\", \"setReadOnly\", 0)\n    or\n    m.isMethod(\"java.io\", \"File\", \"setWritable\", 1)\n    or\n    m.isMethod(\"java.io\", \"File\", \"setWritable\", 2)\n    or\n    m.isMethod(\"java.io\", \"InputStream\", \"skip\", 1)\n    or\n    m.isMethod(\"java.io\", \"InputStream\", \"read\", 1)\n    or\n    m.isMethod(\"java.io\", \"InputStream\", \"read\", 3)\n  )\nselect ma,\n  \"Method \" + ma.getEnclosingCallable().getName() + \" ignores exceptional return value of \" +\n    ma.getMethod().getDeclaringType().getName() + \".\" + ma.getMethod().getName() + \".\"",
        "description": "Ignoring an exceptional value that is returned by a method may cause subsequent code to fail.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Exception Handling/IgnoreExceptionalReturn.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nprivate predicate relevantTypeNames(string typeName, string message) {\n  // `Throwable` is the more severe case due to `Error`s such as `OutOfMemoryError`.\n  typeName = \"Throwable\" and message = \"Error\"\n  or\n  // `Exception` includes `RuntimeException`s such as `ArrayIndexOutOfBoundsException`.\n  typeName = \"Exception\" and message = \"RuntimeException\"\n}\n\nprivate Type getAThrownExceptionType(TryStmt t) {\n  exists(MethodCall ma, Exception e |\n    t.getBlock() = ma.getEnclosingStmt().getEnclosingStmt*() and\n    ma.getMethod().getAnException() = e and\n    result = e.getType()\n  )\n  or\n  exists(ClassInstanceExpr cie, Exception e |\n    t.getBlock() = cie.getEnclosingStmt().getEnclosingStmt*() and\n    cie.getConstructor().getAnException() = e and\n    result = e.getType()\n  )\n  or\n  exists(ThrowStmt ts |\n    t.getBlock() = ts.getEnclosingStmt*() and\n    result = ts.getExpr().getType()\n  )\n}\n\nfrom CatchClause cc, LocalVariableDeclExpr v, TryStmt t, string typeName, string message\nwhere\n  relevantTypeNames(typeName, message) and\n  t.getACatchClause() = cc and\n  cc.getVariable() = v and\n  v.getType().(RefType).hasQualifiedName(\"java.lang\", typeName) and\n  // It's usually OK if the exception is logged in some way, or re-thrown.\n  not exists(v.getAnAccess()) and\n  // Exclude results in test code.\n  not cc.getEnclosingCallable().getDeclaringType() instanceof TestClass and\n  // Check that all exceptions thrown in the try block are\n  // either more specific than the caught type or unrelated to it.\n  not exists(Type et | et = getAThrownExceptionType(t) |\n    et.(RefType).getADescendant().hasQualifiedName(\"java.lang\", typeName)\n  )\nselect cc,\n  \"Do not catch '\" + cc.getVariable().getType() + \"'\" + \"; \" + message +\n    \"s should normally be propagated.\"",
        "description": "Catching 'Throwable' or 'Exception' is dangerous because these can include 'Error' or 'RuntimeException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Exception Handling/ExceptionCatch.ql",
        "language": "java"
    },
    {
        "query": "import CommentedCode\n\nfrom CommentedOutCode comment\nselect comment, \"This comment appears to contain commented-out code.\"",
        "description": "Commented-out code makes the remaining code more difficult to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Comments/CommentedCode.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom JavadocText c\nwhere\n  c.getText().matches(\"%TODO%\") or\n  c.getText().matches(\"%FIXME%\")\nselect c, \"TODO comments should be addressed.\"",
        "description": "A comment that contains 'TODO' or 'FIXME' may indicate code that is incomplete or broken, or it may highlight an ambiguity in the software's specification.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Comments/TodoComments.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ReservedUnicodeInLiteral extends Literal {\n  private int indexStart;\n\n  ReservedUnicodeInLiteral() {\n    not this instanceof CharacterLiteral and\n    this.getCompilationUnit().fromSource() and\n    exists(int codePoint |\n      this.getLiteral().codePointAt(indexStart) = codePoint and\n      (\n        // Unicode C0 control characters\n        codePoint < 32 and not codePoint in [9, 10, 12, 13]\n        or\n        codePoint = 127 // delete control character\n        or\n        codePoint = 8203 // zero-width space\n      )\n    )\n  }\n\n  /** Gets the starting index of the Unicode control sequence. */\n  int getIndexStart() { result = indexStart }\n}\n\nfrom ReservedUnicodeInLiteral literal, int charIndex, int codePoint\nwhere\n  literal.getIndexStart() = charIndex and\n  literal.getLiteral().codePointAt(charIndex) = codePoint and\n  not literal.getEnclosingCallable() instanceof LikelyTestMethod and\n  // Kotlin extraction doesn't preserve the literal value so we can't distinguish\n  // between control characters and their escaped versions, so we exclude Kotlin\n  // to avoid false positives.\n  not literal.getFile().isKotlinSourceFile()\nselect literal,\n  \"Literal value contains control or non-printable whitespace character(s) starting with Unicode code point \"\n    + codePoint + \" at index \" + charIndex + \".\"",
        "description": "Non-explicit control and whitespace characters in literals make code more difficult to read and may lead to incorrect program behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/SpecialCharactersInLiterals/NonExplicitControlAndWhitespaceCharsInLiterals.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.StringFormat\n\npredicate explicitToStringCall(Expr e) {\n  exists(MethodCall ma |\n    ma.getMethod() instanceof ToStringMethod and\n    e = ma.getQualifier()\n  )\n}\n\npredicate directlyDeclaresToString(Class c) { any(ToStringMethod m).getDeclaringType() = c }\n\npredicate inheritsObjectToString(Class t) {\n  not directlyDeclaresToString(t.getSourceDeclaration()) and\n  (\n    t.getASupertype().hasQualifiedName(\"java.lang\", \"Object\")\n    or\n    not t.getASupertype().hasQualifiedName(\"java.lang\", \"Object\") and\n    inheritsObjectToString(t.getASupertype())\n  )\n}\n\nClass getAnImplementation(RefType parent) {\n  result = parent.getADescendant() and\n  not result.isAbstract()\n}\n\npredicate bad(RefType t) {\n  forex(Class sub | sub = getAnImplementation(t) | inheritsObjectToString(sub)) and\n  not t instanceof Array and\n  not t instanceof GenericType and\n  not t instanceof BoundedType and\n  t.fromSource()\n}\n\nfrom Expr e, RefType sourceType\nwhere\n  (implicitToStringCall(e) or explicitToStringCall(e)) and\n  sourceType = e.getType().(RefType).getSourceDeclaration() and\n  bad(sourceType) and\n  not sourceType.isAbstract() and\n  sourceType.fromSource()\nselect e,\n  \"Default toString(): \" + e.getType().getName() +\n    \" inherits toString() from Object, and so is not suitable for printing.\"",
        "description": "Calling the default implementation of 'toString' returns a value that is unlikely to be what you expect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/DefaultToString.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall m\nwhere\n  m.getMethod().hasName(\"next\") and\n  m.getMethod().getNumberOfParameters() = 0 and\n  m.isOwnMethodCall() and\n  exists(Interface i, Method hasNext |\n    i.getSourceDeclaration().hasQualifiedName(\"java.util\", \"Iterator\") and\n    m.getEnclosingCallable() = hasNext and\n    hasNext.getDeclaringType().getSourceDeclaration().getAnAncestor() = i and\n    hasNext.hasName(\"hasNext\")\n  )\nselect m, \"This calls 'next()' from within an Iterator method.\"",
        "description": "Iterator implementations whose 'hasNext' method calls 'next' are most likely incorrect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/NextFromIterator.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall mc\nwhere\n  mc.getMethod() instanceof FinalizeMethod and\n  // The Java documentation for `finalize()` states: \"If a subclass overrides\n  // `finalize` it must invoke the superclass finalizer explicitly\". Therefore,\n  // we do not alert on `super.finalize()` calls that occur within a callable\n  // that overrides `finalize`.\n  not exists(Callable caller, FinalizeMethod fm | caller = mc.getCaller() |\n    caller.(Method).overrides(fm) and\n    mc.getQualifier() instanceof SuperAccess\n  )\nselect mc, \"Call to 'finalize()'.\"",
        "description": "Calling `finalize()` in application code may cause inconsistent program state or unpredictable behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/DoNotCallFinalize.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.StringFormat\n\npredicate arraysToStringArgument(Expr e) {\n  exists(MethodCall ma, Method m |\n    ma.getAnArgument() = e and\n    ma.getMethod() = m and\n    m.getDeclaringType().hasQualifiedName(\"java.util\", \"Arrays\") and\n    m.hasName(\"toString\")\n  )\n}\n\nfrom Expr arr\nwhere\n  arr.getType() instanceof Array and\n  implicitToStringCall(arr) and\n  not exists(FormattingCall fmtcall |\n    // exclude slf4j formatting as it supports array formatting\n    fmtcall.getAnArgumentToBeFormatted() = arr and fmtcall.getSyntax().isLogger()\n  )\n  or\n  arr.getType().(Array).getComponentType() instanceof Array and\n  arraysToStringArgument(arr)\nselect arr, \"Implicit conversion from Array to String.\"",
        "description": "Directly printing an array, without first converting the array to a string, produces unreadable results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/PrintLnArray.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ExitOrHaltMethod extends Method {\n  ExitOrHaltMethod() {\n    exists(Class system | this.getDeclaringType() = system |\n      this.hasName(\"exit\") and\n      system.hasQualifiedName(\"java.lang\", [\"System\", \"Runtime\"])\n      or\n      this.hasName(\"halt\") and\n      system.hasQualifiedName(\"java.lang\", \"Runtime\")\n    )\n  }\n}\n\nclass ExitOrHaltMethodCall extends MethodCall {\n  ExitOrHaltMethodCall() {\n    exists(ExitOrHaltMethod exitMethod | this.getMethod() = exitMethod |\n      exists(SourceMethodNotMainOrTest srcMethod | this = srcMethod.getACallSite(exitMethod))\n    )\n  }\n}\n\nclass IntentionalExitMethodCall extends ExitOrHaltMethodCall {\n  IntentionalExitMethodCall() {\n    this.getMethod().hasName(\"exit\") and\n    this.getAnArgument() = this.getEnclosingCallable().getAParameter().getAnAccess()\n  }\n}\n\nclass SourceMethodNotMainOrTest extends Method {\n  SourceMethodNotMainOrTest() {\n    this.fromSource() and\n    not this instanceof MainMethod and\n    not (\n      this.getEnclosingCallable*() instanceof LikelyTestMethod\n      or\n      this.getDeclaringType()\n          .getEnclosingType*()\n          .(LocalClassOrInterface)\n          .getLocalTypeDeclStmt()\n          .getEnclosingCallable() instanceof LikelyTestMethod\n    )\n  }\n}\n\nfrom ExitOrHaltMethodCall mc\nwhere not mc instanceof IntentionalExitMethodCall\nselect mc,\n  \"Avoid calls to \" + mc.getMethod().getDeclaringType().getName() + \".\" + mc.getMethod().getName() +\n    \"() as this prevents runtime cleanup and makes code harder to reuse.\"",
        "description": "Calling 'System.exit', 'Runtime.halt', or 'Runtime.exit' may make code harder to reuse and prevent important cleanup steps from running.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/CallsToSystemExit.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall ma, ToStringMethod tostring\nwhere\n  tostring.getDeclaringType() instanceof TypeString and\n  ma.getMethod() = tostring\nselect ma, \"Redundant call to 'toString' on a String object.\"",
        "description": "Calling 'toString' on a string is redundant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/CallsToStringToString.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall mc, Method m\nwhere\n  (\n    m.getDeclaringType().hasQualifiedName(\"java.lang\", \"Runtime\") or\n    m.getDeclaringType().hasQualifiedName(\"java.lang\", \"System\")\n  ) and\n  m.hasName(\"gc\") and\n  mc.getMethod() = m\nselect mc, \"Explicit garbage collection. This should only be used in benchmarking code.\"",
        "description": "Triggering garbage collection explicitly may either have no effect or may trigger unnecessary garbage collection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/GarbageCollection.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall ma, Method runfinalizers, Class c\nwhere\n  ma.getMethod() = runfinalizers and\n  runfinalizers.hasName(\"runFinalizersOnExit\") and\n  runfinalizers.getDeclaringType() = c and\n  (\n    c.hasName(\"Runtime\") or\n    c.hasName(\"System\")\n  ) and\n  c.getPackage().hasName(\"java.lang\")\nselect ma, \"Call to runFinalizersOnExit.\"",
        "description": "Calling 'System.runFinalizersOnExit' or 'Runtime.runFinalizersOnExit' may cause finalizers to be run on live objects, leading to erratic behavior or deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Undesirable Calls/CallsToRunFinalizersOnExit.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Record record, Member m\nwhere\n  record.getAMember() = m and\n  m.hasName([\n      \"writeObject\", \"readObject\", \"readObjectNoData\", \"writeExternal\", \"readExternal\",\n      \"serialPersistentFields\"\n    ])\nselect m, \"Ignored serialization member found in record class $@.\", record, record.getName()",
        "description": "Using certain members of a record class during serialization will result in those members being ignored.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Records/IgnoredSerializationMembersOfRecordClass.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DefUse\n\npredicate relevantType(RefType t) {\n  t instanceof Array\n  or\n  exists(RefType sup | sup = t.getAnAncestor().getSourceDeclaration() |\n    sup.hasQualifiedName(\"java.util\", \"Map\") or\n    sup.hasQualifiedName(\"java.util\", \"Collection\")\n  )\n}\n\npredicate modifyMethod(Method m) {\n  relevantType(m.getDeclaringType()) and\n  (\n    m.hasName(\"add\") or\n    m.hasName(\"addAll\") or\n    m.hasName(\"put\") or\n    m.hasName(\"putAll\") or\n    m.hasName(\"push\") or\n    m.hasName(\"pop\") or\n    m.hasName(\"remove\") or\n    m.hasName(\"removeAll\") or\n    m.hasName(\"clear\") or\n    m.hasName(\"set\")\n  )\n}\n\npredicate storesArray(Callable c, int i, Field f) {\n  f.getDeclaringType() = c.getDeclaringType().getAnAncestor().getSourceDeclaration() and\n  relevantType(f.getType()) and\n  exists(Parameter p | p = c.getParameter(i) | f.getAnAssignedValue() = p.getAnAccess()) and\n  not c.isStatic()\n}\n\npredicate returnsArray(Callable c, Field f) {\n  f.getDeclaringType() = c.getDeclaringType().getAnAncestor().getSourceDeclaration() and\n  relevantType(f.getType()) and\n  exists(ReturnStmt rs | rs.getEnclosingCallable() = c and rs.getResult() = f.getAnAccess()) and\n  not c.isStatic()\n}\n\npredicate mayWriteToArray(Expr modified) {\n  writesToArray(modified)\n  or\n  // x = __y__; x[0] = 1;\n  exists(AssignExpr e, LocalVariableDecl v | e.getDest() = v.getAnAccess() |\n    modified = e.getSource() and\n    mayWriteToArray(v.getAnAccess())\n  )\n  or\n  // int[] x = __y__; x[0] = 1;\n  exists(LocalVariableDeclExpr e, Variable v | e.getVariable() = v |\n    modified = e.getInit() and\n    mayWriteToArray(v.getAnAccess())\n  )\n  or\n  // return __array__;    ...  method()[1] = 0\n  exists(ReturnStmt rs | modified = rs.getResult() and relevantType(modified.getType()) |\n    exists(Callable enclosing, MethodCall ma |\n      enclosing = rs.getEnclosingCallable() and ma.getMethod().getSourceDeclaration() = enclosing\n    |\n      mayWriteToArray(ma)\n    )\n  )\n}\n\npredicate writesToArray(Expr array) {\n  relevantType(array.getType()) and\n  (\n    exists(Assignment a, ArrayAccess access | a.getDest() = access | access.getArray() = array)\n    or\n    exists(MethodCall ma | ma.getQualifier() = array | modifyMethod(ma.getMethod()))\n  )\n}\n\nVarAccess modificationAfter(VarAccess v) {\n  mayWriteToArray(result) and\n  useUsePair(v, result)\n}\n\nVarAccess varPassedInto(Callable c, int i) {\n  exists(Call call | call.getCallee() = c | call.getArgument(i) = result)\n}\n\npredicate exposesByReturn(Callable c, Field f, Expr why, string whyText) {\n  returnsArray(c, f) and\n  exists(MethodCall ma |\n    ma.getMethod().getSourceDeclaration() = c and ma.getCompilationUnit() != c.getCompilationUnit()\n  |\n    mayWriteToArray(ma) and\n    why = ma and\n    whyText = \"after this call to \" + c.getName()\n  )\n}\n\npredicate exposesByStore(Callable c, Field f, Expr why, string whyText) {\n  exists(VarAccess v, int i |\n    storesArray(c, i, f) and\n    v = varPassedInto(c, i) and\n    v.getCompilationUnit() != c.getCompilationUnit() and\n    why = modificationAfter(v) and\n    whyText = \"through the variable \" + v.getVariable().getName()\n  )\n}\n\nfrom Callable c, Field f, Expr why, string whyText\nwhere\n  (\n    exposesByReturn(c, f, why, whyText) or\n    exposesByStore(c, f, why, whyText)\n  ) and\n  // Kotlin properties expose internal representation, but it's not accidental, so ignore them\n  not exists(Property p | p.getBackingField() = f)\nselect c,\n  c.getName() + \" exposes the internal representation stored in field \" + f.getName() +\n    \". The value may be modified $@.\", why, whyText",
        "description": "An object that accidentally exposes its internal representation may allow the object's fields to be modified in ways that the object is not prepared to handle.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Implementation Hiding/ExposeRepresentation.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate nonEmptyArrayLiteralOrNull(Expr e) {\n  exists(ArrayCreationExpr arr | arr = e |\n    // Array initializer expressions such as `{1, 2, 3}`.\n    // Array is empty if the initializer expression is empty.\n    exists(arr.getInit().getAnInit())\n    or\n    // Array creation with dimensions (but without initializers).\n    // Empty if the first dimension is 0.\n    exists(Expr dim | dim = arr.getDimension(0) |\n      not dim.(CompileTimeConstantExpr).getIntValue() = 0\n    )\n  )\n  or\n  e instanceof NullLiteral\n  or\n  exists(ConditionalExpr cond | cond = e |\n    nonEmptyArrayLiteralOrNull(cond.getTrueExpr()) and\n    nonEmptyArrayLiteralOrNull(cond.getFalseExpr())\n  )\n}\n\nfrom Field f\nwhere\n  f.isPublic() and\n  f.isStatic() and\n  f.isFinal() and\n  f.getType() instanceof Array and\n  f.fromSource() and\n  forall(AssignExpr a | a.getDest() = f.getAnAccess() | nonEmptyArrayLiteralOrNull(a.getSource()))\nselect f, \"The array constant '\" + f.getName() + \"' is vulnerable to mutation.\"",
        "description": "Array constants are mutable and can be changed by malicious code or by accident.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Implementation Hiding/StaticArray.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Class c, MethodCall getResource, MethodCall getClass\nwhere\n  getResource.getNumArgument() = 1 and\n  (\n    getResource.getMethod().hasName(\"getResource\") or\n    getResource.getMethod().hasName(\"getResourceAsStream\")\n  ) and\n  getResource.getQualifier() = getClass and\n  getClass.isOwnMethodCall() and\n  getClass.getNumArgument() = 0 and\n  getClass.getMethod().hasName(\"getClass\") and\n  getResource.getEnclosingCallable().getDeclaringType() = c and\n  c.isPublic()\nselect getResource, \"The idiom getClass().getResource() is unsafe for classes that may be extended.\"",
        "description": "Calling 'this.getClass().getResource()' may yield unexpected results if called from a subclass in another package.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Implementation Hiding/GetClassGetResource.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Collections\n\npredicate guardedByInstanceOf(VarAccess e, RefType t) {\n  exists(Stmt s, InstanceOfExpr instanceCheck, RefType checkType |\n    (\n      s.(IfStmt).getCondition() = instanceCheck or\n      s.(WhenBranch).getCondition() = instanceCheck\n    ) and\n    instanceCheck.getCheckedType() = checkType and\n    // The same variable appears as the subject of the `instanceof`.\n    instanceCheck.getExpr() = e.getVariable().getAnAccess() and\n    // The checked type is either the type itself, or a raw version. For example, it is usually\n    // fine to check for `x instanceof ArrayList` and then cast to `ArrayList<Foo>`, because\n    // the generic parameter is usually known.\n    (checkType = t or checkType = t.getSourceDeclaration().(GenericType).getRawType()) and\n    // The expression appears in one of the branches.\n    // (We do not verify here whether the guard is correctly implemented.)\n    exists(Stmt branch |\n      branch = s.(IfStmt).getThen() or\n      branch = s.(IfStmt).getElse() or\n      branch = s.(WhenBranch).getRhs()\n    |\n      branch = e.getEnclosingStmt().getEnclosingStmt+()\n    )\n  )\n}\n\nfrom CastingExpr e, CollectionType c, CollectionType coll, string abstractName, string concreteName\nwhere\n  coll instanceof Interface and\n  c instanceof Class and\n  // The result of the cast has type `c`.\n  e.getType() = c and\n  // The expression inside the cast has type `coll`.\n  e.getExpr().getType() = coll and\n  // The cast does not occur inside a check that the variable has that type.\n  // In this case there is not really a break of abstraction, since it is not\n  // *assumed* that the variable has that type. In practice, this usually corresponds\n  // to a branch optimized for a specific subtype, and then a generic branch.\n  not guardedByInstanceOf(e.getExpr(), c) and\n  // Exclude results if \"unchecked\" warnings are deliberately suppressed.\n  not e.getEnclosingCallable().suppressesWarningsAbout(\"unchecked\") and\n  // Report the qualified names if the names are the same.\n  if coll.getName() = c.getName()\n  then (\n    abstractName = coll.getQualifiedName() and concreteName = c.getQualifiedName()\n  ) else (\n    abstractName = coll.getName() and concreteName = c.getName()\n  )\nselect e, \"$@ is cast to the concrete type $@, losing abstraction.\", coll.getSourceDeclaration(),\n  abstractName, c.getSourceDeclaration(), concreteName",
        "description": "A cast from an abstract collection to a concrete implementation type makes the code brittle.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Implementation Hiding/AbstractToConcreteCollection.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate isWithinType(Callable c, RefType t) {\n  // Either the callable is in the target type, or they share a common enclosing type\n  c.getDeclaringType().getEnclosingType*() = t.getEnclosingType*()\n}\n\npredicate isWithinPackage(Expr e, RefType t) {\n  e.getCompilationUnit().getPackage() = t.getPackage()\n}\n\npredicate isWithinVisibleForTestingContext(Callable c) {\n  c.getAnAnnotation().getType().hasName(\"VisibleForTesting\")\n  or\n  isWithinVisibleForTestingContext(c.getEnclosingCallable())\n}\n\nprivate predicate isWithinTest(Expr e) {\n  e.getEnclosingCallable() instanceof LikelyTestMethod\n  or\n  exists(Method lambda, LambdaExpr lambdaExpr |\n    lambda = lambdaExpr.asMethod() and\n    lambda.getEnclosingCallable*() instanceof LikelyTestMethod and\n    e.getEnclosingCallable() = lambda\n  )\n}\n\nfrom Annotatable annotated, Expr e\nwhere\n  annotated.getAnAnnotation().getType().hasName(\"VisibleForTesting\") and\n  (\n    // field access\n    e =\n      any(FieldAccess v |\n        v.getField() = annotated and\n        // depending on the visibility of the field, using the annotation to abuse the visibility may/may not be occurring\n        (\n          // if its package protected report when its used outside its class because it should have been private (class only permitted)\n          v.getField().isPackageProtected() and\n          not isWithinType(v.getEnclosingCallable(), v.getField().getDeclaringType())\n          or\n          // if public or protected report when its used outside its package because package protected should have been enough (package only permitted)\n          (v.getField().isPublic() or v.getField().isProtected()) and\n          not isWithinPackage(v, v.getField().getDeclaringType())\n        )\n      )\n    or\n    // method access\n    e =\n      any(MethodCall c |\n        c.getMethod() = annotated and\n        // depending on the visibility of the method, using the annotation to abuse the visibility may/may not be occurring\n        (\n          // if its package protected report when its used outside its class because it should have been private (class only permitted)\n          c.getMethod().isPackageProtected() and\n          not isWithinType(c.getEnclosingCallable(), c.getMethod().getDeclaringType())\n          or\n          // if public or protected report when its used outside its package because package protected should have been enough (package only permitted)\n          (c.getMethod().isPublic() or c.getMethod().isProtected()) and\n          not isWithinPackage(c, c.getMethod().getDeclaringType())\n        )\n      )\n    or\n    // Class instantiation - report if used outside appropriate scope\n    e =\n      any(ClassInstanceExpr c |\n        c.getConstructedType() = annotated and\n        (\n          c.getConstructedType().isPublic() and not isWithinPackage(c, c.getConstructedType())\n          or\n          c.getConstructedType().hasNoModifier() and\n          c.getConstructedType() instanceof NestedClass and\n          not isWithinType(c.getEnclosingCallable(), c.getConstructedType())\n        )\n      )\n  ) and\n  // not in a test where use is appropriate\n  not isWithinTest(e) and\n  // not when the accessing method or any enclosing method is @VisibleForTesting (test-to-test communication)\n  not isWithinVisibleForTestingContext(e.getEnclosingCallable()) and\n  // not when used in annotation contexts\n  not e.getParent*() instanceof Annotation\nselect e, \"Access of $@ annotated with VisibleForTesting found in production code.\", annotated,\n  \"element\"",
        "description": "Accessing methods, fields or classes annotated with `@VisibleForTesting` from production code goes against the intention of the annotation and may indicate programmer error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Implementation Hiding/VisibleForTestingAbuse.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass LocalBoxedVar extends LocalVariableDecl {\n  LocalBoxedVar() { this.getType() instanceof BoxedType }\n\n  PrimitiveType getPrimitiveType() { this.getType().(BoxedType).getPrimitiveType() = result }\n}\n\npredicate notDeliberatelyBoxed(LocalBoxedVar v) {\n  not forall(VarRead a | a = v.getAnAccess() |\n    exists(Call c, int i |\n      c.getCallee().getParameterType(i) instanceof RefType and\n      c.getArgument(i) = a\n    )\n    or\n    exists(ReturnStmt ret |\n      ret.getResult() = a and\n      ret.getEnclosingCallable().getReturnType() instanceof RefType\n    )\n  )\n}\n\npragma[nomagic]\nint callableGetNumberOfParameters(Callable c) { result = c.getNumberOfParameters() }\n\npredicate affectsOverload(LocalBoxedVar v) {\n  exists(Call call, int i, Callable c1, Callable c2 |\n    call.getCallee() = c1 and\n    call.getArgument(i) = v.getAnAccess() and\n    c1.getDeclaringType() = c2.getDeclaringType() and\n    c1.getParameterType(i) instanceof RefType and\n    c2.getParameterType(i) instanceof PrimitiveType and\n    c1.getName() = c2.getName() and\n    callableGetNumberOfParameters(c1) = callableGetNumberOfParameters(c2)\n  )\n}\n\nfrom LocalBoxedVar v\nwhere\n  forall(Expr e | e = v.getAnAssignedValue() | e.getType() = v.getPrimitiveType()) and\n  (\n    not v.getDeclExpr().hasImplicitInit() or\n    v.getDeclExpr().getParent().(EnhancedForStmt).getExpr().getType().(Array).getComponentType() =\n      v.getPrimitiveType()\n  ) and\n  notDeliberatelyBoxed(v) and\n  not affectsOverload(v)\nselect v,\n  \"The variable '\" + v.getName() +\n    \"' is only assigned values of primitive type and is never 'null', but it is declared with the boxed type '\"\n    + v.getType().toString() + \"'.\"",
        "description": "Using a boxed type for a variable that is never assigned 'null' hinders readability because it implies that 'null' is a potential value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Boxed Types/BoxedVariable.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate varArgsMethod(Method method, Array varargsType, int arity) {\n  exists(MethodCall access |\n    access.getMethod() = method and\n    arity = method.getNumberOfParameters() and\n    not access.getNumArgument() = arity and\n    method.getParameterType(arity - 1) = varargsType\n  )\n}\n\nRefType normalised(Type type) {\n  type.(RawType).getErasure() = result\n  or\n  type.(ParameterizedType).getErasure() = result\n  or\n  type.(BoundedType).getUpperBoundType() = result\n  or\n  not type instanceof RawType and not type instanceof ParameterizedType and type = result\n}\n\npredicate equivalent(Array declared, Array used) {\n  normalised(declared.getElementType()) = normalised(used.getElementType()) and\n  declared.getDimension() = used.getDimension()\n}\n\nfrom Method target, MethodCall access, Array declaredType, Array usedType, int params\nwhere\n  varArgsMethod(target, declaredType, params) and\n  target = access.getMethod() and\n  access.getNumArgument() = params and\n  usedType = access.getArgument(params - 1).getType() and\n  not equivalent(declaredType, usedType) and\n  declaredType.getDimension() != usedType.getDimension() + 1\nselect access.getArgument(params - 1),\n  \"Call to varargs method $@ with inexact argument type (compiler dependent).\", target,\n  target.getName()",
        "description": "Calling a varargs method where it is unclear whether the arguments should be interpreted as a list of arguments or as a single argument, may lead to compiler-dependent behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/legacy/InexactVarArg.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nBlockStmt finallyBlock() { exists(TryStmt try | try.getFinally() = result) }\n\nStmt statementIn(BlockStmt finally) {\n  finallyBlock() = finally and\n  result.getParent+() = finally\n}\n\npredicate banned(Stmt s, BlockStmt finally) {\n  s = statementIn(finally) and\n  (\n    s instanceof ReturnStmt\n    or\n    exists(ThrowStmt throw | s = throw and not throw.getLexicalCatchIfAny() = statementIn(finally))\n    or\n    exists(JumpStmt jump | s = jump and not jump.getTarget() = statementIn(finally))\n  )\n}\n\nfrom Stmt s, BlockStmt finally\nwhere banned(s, finally)\nselect s, \"Leaving a finally-block with this statement can cause exceptions to silently disappear.\"",
        "description": "A 'finally' block that runs because an exception has been thrown, and that does not complete normally, causes the exception to disappear silently.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/legacy/FinallyMayNotComplete.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Assignment a, Parameter p\nwhere a.getDest() = p.getAnAccess()\nselect a, \"Assignment to parameters may decrease code readability.\"",
        "description": "Changing a parameter's value in a method or constructor may decrease code readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/legacy/ParameterAssignment.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass PrimitiveExpr extends Expr {\n  PrimitiveExpr() { this.getType() instanceof PrimitiveType }\n}\n\nclass BoxedExpr extends Expr {\n  BoxedExpr() { this.getType() instanceof BoxedType }\n}\n\nVariable flowTarget(Expr arg) {\n  arg = result.getAnAssignedValue()\n  or\n  exists(Call c, int i | c.getArgument(i) = arg and result = c.getCallee().getParameter(i))\n}\n\npredicate unboxed(BoxedExpr e) {\n  exists(BinaryExpr bin | e = bin.getAnOperand() |\n    if bin instanceof EqualityTest or bin instanceof ComparisonExpr\n    then bin.getAnOperand() instanceof PrimitiveExpr\n    else bin instanceof PrimitiveExpr\n  )\n  or\n  exists(Assignment assign | assign.getDest() instanceof PrimitiveExpr | assign.getSource() = e)\n  or\n  flowTarget(e).getType() instanceof PrimitiveType\n  or\n  exists(ConditionalExpr cond | cond instanceof PrimitiveExpr | cond.getABranchExpr() = e)\n}\n\npredicate boxed(PrimitiveExpr e) {\n  exists(AssignExpr assign | assign.getDest() instanceof BoxedExpr | assign.getSource() = e)\n  or\n  flowTarget(e).getType() instanceof BoxedType\n  or\n  exists(ConditionalExpr cond | cond instanceof BoxedExpr |\n    cond.getTrueExpr() = e or cond.getFalseExpr() = e\n  )\n}\n\npredicate rebox(Assignment e, Variable v) {\n  v.getType() instanceof BoxedType and\n  not e instanceof AssignExpr and\n  e.getDest() = v.getAnAccess()\n}\n\nfrom Expr e, string conv\nwhere\n  e.getFile().isJavaSourceFile() and\n  (\n    boxed(e) and conv = \"This expression is implicitly boxed.\"\n    or\n    unboxed(e) and conv = \"This expression is implicitly unboxed.\"\n    or\n    exists(Variable v | rebox(e, v) |\n      conv =\n        \"This expression implicitly unboxes, updates, and reboxes the value of '\" + v.getName() +\n          \"'.\"\n    )\n  )\nselect e, conv",
        "description": "Implicit boxing or unboxing of primitive types, such as 'int' and 'double', may cause confusion and subtle performance problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/legacy/AutoBoxing.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nstring neededByJavadoc(JavadocElement c) {\n  result = c.getText().regexpCapture(\".*\\\\{@link(?:plain)?\\\\s+(\\\\w+)\\\\b.*\\\\}.*\", 1) or\n  result = c.(ThrowsTag).getExceptionName() or\n  result = c.(SeeTag).getReference()\n}\n\nAnnotation nestedAnnotation(Annotation a) { result.getAnnotatedElement().(Expr).getParent+() = a }\n\nRefType neededByAnnotation(Annotation a) {\n  exists(TypeAccess t | t.getParent+() = a | result = t.getType().(RefType).getSourceDeclaration())\n  or\n  exists(ArrayTypeAccess at | at.getParent+() = a |\n    result = at.getType().(Array).getElementType().(RefType).getSourceDeclaration()\n  )\n  or\n  exists(VarAccess va | va.getParent+() = a | result = va.getVariable().(Field).getDeclaringType())\n  or\n  result = a.getType()\n  or\n  result = a.getType().(NestedType).getEnclosingType+()\n  or\n  result = neededByAnnotation(nestedAnnotation(a))\n}\n\nRefType neededType(CompilationUnit cu) {\n  // Annotations\n  exists(Annotation a | a.getAnnotatedElement().getCompilationUnit() = cu |\n    result = neededByAnnotation(a)\n  )\n  or\n  // type accesses\n  exists(TypeAccess t | t.getCompilationUnit() = cu |\n    result = t.getType().(RefType).getSourceDeclaration()\n  )\n  or\n  exists(ArrayTypeAccess at | at.getCompilationUnit() = cu |\n    result = at.getType().(Array).getElementType().(RefType).getSourceDeclaration()\n  )\n  or\n  // throws clauses\n  exists(Callable c | c.getCompilationUnit() = cu | result = c.getAnException().getType())\n  or\n  // Javadoc\n  exists(JavadocElement j | cu.getFile() = j.getFile() | result.getName() = neededByJavadoc(j))\n}\n\nRefType importedType(Import i) {\n  result = i.(ImportOnDemandFromPackage).getAnImport() or\n  result = i.(ImportOnDemandFromType).getAnImport() or\n  result = i.(ImportType).getImportedType()\n}\n\npredicate neededImport(Import i) { importedType(i) = neededType(i.getCompilationUnit()) }\n\nfrom Import i\nwhere\n  not neededImport(i) and\n  not i instanceof ImportStaticOnDemand and\n  not i instanceof ImportStaticTypeMember\nselect i, \"Import of '\" + i + \"' is not used.\"",
        "description": "A redundant 'import' statement introduces unnecessary and undesirable dependencies.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/legacy/UnnecessaryImport.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CastingExpr redundant, Type type\nwhere\n  (redundant instanceof CastExpr or redundant instanceof SafeCastExpr) and\n  redundant.getType() = type and\n  type = redundant.getExpr().getType()\nselect redundant, \"This cast is redundant - the expression is already of type '\" + type + \"'.\"",
        "description": "Casting an object to its own type is unnecessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/legacy/UnnecessaryCast.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ImportOnDemandFromPackage i\nselect i, \"It is advisable to make imports explicit.\"",
        "description": "An implicit import obscures the dependencies of a file and may cause confusing compile-time errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Declarations/MakeImportsExplicit.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Common\n\nfrom SwitchStmt s, Stmt c\nwhere\n  c = s.getACase() and\n  not c.getControlFlowNode().getASuccessor().asStmt() instanceof SwitchCase and\n  not s.(Annotatable).suppressesWarningsAbout(\"fallthrough\") and\n  mayDropThroughWithoutComment(s, c)\nselect c,\n  \"Switch case may fall through to the next case. Use a break or return to terminate this case.\"",
        "description": "A 'case' statement that does not contain a 'break' statement allows execution to 'fall through' to the next 'case', which may not be intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Declarations/BreakInSwitchCase.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.Member\n\nclass ConstantField extends Field {\n  ConstantField() { this.isStatic() and this.isFinal() }\n}\n\npragma[noinline]\npredicate typeWithConstantField(RefType t) { exists(ConstantField f | f.getDeclaringType() = t) }\n\nclass ConstantRefType extends RefType {\n  ConstantRefType() {\n    this.fromSource() and\n    (\n      this instanceof Interface\n      or\n      this instanceof Class and this.isAbstract()\n    ) and\n    typeWithConstantField(this) and\n    forall(Member m | m.getDeclaringType() = this |\n      m.(Constructor).isDefaultConstructor() or\n      m instanceof StaticInitializer or\n      m instanceof ConstantField\n    )\n  }\n\n  string getKind() {\n    result = \"interface\" and this instanceof Interface\n    or\n    result = \"class\" and this instanceof Class\n  }\n}\n\nfrom ConstantRefType t, RefType sub\nwhere\n  sub.fromSource() and\n  sub.getASupertype() = t and\n  not sub instanceof ConstantRefType and\n  sub = sub.getSourceDeclaration()\nselect sub, \"Type \" + sub.getName() + \" implements constant \" + t.getKind() + \" $@.\", t, t.getName()",
        "description": "Implementing an interface (or extending an abstract class) only to put a number of constant definitions into scope is considered bad practice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Declarations/NoConstantsOnly.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npragma[nomagic]\nprivate predicate confusingPrimitiveBoxedTypes(Type t, Type u) {\n  t.(PrimitiveType).getBoxedType() = u or\n  u.(PrimitiveType).getBoxedType() = t\n}\n\nprivate predicate overloadedMethods(Method n, Method m) {\n  n.fromSource() and\n  exists(RefType rt, string name, int numParams |\n    candidateMethod(rt, m, name, numParams) and\n    candidateMethod(rt, n, name, numParams)\n  ) and\n  n != m and\n  n.getSourceDeclaration().getSignature() < m.getSourceDeclaration().getSignature()\n}\n\nprivate predicate overloadedMethodsMostSpecific(Method n, Method m) {\n  overloadedMethods(n, m) and\n  not exists(Method nSup, Method mSup |\n    n.overridesOrInstantiates*(nSup) and m.overridesOrInstantiates*(mSup)\n  |\n    overloadedMethods(nSup, mSup) and\n    (n != nSup or m != mSup)\n  )\n}\n\nprivate predicate whitelist(string name) { name = \"visit\" }\n\npragma[nomagic]\nprivate predicate candidateMethod(RefType t, Method m, string name, int numParam) {\n  exists(Method n | n.getSourceDeclaration() = m | t.inherits(n)) and\n  m.getName() = name and\n  m.getNumberOfParameters() = numParam and\n  m = m.getSourceDeclaration() and\n  not m.getAnAnnotation() instanceof DeprecatedAnnotation and\n  // Exclude compiler generated methods, such as Kotlin `$default` methods:\n  not m.isCompilerGenerated() and\n  not whitelist(name)\n}\n\npredicate paramTypePair(Type t1, Type t2) {\n  exists(Method n, Method m, int i |\n    overloadedMethodsMostSpecific(n, m) and\n    t1 = n.getParameterType(pragma[only_bind_into](i)) and\n    t2 = m.getParameterType(pragma[only_bind_into](i))\n  )\n}\n\n// handle simple cases separately\npredicate potentiallyConfusingTypesSimple(Type t1, Type t2) {\n  paramTypePair(t1, t2) and\n  (\n    t1 = t2\n    or\n    t1 instanceof TypeObject and t2 instanceof RefType\n    or\n    t2 instanceof TypeObject and t1 instanceof RefType\n    or\n    confusingPrimitiveBoxedTypes(t1, t2)\n  )\n}\n\n// check erased types first\npredicate potentiallyConfusingTypesRefTypes(RefType t1, RefType t2) {\n  paramTypePair(t1, t2) and\n  not potentiallyConfusingTypesSimple(t1, t2) and\n  haveIntersection(t1, t2)\n}\n\n// then check hasSubtypeOrInstantiation\npragma[nomagic]\npredicate potentiallyConfusingTypes(Type t1, Type t2) {\n  potentiallyConfusingTypesSimple(t1, t2)\n  or\n  potentiallyConfusingTypesRefTypes(t1, t2) and\n  exists(RefType commonSubtype | hasSubtypeOrInstantiation*(t1, commonSubtype) |\n    hasSubtypeOrInstantiation*(t2, commonSubtype)\n  )\n}\n\nprivate predicate hasSubtypeOrInstantiation(RefType t, RefType sub) {\n  hasSubtype(t, sub) or\n  sub.getSourceDeclaration() = t\n}\n\nprivate predicate confusinglyOverloaded(Method m, Method n) {\n  overloadedMethodsMostSpecific(n, m) and\n  forall(int i, Parameter p, Parameter q | p = n.getParameter(i) and q = m.getParameter(i) |\n    potentiallyConfusingTypes(p.getType(), q.getType())\n  ) and\n  // There is no possibility for confusion between two methods with identical behavior.\n  not exists(Method target | delegate*(m, target) and delegate*(n, target))\n}\n\nprivate predicate wrappedAccess(Expr e, MethodCall ma) {\n  e = ma or\n  wrappedAccess(e.(CastingExpr).getExpr(), ma)\n}\n\nprivate predicate delegate(Method caller, Method callee) {\n  exists(MethodCall ma | ma.getMethod() = callee |\n    exists(Stmt stmt | stmt = caller.getBody().(SingletonBlock).getStmt() |\n      wrappedAccess(stmt.(ExprStmt).getExpr(), ma) or\n      wrappedAccess(stmt.(ReturnStmt).getResult(), ma)\n    ) and\n    forex(Parameter p, int i, Expr arg | p = caller.getParameter(i) and ma.getArgument(i) = arg |\n      // The parameter is propagated without modification.\n      arg = p.getAnAccess()\n      or\n      // The parameter is cast to a supertype.\n      arg.(CastingExpr).getExpr() = p.getAnAccess() and\n      arg.getType().(RefType).getASubtype() = p.getType()\n    )\n  )\n}\n\nfrom Method m, Method n, string messageQualifier\nwhere\n  confusinglyOverloaded(m, n) and\n  (\n    if m.getDeclaringType() = n.getDeclaringType()\n    then messageQualifier = \"\"\n    else messageQualifier = m.getDeclaringType().getName() + \".\"\n  )\nselect n,\n  \"Method \" + n.getDeclaringType() + \".\" + n +\n    \"(..) could be confused with overloaded method $@, since dispatch depends on static types.\",\n  m.getSourceDeclaration(), messageQualifier + m.getName()",
        "description": "Overloaded methods that have the same number of parameters, where each pair of corresponding parameter types is convertible by casting or autoboxing, may be confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/ConfusingOverloading.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nRefType nestedSupertypePlus(RefType t) {\n  t.getASourceSupertype() = result and\n  t instanceof NestedType\n  or\n  exists(RefType mid | mid = nestedSupertypePlus(t) | mid.getASourceSupertype() = result)\n}\n\npredicate callToInheritedMethod(RefType lexicalScope, MethodCall ma, string signature) {\n  not ma.getMethod().isStatic() and\n  not ma.hasQualifier() and\n  ma.getEnclosingCallable().getDeclaringType() = lexicalScope and\n  nestedSupertypePlus(lexicalScope).getAMethod() = ma.getMethod().getSourceDeclaration() and\n  signature = ma.getMethod().getSignature()\n}\n\nMethod methodInEnclosingType(NestedType nested, string signature) {\n  (result.isStatic() or not nested.isStatic()) and\n  result.getSignature() = signature and\n  exists(RefType outer | outer = nested.getEnclosingType() |\n    result = outer.getAMethod() or\n    result = methodInEnclosingType(nested, signature)\n  )\n}\n\nfrom MethodCall ma, Method m, NestedType nt, string signature\nwhere\n  callToInheritedMethod(nt, ma, signature) and\n  m = methodInEnclosingType(nt, signature) and\n  // There is actually scope for confusion.\n  not nt.getASourceSupertype+() = m.getDeclaringType()\nselect ma, \"A $@ is called instead of a $@.\", ma.getMethod(), \"method declared in a superclass\", m,\n  \"method with the same signature in an enclosing class\"",
        "description": "An unqualified call to a method that exists with the same signature in both a superclass and an outer class is ambiguous.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/AmbiguousOuterSuper.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType sub, RefType sup\nwhere\n  sub.fromSource() and\n  sup = sub.getASupertype() and\n  pragma[only_bind_out](sub.getName()) = pragma[only_bind_out](sup.getName())\nselect sub, sub.getName() + \" has the same name as its supertype $@.\", sup, sup.getQualifiedName()",
        "description": "A class that has the same name as its superclass may be confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/SameNameAsSuper.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate methodNames(RefType t, Method m, string lowercase, string name) {\n  exists(RefType t2 |\n    m.getDeclaringType() = t2 and\n    hasDescendant(t2, t)\n  ) and\n  name = m.getName() and\n  lowercase = name.toLowerCase() and\n  lowercase.length() > 1\n}\n\npredicate confusing(Method m1, Method m2) {\n  exists(RefType t, string lower, string name1, string name2 |\n    methodNames(t, m1, lower, name1) and\n    methodNames(t, m2, lower, name2) and\n    name1 != name2\n  )\n}\n\n\nfrom Method m1, Method m2\nwhere\n  confusing(m1, m2) and\n  m1.getDeclaringType() != m2.getDeclaringType() and\n  (\n    m1.isStatic() and m2.isStatic()\n    or\n    not m1.isStatic() and not m2.isStatic()\n  ) and\n  not exists(Method mid |\n    confusing(m1, mid) and\n    mid.getDeclaringType().getAStrictAncestor() = m2.getDeclaringType()\n  ) and\n  not exists(Method notConfusing |\n    notConfusing.getDeclaringType() = m1.getDeclaringType() and\n    notConfusing.getName() = m2.getName()\n  )\nselect m1,\n  \"It is confusing to have methods \" + m1.getName() + \" in \" + m1.getDeclaringType().getName() +\n    \" and \" + m2.getName() + \" in \" + m2.getDeclaringType().getName() + \".\"",
        "description": "A method that would override another method but does not, because the name is capitalized differently, is confusing and may be a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/ConfusingOverridesNames.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Shadowing\n\nfrom LocalVariableDecl d, Class c, Field f, Callable callable, string callableType\nwhere\n  shadows(d, c, f, callable) and\n  not assignmentToShadowingLocal(d, f) and\n  not assignmentFromShadowingLocal(d, f) and\n  not thisAccess(d, f) and\n  not confusingAccess(d, f) and\n  (if callable instanceof Constructor then callableType = \"\" else callableType = \"method \")\nselect d, \"This local variable shadows field $@, which is not used in \" + callableType + \"$@.\", f,\n  f.getName(), callable, callable.getName()",
        "description": "If a local variable shadows a field of the same name, each use of the name is harder to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/LocalShadowsField.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate methodTypeAndLowerCaseName(Method m, RefType t, string name) {\n  t = m.getDeclaringType() and\n  name = m.getName().toLowerCase()\n}\n\nfrom Method m, Method n\nwhere\n  exists(RefType t, string name |\n    methodTypeAndLowerCaseName(m, t, name) and\n    methodTypeAndLowerCaseName(n, t, name)\n  ) and\n  not m.getAnAnnotation() instanceof DeprecatedAnnotation and\n  not n.getAnAnnotation() instanceof DeprecatedAnnotation and\n  m.getName() < n.getName()\nselect m, \"The method '\" + m.getName() + \"' may be confused with $@.\", n, n.getName()",
        "description": "Methods in the same class whose names differ only in capitalization are confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/ConfusingMethodNames.ql",
        "language": "java"
    },
    {
        "query": "import java\nprivate import semmle.code.java.frameworks.android.Compose\n\nclass VisibleInstanceField extends Field {\n  VisibleInstanceField() {\n    not this.isPrivate() and\n    not this.isStatic()\n  }\n}\n\nfrom RefType type, RefType supertype, VisibleInstanceField masked, VisibleInstanceField masking\nwhere\n  type.getASourceSupertype+() = supertype and\n  masking.getDeclaringType() = type and\n  masked.getDeclaringType() = supertype and\n  masked.getName() = masking.getName() and\n  // Exclude intentional masking.\n  not exists(VarAccess va | va.getVariable() = masked | va.getQualifier() instanceof SuperAccess) and\n  type.fromSource() and\n  // Exclude live literal variables, which is generated code.\n  not masking.getInitializer() instanceof LiveLiteral\nselect masking, \"This field shadows another field called $@ in a superclass.\", masked,\n  masked.getName()",
        "description": "Hiding a field in a superclass by redeclaring it in a subclass might be unintentional, especially if references to the hidden field are not qualified using 'super'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/FieldMasksSuperField.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Shadowing\n\nfrom LocalVariableDecl d, Class c, Field f, Callable callable, string callableType, string message\nwhere\n  shadows(d, c, f, callable) and\n  not assignmentToShadowingLocal(d, f) and\n  not assignmentFromShadowingLocal(d, f) and\n  (if callable instanceof Constructor then callableType = \"\" else callableType = \"method \") and\n  (\n    confusingAccess(d, f) and\n    message =\n      \"Confusing name: \" + callableType +\n        \"$@ also refers to field $@ (without qualifying it with 'this').\"\n    or\n    thisAccess(d, f) and\n    not confusingAccess(d, f) and\n    message =\n      \"Potentially confusing name: \" + callableType + \"$@ also refers to field $@ (as this.\" +\n        f.getName() + \").\"\n  )\nselect d, message, callable, callable.getName(), f, f.getName()",
        "description": "A method in which a variable is declared with the same name as a field is difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Naming Conventions/LocalShadowsFieldConfusing.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass MockitoMockCall extends MethodCall {\n  MockitoMockCall() { this.getMethod().hasQualifiedName(\"org.mockito\", \"Mockito\", \"mock\") }\n\n  /**\n   * Gets the type that this call intends to mock. For example:\n   * ```java\n   * EmployeeRecord employeeRecordMock = mock(EmployeeRecord.class);\n   * ```\n   * This predicate gets the class `EmployeeRecord` in the above example.\n   */\n  Type getMockedType() { result = this.getAnArgument().(TypeLiteral).getReferencedType() }\n}\n\nclass MockitoMockingMethodCall extends MethodCall {\n  MockitoMockCall mockCall;\n\n  MockitoMockingMethodCall() {\n    /* 1. The qualifier originates from the mock call. */\n    this.getQualifier().getControlFlowNode().getAPredecessor+() = mockCall.getControlFlowNode() and\n    /* 2. The mocked method can be found in the class being mocked with the mock call. */\n    mockCall.getMockedType().(ClassOrInterface).getAMethod() = this.getMethod()\n  }\n\n  /**\n   * Gets the call to Mockito's `mock` from which the qualifier, the mocked object, originates.\n   */\n  MockitoMockCall getMockitoMockCall() { result = mockCall }\n}\n\n\nfrom JUnit4TestMethod testMethod, ClassOrInterface mockedClassOrInterface\nwhere\n  exists(MockitoMockCall mockCall |\n    mockCall.getEnclosingCallable() = testMethod and\n    mockedClassOrInterface = mockCall.getMockedType() and\n    // Only flag classes with multiple public methods (2 or more)\n    strictcount(Method m | m = mockedClassOrInterface.getAMethod() and m.isPublic()) > 1 and\n    forex(Method method | method = mockedClassOrInterface.getAMethod() and method.isPublic() |\n      exists(MockitoMockingMethodCall mockedMethod |\n        mockedMethod.getMockitoMockCall() = mockCall and\n        mockedMethod.getMethod() = method\n      )\n    )\n  )\nselect testMethod, \"This test method mocks all public methods of a $@.\", mockedClassOrInterface,\n  \"class or an interface\"",
        "description": "Mocking all public methods provided by a class might indicate the unit test aims to test too many things.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Testing/ExcessivePublicMethodMocking.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Reflection\n\npredicate isClassOf(ParameterizedClass c, RefType t) {\n  c.getGenericType() instanceof TypeClass and\n  c.getATypeArgument().getSourceDeclaration() = t.getSourceDeclaration()\n}\n\npredicate subjectToAtomicReferenceFieldUpdater(Field f) {\n  exists(Class arfu, Method newUpdater, MethodCall c |\n    arfu.hasQualifiedName(\"java.util.concurrent.atomic\", \"AtomicReferenceFieldUpdater\") and\n    newUpdater = arfu.getAMethod() and\n    newUpdater.hasName(\"newUpdater\") and\n    c.getMethod().getSourceDeclaration() = newUpdater and\n    isClassOf(c.getArgument(0).getType(), f.getDeclaringType()) and\n    isClassOf(c.getArgument(1).getType(), f.getType()) and\n    c.getArgument(2).(StringLiteral).getValue() = f.getName()\n  )\n}\n\npredicate lookedUpReflectively(Field f) {\n  exists(MethodCall getDeclaredField |\n    isClassOf(getDeclaredField.getQualifier().getType(), f.getDeclaringType()) and\n    getDeclaredField.getMethod().hasName(\"getDeclaredField\") and\n    getDeclaredField.getArgument(0).(StringLiteral).getValue() = f.getName()\n  )\n}\n\npredicate isVMObserver(RefType rt) {\n  exists(Method register |\n    register.getDeclaringType().hasQualifiedName(\"sun.jvm.hotspot.runtime\", \"VM\") and\n    register.hasName(\"registerVMInitializedObserver\") and\n    register.getAReference().getEnclosingCallable().(StaticInitializer).getDeclaringType() = rt\n  )\n}\n\nfrom Field f, FieldRead fr\nwhere\n  f.fromSource() and\n  fr.getField() = f and\n  not f.getDeclaringType() instanceof EnumType and\n  forall(Assignment ae | ae.getDest() = f.getAnAccess() | ae.getSource() instanceof NullLiteral) and\n  not exists(UnaryAssignExpr ua | ua.getExpr() = f.getAnAccess()) and\n  not f.isFinal() and\n  // Exclude fields that may be accessed reflectively.\n  not reflectivelyWritten(f) and\n  not lookedUpReflectively(f) and\n  not subjectToAtomicReferenceFieldUpdater(f) and\n  // If an object containing `f` is, or may be, passed to a native method,\n  // assume it initializes the field.\n  not exists(Callable c | c.isNative() |\n    c.getAParameter().getType() = f.getDeclaringType() or\n    c.getAReference().getAnArgument().getType() = f.getDeclaringType() or\n    c.getDeclaringType() = f.getDeclaringType()\n  ) and\n  // Exclude special VM classes.\n  not isVMObserver(f.getDeclaringType())\nselect f, \"The field '\" + f.getName() + \"' is never explicitly assigned a value, yet $@.\", fr,\n  \"the field is read\"",
        "description": "A field that is never assigned a value (except possibly 'null') just returns the default value when it is read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/NonAssignedFields.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DeadLocals\n\nfrom LocalScopeVariable v\nwhere\n  assigned(v) and // Only assignments, not initialization\n  not read(v)\nselect v, \"Local variable \" + v.getName() + \" is only assigned to, never read.\"",
        "description": "A local variable is written to, but never read. Either the local variable is useless, or its value was intended to be used but is not.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/LocalNotRead.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom LabeledStmt label\nwhere not exists(JumpStmt jump | jump.getTargetLabel() = label)\nselect label, \"Label '\" + label.getLabel() + \"' is not used.\"",
        "description": "An unused label for a loop or 'switch' statement is either redundant or indicates incorrect 'break' or 'continue' statements.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/UnusedLabel.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nMethod protectedObjectMethod(string signature) {\n  result.getSignature() = signature and\n  result.isProtected() and\n  result.getDeclaringType() instanceof TypeObject\n}\n\nfrom Method method, Method objMethod, Interface impossible\nwhere\n  method.getDeclaringType() = impossible and\n  objMethod = protectedObjectMethod(method.getSignature()) and\n  not hasDescendant(objMethod.getReturnType(), method.getReturnType())\nselect method,\n  \"This method's return type conflicts with Object.\" + method.getName() +\n    \" so $@ can never be implemented.\", impossible, impossible.getName()",
        "description": "An interface method that is incompatible with a protected method on 'java.lang.Object' means that the interface cannot be implemented.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/InterfaceCannotBeImplemented.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom AssignExpr e, LocalVariableDecl v\nwhere\n  e.getDest().(VarAccess).getVariable() = v and\n  e.getParent+() instanceof ReturnStmt\nselect e, \"Assignment to a local variable in a return statement may have no effect.\"",
        "description": "Assigning to a local variable in a 'return' statement has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/AssignmentInReturn.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Reflection\nimport semmle.code.java.frameworks.Lombok\n\nfrom Field f\nwhere\n  not (f.isPublic() or f.isProtected()) and\n  f.fromSource() and\n  not f.getDeclaringType() instanceof EnumType and\n  not exists(VarAccess va | va.getVariable() = f) and\n  // Exclude results in generated classes.\n  not f.getDeclaringType() instanceof GeneratedClass and\n  // Exclude fields that may be reflectively read (this includes standard serialization).\n  not reflectivelyRead(f) and\n  // Exclude fields with deliberately suppressed warnings.\n  not f.suppressesWarningsAbout(\"unused\") and\n  // Exclude fields with relevant Lombok annotations.\n  not f instanceof LombokGetterAnnotatedField\nselect f, \"Unused field \" + f.getName() + \" in \" + f.getDeclaringType().getName() + \".\"",
        "description": "A field that is never used is probably unnecessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/UnusedField.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DeadLocals\n\nfrom LocalVariableDeclExpr ve, LocalVariableDecl v\nwhere\n  v = ve.getVariable() and\n  not assigned(v) and\n  not read(v) and\n  exists(ve.getInit()) and\n  not exprHasNoEffect(ve.getInit())\nselect v, \"Local variable \" + v.getName() + \" is never read or written to after it is initialised.\"",
        "description": "A local variable that is initialized but not subsequently used may indicate an error in the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/LocalInitialisedButNotUsed.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom FinalizeMethod m, Assignment assign, FieldAccess lhs, NullLiteral null\nwhere\n  assign.getEnclosingCallable() = m and\n  null.getParent() = assign and\n  lhs = assign.getDest() and\n  lhs.getField().getDeclaringType() = m.getDeclaringType().getAnAncestor() and\n  m.fromSource()\nselect assign, \"Finalizer nulls fields.\"",
        "description": "Setting fields to 'null' in a finalizer does not cause the object to be collected by the garbage collector any earlier, and may adversely affect performance.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/FinalizerNullsFields.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom FinalizeMethod finalize\nwhere\n  finalize.fromSource() and\n  not exists(Stmt s | s.getEnclosingCallable() = finalize | not s instanceof BlockStmt)\nselect finalize, \"Empty finalize method.\"",
        "description": "An empty 'finalize' method is useless and prevents its superclass's 'finalize' method (if any) from being called.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/EmptyFinalize.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DeadLocals\n\nfrom VariableUpdate def, LocalScopeVariable v\nwhere\n  def.getDestVar() = v and\n  deadLocal(def) and\n  not expectedDead(def) and\n  not overwritten(def) and\n  read(v) and\n  not def.(AssignExpr).getSource() instanceof NullLiteral and\n  (def instanceof Assignment or def.(UnaryAssignExpr).getParent() instanceof ExprStmt)\nselect def, \"This definition of \" + v.getName() + \" is never used.\"",
        "description": "Assigning a value to a local variable that is not later used has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/DeadStoreOfLocalUnread.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nVarAccess getARead(LocalVariableDecl v) {\n  v.getAnAccess() = result and\n  not exists(Assignment assign | assign.getDest() = result)\n}\n\npredicate readImplicitly(LocalVariableDecl v) {\n  exists(TryStmt t | t.getAResourceDecl().getAVariable() = v.getDeclExpr())\n}\n\nfrom LocalVariableDecl v\nwhere\n  not exists(getARead(v)) and\n  // Discarded exceptions are covered by another query.\n  not exists(CatchClause cc | cc.getVariable().getVariable() = v) and\n  // Exclude common Kotlin pattern to do something n times: `for(i in 1..n) { doSomething() }\n  not exists(EnhancedForStmt f |\n    f.getVariable().getVariable() = v and\n    f.getExpr().getType().(RefType).hasQualifiedName(\"kotlin.ranges\", [\"IntRange\", \"LongRange\"])\n  ) and\n  not readImplicitly(v)\nselect v, \"Variable '\" + v + \"' is never read.\"",
        "description": "A local variable that is never read is redundant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/UnreadLocal.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate ignored(Method m) {\n  m.isAbstract() or\n  m.overrides(_)\n}\n\nMethod forwarderCandidate(Method forwardee) {\n  result != forwardee and\n  result.getName() = forwardee.getName() and\n  result.getDeclaringType() = forwardee.getDeclaringType() and\n  forex(MethodCall c | c.getMethod() = forwardee | c.getCaller() = result) and\n  forall(MethodCall c | c.getCaller() = result | c.getMethod() = forwardee)\n}\n\nfrom Method forwarder, Method forwardee\nwhere\n  forwarder = forwarderCandidate(forwardee) and\n  // Exclusions\n  not ignored(forwarder) and\n  not ignored(forwardee) and\n  not exists(VirtualMethodCall c |\n    c.getMethod() = forwardee and\n    c.getCaller() = forwarder and\n    c.(MethodCall).hasQualifier()\n  )\nselect forwarder.getSourceDeclaration(),\n  \"This method is a forwarder for $@, which is not called independently - the methods can be merged.\",\n  forwardee.getSourceDeclaration(), forwardee.getName()",
        "description": "A method forwards calls to another method of the same name that is not called independently.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/PointlessForwardingMethod.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DeadLocals\n\npredicate minusOne(MinusExpr e) { e.getExpr().(Literal).getValue() = \"1\" }\n\npredicate flowStep(Expr decl, Expr init) {\n  decl = init\n  or\n  exists(Field f | f.isFinal() and decl.(FieldAccess).getField() = f |\n    init = f.getAnAssignedValue()\n  )\n  or\n  decl.(CastingExpr).getExpr() = init\n}\n\npredicate excludedInit(Type t, Expr decl) {\n  exists(Expr init | flowStep(decl, init) |\n    // The `null` literal for reference types.\n    t instanceof RefType and init instanceof NullLiteral\n    or\n    // The default value for primitive types.\n    init = t.(PrimitiveType).getADefaultValue()\n    or\n    // The expression `-1` for integral types.\n    t instanceof IntegralType and minusOne(init)\n  )\n}\n\nfrom VariableUpdate def, LocalScopeVariable v\nwhere\n  def.getDestVar() = v and\n  deadLocal(def) and\n  not expectedDead(def) and\n  overwritten(def) and\n  not exists(LocalVariableDeclExpr decl | def = decl |\n    excludedInit(decl.getVariable().getType(), decl.getInit())\n  )\nselect def,\n  \"This assignment to \" + v.getName() +\n    \" is useless: the value is always overwritten before it is read.\"",
        "description": "An assignment to a local variable that is not used before a further assignment is made has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/DeadStoreOfLocal.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DeadLocals\n\nfrom LocalVariableDeclExpr ve, LocalVariableDecl v\nwhere\n  v = ve.getVariable() and\n  not assigned(v) and\n  not read(v) and\n  (not exists(ve.getInit()) or exprHasNoEffect(ve.getInit())) and\n  // Remove contexts where Java forces a variable declaration: enhanced-for, catch clauses and pattern cases.\n  // Rules about catch clauses belong in an exception handling query\n  not ve.hasImplicitInit()\nselect v, \"Variable \" + v.getName() + \" is not used.\"",
        "description": "A local variable that is not initialized, assigned, or read may indicate incomplete code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/UnusedLocal.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Reflection\n\npragma[nomagic]\ncached\nprivate RefType getASuperTypePlus(RefType t) { hasDescendant(result, t) and result != t }\n\npredicate dead(RefType dead) {\n  dead.fromSource() and\n  // Nothing depends on this type.\n  not exists(RefType s | s.getMetrics().getADependency() = dead) and\n  // Exclude Struts or JSP classes (marked with Javadoc tags).\n  not exists(JavadocTag tag, string x |\n    tag = dead.getDoc().getJavadoc().getATag(x) and\n    (x.matches(\"@struts%\") or x.matches(\"@jsp%\"))\n  ) and\n  // Exclude public types.\n  not dead.isPublic() and\n  // Exclude results that have a `main` method.\n  not dead.getAMethod().hasName(\"main\") and\n  // Exclude results that are referenced in XML files.\n  not exists(XmlAttribute xla | xla.getValue() = dead.getQualifiedName()) and\n  // Exclude type variables.\n  not dead instanceof BoundedType and\n  // Exclude JUnit tests.\n  not dead.getAnAncestor().hasName(\"TestCase\") and\n  // Exclude enum types.\n  not dead instanceof EnumType and\n  // Exclude anonymous classes\n  not dead instanceof AnonymousClass and\n  // Exclude classes that look like they may be reflectively constructed.\n  not dead.getAnAnnotation() instanceof ReflectiveAccessAnnotation and\n  not dead.getAMethod().getAnAnnotation() instanceof ReflectiveAccessAnnotation and\n  // Insist all source ancestors are dead as well.\n  forall(RefType t | t.fromSource() and t = getASuperTypePlus(dead) | dead(t)) and\n  // Exclude compiler generated classes (e.g. declaring type of adapter functions in Kotlin)\n  not dead.isCompilerGenerated()\n}\n\nfrom RefType t, string kind\nwhere\n  dead(t) and\n  (\n    t instanceof Class and kind = \"class\"\n    or\n    t instanceof Interface and kind = \"interface\"\n  )\nselect t,\n  \"Unused \" + kind + \": \" + t.getName() + \" is not referenced within this codebase. \" +\n    \"If not used as an external API it should be removed.\"",
        "description": "A non-public class or interface that is not used anywhere in the program wastes programmer resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/DeadRefTypes.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.SSA\n\nclass ZipOutputStream extends Class {\n  ZipOutputStream() {\n    exists(Class zip | zip.hasQualifiedName(\"java.util.zip\", \"ZipOutputStream\") |\n      this.hasSupertype*(zip)\n    )\n  }\n\n  Method putNextEntry() {\n    (\n      result.getDeclaringType() = this or\n      this.inherits(result)\n    ) and\n    result.getName() = \"putNextEntry\" and\n    result.getNumberOfParameters() = 1 and\n    result.getAParamType().(Class).hasQualifiedName(\"java.util.zip\", \"ZipEntry\")\n  }\n\n  Method closeEntry() {\n    (\n      result.getDeclaringType() = this or\n      this.inherits(result)\n    ) and\n    result.getName() = \"closeEntry\" and\n    result.getNumberOfParameters() = 0\n  }\n}\n\nfrom\n  ZipOutputStream jos, MethodCall putNextEntry, MethodCall closeEntry, VarRead putNextQualifier,\n  VarRead closeQualifier\nwhere\n  putNextEntry.getMethod() = jos.putNextEntry() and\n  closeEntry.getMethod() = jos.closeEntry() and\n  putNextQualifier = putNextEntry.getQualifier() and\n  closeQualifier = closeEntry.getQualifier() and\n  adjacentUseUseSameVar(putNextQualifier, closeQualifier) and\n  not exists(VarRead other |\n    adjacentUseUseSameVar(other, closeQualifier) and\n    other != putNextQualifier\n  )\nselect closeEntry, \"Empty ZIP file entry created.\"",
        "description": "Omitting a call to 'ZipOutputStream.write' when writing a ZIP file to an output stream means that an empty ZIP file entry is written.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Dead Code/CreatesEmptyZip.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass BoolCompare extends EqualityTest {\n  BoolCompare() { this.getAnOperand() instanceof BooleanLiteral }\n\n  predicate simplify(string pattern, string rewrite) {\n    exists(boolean b | b = this.getAnOperand().(BooleanLiteral).getBooleanValue() |\n      this instanceof ValueOrReferenceEqualsExpr and\n      b = true and\n      pattern = \"A == true\" and\n      rewrite = \"A\"\n      or\n      this instanceof ValueOrReferenceNotEqualsExpr and\n      b = false and\n      pattern = \"A != false\" and\n      rewrite = \"A\"\n      or\n      this instanceof ValueOrReferenceEqualsExpr and\n      b = false and\n      pattern = \"A == false\" and\n      rewrite = \"!A\"\n      or\n      this instanceof ValueOrReferenceNotEqualsExpr and\n      b = true and\n      pattern = \"A != true\" and\n      rewrite = \"!A\"\n    )\n  }\n}\n\npredicate conditionalWithBool(ConditionalExpr c, string pattern, string rewrite) {\n  exists(boolean truebranch |\n    c.getTrueExpr().(BooleanLiteral).getBooleanValue() = truebranch and\n    not c.getFalseExpr() instanceof BooleanLiteral and\n    not c.getFalseExpr().getType() instanceof NullType and\n    (\n      truebranch = true and pattern = \"A ? true : B\" and rewrite = \"A || B\"\n      or\n      truebranch = false and pattern = \"A ? false : B\" and rewrite = \"!A && B\"\n    )\n  )\n  or\n  exists(boolean falsebranch |\n    not c.getTrueExpr() instanceof BooleanLiteral and\n    not c.getTrueExpr().getType() instanceof NullType and\n    c.getFalseExpr().(BooleanLiteral).getBooleanValue() = falsebranch and\n    (\n      falsebranch = true and pattern = \"A ? B : true\" and rewrite = \"!A || B\"\n      or\n      falsebranch = false and pattern = \"A ? B : false\" and rewrite = \"A && B\"\n    )\n  )\n  or\n  exists(boolean truebranch, boolean falsebranch |\n    c.getTrueExpr().(BooleanLiteral).getBooleanValue() = truebranch and\n    c.getFalseExpr().(BooleanLiteral).getBooleanValue() = falsebranch and\n    (\n      truebranch = true and falsebranch = false and pattern = \"A ? true : false\" and rewrite = \"A\"\n      or\n      truebranch = false and falsebranch = true and pattern = \"A ? false : true\" and rewrite = \"!A\"\n    )\n  )\n}\n\nclass ComparisonOrEquality extends BinaryExpr {\n  ComparisonOrEquality() { this instanceof ComparisonExpr or this instanceof EqualityTest }\n\n  predicate negate(string pattern, string rewrite) {\n    this instanceof EQExpr and pattern = \"!(A == B)\" and rewrite = \"A != B\"\n    or\n    this instanceof NEExpr and pattern = \"!(A != B)\" and rewrite = \"A == B\"\n    or\n    this instanceof LTExpr and pattern = \"!(A < B)\" and rewrite = \"A >= B\"\n    or\n    this instanceof GTExpr and pattern = \"!(A > B)\" and rewrite = \"A <= B\"\n    or\n    this instanceof LEExpr and pattern = \"!(A <= B)\" and rewrite = \"A > B\"\n    or\n    this instanceof GEExpr and pattern = \"!(A >= B)\" and rewrite = \"A < B\"\n  }\n}\n\nfrom Expr e, string pattern, string rewrite\nwhere\n  e.getFile().isJavaSourceFile() and\n  (\n    e.(BoolCompare).simplify(pattern, rewrite)\n    or\n    conditionalWithBool(e, pattern, rewrite)\n    or\n    e.(LogNotExpr).getExpr().(ComparisonOrEquality).negate(pattern, rewrite)\n    or\n    e.(LogNotExpr).getExpr() instanceof LogNotExpr and\n    pattern = \"!!A\" and\n    rewrite = \"A\"\n  )\nselect e, \"Expressions of the form \\\"\" + pattern + \"\\\" can be simplified to \\\"\" + rewrite + \"\\\".\"",
        "description": "Boolean expressions that are unnecessarily complicated hinder readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Boolean Logic/SimplifyBoolExpr.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport MagicConstants\n\npredicate isSystemProperty(string e) {\n  e =\n    [\n      \"java.version\", \"java.vendor\", \"java.specification.version\", \"java.specification.vendor\",\n      \"java.specification.name\", \"java.class.version\", \"java.class.path\", \"java.library.path\",\n      \"java.io.tmpdir\", \"java.compiler\", \"java.ext.dirs\", \"os.name\", \"java.vendor.url\", \"os.arch\",\n      \"os.version\", \"file.separator\", \"path.separator\", \"line.separator\", \"user.name\", \"user.home\",\n      \"user.dir\", \"java.home\", \"java.vm.specification.version\", \"java.vm.specification.vendor\",\n      \"java.vm.specification.name\", \"java.vm.version\", \"java.vm.vendor\", \"java.vm.name\"\n    ]\n}\n\npredicate trivialContext(Literal e) {\n  // String concatenation.\n  e.getParent() instanceof AddExpr\n  or\n  e.getParent() instanceof AssignAddExpr\n  or\n  exists(MethodCall ma |\n    ma.getMethod().getName() = \"append\" and\n    (e = ma.getAnArgument() or e = ma.getQualifier())\n  )\n  or\n  // Standard property in a call to `System.getProperty()`.\n  exists(MethodCall ma |\n    ma.getMethod().getName() = \"getProperty\" and\n    e = ma.getAnArgument() and\n    ma.getMethod().getDeclaringType() instanceof TypeSystem and\n    isSystemProperty(e.getValue())\n  )\n  or\n  // Message in an exception.\n  exists(ClassInstanceExpr constr |\n    constr.getType().(RefType).getAStrictAncestor().hasName(\"Exception\") and\n    e = constr.getArgument(0)\n  )\n}\n\nfrom StringLiteral e, string msg\nwhere\n  magicConstant(e, msg) and\n  not trivialContext(e)\nselect e, msg",
        "description": "A magic string makes code less readable and maintainable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Magic Constants/MagicConstantsString.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport MagicConstants\n\nfrom Literal magicLiteral, string message, Field field, string linkText\nwhere\n  isNumber(magicLiteral) and\n  literalInsteadOfConstant(magicLiteral, message, field, linkText)\nselect magicLiteral, message, field, linkText",
        "description": "A magic number, which is used instead of an existing named constant, makes code less readable and maintainable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Magic Constants/MagicNumbersUseConstant.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport MagicConstants\n\nfrom Literal e, string msg\nwhere\n  magicConstant(e, msg) and\n  isNumber(e)\nselect e, msg",
        "description": "A magic number makes code less readable and maintainable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Magic Constants/MagicConstantsNumbers.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport MagicConstants\n\nfrom StringLiteral magicLiteral, string message, Field field, string linkText\nwhere literalInsteadOfConstant(magicLiteral, message, field, linkText)\nselect magicLiteral, message, field, linkText",
        "description": "A magic string, which is used instead of an existing named constant, makes code less readable and maintainable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Violations of Best Practice/Magic Constants/MagicStringsUseConstant.ql",
        "language": "java"
    },
    {
        "query": "import UnusedMavenDependencies\n\npredicate whitelist(Dependency d) {\n  // jsr305 contains package annotations. If a project uses those exclusively, we will\n  // consider it \"unused\".\n  d.getShortCoordinate() = \"com.google.code.findbugs:jsr305\"\n}\n\nfrom PomDependency d, Pom source\nwhere\n  source.getADependency() = d and\n  // There is not a Pom file for the target of this dependency, so we assume that it was resolved by\n  // a binary file in the local maven repository.\n  not exists(d.getPom()) and\n  // In order to accurately identify whether this binary dependency is required, we must have identified\n  // a Maven repository. If we have not found a repository, it's likely that it has a custom path of\n  // which we are unaware, so do not report any problems.\n  exists(MavenRepo mr) and\n  // We either haven't indexed a relevant jar file, which suggests that nothing statically depended upon\n  // it, or we have indexed the relevant jar file, but no source code in the project defined by the pom\n  // depends on any code within the detected jar.\n  not pomDependsOnContainer(source, d.getJar()) and\n  // If something that depends on us depends on the jar represented by this dependency, and it doesn't\n  // depend directly on the jar itself, we don't consider it to be \"unused\".\n  not exists(Pom pomThatDependsOnSource | pomThatDependsOnSource.getAnExportedPom+() = source |\n    pomDependsOnContainer(pomThatDependsOnSource, d.getJar()) and\n    not exists(File f | f = pomThatDependsOnSource.getADependency().getJar() and f = d.getJar())\n  ) and\n  // Filter out those dependencies on the whitelist\n  not whitelist(d)\nselect d, \"Maven dependency on the binary package \" + d.getShortCoordinate() + \" is unused.\"",
        "description": "Unnecessary Maven dependencies are a maintenance burden.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Architecture/Dependencies/UnusedMavenDependencyBinary.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t1, RefType t2\nwhere\n  depends(t1, t2) and\n  depends(t2, t1) and\n  // Prevent symmetrical results.\n  t1.getName() < t2.getName() and\n  t1.fromSource() and\n  t2.fromSource() and\n  // Exclusions.\n  not (\n    t1 instanceof AnonymousClass or\n    t1 instanceof BoundedType or\n    t2 instanceof AnonymousClass or\n    t2 instanceof BoundedType or\n    t1.getName().toLowerCase().matches(\"%visitor%\") or\n    t2.getName().toLowerCase().matches(\"%visitor%\") or\n    t1.getAMethod().getName().toLowerCase().matches(\"%visit%\") or\n    t2.getAMethod().getName().toLowerCase().matches(\"%visit%\") or\n    t1.getPackage() = t2.getPackage() or\n    t1.getFile().isKotlinSourceFile() or\n    t2.getFile().isKotlinSourceFile()\n  )\nselect t1, \"This type and type $@ are mutually dependent.\", t2, t2.getName()",
        "description": "Mutual dependency between types makes code difficult to understand and test.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Architecture/Dependencies/MutualDependency.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.xml.MavenPom\nimport UnusedMavenDependencies\n\nfrom PomDependency d, Pom source, Pom target\nwhere\n  source.getADependency() = d and\n  // We have a targetPom file, so this is a \"source\" dependency, rather than a binary dependency\n  // from the Maven repository. Note, although .pom files exist in the local maven repository, they\n  // are usually not indexed because they are outside the source directory. We assume that they have\n  // not been indexed.\n  target = d.getPom() and\n  // If we have a pom for the target of this dependency, then it is unused iff neither it, nor any\n  // of its transitive dependencies are required.\n  not exists(Pom exported | exported = target.getAnExportedPom*() |\n    pomDependsOnContainer(source, exported.getAnExportedDependency().getJar()) or\n    pomDependsOnPom(source, exported)\n  )\nselect d, \"Maven dependency onto \" + d.getShortCoordinate() + \" is unused.\"",
        "description": "Unnecessary Maven dependencies are a maintenance burden.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Architecture/Dependencies/UnusedMavenDependencySource.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nMember getAUsedMember(Method m) {\n  result.(Field).getAnAccess().getEnclosingCallable() = m or\n  result.(Callable).getAReference().getEnclosingCallable() = m\n}\n\nint dependencyCount(Method source, RefType target) {\n  result = strictcount(Member m | m = getAUsedMember(source) and m = target.getAMember())\n}\n\npredicate methodDependsOn(Method m, RefType target) { exists(dependencyCount(m, target)) }\n\npredicate dependsOn(RefType source, RefType target) {\n  methodDependsOn(source.getACallable(), target)\n}\n\nint selfDependencyCount(Method source) {\n  result = sum(dependencyCount(source, source.getDeclaringType().getEnclosingType*()))\n}\n\npredicate dependsHighlyOn(Method source, RefType target, int selfCount, int depCount) {\n  depCount = dependencyCount(source, target) and\n  selfCount = selfDependencyCount(source) and\n  depCount > 2 * selfCount and\n  depCount > 4\n}\n\npredicate query(Method m, RefType targetType, int selfCount, int depCount) {\n  exists(RefType sourceType | sourceType = m.getDeclaringType() |\n    dependsHighlyOn(m, targetType, selfCount, depCount) and\n    // Interfaces are depended upon by their very nature\n    not targetType instanceof Interface and\n    // Anonymous classes are often used as callbacks, which heavily depend on other classes\n    not sourceType instanceof AnonymousClass and\n    // Do not move initializer methods\n    not m instanceof InitializerMethod and\n    // Do not move up/down the class hierarchy\n    not (\n      sourceType.getAnAncestor().getSourceDeclaration() = targetType or\n      targetType.getAnAncestor().getSourceDeclaration() = sourceType\n    ) and\n    // Do not move between nested types\n    not (sourceType.getEnclosingType*() = targetType or targetType.getEnclosingType*() = sourceType) and\n    // Tests are allowed to be invasive and depend on the tested classes highly\n    not sourceType instanceof TestClass and\n    // Check that the target type already depends on every type used by the method\n    forall(RefType dependency | methodDependsOn(m, dependency) | dependsOn(targetType, dependency))\n  )\n}\n\nfrom Method m, RefType other, int selfCount, int depCount\nwhere\n  query(m, other, selfCount, depCount) and\n  // Don't include types that are used from many different places - we only highlight\n  // relatively local fixes that could reasonably be implemented.\n  count(Method yetAnotherMethod | query(yetAnotherMethod, other, _, _)) < 10\nselect m,\n  \"Method \" + m.getName() + \" is too closely tied to $@: \" + depCount +\n    \" dependencies to it, but only \" + selfCount + \" dependencies to its own type.\", other,\n  other.getName()",
        "description": "A method that uses more methods or variables from another (unrelated) class than from its own class violates the principle of putting data and behavior in the same place.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Architecture/Refactoring Opportunities/FeatureEnvy.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom NestedClass c\nwhere\n  c.getNestingDepth() > 1 and\n  exists(Method m | m.getDeclaringType() = c | not m instanceof StaticInitializer) and\n  not c instanceof AnonymousClass and\n  not c instanceof EnumType\nselect c, \"This class is deeply nested, which can hinder readability.\"",
        "description": "Deeply-nested classes are difficult to understand, since they have access to many scopes",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Architecture/Refactoring Opportunities/DeeplyNestedClass.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t, int aff, int eff\nwhere\n  t.fromSource() and\n  aff = t.getMetrics().getAfferentCoupling() and\n  eff = t.getMetrics().getEfferentSourceCoupling() and\n  aff > 15 and\n  eff > 15\nselect t as class_,\n  \"Hub class: this class depends on \" + eff.toString() + \" classes and is used by \" + aff.toString()\n    + \" classes.\"",
        "description": "Hub classes, which are classes that use, and are used by, many other classes, are complex and difficult to change without affecting the rest of the system.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Architecture/Refactoring Opportunities/HubClasses.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate enclosingRefType(Variable v, RefType type) {\n  v.(Field).getDeclaringType() = type or\n  v.(LocalVariableDecl).getCallable().getDeclaringType() = type or\n  v.(Parameter).getCallable().getDeclaringType() = type\n}\n\npredicate remoteVarAccess(RefType source, RefType target, VarAccess va) {\n  va.getEnclosingCallable().getDeclaringType() = source and\n  enclosingRefType(va.getVariable(), target) and\n  source != target\n}\n\npredicate remoteFunAccess(RefType source, RefType target, MethodCall fc) {\n  fc.getEnclosingCallable().getDeclaringType() = source and\n  fc.getMethod().getDeclaringType() = target and\n  source != target\n}\n\npredicate candidateTypePair(RefType source, RefType target) {\n  remoteVarAccess(source, target, _) or remoteFunAccess(source, target, _)\n}\n\npredicate variableDependencyCount(RefType source, RefType target, int res) {\n  candidateTypePair(source, target) and\n  res = count(VarAccess va | remoteVarAccess(source, target, va))\n}\n\npredicate functionDependencyCount(RefType source, RefType target, int res) {\n  candidateTypePair(source, target) and\n  res = count(MethodCall fc | remoteFunAccess(source, target, fc))\n}\n\npredicate dependencyCount(RefType source, RefType target, int res) {\n  exists(int varCount, int funCount |\n    variableDependencyCount(source, target, varCount) and\n    functionDependencyCount(source, target, funCount) and\n    res = varCount + funCount and\n    res > 20\n  )\n}\n\nfrom RefType a, RefType b, int ca, int cb\nwhere\n  dependencyCount(a, b, ca) and\n  dependencyCount(b, a, cb) and\n  ca > 20 and\n  cb > 20 and\n  ca >= cb and\n  not exists(CompilationUnit cu | cu = a.getCompilationUnit() and cu = b.getCompilationUnit())\nselect a,\n  \"Type \" + a.getName() + \" is too closely tied to $@ (\" + ca.toString() +\n    \" dependencies one way and \" + cb.toString() + \" the other).\", b, b.getName()",
        "description": "Two otherwise unrelated classes that share too much information about each other are difficult to maintain, change and understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Architecture/Refactoring Opportunities/InappropriateIntimacy.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.deadcode.DeadCode\n\nfrom UnusedEnumConstant e\nwhere not e.whitelisted()\nselect e, e.getName() + \" is unused -- its value is never obtained.\"",
        "description": "Dead enum constants add unnecessary complexity.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/DeadCode/DeadEnumConstant.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.deadcode.DeadCode\n\nfrom DeadField f, Element origin, string reason\nwhere\n  not f.getFile().isKotlinSourceFile() and\n  not origin.getFile().isKotlinSourceFile() and\n  not f.isInDeadScope() and\n  if f.getAnAccess() instanceof FieldRead\n  then (\n    if exists(getADeadRoot(f.getAnAccess().(FieldRead).getEnclosingCallable()))\n    then (\n      origin = getADeadRoot(f.getAnAccess().(FieldRead).getEnclosingCallable()) and\n      reason = \" is only read from dead code originating at $@.\"\n    ) else (\n      origin = f and\n      reason = \" is only read from a dead-code cycle.\"\n    )\n  ) else (\n    origin = f and\n    reason = \" is entirely unread.\"\n  )\nselect f, \"The field \" + f.getName() + reason, origin, origin.getName()",
        "description": "Fields that are never read are likely unnecessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/DeadCode/DeadField.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.deadcode.DeadCode\n\nfrom DeadMethod c, Callable origin, string reason\nwhere\n  not c.getFile().isKotlinSourceFile() and\n  not origin.getFile().isKotlinSourceFile() and\n  not c.isInDeadScope() and\n  if exists(DeadRoot deadRoot | deadRoot = getADeadRoot(c) | deadRoot.getSourceDeclaration() != c)\n  then (\n    // We've found a dead root that is not this callable (or an instantiation thereof).\n    origin = getADeadRoot(c).getSourceDeclaration() and\n    reason = \" is only used from dead code originating at $@.\"\n  ) else (\n    origin = c and\n    if\n      exists(Callable cause | cause = possibleLivenessCause(c) and not cause instanceof DeadRoot |\n        cause.getSourceDeclaration() = c\n        implies\n        possibleLivenessCause(cause).getSourceDeclaration() != c\n      )\n    then\n      // There are no dead roots that are not this callable (or an instantiation thereof), and at least one\n      // liveness cause (ignoring trivial cycles between a parameterized callable and its source declaration).\n      reason = \" is only used from, or in, a dead-code cycle.\"\n    else reason = \" is entirely unused.\"\n  )\nselect c, \"The method \" + c.getName() + reason, origin, origin.getName()",
        "description": "Dead methods add unnecessary complexity.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/DeadCode/DeadMethod.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.deadcode.DeadCode\n\nfrom File f, int n\nwhere\n  n =\n    // Lines of code contributed by dead classes.\n    sum(DeadClass deadClass |\n        deadClass.getFile() = f\n      |\n        deadClass.getNumberOfLinesOfCode() -\n            // Remove inner and local classes, as they are reported as separate dead classes. Do not\n            // remove anonymous classes, because they aren't reported separately.\n            sum(NestedClass innerClass |\n              innerClass.getEnclosingType() = deadClass and not innerClass.isAnonymous()\n            |\n              innerClass.getNumberOfLinesOfCode()\n            )\n      ) +\n      // Lines of code contributed by dead methods, not in dead classes.\n      sum(DeadMethod deadMethod |\n        deadMethod.getFile() = f and not deadMethod.isInDeadScope()\n      |\n        deadMethod.getNumberOfLinesOfCode() -\n            // Remove local classes defined in the dead method - they are reported separately as a dead\n            // class. We keep anonymous class counts, because anonymous classes are not reported\n            // separately.\n            sum(LocalClassOrInterface localClass |\n              localClass.getLocalTypeDeclStmt().getEnclosingCallable() = deadMethod\n            |\n              localClass.getNumberOfLinesOfCode()\n            )\n      ) +\n      // Lines of code contributed by dead fields, not in dead classes.\n      sum(DeadField deadField |\n        deadField.getFile() = f and not deadField.isInDeadScope()\n      |\n        deadField.getNumberOfLinesOfCode()\n      ) +\n      // Lines of code contributed by unused enum constants.\n      sum(UnusedEnumConstant deadEnumConstant |\n        deadEnumConstant.getFile() = f\n      |\n        deadEnumConstant.getNumberOfLinesOfCode()\n      )\nselect f, n order by n desc",
        "description": "The number of lines of dead code in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/DeadCode/FLinesOfDeadCode.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.deadcode.DeadCode\n\nfrom DeadClass c, Element origin, string reason\nwhere\n  not c.getFile().isKotlinSourceFile() and\n  not origin.getFile().isKotlinSourceFile() and\n  if exists(DeadRoot root | root = c.getADeadRoot() | not root = c.getACallable())\n  then (\n    // Report a list of the dead roots.\n    origin = c.getADeadRoot() and\n    not origin = c.getACallable() and\n    // There are uses of this class from outside the class.\n    reason = \" is only used from dead code originating at $@.\"\n  ) else (\n    // There are no dead roots outside this class.\n    origin = c and\n    if c.isUnusedOutsideClass()\n    then\n      // Never accessed outside this class, so it's entirely unused.\n      reason = \" is entirely unused.\"\n    else\n      // There are no dead roots outside the class, but the class has a possible liveness cause\n      // external to the class, so it must be accessed from at least one dead-code cycle.\n      reason = \" is only used from or in a dead-code cycle.\"\n  )\nselect c, \"The class \" + c.getName() + reason, origin, origin.getName()",
        "description": "Dead classes add unnecessary complexity.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/DeadCode/DeadClass.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.deadcode.DeadCode\n\nfrom RootdefCallable c\nwhere not c.whitelisted()\nselect c.unusedParameter() as p, \"The parameter '\" + p + \"' is never used.\"",
        "description": "Parameters that are not used add unnecessary complexity to an interface.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/DeadCode/UselessParameter.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass NonAbstractSource extends Method {\n  NonAbstractSource() {\n    this.fromSource() and\n    not this.isAbstract() and\n    not this instanceof LikelyTestMethod\n  }\n}\n\nfrom NonAbstractSource m\nwhere\n  //empty\n  not exists(m.getBody().getAChild()) and\n  //permit comment lines explaining why this is empty\n  m.getNumberOfCommentLines() = 0 and\n  //permit a javadoc above as well as sufficient reason to leave empty\n  not exists(m.getDoc().getJavadoc()) and\n  //annotated methods are considered compliant\n  not exists(m.getAnAnnotation()) and\n  //native methods have no body\n  not m.isNative()\nselect m, \"Empty method found.\"",
        "description": "An empty method serves no purpose and makes code less readable. An empty method may indicate an error on the part of the developer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/EmptyMethod.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom LabeledStmt l, SwitchStmt s, string alert\nwhere\n  l = s.getAStmt+() and\n  if exists(JumpStmt jump | jump.getTargetLabel() = l)\n  then alert = \"Confusing non-case label in switch statement.\"\n  else\n    alert =\n      \"Possibly erroneous non-case label in switch statement. The case keyword might be missing.\"\nselect l, alert",
        "description": "A non-case label appearing in a switch statement is confusing to read or may even indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/LabelInSwitch.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method superMethod, Method method\nwhere\n  overridesIgnoringAccess(method, _, superMethod, _) and\n  not method.overrides(superMethod) and\n  not superMethod.isPublic() and\n  not superMethod.isProtected() and\n  not superMethod.isPrivate()\nselect method, \"This method does not override $@ because it is private to another package.\",\n  superMethod, superMethod.getDeclaringType().getName() + \".\" + superMethod.getName()",
        "description": "A method that appears to override another method but does not, because the declaring classes are in different packages, is potentially confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/OverridePackagePrivate.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.NullGuards\nimport semmle.code.java.controlflow.Guards\n\nfrom Expr guard, Expr e, Expr reason, string msg\nwhere\n  guardSuggestsExprMaybeNull(guard, e) and\n  e = clearlyNotNullExpr(reason) and\n  (\n    if reason = directNullGuard(_, _, _)\n    then msg = \"This check is useless. $@ cannot be null at this check, since it is guarded by $@.\"\n    else\n      if reason != e\n      then\n        msg = \"This check is useless. $@ cannot be null at this check, since $@ always is non-null.\"\n      else msg = \"This check is useless, since $@ always is non-null.\"\n  )\nselect guard, msg, e, e.toString(), reason, reason.toString()",
        "description": "Checking whether an expression is null when that expression cannot possibly be null is useless.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/UselessNullCheck.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom InstanceOfExpr ioe, RefType t, RefType ct\nwhere\n  ioe.getExpr() instanceof ThisAccess and\n  t = ioe.getExpr().getType() and\n  ct = ioe.getSyntacticCheckedType() and\n  ct.getAnAncestor() = t\nselect ioe,\n  \"Testing whether 'this' is an instance of $@ in $@ introduces a dependency cycle between the two types.\",\n  ct, ct.getName(), t, t.getName()",
        "description": "Testing whether 'this' is an instance of a derived type introduces a dependency cycle between the type of 'this' and the target type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/DubiousTypeTestOfThis.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Expr e, RefType src, RefType dest\nwhere\n  exists(CastExpr cse | cse = e |\n    exists(cse.getLocation()) and\n    cse.getExpr() instanceof ThisAccess and\n    src = cse.getExpr().getType() and\n    dest = cse.getType()\n  ) and\n  src.hasSubtype*(dest) and\n  src != dest and\n  not dest instanceof TypeVariable\nselect e, \"Downcasting 'this' from $@ to $@ introduces a dependency cycle between the two types.\",\n  src, src.getName(), dest, dest.getName()",
        "description": "Casting 'this' to a derived type introduces a dependency cycle between the type of 'this' and the target type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/DubiousDowncastOfThis.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate usefulUpcast(CastingExpr e) {\n  // Upcasts that may be performed to affect resolution of methods or constructors.\n  exists(Call c, int i, Callable target |\n    c.getArgument(i) = e and\n    target = c.getCallee() and\n    // An upcast to the type of the corresponding parameter.\n    e.getType() = target.getParameterType(i)\n  |\n    // There is an overloaded method/constructor in the class that we might be trying to avoid.\n    exists(Callable other |\n      other.getName() = target.getName() and\n      other.getSourceDeclaration() != target.getSourceDeclaration()\n    |\n      c.(MethodCall).getReceiverType().inherits(other.(Method)) or\n      other = target.(Constructor).getDeclaringType().getAConstructor()\n    )\n  )\n  or\n  // Upcasts of a varargs argument.\n  exists(Call c, int iArg, int iParam | c.getArgument(iArg) = e |\n    c.getCallee().getParameter(iParam).isVarargs() and iArg >= iParam\n  )\n  or\n  // Upcasts that are performed on an operand of a ternary expression.\n  e = any(ConditionalExpr ce).getABranchExpr()\n  or\n  // Upcasts to raw types.\n  e.getType() instanceof RawType\n  or\n  e.getType().(Array).getElementType() instanceof RawType\n  or\n  // Upcasts that are performed to affect field, private method, or static method resolution.\n  exists(FieldAccess fa | e = fa.getQualifier() |\n    not e.getExpr().getType().(RefType).inherits(fa.getField())\n  )\n  or\n  exists(MethodCall ma, Method m |\n    e = ma.getQualifier() and\n    m = ma.getMethod() and\n    (m.isStatic() or m.isPrivate())\n  |\n    not e.getExpr().getType().(RefType).inherits(m)\n  )\n}\n\nfrom Expr e, RefType src, RefType dest\nwhere\n  exists(CastingExpr cse | cse = e |\n    (cse instanceof CastExpr or cse instanceof SafeCastExpr) and\n    exists(cse.getLocation()) and\n    src = cse.getExpr().getType() and\n    dest = cse.getType()\n  ) and\n  dest = src.getAStrictAncestor() and\n  not usefulUpcast(e)\nselect e, \"There is no need to upcast from $@ to $@ - the conversion can be done implicitly.\", src,\n  src.getName(), dest, dest.getName()",
        "description": "Upcasting a derived type to its base type is usually unnecessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/UselessUpcast.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom InstanceOfExpr ioe, RefType t, RefType ct\nwhere\n  t = ioe.getExpr().getType() and\n  ct = ioe.getCheckedType() and\n  ct = t.getAStrictAncestor()\nselect ioe,\n  \"There is no need to test whether an instance of $@ is also an instance of $@ - it always is.\", t,\n  t.getName(), ct, ct.getName()",
        "description": "Testing whether a derived type is an instance of its base type is unnecessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/UselessTypeTest.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom TypeVariable v, RefType bound\nwhere\n  v.getATypeBound().getType() = bound and\n  bound.isFinal()\nselect v,\n  \"Type '\" + bound + \"' is final, so <\" + v.getName() + \" extends \" + bound + \"> is confusing.\"",
        "description": "If 'C' is a final class, a type bound such as '? extends C' is confusing because it implies that 'C' has subclasses, but a final class has no subclasses.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/TypeVarExtendsFinalType.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nint instanceofCountForIfChain(IfStmt is) {\n  exists(int rest |\n    (\n      if is.getElse() instanceof IfStmt\n      then rest = instanceofCountForIfChain(is.getElse())\n      else rest = 0\n    ) and\n    (if is.getCondition() instanceof InstanceOfExpr then result = 1 + rest else result = rest)\n  )\n}\n\nfrom IfStmt is, int n\nwhere\n  n = instanceofCountForIfChain(is) and\n  n > 5 and\n  not exists(IfStmt other | is = other.getElse())\nselect is,\n  \"This if block performs a chain of \" + n +\n    \" type tests - consider alternatives, e.g. polymorphism or the visitor pattern.\"",
        "description": "Long sequences of type tests on a variable are difficult to maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/ChainedInstanceof.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nRefType anOuterType(TypeVariable var) {\n  var.getGenericCallable().getDeclaringType() = result or\n  var.getGenericType() = result or\n  result = anOuterType(var).(NestedType).getEnclosingType()\n}\n\npragma[inline]\nRefType aTypeVisibleFrom(TypeVariable var) {\n  result = anOuterType(var)\n  or\n  exists(ImportType i |\n    var.getLocation().getFile() = i.getCompilationUnit() and\n    result = i.getImportedType()\n  )\n  or\n  var.getPackage() = result.getPackage() and result instanceof TopLevelType\n}\n\nfrom RefType hidden, TypeVariable var\nwhere\n  hidden = aTypeVisibleFrom(var) and\n  var.getName() = hidden.getName()\nselect var, \"Type $@ is hidden by this type variable.\", hidden, hidden.getQualifiedName()",
        "description": "A type variable with the same name as another type that is in scope can cause the two types to be confused.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/TypeVariableHidesType.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport IterableClass\n\npredicate iteratorWrapper(Iterable it, Field f, boolean wrap) {\n  // A class that implements `java.lang.Iterable` and\n  // declares a final or effectively final field ...\n  f.getDeclaringType().getSourceDeclaration() = it and\n  (\n    f.isFinal()\n    or\n    strictcount(f.getAnAssignedValue()) = 1 and\n    f.getAnAssignedValue().getEnclosingCallable() instanceof InitializerMethod\n  ) and\n  // ... whose type is a sub-type of `java.util.Iterator` and ...\n  f.getType()\n      .(RefType)\n      .getAnAncestor()\n      .getSourceDeclaration()\n      .hasQualifiedName(\"java.util\", \"Iterator\") and\n  // ... whose value is returned by the `iterator()` method of this class ...\n  exists(Expr iterator | iterator = it.simpleIterator() |\n    // ... either directly ...\n    iterator = f.getAnAccess() and wrap = false\n    or\n    // ... or wrapped in another Iterator.\n    exists(ClassInstanceExpr cie | cie = iterator and wrap = true |\n      cie.getAnArgument() = f.getAnAccess() or\n      cie.getAnonymousClass().getAMethod() = f.getAnAccess().getEnclosingCallable()\n    )\n  )\n}\n\nfrom Iterable i, Field f, boolean wrap, string appearto, string iteratorbasedon\nwhere\n  iteratorWrapper(i, f, wrap) and\n  (\n    wrap = true and appearto = \"appear to \" and iteratorbasedon = \"an iterator based on \"\n    or\n    wrap = false and appearto = \"\" and iteratorbasedon = \"\"\n  )\nselect i,\n  \"This class implements Iterable, but does not \" + appearto + \"support multiple iterations,\" +\n    \" since its iterator method always returns \" + iteratorbasedon + \"the same $@.\", f, \"iterator\"",
        "description": "An 'Iterable' that reuses an 'Iterator' instance does not support multiple traversals and can lead to unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/WrappedIterator.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport IterableClass\n\nclass IterableIterator extends Iterable {\n  IterableIterator() { this.simpleIterator() instanceof ThisAccess }\n}\n\nclass EmptyIterableIterator extends IterableIterator {\n  EmptyIterableIterator() {\n    exists(Method m |\n      m.getDeclaringType().getSourceDeclaration() = this and\n      m.getName() = \"hasNext\" and\n      m.getBody()\n          .(SingletonBlock)\n          .getStmt()\n          .(ReturnStmt)\n          .getResult()\n          .(BooleanLiteral)\n          .getBooleanValue() = false\n    )\n  }\n}\n\nfrom IterableIterator i\nwhere\n  // Exclude the empty iterator as that is safe to reuse.\n  not i instanceof EmptyIterableIterator\nselect i, \"This Iterable is its own Iterator, but does not guard against multiple iterations.\"",
        "description": "An 'Iterator' that also implements 'Iterable' by returning itself as its 'Iterator' does not support multiple traversals. This can lead to unexpected behavior when it is viewed as an 'Iterable'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/IterableIterator.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate complicatedBranch(Stmt branch) {\n  any(ConditionalExpr ce).getParent*() = branch or\n  count(MethodCall a | a.getParent*() = branch) > 1\n}\n\npredicate complicatedCondition(Expr cond) {\n  exists(Expr e | e = cond.getAChildExpr*() |\n    e instanceof AndLogicalExpr or\n    e instanceof OrLogicalExpr\n  )\n}\n\npredicate toCompare(Expr left, Expr right) {\n  exists(IfStmt is, AssignExpr at, AssignExpr ae |\n    at.getParent() = is.getThen() and\n    ae.getParent() = is.getElse()\n  |\n    left = at.getDest() and right = ae.getDest()\n    or\n    left = at.getDest().(VarAccess).getQualifier() and\n    right = ae.getDest().(VarAccess).getQualifier()\n  )\n}\n\npredicate sameVariable(VarAccess left, VarAccess right) {\n  toCompare(left, right) and\n  left.getVariable() = right.getVariable() and\n  (\n    exists(Expr q1, Expr q2 |\n      left.getQualifier() = q1 and\n      sameVariable(q1, q2) and\n      right.getQualifier() = q2\n    )\n    or\n    left.isLocal() and right.isLocal()\n  )\n}\n\nfrom IfStmt is, string what\nwhere\n  (\n    is.getThen() instanceof ReturnStmt and\n    is.getElse() instanceof ReturnStmt and\n    what = \"return\"\n    or\n    exists(AssignExpr at, AssignExpr ae |\n      at.getParent() = is.getThen() and\n      ae.getParent() = is.getElse() and\n      sameVariable(at.getDest(), ae.getDest()) and\n      what = \"write to the same variable\"\n    )\n  ) and\n  // Exclusions.\n  not (\n    exists(IfStmt other | is = other.getElse()) or\n    complicatedCondition(is.getCondition()) or\n    complicatedBranch(is.getThen()) or\n    complicatedBranch(is.getElse())\n  )\nselect is,\n  \"Both branches of this 'if' statement \" + what + \" - consider using '?' to express intent better.\"",
        "description": "An 'if' statement where both branches either (a) return or (b) write to the same variable can often be expressed more clearly using the '?' operator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/MissedTernaryOpportunity.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType type, AnnotationType annotation\nwhere type.getASupertype() = annotation\nselect type,\n  \"Should this class be annotated by '\" + annotation.getName() + \"', not have it as a super-type?\"",
        "description": "Extending or implementing an annotation is unlikely to be what the programmer intends.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/ImplementsAnnotation.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nElement elementNamedEnum() {\n  result.(CompilationUnit).getPackage().getName().regexpMatch(\"(.*\\\\.|)enum(\\\\..*|)\") or\n  result.getName() = \"enum\"\n}\n\nselect elementNamedEnum(),\n  \"Code using 'enum' as an identifier will not compile with a recent version of Java.\"",
        "description": "Using 'enum' as an identifier makes the code incompatible with Java 5 and later.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/EnumIdentifier.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Expr e, GenericType src, TypeVariable dest\nwhere\n  exists(CastExpr cse |\n    cse = e and\n    exists(cse.getLocation()) and\n    cse.getExpr() instanceof ThisAccess and\n    src = cse.getExpr().getType() and\n    dest = cse.getType()\n  ) and\n  dest.getGenericType() = src\nselect e,\n  \"Casting 'this' to $@, a type parameter of $@, masks an implicit type constraint that should be explicitly stated.\",\n  dest, dest.getName(), src, src.getName()",
        "description": "Casting 'this' to a type parameter of the current type masks an implicit type constraint that should be explicitly stated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Language Abuse/CastThisToTypeParameter.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DiagnosticsReporting\n\nfrom string msg, int sev\nwhere reportableErrors(_, msg, sev)\nselect msg, sev",
        "description": "A list of extraction errors for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Diagnostics/ExtractionErrors.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DiagnosticsReporting\n\nfrom CompilationUnit f\nwhere extracted(f)\nselect f, \"\"",
        "description": "A list of all files in the source code directory that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Diagnostics/SuccessfullyExtractedFiles.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DiagnosticsReporting\n\nfrom string msg, int sev\nwhere reportableWarnings(_, msg, sev)\nselect msg, sev",
        "description": "A list of extraction warnings for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Diagnostics/ExtractionWarnings.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.hasSummary() }\n\nfrom string apiName, int usages\nwhere Results<relevant/1>::restrict(apiName, usages)\nselect apiName, usages order by usages desc",
        "description": "A list of 3rd party APIs detected as flow steps. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/SupportedExternalTaint.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport ExternalApi\n\nprivate predicate relevant(ExternalApi api) { not api.isSupported() }\n\nfrom string apiName, int usages\nwhere Results<relevant/1>::restrict(apiName, usages)\nselect apiName, usages order by usages desc",
        "description": "A list of 3rd party APIs used in the codebase. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/UnsupportedExternalAPIs.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.isSource() }\n\nfrom string apiName, int usages\nwhere Results<relevant/1>::restrict(apiName, usages)\nselect apiName, usages order by usages desc",
        "description": "A list of 3rd party APIs detected as sources. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/SupportedExternalSources.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport ExternalApi\n\nprivate predicate getRelevantUsages(string jarname, int usages) {\n  usages =\n    strictcount(Call c, ExternalApi a |\n      c.getCallee().getSourceDeclaration() = a and\n      not c.getFile() instanceof GeneratedFile and\n      a.jarContainer() = jarname\n    )\n}\n\nprivate int getOrder(string jarname) {\n  jarname =\n    rank[result](string jar, int usages |\n      getRelevantUsages(jar, usages)\n    |\n      jar order by usages desc, jar\n    )\n}\n\nfrom ExternalApi api, string jarname, int usages\nwhere\n  jarname = api.jarContainer() and\n  getRelevantUsages(jarname, usages) and\n  getOrder(jarname) <= resultLimit()\nselect jarname, usages order by usages desc",
        "description": "A list of external libraries used in the code",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/ExternalLibraryUsage.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.isSink() }\n\nfrom string apiName, int usages\nwhere Results<relevant/1>::restrict(apiName, usages)\nselect apiName, usages order by usages desc",
        "description": "A list of 3rd party APIs detected as sinks. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/SupportedExternalSinks.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DatabaseQuality\n\nprivate predicate diagnostic(string msg, float value, float threshold) {\n  CallTargetStatsReport::percentageOfOk(msg, value) and\n  threshold = 85\n  or\n  ExprTypeStatsReport::percentageOfOk(msg, value) and\n  threshold = 85\n}\n\nprivate newtype TDbQualityDiagnostic =\n  TTheDbQualityDiagnostic() {\n    exists(float percentageGood, float threshold |\n      diagnostic(_, percentageGood, threshold) and\n      percentageGood < threshold\n    )\n  }\n\nprivate string getDbHealth() {\n  result =\n    strictconcat(string msg, float value, float threshold |\n      diagnostic(msg, value, threshold)\n    |\n      msg + \": \" + value.floor() + \" % (threshold \" + threshold.floor() + \" %)\", \". \"\n    )\n}\n\nclass DbQualityDiagnostic extends TDbQualityDiagnostic {\n  string toString() {\n    result =\n      \"Scanning Java code completed successfully, but the scan encountered issues. \" +\n        \"This may be caused by problems identifying dependencies or use of generated source code. \" +\n        \"Some metrics of the database quality are: \" + getDbHealth() + \". \" +\n        \"Ideally these metrics should be above their thresholds. \" +\n        \"Addressing these issues is advisable to avoid false-positives or missing results. If they cannot be addressed, consider scanning Java \"\n        +\n        \"using either the `autobuild` or `manual` [build modes](https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages#comparison-of-the-build-modes).\"\n  }\n}\n\nquery predicate diagnosticAttributes(DbQualityDiagnostic e, string key, string value) {\n  exists(e) and // Quieten warning about unconstrained 'e'\n  key = [\"visibilityCliSummaryTable\", \"visibilityTelemetry\", \"visibilityStatusPage\"] and\n  value = \"true\"\n}\n\nfrom DbQualityDiagnostic d\nselect d, d.toString(), 1",
        "description": "Low Java analysis quality",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/DatabaseQualityDiagnostics.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Diagnostics\nimport DatabaseQuality\n\npredicate compilationInfo(string key, int value) {\n  exists(Compilation c, string infoKey |\n    key = infoKey + \": \" + c.getInfo(infoKey) and\n    value = 1\n  )\n}\n\npredicate fileCount(string key, int value) {\n  key = \"Number of files\" and\n  value = strictcount(File f)\n}\n\npredicate fileCountByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Number of files with extension \" + extension and\n    value = strictcount(File f | f.getExtension() = extension)\n  )\n}\n\npredicate totalNumberOfLines(string key, int value) {\n  key = \"Total number of lines\" and\n  value = strictsum(File f | any() | f.getTotalNumberOfLines())\n}\n\npredicate numberOfLinesOfCode(string key, int value) {\n  key = \"Number of lines of code\" and\n  value = strictsum(File f | any() | f.getNumberOfLinesOfCode())\n}\n\npredicate totalNumberOfLinesByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Total number of lines with extension \" + extension and\n    value = strictsum(File f | f.getExtension() = extension | f.getTotalNumberOfLines())\n  )\n}\n\npredicate numberOfLinesOfCodeByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Number of lines of code with extension \" + extension and\n    value = strictsum(File f | f.getExtension() = extension | f.getNumberOfLinesOfCode())\n  )\n}\n\npredicate extractorDiagnostics(string key, int value) {\n  exists(string extractor, int severity |\n    key = \"Number of diagnostics from \" + extractor + \" with severity \" + severity.toString() and\n    value =\n      strictcount(Diagnostic d | d.getGeneratedBy() = extractor and d.getSeverity() = severity)\n  )\n}\n\n\npredicate extractorTotalDiagnostics(string key, int value) {\n  exists(string extractor, string limitRegex |\n    limitRegex = \"Total of ([0-9]+) diagnostics \\\\(reached limit of ([0-9]+)\\\\).*\" and\n    key = \"Total number of diagnostics from \" + extractor and\n    value =\n      strictcount(Diagnostic d | d.getGeneratedBy() = extractor) +\n        sum(Diagnostic d |\n          d.getGeneratedBy() = extractor\n        |\n          d.getMessage().regexpCapture(limitRegex, 1).toInt() -\n              d.getMessage().regexpCapture(limitRegex, 2).toInt() - 1\n        )\n  )\n}\n\nfrom string key, int value\nwhere\n  not exists(string pattern | extractorInformationSkipKey(pattern) and key.matches(pattern)) and\n  (\n    compilationInfo(key, value) or\n    fileCount(key, value) or\n    fileCountByExtension(key, value) or\n    totalNumberOfLines(key, value) or\n    numberOfLinesOfCode(key, value) or\n    totalNumberOfLinesByExtension(key, value) or\n    numberOfLinesOfCodeByExtension(key, value) or\n    extractorDiagnostics(key, value) or\n    extractorTotalDiagnostics(key, value) or\n    CallTargetStatsReport::numberOfOk(key, value) or\n    CallTargetStatsReport::numberOfNotOk(key, value) or\n    CallTargetStatsReport::percentageOfOk(key, any(float x | value = x.floor())) or\n    ExprTypeStatsReport::numberOfOk(key, value) or\n    ExprTypeStatsReport::numberOfNotOk(key, value) or\n    ExprTypeStatsReport::percentageOfOk(key, any(float x | value = x.floor()))\n  )\nselect key, value",
        "description": "Information about the extraction for a Java database",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/ExtractorInformation.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport ExternalApi\n\nprivate predicate relevant(ExternalApi api) { api.isSupported() }\n\nfrom string apiName, int usages\nwhere Results<relevant/1>::restrict(apiName, usages)\nselect apiName, usages order by usages desc",
        "description": "A list of supported 3rd party APIs used in the codebase. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Telemetry/SupportedExternalApis.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m, Method other\nwhere none()\nselect m, \"Method \" + m.getName() + \" is duplicated in $@.\", other,\n  other.getDeclaringType().getQualifiedName()",
        "description": "Duplicated methods make code more difficult to understand and introduce a risk of changes being made to only one copy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/external/DuplicateMethod.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom BlockStmt d, int lines, File otherFile, int otherLine\nwhere none()\nselect d,\n  \"Duplicate code: \" + lines + \" lines are duplicated at \" + otherFile.getStem() + \":\" + otherLine +\n    \".\"",
        "description": "This block of code is duplicated elsewhere. If possible, the shared code should be refactored so there is only one occurrence left. It may not always be possible to address these issues; other duplicate code checks (such as duplicate function, duplicate class) give subsets of the results with higher confidence.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/external/DuplicateBlock.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom AnonymousClass c, AnonymousClass other\nwhere none()\nselect c, \"Anonymous class is identical to $@.\", other,\n  \"another anonymous class in \" + other.getFile().getStem()",
        "description": "Duplicated anonymous classes indicate that refactoring is necessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/external/DuplicateAnonymous.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom File f, File other, int percent\nwhere none()\nselect f, percent + \"% of the lines in \" + f.getStem() + \" are similar to lines in $@.\", other,\n  other.getStem()",
        "description": "Files in which most of the lines are similar to those in another file make code more difficult to understand and introduce a risk of changes being made to only one copy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/external/MostlySimilarFile.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom File f, File other, int percent\nwhere none()\nselect f, percent + \"% of the lines in \" + f.getStem() + \" are copies of lines in $@.\", other,\n  other.getStem()",
        "description": "Files in which most of the lines are duplicated in another file make code more difficult to understand and introduce a risk of changes being made to only one copy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/external/MostlyDuplicateFile.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Class c, string message, Class link\nwhere none()\nselect c, message, link, link.getQualifiedName()",
        "description": "Classes in which most of the methods are duplicated in another class make code more difficult to understand and introduce a risk of changes being made to only one copy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/external/MostlyDuplicateClass.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m, Method other, int percent\nwhere none()\nselect m, percent + \"% of the statements in \" + m.getName() + \" are duplicated in $@.\", other,\n  other.getDeclaringType().getName() + \".\" + other.getStringSignature()",
        "description": "Methods in which most of the lines are duplicated in another method make code more difficult to understand and introduce a risk of changes being made to only one copy.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/external/MostlyDuplicateMethod.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenThisCallable target, Call call, ThisAccess ta\nwhere\n  ejbCalls(origin, target, call) and\n  ta = forbiddenThisUse(target)\nselect origin, \"EJB should not use 'this' as a method argument or result $@.\", ta, \"here\"",
        "description": "An EJB should not use 'this' as a method argument or result. Instead, it should use the result of SessionContext.getBusinessObject, SessionContext.getEJBObject, SessionContext.getEJBLocalObject, EntityContext.getEJBObject, or EntityContext.getEJBLocalObject.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbThis.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenFileCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not access the file system by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not attempt to access files or directories in the file system. Such use could compromise security and is not a suitable data access method for enterprise components.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbFileIO.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenServerSocketCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not use a socket as a server by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not attempt to listen to or accept connections on a socket, or use a socket for multicast. Functioning as a general network server would conflict with the EJB's purpose to serve EJB clients.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbSocketAsServer.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenThreadingCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not attempt to manage threads by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not attempt to manage threads, as it could interfere with the EJB container's operation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbThreads.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenSecurityConfigurationCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not access a security configuration by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not attempt to access or modify any Java security configuration, including the Policy, Security, Provider, Signer and Identity objects. This functionality is reserved for the EJB container for security reasons.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbSecurityConfiguration.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenReflectionCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not use reflection by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not attempt to use the Reflection API, as this could compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbReflection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenContainerInterferenceCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not interfere with its container's operation by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not attempt to create a class loader, obtain the current class loader, set the context class loader, set a security manager, create a new security manager, stop the JVM, or change the input, output or error streams. Such operations could interfere with the EJB container's operation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbContainerInterference.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenSetFactoryCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not set a factory by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not set the socket factory used by ServerSocket or Socket, or the stream handler factory used by URL. Such operations could compromise security or interfere with the EJB container's operation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbSetSocketOrUrlFactory.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenSynchronizationCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not use synchronization by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not use synchronization, since it will not work properly if an EJB is distributed across multiple JVMs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbSynchronization.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenStaticFieldCallable target, Call call, FieldAccess fa, Field f\nwhere\n  ejbCalls(origin, target, call) and\n  fa = forbiddenStaticFieldUse(target) and\n  fa.getField() = f\nselect origin, \"EJB should not access non-final static field $@ $@.\", f,\n  f.getDeclaringType().getName() + \".\" + f.getName(), fa, \"here\"",
        "description": "An EJB should not make use of non-final static fields, since a consistent state of such fields is not guaranteed if an EJB instance is distributed across multiple JVMs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbStaticFieldNonFinal.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenNativeCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not use native code by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not attempt to load or execute native code. Such use could compromise security and system stability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbNative.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenGraphicsCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not use AWT or other graphics functionality by $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName()",
        "description": "An EJB should not use AWT or other graphics functionality. Such operations are normally performed by an end-user interface that accesses a server but not by the server itself.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbGraphics.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.javaee.ejb.EJB\nimport semmle.code.java.frameworks.javaee.ejb.EJBRestrictions\n\n\nfrom Callable origin, ForbiddenSerializationCallable target, Call call\nwhere ejbCalls(origin, target, call)\nselect origin, \"EJB should not use a substitution feature of serialization by calling $@.\", call,\n  target.getDeclaringType().getName() + \".\" + target.getName() + \" $@\"",
        "description": "An EJB should not use the subclass or object substitution features of the Java serialization protocol, since their use could compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/JavaEE/EJB/EjbSerialization.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nclass ParentBean extends SpringBean {\n  ParentBean() { exists(SpringBean b | b.getBeanParent() = this) }\n\n  RefType getDeclaredClass() {\n    result = this.getClass() and\n    this.hasAttribute(\"class\") and\n    not this.getAttribute(\"abstract\").getValue() = \"true\"\n  }\n}\n\nfrom ParentBean parent\nwhere parent.getDeclaredClass().isAbstract()\nselect parent, \"This parent bean should not have an abstract class.\"",
        "description": "A non-abstract Spring bean that is a parent of other beans and specifies an abstract class causes an error during bean instantiation.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/ParentShouldNotUseAbstractClass.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringBean b\nwhere b.getAutowire() != \"no\"\nselect b, \"Avoid using autowiring.\"",
        "description": "Using autowiring in Spring beans may make it difficult to maintain large projects.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/AvoidAutowiring.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringImport i\nwhere\n  exists(SpringBean b |\n    i.getSpringBeanFile() = b.getSpringBeanFile() and\n    i.getLocation().getStartLine() > b.getLocation().getStartLine()\n  )\nselect i, \"Imports should come before bean definitions.\"",
        "description": "Putting 'import' statements before bean definitions in a Spring bean configuration file makes it easier to immediately see all the file's dependencies.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/ImportsFirst.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringAbstractRef ref, SpringBean refBean, SpringBean referencedBean\nwhere\n  refBean = ref.getEnclosingBean() and\n  referencedBean = ref.getBean() and\n  referencedBean.getSpringBeanFile() = refBean.getSpringBeanFile() and\n  not ref.hasBeanLocalName()\nselect ref,\n  \"Non-local reference points to bean $@ in the same file. Use a local reference instead.\",\n  referencedBean, referencedBean.getBeanIdentifier()",
        "description": "Using local references when referring to Spring beans in the same file allows reference errors to be detected during XML parsing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/UseLocalRef.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringBean b\nwhere\n  not exists(SpringDescription d |\n    d = b.getASpringChild() or d = b.getSpringBeanFile().getBeansElement().getAChild()\n  )\nselect b, \"This bean does not have a description.\"",
        "description": "Adding 'description' elements to a Spring XML bean definition file is good practice.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/NoBeanDescription.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringBean b\nwhere\n  not b.hasBeanId() and\n  b.hasBeanName()\nselect b,\n  \"Use \\\"id\\\" instead of \\\"name\\\" to take advantage of the IDREF constraint in the XML parser.\"",
        "description": "Using 'id' instead of 'name' to name a Spring bean enables the XML parser to perform additional checks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/UseIdInsteadOfName.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nclass SpringConstructorArgUseShortcut extends SpringConstructorArg {\n  SpringConstructorArgUseShortcut() {\n    not this.hasArgValueString() and\n    this.getASpringChild() instanceof SpringValue\n  }\n\n  string getMessage() {\n    not this.hasArgValueString() and\n    this.getASpringChild() instanceof SpringValue and\n    result = \"Use the shortcut \\\"value\\\" attribute instead of a nested <value> element.\"\n  }\n}\n\nclass SpringEntryUseShortcut extends SpringEntry {\n  SpringEntryUseShortcut() {\n    not this.hasValueStringRaw() and\n    this.getASpringChild() instanceof SpringValue\n  }\n\n  string getMessage() {\n    not this.hasValueStringRaw() and\n    this.getASpringChild() instanceof SpringValue and\n    result = \"Use the shortcut \\\"value\\\" attribute instead of a nested <value> element.\"\n  }\n}\n\nclass SpringPropertyUseShortcut extends SpringProperty {\n  SpringPropertyUseShortcut() {\n    not this.hasPropertyValueString() and\n    this.getASpringChild() instanceof SpringValue\n  }\n\n  string getMessage() {\n    not this.hasPropertyValueString() and\n    this.getASpringChild() instanceof SpringValue and\n    result = \"Use the shortcut \\\"value\\\" attribute instead of a nested <value> element.\"\n  }\n}\n\nfrom SpringXmlElement springElement, string msg\nwhere\n  exists(SpringConstructorArgUseShortcut cons | cons = springElement and msg = cons.getMessage())\n  or\n  exists(SpringEntryUseShortcut entry | entry = springElement and msg = entry.getMessage())\n  or\n  exists(SpringPropertyUseShortcut prop | prop = springElement and msg = prop.getMessage())\nselect springElement, msg",
        "description": "Using shortcut forms may make a Spring XML configuration file less cluttered.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/UseShortcutForms.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringBean b\nwhere b.getASpringChild() instanceof SpringConstructorArg\nselect b, \"Use setter injection instead of constructor injection.\"",
        "description": "When using the Spring Framework, using setter injection instead of constructor injection is more flexible, especially when several properties are optional.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/UseSetterInjection.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringConstructorArg carg\nwhere carg.hasArgIndex()\nselect carg, \"Use constructor-arg types instead of index.\"",
        "description": "Using a type name instead of an index number in a Spring 'constructor-arg' element improves readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Violations of Best Practice/DontUseConstructorArgIndex.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringProperty p\nwhere\n  not p.getEnclosingBean().isAbstract() and\n  not exists(p.getSetterMethod())\nselect p, \"This property is missing a setter method on $@.\", p.getEnclosingBean().getClass() as c,\n  c.getName()",
        "description": "Not declaring a setter for a property that is defined in a Spring XML file causes a compilation error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/XML Configuration Errors/MissingSetters.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nclass InstanceFieldWrite extends FieldWrite {\n  InstanceFieldWrite() {\n    // Must be in an instance callable\n    not this.getEnclosingCallable().isStatic() and\n    // Must be declared in this type or a supertype.\n    this.getEnclosingCallable().getDeclaringType().inherits(this.getField()) and\n    this.isOwnFieldAccess()\n  }\n}\n\nclass ImpureStmt extends Stmt {\n  ImpureStmt() {\n    exists(Expr e | e.getEnclosingStmt() = this |\n      // Only permit calls to set of whitelisted targets.\n      e instanceof Call and\n      not e.(Call).getCallee().getDeclaringType().hasQualifiedName(\"java.util\", \"Collections\")\n      or\n      // Writing to a field that is not an instance field is a no-no\n      e instanceof FieldWrite and not e instanceof InstanceFieldWrite\n    )\n  }\n}\n\nprivate Stmt getANestedStmt(BlockStmt block) {\n  // Any non-block statement\n  not result instanceof BlockStmt and result = block.getAStmt()\n  or\n  // Or any statement nested in a block\n  result = getANestedStmt(block.getAStmt())\n}\n\nclass SpringPureClass extends Class {\n  SpringPureClass() {\n    // The only permitted statement in static initializers is the initialization of a static\n    // final or effectively final logger fields, or effectively immutable types.\n    forall(Stmt s | s = getANestedStmt(this.getAMember().(StaticInitializer).getBody()) |\n      exists(Field f | f = s.(ExprStmt).getExpr().(AssignExpr).getDest().(FieldWrite).getField() |\n        (\n          // A logger field\n          f.getName().toLowerCase() = \"logger\" or\n          f.getName().toLowerCase() = \"log\" or\n          // An immutable type\n          f.getType() instanceof ImmutableType\n        ) and\n        f.isStatic() and\n        // Only written to in this statement e.g. final or effectively final\n        forall(FieldWrite fw | fw = f.getAnAccess() | fw.getEnclosingStmt() = s)\n      )\n    ) and\n    // No constructor, instance initializer or Spring bean init or setter method that is impure.\n    not exists(Callable c, ImpureStmt impureStmt |\n      (\n        this.inherits(c.(Method)) or\n        c = this.getAMember()\n      ) and\n      impureStmt.getEnclosingCallable() = c\n    |\n      c instanceof InstanceInitializer\n      or\n      c instanceof Constructor\n      or\n      // afterPropertiesSet() method called after bean initialization\n      c = this.(InitializingBeanClass).getAfterPropertiesSet()\n      or\n      // Init and setter methods must be pure, because they are called when the bean is initialized\n      exists(SpringBean bean | this = bean.getClass() |\n        c = bean.getInitMethod() or\n        c = bean.getAProperty().getSetterMethod()\n      )\n      or\n      // Setter method by autowiring, either in the XML or by annotation\n      c = this.getAMethod().(SpringBeanAutowiredCallable)\n      or\n      c = this.getAMethod().(SpringBeanXmlAutowiredSetterMethod)\n    )\n  }\n}\n\nclass SpringBeanFactory extends ClassOrInterface {\n  SpringBeanFactory() {\n    this.getAnAncestor().hasQualifiedName(\"org.springframework.beans.factory\", \"BeanFactory\")\n  }\n\n  /**\n   * Get a bean constructed by a call to this bean factory.\n   */\n  SpringBean getAConstructedBean() {\n    exists(Method getBean, MethodCall call |\n      getBean.hasName(\"getBean\") and\n      call.getMethod() = getBean and\n      getBean.getDeclaringType() = this\n    |\n      result.getBeanIdentifier() = call.getArgument(0).(CompileTimeConstantExpr).getStringValue()\n    )\n  }\n}\n\nclass LiveSpringBean extends SpringBean {\n  LiveSpringBean() {\n    // Must not be needed for side effects due to construction\n    // Only loaded by the container when required, so construction cannot have any useful side-effects\n    not this.isLazyInit() and\n    // or has no side-effects when constructed\n    not this.getClass() instanceof SpringPureClass\n    or\n    (\n      // If the class does not exist for this bean, or the class is not a source bean, then this is\n      // likely to be a definition using a library class, in which case we should consider it to be\n      // live.\n      not exists(this.getClass())\n      or\n      not this.getClass().fromSource()\n      or\n      // In alfresco, \"webscript\" beans should be considered live\n      this.getBeanParent*().getBeanParentName() = \"webscript\"\n      or\n      // A live child bean implies this bean is live\n      exists(LiveSpringBean child | this = child.getBeanParent())\n      or\n      // Beans constructed by a bean factory are considered live\n      exists(SpringBeanFactory beanFactory | this = beanFactory.getAConstructedBean())\n    )\n    or\n    (\n      // Referenced by a live bean, either as a property or argument in the XML\n      exists(LiveSpringBean other |\n        this = other.getAConstructorArg().getArgRefBean() or\n        this = other.getAProperty().getPropertyRefBean()\n      )\n      or\n      // Referenced as a factory bean\n      exists(LiveSpringBean springBean | this = springBean.getFactoryBean())\n      or\n      // Injected by @Autowired annotation\n      exists(SpringBeanAutowiredCallable autowiredCallable |\n        // The callable must be in a live class\n        autowiredCallable.getEnclosingSpringBean() instanceof LiveSpringBean or\n        autowiredCallable.getEnclosingSpringComponent().isLive()\n      |\n        // This bean is injected into it\n        this = autowiredCallable.getAnInjectedBean()\n      )\n      or\n      // Injected by @Autowired annotation on field\n      exists(SpringBeanAutowiredField autowiredField |\n        // The field must be in a live class\n        autowiredField.getEnclosingSpringBean() instanceof LiveSpringBean or\n        autowiredField.getEnclosingSpringComponent().isLive()\n      |\n        // This bean is injected into it\n        this = autowiredField.getInjectedBean()\n      )\n      or\n      // Injected by autowired specified in XML\n      exists(SpringBeanXmlAutowiredSetterMethod setterMethod |\n        // The config method must be on a live bean\n        setterMethod.getDeclaringType().(SpringBeanRefType).getSpringBean() instanceof\n          LiveSpringBean\n      |\n        // This bean is injected into it\n        this = setterMethod.getInjectedBean()\n      )\n    )\n  }\n}\n\nclass UnusedSpringBean extends SpringBean {\n  UnusedSpringBean() { not this instanceof LiveSpringBean }\n}\n\nfrom UnusedSpringBean unused\nselect unused, \"The spring bean \" + unused.getBeanIdentifier() + \" is never used.\"",
        "description": "Beans that are specified but never used are redundant and should be removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Architecture/Refactoring Opportunities/UnusedBean.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringBean bean, SpringProperty prop, SpringProperty overriddenProp, SpringBean ancestorBean\nwhere\n  prop = bean.getADeclaredProperty() and\n  ancestorBean = bean.getBeanParent+() and\n  ancestorBean.getADeclaredProperty() = overriddenProp and\n  overriddenProp.getPropertyName() = prop.getPropertyName() and\n  prop.isSimilar(overriddenProp)\nselect prop, \"Property overrides $@ in parent, but has the same contents.\", overriddenProp,\n  overriddenProp.toString()",
        "description": "A bean property that overrides the same property in a parent bean, and has the same contents, is useless.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Architecture/Refactoring Opportunities/UselessPropertyOverride.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nclass MySpringBean extends SpringBean {\n  int getNumberOfSimilarPropertiesWith(SpringBean other) {\n    result = count(this.getASimilarPropertyWith(other))\n  }\n\n  SpringProperty getASimilarPropertyWith(SpringBean other) {\n    exists(SpringProperty otherProp |\n      otherProp = other.getADeclaredProperty() and\n      result.isSimilar(otherProp) and\n      result = this.getADeclaredProperty()\n    )\n  }\n}\n\nfrom MySpringBean bean1, SpringBean bean2, int similarProps\nwhere\n  similarProps = bean1.getNumberOfSimilarPropertiesWith(bean2) and\n  similarProps >= 3 and\n  bean1.getBeanIdentifier() < bean2.getBeanIdentifier() and\n  bean1 != bean2\nselect bean1,\n  \"This bean has \" + similarProps.toString() +\n    \" properties similar to $@. Consider introducing a common parent bean for these two beans.\",\n  bean2, bean2.getBeanIdentifier()",
        "description": "Beans that share similar properties exhibit unnecessary repetition in the bean definitions and make the system's architecture more difficult to see.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Architecture/Refactoring Opportunities/MissingParentBean.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.spring.Spring\n\nfrom SpringBeanFile f\nwhere count(f.getABean()) > 40\nselect f, \"There are too many beans in this file.\"",
        "description": "Too many beans in a file can make the file difficult to understand and maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Frameworks/Spring/Architecture/Refactoring Opportunities/TooManyBeans.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npragma[nomagic]\npredicate inherits(Class c, Field f) {\n  f = c.getAField()\n  or\n  not f.isPrivate() and c.getAStrictAncestor().getAField() = f\n}\n\nclass EnclosingInstanceAccess extends Expr {\n  EnclosingInstanceAccess() { exists(enclosingInstanceAccess(this)) }\n\n  RefType getAnAccessedType() { result = enclosingInstanceAccess(this) }\n}\n\nRefType enclosingInstanceAccess(Expr expr) {\n  exists(RefType enclosing | enclosing = expr.getEnclosingCallable().getDeclaringType() |\n    // A direct qualified `this` access that doesn't refer to the containing\n    // class must refer to an enclosing instance instead.\n    result = expr.(ThisAccess).getType() and result != enclosing\n    or\n    // A qualified `super` access qualified with a type that isn't the enclosing type.\n    result = expr.(SuperAccess).getQualifier().(TypeAccess).getType() and result != enclosing\n    or\n    // An unqualified `new` expression constructing a\n    // non-static type that needs an enclosing instance.\n    exists(ClassInstanceExpr new, InnerClass t |\n      new = expr and t = new.getType().(RefType).getSourceDeclaration()\n    |\n      result = t and\n      not exists(new.getQualifier()) and\n      not t.getEnclosingType*() = enclosing\n    )\n    or\n    // An unqualified `new` expression constructing another instance of the\n    // class it is itself located in, calling a constructor that uses an\n    // enclosing instance.\n    exists(ClassInstanceExpr new, Constructor ctor, Expr e2 |\n      new = expr and\n      not exists(new.getQualifier()) and\n      ctor = new.getConstructor() and\n      enclosing.getEnclosingType*().(InnerClass) = ctor.getDeclaringType() and\n      ctor = e2.getEnclosingCallable() and\n      result = enclosingInstanceAccess(e2)\n    )\n    or\n    // An unqualified method or field access to a member that isn't inherited\n    // must refer to an enclosing instance.\n    exists(FieldAccess fa | fa = expr |\n      result = fa.getField().getDeclaringType() and\n      not exists(fa.getQualifier()) and\n      not fa.getVariable().(Field).isStatic() and\n      not inherits(enclosing, fa.getVariable())\n    )\n    or\n    exists(MethodCall ma | ma = expr |\n      result = ma.getMethod().getDeclaringType() and\n      not exists(ma.getQualifier()) and\n      not ma.getMethod().isStatic() and\n      not enclosing.inherits(ma.getMethod())\n    )\n  )\n}\n\npredicate potentiallyStatic(InnerClass c) {\n  not exists(EnclosingInstanceAccess a, Method m |\n    m = a.getEnclosingCallable() and\n    m.getDeclaringType() = c\n  ) and\n  c instanceof MemberType and\n  forall(\n    InnerClass other // If nested and non-static, ...\n  |\n    // ... all supertypes (which are from source), ...\n    other = c.getASourceSupertype() and other.fromSource()\n    or\n    // ... and the enclosing type, ...\n    other = c.getEnclosingType()\n  |\n    // ... must be (potentially) static.\n    potentiallyStatic(other)\n  ) and\n  // No nested classes of `c` access an enclosing instance of `c` except in their constructors, i.e.\n  // for all accesses to a non-static member of an enclosing instance ...\n  forall(EnclosingInstanceAccess a, Method m |\n    // ... that occur in a method of a nested class of `c` ...\n    m = a.getEnclosingCallable() and m.getDeclaringType().getEnclosingType+() = c\n  |\n    // ... the access must be to a member of a type enclosed in `c` or `c` itself.\n    a.getAnAccessedType().getEnclosingType*() = c\n  ) and\n  // Any supertype of a class nested in `c` must be potentially static.\n  forall(InnerClass nested | nested.getEnclosingType+() = c |\n    forall(InnerClass superOfNested | superOfNested = nested.getASourceSupertype+() |\n      potentiallyStatic(superOfNested)\n    )\n  ) and\n  // JUnit Nested test classes are required to be non-static.\n  not c.hasAnnotation(\"org.junit.jupiter.api\", \"Nested\") and\n  // There's no `static` in kotlin:\n  not c.getLocation().getFile().isKotlinSourceFile()\n}\n\nclass ProblematicClass extends InnerClass {\n  ProblematicClass() { potentiallyStatic(this) }\n\n  /**\n   * Check for accesses to the enclosing instance in a constructor or field\n   * initializer.\n   */\n  predicate usesEnclosingInstanceInConstructor() {\n    exists(EnclosingInstanceAccess a | a.getEnclosingCallable() = this.getAConstructor())\n  }\n}\n\nfrom ProblematicClass c, string msg\nwhere\n  c.fromSource() and\n  if c.usesEnclosingInstanceInConstructor()\n  then msg = \" could be made static, since the enclosing instance is used only in its constructor.\"\n  else msg = \" should be made static, since the enclosing instance is not used.\"\nselect c, c.getName() + msg",
        "description": "A non-static nested class keeps a reference to the enclosing object, which makes the nested class bigger and may cause a memory leak.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/InnerClassCouldBeStatic.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom StringReplaceAllCall replaceAllCall, StringLiteral firstArg\nwhere\n  firstArg = replaceAllCall.getArgument(0) and\n  //only contains characters that could be a simple string\n  firstArg.getValue().regexpMatch(\"^[a-zA-Z0-9]+$\")\nselect replaceAllCall,\n  \"This call to 'replaceAll' should be a call to 'replace' as its $@ is not a regular expression.\",\n  firstArg, \"first argument\"",
        "description": "Using `String#replaceAll` with a first argument which is not a regular expression is less efficient than using `String#replace`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/StringReplaceAllWithNonRegex.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass KeySetIterator extends LocalVariableDecl {\n  KeySetIterator() {\n    exists(LocalVariableDeclExpr lvde, MethodCall init |\n      lvde.getVariable() = this and\n      lvde.getInit() = init and\n      init.getMethod().hasName(\"iterator\") and\n      init.getQualifier().(MethodCall).getMethod().hasName(\"keySet\")\n    )\n  }\n\n  LocalVariableDecl getBase() {\n    exists(LocalVariableDeclExpr lvde, MethodCall init |\n      lvde.getVariable() = this and\n      lvde.getInit() = init and\n      init.getQualifier().(MethodCall).getQualifier().(VarAccess).getVariable() = result\n    )\n  }\n}\n\npredicate isKeyNext(Expr e, KeySetIterator it) {\n  exists(MethodCall ma | ma = e |\n    ma.getMethod().hasName(\"next\") and\n    ma.getQualifier().(VarAccess).getVariable() = it\n  )\n  or\n  isKeyNext(e.(CastingExpr).getExpr(), it)\n}\n\nclass Key extends LocalVariableDecl {\n  Key() {\n    exists(LocalVariableDeclExpr lvde |\n      lvde.getVariable() = this and\n      isKeyNext(lvde.getInit(), _)\n    )\n  }\n\n  KeySetIterator getBase() {\n    exists(LocalVariableDeclExpr lvde |\n      lvde.getVariable() = this and\n      isKeyNext(lvde.getInit(), result)\n    )\n  }\n}\n\nfrom MethodCall ma, Method get\nwhere\n  ma.getMethod() = get and\n  get.hasName(\"get\") and\n  ma.getAnArgument().(VarAccess).getVariable().(Key).getBase().getBase() =\n    ma.getQualifier().(VarAccess).getVariable()\nselect ma, \"Inefficient use of key set iterator instead of entry set iterator.\"",
        "description": "Iterating through the values of a map using the key set is inefficient.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/InefficientKeySetIterator.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall mc\nwhere\n  mc.getQualifier().getType() instanceof TypeString and\n  mc.getMethod().hasName(\"equals\") and\n  (\n    mc.getArgument(0).(StringLiteral).getValue() = \"\" or\n    mc.getQualifier().(StringLiteral).getValue() = \"\"\n  )\nselect mc, \"Inefficient comparison to empty string, check for zero length instead.\"",
        "description": "Checking a string for equality with an empty string is inefficient.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/InefficientEmptyStringTest.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass InefficientWriteBytes extends Class {\n  InefficientWriteBytes() {\n    this.hasQualifiedName(\"java.io\", \"OutputStream\") or\n    this.hasQualifiedName(\"java.io\", \"FilterOutputStream\")\n  }\n}\n\nfrom Class c, Method m\nwhere\n  not c.isAbstract() and\n  not c instanceof InefficientWriteBytes and\n  c.getASupertype() instanceof InefficientWriteBytes and\n  c.getAMethod() = m and\n  m.getName() = \"write\" and\n  m.getNumberOfParameters() = 1 and\n  m.getParameterType(0).(PrimitiveType).getName() = \"int\" and\n  exists(Method m2 | c.inherits(m2) |\n    m2.getName() = \"write\" and\n    m2.getNumberOfParameters() = 3 and\n    m2.getDeclaringType() instanceof InefficientWriteBytes\n  ) and\n  // If that method doesn't call write itself, then we don't have a problem.\n  // This is the case is some dummy implementations.\n  exists(MethodCall ma | ma.getEnclosingCallable() = m | ma.getMethod().getName() = \"write\")\nselect c,\n  \"This class extends 'java.io.OutputStream' and implements $@, but does not override 'write(byte[],int,int)'.\",\n  m, m.getName()",
        "description": "Using the default implementation of 'write(byte[],int,int)' provided by 'java.io.OutputStream' is very inefficient.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/InefficientOutputStream.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ClassInstanceExpr e\nwhere\n  e.getConstructor().getDeclaringType() instanceof TypeString and\n  e.getArgument(0).getType() instanceof TypeString\nselect e, \"Inefficient new String(String) constructor.\"",
        "description": "Using the 'String(String)' constructor is less memory efficient than using the constructor argument directly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/NewStringString.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.Type\nimport semmle.code.java.Expr\nimport semmle.code.java.Statement\nimport semmle.code.java.JDK\n\npredicate useAndDef(Assignment a, Variable v) {\n  a.getDest() = v.getAnAccess() and\n  v.getType() instanceof TypeString and\n  (\n    a instanceof AssignAddExpr\n    or\n    exists(VarAccess use | use.getVariable() = v | use.getParent*() = a.getSource()) and\n    a.getSource() instanceof AddExpr\n  )\n}\n\npredicate declaredInLoop(LocalVariableDecl v, LoopStmt loop) {\n  exists(LocalVariableDeclExpr e |\n    e.getVariable() = v and\n    e.getEnclosingStmt().getEnclosingStmt*() = loop.getBody()\n  )\n  or\n  exists(EnhancedForStmt for | for = loop | for.getVariable().getVariable() = v)\n}\n\nfrom Assignment a, Variable v\nwhere\n  useAndDef(a, v) and\n  exists(LoopStmt loop | a.getEnclosingStmt().getEnclosingStmt*() = loop |\n    not declaredInLoop(v, loop)\n  )\nselect a, \"The string \" + v.getName() + \" is built-up in a loop: use string buffer.\"",
        "description": "Performing string concatenation in a loop that iterates many times may affect performance.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/ConcatenationInLoops.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ClassInstanceExpr call, BoxedType type\nwhere\n  type = call.getType() and\n  not call.getEnclosingCallable().getDeclaringType() = type\nselect call,\n  \"Inefficient constructor for \" + type.getPrimitiveType().getName() + \" value, use \" +\n    type.getName() + \".valueOf(...) instead.\"",
        "description": "Calling the constructor of a boxed type is inefficient.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Performance/InefficientPrimConstructor.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Documentable documentable, ParamTag paramTag, string msg\nwhere\n  documentable.getJavadoc().getAChild() = paramTag and\n  if exists(paramTag.getParamName())\n  then\n    documentable instanceof Callable and\n    exists(string what |\n      if documentable instanceof Constructor then what = \"constructor\" else what = \"method\"\n    |\n      // The tag's value is neither matched by a callable parameter name ...\n      not documentable.(Callable).getAParameter().getName() = paramTag.getParamName() and\n      // ... nor by a type parameter name.\n      not exists(TypeVariable tv | tv.getGenericCallable() = documentable |\n        \"<\" + tv.getName() + \">\" = paramTag.getParamName()\n      ) and\n      msg =\n        \"@param tag \\\"\" + paramTag.getParamName() + \"\\\" does not match any actual parameter of \" +\n          what + \" \\\"\" + documentable.getName() + \"()\\\".\"\n    )\n    or\n    documentable instanceof ClassOrInterface and\n    not documentable instanceof Record and\n    not exists(TypeVariable tv | tv.getGenericType() = documentable |\n      \"<\" + tv.getName() + \">\" = paramTag.getParamName()\n    ) and\n    msg =\n      \"@param tag \\\"\" + paramTag.getParamName() +\n        \"\\\" does not match any actual type parameter of type \\\"\" + documentable.getName() + \"\\\".\"\n    or\n    documentable instanceof Record and\n    not exists(TypeVariable tv | tv.getGenericType() = documentable |\n      \"<\" + tv.getName() + \">\" = paramTag.getParamName()\n    ) and\n    not documentable.(Record).getCanonicalConstructor().getAParameter().getName() =\n      paramTag.getParamName() and\n    msg =\n      \"@param tag \\\"\" + paramTag.getParamName() +\n        \"\\\" does not match any actual type parameter or record parameter of record \\\"\" +\n        documentable.getName() + \"\\\".\"\n  else\n    // The tag has no value at all.\n    msg = \"This @param tag does not have a value.\"\nselect paramTag, msg",
        "description": "Javadoc @param tags that do not match any parameters in the method or constructor or any type parameters of the annotated class are confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Documentation/SpuriousJavadocParam.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport JavadocCommon\n\nfrom DocuRefType t\nwhere not t.hasAcceptableDocText()\nselect t, \"This type does not have a non-trivial Javadoc comment.\"",
        "description": "A public class or interface that does not have a Javadoc comment affects maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Documentation/MissingJavadocTypes.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nRefType getTaggedType(ThrowsTag tag) {\n  result.hasName(tag.getExceptionName()) and\n  exists(ImportType i | i.getFile() = tag.getFile() | i.getImportedType() = result)\n}\n\n// Uses ClassOrInterface as type for thrownType to also cover case where erroneously an interface\n// type is declared as thrown exception\nfrom ThrowsTag throwsTag, ClassOrInterface thrownType, Callable docMethod\nwhere\n  getTaggedType(throwsTag) = thrownType and\n  docMethod.getDoc().getJavadoc().getAChild*() = throwsTag and\n  not thrownType instanceof UncheckedThrowableType and\n  not docMethod.getAnException().getType().getADescendant() = thrownType\nselect throwsTag,\n  \"Javadoc for \" + docMethod + \" claims to throw \" + thrownType.getName() +\n    \" but this is impossible.\"",
        "description": "Javadoc that incorrectly claims a method or constructor can throw an exception is misleading.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Documentation/ImpossibleJavadocThrows.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport JavadocCommon\n\nfrom DocuThrows c, RefType t\nwhere\n  exists(Exception e |\n    c.getAnException() = e and\n    e.getType() = t and\n    not c.hasAcceptableThrowsTag(e)\n  )\nselect c,\n  \"This \" + c.toMethodOrConstructorString() +\n    \" throws $@ but does not have a corresponding Javadoc tag.\", t, t.getName()",
        "description": "A public method or constructor that throws an exception but does not have a Javadoc tag for the exception affects maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Documentation/MissingJavadocThrows.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport JavadocCommon\n\nfrom DocuCallable c\nwhere not c.hasAcceptableDocText()\nselect c,\n  \"This \" + c.toMethodOrConstructorString() + \" does not have a non-trivial Javadoc comment.\"",
        "description": "A public method or constructor that does not have a Javadoc comment affects maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Documentation/MissingJavadocMethods.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport JavadocCommon\n\nfrom DocuReturn c\nwhere not c.hasAcceptableReturnTag()\nselect c, \"This method's return value does not have a non-trivial Javadoc tag.\"",
        "description": "A public method that does not have a Javadoc tag for its return value affects maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Documentation/MissingJavadocReturnValues.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport JavadocCommon\n\nfrom DocuParam p\nwhere not p.hasAcceptableParamTag()\nselect p, \"This parameter does not have a non-trivial Javadoc tag.\"",
        "description": "A public method or constructor that does not have a Javadoc tag for each parameter affects maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Documentation/MissingJavadocParameters.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ClassInstanceExpr cie\nwhere cie.getConstructor().getDeclaringType() instanceof RawType\nselect cie, \"This is a non-parameterized constructor invocation of a generic type.\"",
        "description": "Parameterizing a call to a constructor of a generic type increases type safety and code readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Types/GenericsConstructor.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m\nwhere\n  m.fromSource() and\n  m.getReturnType() instanceof RawType\nselect m, \"This method has a non-parameterized return type.\"",
        "description": "Using a parameterized instance of a generic type for a method return type increases type safety and code readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Types/GenericsReturnType.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Variable v\nwhere\n  v.fromSource() and\n  v.getType() instanceof RawType\nselect v, \"This declaration uses a non-parameterized type.\"",
        "description": "Declaring a field, parameter, or local variable as a parameterized type increases type safety and code readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Types/GenericsVariable.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass OverridingMethod extends Method {\n  OverridingMethod() { this.overrides(_) }\n\n  predicate isOverrideAnnotated() { this.getAnAnnotation() instanceof OverrideAnnotation }\n}\n\nfrom OverridingMethod m, Method overridden\nwhere\n  m.fromSource() and\n  m.overrides(overridden) and\n  not m.hasModifier(\"override\") and\n  not m.isOverrideAnnotated() and\n  not exists(FunctionalExpr mref | mref.asMethod() = m) and\n  // Ignore generated constructs, such as <clinit> functions extracted from Kotlin code:\n  not m.isCompilerGenerated()\nselect m, \"This method overrides $@; it is advisable to add an Override annotation.\", overridden,\n  overridden.getDeclaringType() + \".\" + overridden.getName()",
        "description": "A method that overrides a method in a superclass but does not have an 'Override' annotation cannot take advantage of compiler checks, and makes code less readable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Declarations/MissingOverrideAnnotation.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass NonConstantSourceField extends Field {\n  NonConstantSourceField() {\n    this.fromSource() and\n    not (this.isFinal() and this.isStatic())\n  }\n}\n\nfrom NonConstantSourceField f\nwhere\n  not f.isPrivate() and\n  not exists(VarAccess va | va.getVariable() = f |\n    va.getEnclosingCallable().getDeclaringType() != f.getDeclaringType()\n  ) and\n  not f.getAnAnnotation() instanceof ReflectiveAccessAnnotation\nselect f, \"This non-private field is not accessed outside of its declaring type.\"",
        "description": "A non-constant field that is not declared 'private', but is not accessed outside of its declaring type, may decrease code maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Declarations/NonPrivateField.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass Initialization extends Callable {\n  Initialization() {\n    this instanceof Constructor or\n    this instanceof InitializerMethod\n  }\n}\n\nclass AnyAssignment extends Expr {\n  AnyAssignment() {\n    this instanceof Assignment or\n    this instanceof UnaryAssignExpr\n  }\n\n  /** The expression modified by this assignment. */\n  Expr getDest() {\n    this.(Assignment).getDest() = result or\n    this.(UnaryAssignExpr).getExpr() = result\n  }\n}\n\nclass ImmutableField extends Field {\n  ImmutableField() {\n    this.fromSource() and\n    not this instanceof EnumConstant and\n    this.getType() instanceof ImmutableType and\n    // The field is only assigned to in a constructor or static initializer of the type it is declared in.\n    forall(FieldAccess fw, AnyAssignment ae |\n      fw.getField() = this and\n      fw = ae.getDest()\n    |\n      ae.getEnclosingCallable().getDeclaringType() = this.getDeclaringType() and\n      ae.getEnclosingCallable() instanceof Initialization\n    )\n  }\n}\n\nfrom ImmutableField f\nwhere not f.isFinal()\nselect f,\n  \"This immutable field is not declared final but is only assigned to during initialization.\"",
        "description": "A field of immutable type that is assigned to only in a constructor or static initializer of its declaring type, but is not declared 'final', may lead to defects and makes code less readable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Declarations/NonFinalImmutableField.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nprivate predicate isDeprecatedCallable(Callable c) {\n  c.getAnAnnotation() instanceof DeprecatedAnnotation or\n  exists(c.getDoc().getJavadoc().getATag(\"@deprecated\"))\n}\n\nfrom Call ca, Callable c\nwhere\n  ca.getCallee().getSourceDeclaration() = c and\n  isDeprecatedCallable(c) and\n  // Exclude deprecated calls from within deprecated code.\n  not isDeprecatedCallable(ca.getCaller())\nselect ca, \"Invoking $@ should be avoided because it has been deprecated.\", c,\n  c.getDeclaringType() + \".\" + c.getName()",
        "description": "Using a method or constructor that has been marked as deprecated may be dangerous or fail to take advantage of a better method or constructor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Deprecated Code/AvoidDeprecatedCallableAccess.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate lineDefinesEnum(File f, int line) {\n  exists(Location l |\n    exists(EnumType e | e.getLocation() = l) or\n    exists(EnumConstant e | e.getLocation() = l)\n  |\n    f = l.getFile() and line = l.getStartLine()\n  )\n}\n\npredicate oneLineStatement(Stmt s, File f, int line, int col) {\n  exists(Location l | s.getLocation() = l |\n    f = l.getFile() and\n    line = l.getStartLine() and\n    line = l.getEndLine() and\n    col = l.getStartColumn()\n  ) and\n  // Exclude blocks: `{break;}` is not really a violation.\n  not s instanceof BlockStmt and\n  // Exclude implicit super constructor invocations.\n  not s instanceof SuperConstructorInvocationStmt and\n  // Java enums are desugared to a whole bunch of generated statements.\n  not lineDefinesEnum(f, line)\n}\n\nfrom Stmt s, Stmt s2\nwhere\n  exists(File f, int line, int col, int col2 |\n    f.isJavaSourceFile() and\n    oneLineStatement(s, f, line, col) and\n    oneLineStatement(s2, f, line, col2) and\n    col < col2 and\n    // Don't report multiple results if more than 2 statements are on a single line.\n    col = min(int otherCol | oneLineStatement(_, f, line, otherCol))\n  )\nselect s, \"This statement is followed by another on the same line.\"",
        "description": "More than one statement per line decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Statements/OneStatementPerLine.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom IfStmt prev, IfStmt last\nwhere\n  not exists(last.getElse()) and\n  prev.getElse() = last\nselect last, \"If-else-if statement does not have a terminating else statement.\"",
        "description": "An 'if-else-if' statement without a terminating 'else' clause may allow execution to 'fall through' silently.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Statements/TerminateIfElseIfWithElse.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom SwitchStmt switch\nwhere\n  not switch.getExpr().getType() instanceof EnumType and\n  not exists(switch.getDefaultCase())\nselect switch, \"Switch statement does not have a default case.\"",
        "description": "A 'switch' statement that is based on a non-enumerated type and that does not have a 'default' case may allow execution to 'fall through' silently.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Statements/MissingDefaultInSwitch.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere\n  t.fromSource() and\n  not t instanceof AnonymousClass and\n  not t.isCompilerGenerated() and\n  not t.getName().substring(0, 1).toUpperCase() = t.getName().substring(0, 1)\nselect t, \"Class and interface names should start in uppercase.\"",
        "description": "A class or interface name that begins with a lowercase letter decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Naming/NamingConventionsRefTypes.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m\nwhere\n  m.fromSource() and\n  not m.getName().substring(0, 1).toLowerCase() = m.getName().substring(0, 1)\nselect m, \"Method names should start in lowercase.\"",
        "description": "A method name that begins with an uppercase letter decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Naming/NamingConventionsMethods.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport NamingConventionsCommon\n\nfrom Variable v\nwhere\n  v.fromSource() and\n  not v instanceof ConstantField and\n  v.getName().substring(0, 1).toLowerCase() != v.getName().substring(0, 1)\nselect v, \"Variable names should start in lowercase.\"",
        "description": "A variable name that begins with an uppercase letter decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Naming/NamingConventionsVariables.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport NamingConventionsCommon\n\nfrom ConstantField f\nwhere\n  f.fromSource() and\n  not f.getName() = \"serialVersionUID\" and\n  f.getType() instanceof ImmutableType and\n  not f.getName().toUpperCase() = f.getName()\nselect f, \"Static final fields should not contain lowercase letters.\"",
        "description": "A static, final field name that contains lowercase letters decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Naming/NamingConventionsConstants.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t, Package p\nwhere\n  p = t.getPackage() and\n  t.fromSource() and\n  not p.getName().toLowerCase() = p.getName()\nselect t,\n  \"This type belongs to the package \" + p.getName() +\n    \", which should not include uppercase letters.\"",
        "description": "A package name that contains uppercase letters decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Naming/NamingConventionsPackages.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t\nwhere\n  t.fromSource() and\n  t.getASupertype() instanceof TypeCloneable\nselect t, \"This type implements or extends Cloneable, which should be avoided.\"",
        "description": "Using the 'Cloneable' interface is bad practice. Copying an object using the 'Cloneable interface' and 'Object.clone' is error-prone.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Java Objects/AvoidCloneableInterface.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall ma, Method m\nwhere\n  m = ma.getMethod() and\n  m instanceof CloneMethod and\n  // But ignore direct calls to Object.clone\n  not m.getDeclaringType() instanceof TypeObject\nselect ma, \"Invoking a method that overrides clone() should be avoided.\"",
        "description": "Calling a method that overrides 'Object.clone' is bad practice. Copying an object using the 'Cloneable interface' and 'Object.clone' is error-prone.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Java Objects/AvoidCloneMethodAccess.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ObjectFinalizeMethod extends Method {\n  ObjectFinalizeMethod() {\n    this.getDeclaringType() instanceof TypeObject and\n    this.getName() = \"finalize\" and\n    this.hasNoParameters()\n  }\n}\n\nfrom Method m, ObjectFinalizeMethod finalize\nwhere\n  m.fromSource() and\n  m.overrides(finalize)\nselect m, \"Overriding the Object.finalize() method should be avoided.\"",
        "description": "Overriding 'Object.finalize' is not a reliable way to terminate use of resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Java Objects/AvoidFinalizeOverride.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ObjectCloneMethod extends CloneMethod {\n  ObjectCloneMethod() { this.getDeclaringType() instanceof TypeObject }\n}\n\nfrom Method m, ObjectCloneMethod clone\nwhere\n  m.fromSource() and\n  // Only consider direct overrides of Object.clone\n  m.overrides(clone)\nselect m, \"Overriding the Object.clone() method should be avoided.\"",
        "description": "Overriding 'Object.clone' is bad practice. Copying an object using the 'Cloneable interface' and 'Object.clone' is error-prone.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Advisory/Java Objects/AvoidCloneOverride.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.Nullness\n\nfrom Expr e\nwhere dereference(e) and e = nullExpr()\nselect e, \"This expression is dereferenced and may be null.\"",
        "description": "Dereferencing an expression whose value may be 'null' may cause a 'NullPointerException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Nullness/NullExprDeref.ql",
        "language": "java"
    },
    {
        "query": "import java\nprivate import semmle.code.java.dataflow.SSA\nprivate import semmle.code.java.dataflow.Nullness\n\nfrom VarAccess access, SsaSourceVariable var\nwhere alwaysNullDeref(var, access)\nselect access, \"Variable $@ is always null at this dereference.\", var.getVariable(),\n  var.getVariable().getName()",
        "description": "Dereferencing a variable whose value is 'null' causes a 'NullPointerException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Nullness/NullAlways.ql",
        "language": "java"
    },
    {
        "query": "import java\nprivate import semmle.code.java.dataflow.SSA\nprivate import semmle.code.java.dataflow.Nullness\n\nfrom VarAccess access, SsaSourceVariable var, string msg, Expr reason\nwhere\n  nullDeref(var, access, msg, reason) and\n  // Exclude definite nulls here, as these are covered by `NullAlways.ql`.\n  not alwaysNullDeref(var, access) and\n  // Kotlin enforces this already:\n  not access.getLocation().getFile().isKotlinSourceFile()\nselect access, \"Variable $@ may be null at this access \" + msg + \".\", var.getVariable(),\n  var.getVariable().getName(), reason, \"this\"",
        "description": "Dereferencing a variable whose value may be 'null' may cause a 'NullPointerException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Nullness/NullMaybe.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.controlflow.Guards\nimport semmle.code.java.dataflow.SSA\n\npredicate loopWhileTrue(LoopStmt loop) {\n  loop instanceof ForStmt and not exists(loop.getCondition())\n  or\n  loop.getCondition().(BooleanLiteral).getBooleanValue() = true\n}\n\npredicate loopExit(LoopStmt loop, Stmt exit) {\n  exit.getEnclosingStmt*() = loop.getBody() and\n  (\n    exit instanceof ReturnStmt or\n    exit.(BreakStmt).getTarget() = loop.getEnclosingStmt*()\n  )\n}\n\npredicate loopExitGuard(LoopStmt loop, Expr cond) {\n  exists(ConditionBlock cb, boolean branch |\n    cond = cb.getCondition() and\n    cond.getEnclosingStmt().getEnclosingStmt*() = loop.getBody() and\n    forex(Stmt exit | loopExit(loop, exit) | cb.controls(exit.getBasicBlock(), branch))\n  )\n}\n\npredicate mainLoopCondition(LoopStmt loop, Expr cond) {\n  loop.getCondition() = cond and\n  exists(Expr loopReentry, ControlFlowNode last |\n    if exists(loop.(ForStmt).getAnUpdate())\n    then loopReentry = loop.(ForStmt).getUpdate(0)\n    else loopReentry = cond\n  |\n    last.getEnclosingStmt().getEnclosingStmt*() = loop.getBody() and\n    last.getASuccessor().asExpr().getParent*() = loopReentry\n  )\n}\n\nfrom LoopStmt loop, Expr cond\nwhere\n  (\n    mainLoopCondition(loop, cond)\n    or\n    loopWhileTrue(loop) and loopExitGuard(loop, cond)\n  ) and\n  // None of the ssa variables in `cond` are updated inside the loop.\n  forex(SsaVariable ssa, VarRead use | ssa.getAUse() = use and use.getParent*() = cond |\n    not ssa.getCfgNode().getEnclosingStmt().getEnclosingStmt*() = loop or\n    ssa.getCfgNode().asExpr().getParent*() = loop.(ForStmt).getAnInit()\n  ) and\n  // And `cond` does not use method calls, field reads, or array reads.\n  not exists(MethodCall ma | ma.getParent*() = cond) and\n  not exists(FieldRead fa |\n    // Ignore if field is final\n    not fa.getField().isFinal() and\n    fa.getParent*() = cond\n  ) and\n  not exists(ArrayAccess aa | aa.getParent*() = cond)\nselect cond, \"$@ might not terminate, as this loop condition is constant within the loop.\", loop,\n  \"Loop\"",
        "description": "A loop condition that remains constant throughout the iteration indicates faulty logic and is likely to cause infinite looping.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Termination/ConstantLoopCondition.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ComparisonOrEqTestExpr extends Expr {\n  ComparisonOrEqTestExpr() {\n    this instanceof ComparisonExpr or\n    this instanceof ReferenceEqualityTest\n  }\n}\n\nclass Empty extends Stmt {\n  Empty() {\n    this instanceof EmptyStmt or\n    this.(BlockStmt).getNumStmt() = 0\n  }\n}\n\nclass EmptyLoop extends Stmt {\n  EmptyLoop() {\n    exists(ForStmt stmt | stmt = this |\n      not exists(stmt.getAnInit()) and\n      not exists(stmt.getAnUpdate()) and\n      stmt.getStmt() instanceof Empty\n    )\n    or\n    this.(WhileStmt).getStmt() instanceof Empty\n    or\n    this.(DoStmt).getStmt() instanceof Empty\n  }\n\n  Expr getCondition() {\n    result = this.(ForStmt).getCondition() or\n    result = this.(WhileStmt).getCondition() or\n    result = this.(DoStmt).getCondition()\n  }\n}\n\nfrom EmptyLoop loop, FieldAccess access, Field field, ComparisonOrEqTestExpr expr\nwhere\n  loop.getCondition() = expr and\n  access.isOwnFieldAccess() and\n  access.getParent() = expr and\n  field = access.getVariable() and\n  field.isStatic() and\n  not field.isFinal() and\n  not field.isVolatile() and\n  field.getType() instanceof RefType\nselect access,\n  \"Spinning on \" + field.getName() + \" in \" + loop.getEnclosingCallable().getName() + \".\"",
        "description": "Repeatedly reading a non-volatile field within the condition of an empty loop may result in an infinite loop.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Termination/SpinOnField.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom TypeSerializable serializable, Class c, Method m\nwhere\n  c.hasSupertype+(serializable) and\n  m.getDeclaringType() = c and\n  m.hasName(\"readResolve\") and\n  m.hasNoParameters() and\n  not m.getReturnType() instanceof TypeObject\nselect m,\n  \"The method \" + m.getName() + \" must be declared with a return type of Object rather than \" +\n    m.getReturnType().getName() + \".\"",
        "description": "An implementation of 'readResolve' that does not have the signature that is expected by the Java serialization framework is not recognized by the serialization mechanism.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/ReadResolveObject.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom TypeSerializable serializable, Class c, Field f\nwhere\n  not c.hasSupertype+(serializable) and\n  f.getDeclaringType() = c and\n  f.isTransient()\nselect f, \"The field \" + f.getName() + \" is transient but \" + c.getName() + \" is not Serializable.\"",
        "description": "Using the 'transient' field modifier in non-serializable classes has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/TransientNotSerializable.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m, TypeSerializable serializable, string reason\nwhere\n  m.fromSource() and\n  m.getDeclaringType().hasSupertype+(serializable) and\n  (\n    m.hasStringSignature(\"readObject(ObjectInputStream)\") or\n    m.hasStringSignature(\"readObjectNoData()\") or\n    m.hasStringSignature(\"writeObject(ObjectOutputStream)\")\n  ) and\n  (\n    not m.isPrivate() and reason = \"Method must be private\"\n    or\n    m.isStatic() and reason = \"Method must not be static\"\n    or\n    not m.getReturnType() instanceof VoidType and reason = \"Return type must be void\"\n  )\nselect m, \"Not recognized by Java serialization framework: \" + reason",
        "description": "A serialized class that implements 'readObject', 'readObjectNoData' or 'writeObject' but does not use the correct signatures causes the default serialization mechanism to be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/IncorrectSerializableMethods.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Class extern, Interface externalizable\nwhere\n  externalizable.hasQualifiedName(\"java.io\", \"Externalizable\") and\n  extern.hasSupertype+(externalizable) and\n  not extern.isAbstract() and\n  not exists(Constructor c | c = extern.getAConstructor() |\n    c.hasNoParameters() and\n    c.isPublic()\n  )\nselect extern, \"This class is Externalizable but has no public no-argument constructor.\"",
        "description": "A class that implements 'Externalizable' but does not have a public no-argument constructor causes an 'InvalidClassException' to be thrown.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/MissingVoidConstructorOnExternalizable.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Field f\nwhere\n  f.hasName(\"serialVersionUID\") and\n  (\n    not f.isFinal() or\n    not f.isStatic() or\n    not f.getType().hasName(\"long\")\n  ) and\n  f.getDeclaringType().getAStrictAncestor() instanceof TypeSerializable\nselect f, \"'serialVersionUID' should be final, static, and of type long.\"",
        "description": "A 'serialVersionUID' field that is declared in a serializable class but is of the wrong type cannot be used by the serialization framework.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/IncorrectSerialVersionUID.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate nonSerializableComparator(Class c) {\n  exists(TypeSerializable serializable, GenericInterface comparator |\n    comparator.hasQualifiedName(\"java.util\", \"Comparator\") and\n    c.getASourceSupertype+() = comparator and\n    not c.getASourceSupertype+() = serializable and\n    c.fromSource()\n  )\n}\n\npredicate sortedCollectionBaseType(RefType t) {\n  t.hasName(\"SortedSet\") or\n  t.hasName(\"SortedMap\") or\n  t.hasName(\"PriorityQueue\")\n}\n\npredicate sortedCollectionType(RefType t) {\n  sortedCollectionBaseType(t.getAnAncestor().getSourceDeclaration())\n}\n\nstring nameFor(Class c) {\n  nonSerializableComparator(c) and\n  (\n    c instanceof AnonymousClass and result = \"This comparator\"\n    or\n    not c instanceof AnonymousClass and result = c.getName()\n  )\n}\n\nfrom Class c, Expr arg, ClassInstanceExpr cie\nwhere\n  nonSerializableComparator(c) and\n  c = arg.getType() and\n  arg = cie.getAnArgument() and\n  sortedCollectionType(cie.getType())\nselect arg,\n  nameFor(c) + \" is not serializable, so should not be used as the comparator in a \" +\n    cie.getType().getName() + \".\"",
        "description": "A comparator that is passed to an ordered collection (for example, a treemap) must be serializable, otherwise the collection fails to serialize at run-time.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/NonSerializableComparator.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate isSerializable(RefType t) { t.getAnAncestor() instanceof TypeSerializable }\n\npredicate withinStaticContext(NestedClass c) {\n  c.isStatic() or\n  c.(AnonymousClass).getClassInstanceExpr().getEnclosingCallable().isStatic() // JLS 15.9.2\n}\n\nRefType enclosingInstanceType(Class inner) {\n  not withinStaticContext(inner) and\n  result = inner.(NestedClass).getEnclosingType()\n}\n\npredicate castTo(ClassInstanceExpr cie, RefType to) {\n  exists(LocalVariableDeclExpr lvd | lvd.getInit() = cie | to = lvd.getType())\n  or\n  exists(Assignment a | a.getSource() = cie | to = a.getType())\n  or\n  exists(Call call, int n | call.getArgument(n) = cie | to = call.getCallee().getParameterType(n))\n  or\n  exists(ReturnStmt ret | ret.getResult() = cie | to = ret.getEnclosingCallable().getReturnType())\n  or\n  exists(ArrayCreationExpr ace | ace.getInit().getAnInit() = cie |\n    to = ace.getType().(Array).getComponentType()\n  )\n}\n\npredicate exceptions(NestedClass inner) {\n  inner instanceof AnonymousClass\n  or\n  // Serializable objects with custom `readObject` or `writeObject` methods may write out\n  // the \"non-serializable\" fields in a different way.\n  inner.declaresMethod(\"readObject\")\n  or\n  inner.declaresMethod(\"writeObject\")\n  or\n  // Exclude cases where serialization warnings are deliberately suppressed.\n  inner.suppressesWarningsAbout(\"serial\")\n  or\n  // The class `inner` is a local class or non-public member class and\n  // all its instance expressions are cast to non-serializable types.\n  (inner instanceof LocalClass or not inner.isPublic()) and\n  forall(ClassInstanceExpr cie, RefType target |\n    cie.getConstructedType() = inner and castTo(cie, target)\n  |\n    not isSerializable(target)\n  ) and\n  // Exception 1: the expression is used as an argument to `writeObject()`.\n  not exists(Call writeCall, ClassInstanceExpr cie | cie.getConstructedType() = inner |\n    writeCall.getCallee().hasName(\"writeObject\") and\n    writeCall.getAnArgument() = cie\n  ) and\n  // Exception 2: the expression is thrown as an exception (exceptions should be serializable\n  // due to use cases such as remote procedure calls, logging, etc.)\n  not exists(ThrowStmt ts, ClassInstanceExpr cie |\n    cie.getConstructedType() = inner and\n    ts.getExpr() = cie\n  ) and\n  // Exception 3: if the programmer added a `serialVersionUID`, we interpret that\n  // as an intent to make the class serializable.\n  not exists(Field f | f.getDeclaringType() = inner | f.hasName(\"serialVersionUID\"))\n}\n\nfrom NestedClass inner, Class outer, string advice\nwhere\n  inner.getFile().isJavaSourceFile() and\n  isSerializable(inner) and\n  outer = enclosingInstanceType+(inner) and\n  not isSerializable(outer) and\n  not exceptions(inner) and\n  (\n    if inner instanceof LocalClass\n    then advice = \"Consider implementing readObject() and writeObject().\"\n    else advice = \"Consider making the class static or implementing readObject() and writeObject().\"\n  )\nselect inner, \"Serializable inner class of non-serializable class $@. \" + advice, outer,\n  outer.getName()",
        "description": "A class that is serializable with an enclosing class that is not serializable causes serialization to fail.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/NonSerializableInnerClass.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Class serial, Class nonserial, TypeSerializable serializable\nwhere\n  serial.hasSupertype(nonserial) and\n  serial.hasSupertype+(serializable) and\n  not nonserial.hasSupertype+(serializable) and\n  not exists(Constructor c |\n    c = nonserial.getSourceDeclaration().getAConstructor() and\n    c.hasNoParameters() and\n    not c.isPrivate()\n  ) and\n  // Assume if an object replaces itself prior to serialization,\n  // then it is unlikely to be directly deserialized.\n  // That means it won't need to comply with default serialization rules,\n  // such as non-serializable super-classes having a no-argument constructor.\n  not exists(Method m |\n    m = serial.getAMethod() and\n    m.hasName(\"writeReplace\") and\n    m.getReturnType() instanceof TypeObject and\n    m.hasNoParameters()\n  ) and\n  serial.fromSource()\nselect serial,\n  \"This class is serializable, but its non-serializable \" +\n    \"super-class $@ does not declare a no-argument constructor.\", nonserial, nonserial.getName()",
        "description": "A non-serializable, immediate superclass of a serializable class that does not itself declare an accessible, no-argument constructor causes deserialization to fail.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/MissingVoidConstructorsOnSerializable.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Collections\nimport semmle.code.java.Maps\nimport semmle.code.java.frameworks.javaee.ejb.EJB\n\npredicate externalizable(Interface interface) {\n  interface.hasQualifiedName(\"java.io\", \"Externalizable\")\n}\n\npredicate serializableOrExternalizable(Interface interface) {\n  externalizable(interface) or\n  interface instanceof TypeSerializable\n}\n\npredicate collectionOrMapType(RefType t) { t instanceof CollectionType or t instanceof MapType }\n\npredicate serializableType(RefType t) {\n  exists(RefType sup | sup = t.getAnAncestor() | serializableOrExternalizable(sup))\n  or\n  // Collection interfaces are not serializable, but their implementations are\n  // likely to be.\n  collectionOrMapType(t) and\n  not t instanceof RawType and\n  forall(RefType param | param = t.(ParameterizedType).getATypeArgument() | serializableType(param))\n  or\n  exists(BoundedType bt | bt = t | serializableType(bt.getUpperBoundType()))\n}\n\nRefType reasonForNonSerializableCollection(ParameterizedType par) {\n  collectionOrMapType(par) and\n  result = par.getATypeArgument() and\n  not serializableType(result)\n}\n\nstring nonSerialReason(RefType t) {\n  not serializableType(t) and\n  if exists(reasonForNonSerializableCollection(t))\n  then result = reasonForNonSerializableCollection(t).getName() + \" is not serializable\"\n  else result = t.getName() + \" is not serializable\"\n}\n\npredicate exceptions(Class c, Field f) {\n  f.getDeclaringType() = c and\n  (\n    c.isCompilerGenerated()\n    or\n    // `Serializable` objects with custom `readObject` or `writeObject` methods\n    // may write out the \"non-serializable\" fields in a different way.\n    c.declaresMethod(\"readObject\")\n    or\n    c.declaresMethod(\"writeObject\")\n    or\n    // Exclude classes with suppressed warnings.\n    c.suppressesWarningsAbout(\"serial\")\n    or\n    // Exclude anonymous classes whose `ClassInstanceExpr` is assigned to\n    // a variable on which serialization warnings are suppressed.\n    exists(Variable v |\n      v.getAnAssignedValue() = c.(AnonymousClass).getClassInstanceExpr() and\n      v.suppressesWarningsAbout(\"serial\")\n    )\n    or\n    f.isTransient()\n    or\n    f.isStatic()\n    or\n    // Classes that implement `Externalizable` completely take over control during serialization.\n    externalizable(c.getAStrictAncestor())\n    or\n    // Stateless session beans are not normally serialized during their usual life-cycle\n    // but are forced by their expected supertype to be serializable.\n    // Arguably, warnings for their non-serializable fields can therefore be suppressed in practice.\n    c instanceof StatelessSessionEjb\n    or\n    // Enum types are serialized by name, so it doesn't matter if they have non-serializable fields.\n    c instanceof EnumType\n  )\n}\n\nfrom Class c, Field f, string reason\nwhere\n  c.fromSource() and\n  c.getAStrictAncestor() instanceof TypeSerializable and\n  f.getDeclaringType() = c and\n  not exceptions(c, f) and\n  reason = nonSerialReason(f.getType())\nselect f,\n  \"This field is in a serializable class, but is not serializable itself because \" + reason + \".\"",
        "description": "A non-transient field in a serializable class must also be serializable otherwise it causes the class to fail to serialize with a 'NotSerializableException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Serialization/NonSerializableField.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method equal\nwhere\n  equal.hasName(\"equal\") and\n  equal.getNumberOfParameters() = 1 and\n  equal.getAParamType() instanceof TypeObject and\n  equal.fromSource()\nselect equal, \"Did you mean to name this method 'equals' rather than 'equal'?\"",
        "description": "A method named 'equal' may be intended to be named 'equals'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/EqualsTypo.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.StringFormat\n\nfrom FormattingCall fmtcall, FormatString fmt, int refs, int args\nwhere\n  fmtcall.getAFormatString() = fmt and\n  refs = fmt.getMaxFmtSpecIndex() and\n  args = fmtcall.getVarargsCount() and\n  refs > args\nselect fmtcall,\n  \"This format call refers to \" + refs + \" argument(s) but only supplies \" + args + \" argument(s).\"",
        "description": "A format call with an insufficient number of arguments causes an 'IllegalFormatException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/MissingFormatArg.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass NewStringBufferOrBuilder extends ClassInstanceExpr {\n  NewStringBufferOrBuilder() { this.getConstructedType() instanceof StringBuildingType }\n\n  string getName() { result = this.getConstructedType().getName() }\n}\n\nfrom NewStringBufferOrBuilder nsb\nwhere nsb.getArgument(0).getType().hasName(\"char\")\nselect nsb,\n  \"A character value passed to 'new \" + nsb.getName() + \"' is interpreted as the buffer capacity.\"",
        "description": "A character value is passed to the constructor of 'StringBuffer' or 'StringBuilder'. This value will be converted to an integer and interpreted as the buffer's initial capacity, which is probably not intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/StringBufferCharInit.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass DangerousExpression extends Expr {\n  DangerousExpression() {\n    exists(Expr e | this = e.getParent*() |\n      e instanceof MethodCall or\n      e instanceof ArrayAccess or\n      exists(e.(FieldAccess).getQualifier())\n    )\n  }\n}\n\nclass NonShortCircuit extends BinaryExpr {\n  NonShortCircuit() {\n    (\n      this instanceof AndBitwiseExpr or\n      this instanceof OrBitwiseExpr\n    ) and\n    this.getLeftOperand().getType().hasName(\"boolean\") and\n    this.getRightOperand().getType().hasName(\"boolean\") and\n    this.getRightOperand() instanceof DangerousExpression\n  }\n}\n\nfrom NonShortCircuit e\nselect e, \"Possibly dangerous use of non-short circuit logic.\"",
        "description": "Using a bitwise logical operator on a boolean where a conditional-and or conditional-or operator is intended may yield the wrong result or cause an exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/DangerousNonCircuitLogic.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Collections\nimport semmle.code.java.Maps\n\nabstract class SizeOfContainer extends Expr {\n  abstract string getContainerKind();\n}\n\nclass ArrayLengthRead extends FieldRead, SizeOfContainer {\n  ArrayLengthRead() { this.getField() instanceof ArrayLengthField }\n\n  override string getContainerKind() { result = \"an array\" }\n}\n\nclass StringLengthRead extends MethodCall, SizeOfContainer {\n  StringLengthRead() { this.getMethod() instanceof StringLengthMethod }\n\n  override string getContainerKind() { result = \"a string\" }\n}\n\nclass CollectionSizeCall extends MethodCall, SizeOfContainer {\n  CollectionSizeCall() { this.getMethod() instanceof CollectionSizeMethod }\n\n  override string getContainerKind() { result = \"a collection\" }\n}\n\nclass MapSizeCall extends MethodCall, SizeOfContainer {\n  MapSizeCall() { this.getMethod() instanceof MapSizeMethod }\n\n  override string getContainerKind() { result = \"a map\" }\n}\n\nclass IntegralZeroLiteral extends Literal {\n  IntegralZeroLiteral() {\n    (this instanceof IntegerLiteral or this instanceof LongLiteral) and\n    this.getValue().toInt() = 0\n  }\n}\n\nprivate predicate comparisonOfContainerSizeToZero(\n  BinaryExpr e, string containerKind, string trueOrFalse\n) {\n  exists(Expr l, Expr r | l = e.getLeftOperand() and r = e.getRightOperand() |\n    e instanceof LTExpr and\n    l.(SizeOfContainer).getContainerKind() = containerKind and\n    r instanceof IntegralZeroLiteral and\n    trueOrFalse = \"false\"\n    or\n    e instanceof GTExpr and\n    l instanceof IntegralZeroLiteral and\n    r.(SizeOfContainer).getContainerKind() = containerKind and\n    trueOrFalse = \"false\"\n    or\n    e instanceof GEExpr and\n    l.(SizeOfContainer).getContainerKind() = containerKind and\n    r instanceof IntegralZeroLiteral and\n    trueOrFalse = \"true\"\n    or\n    e instanceof LEExpr and\n    l instanceof IntegralZeroLiteral and\n    r.(SizeOfContainer).getContainerKind() = containerKind and\n    trueOrFalse = \"true\"\n  )\n}\n\nfrom BinaryExpr e, string containerKind, string trueOrFalse\nwhere comparisonOfContainerSizeToZero(e, containerKind, trueOrFalse)\nselect e,\n  \"This expression is always \" + trueOrFalse + \", since \" + containerKind +\n    \" can never have negative size.\"",
        "description": "Comparing the size of a container to zero with this operator will always return the same value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/ContainerSizeCmpZero.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.StringFormat\n\nint getNumberOfReferencedIndices(FormattingCall fmtcall) {\n  exists(int maxref, int skippedrefs |\n    maxref = max(FormatString fmt | fmtcall.getAFormatString() = fmt | fmt.getMaxFmtSpecIndex()) and\n    skippedrefs =\n      count(int i |\n        forex(FormatString fmt | fmtcall.getAFormatString() = fmt |\n          i = fmt.getASkippedFmtSpecIndex()\n        )\n      ) and\n    result = maxref - skippedrefs\n  )\n}\n\nfrom FormattingCall fmtcall, int refs, int args\nwhere\n  refs = getNumberOfReferencedIndices(fmtcall) and\n  args = fmtcall.getVarargsCount() and\n  refs < args and\n  not (fmtcall.hasTrailingThrowableArgument() and refs = args - 1)\nselect fmtcall,\n  \"This format call refers to \" + refs + \" argument(s) but supplies \" + args + \" argument(s).\"",
        "description": "A format call with a format string that refers to fewer arguments than the number of supplied arguments will silently ignore the additional arguments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/UnusedFormatArg.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npragma[nomagic]\npredicate toCompare(VarAccess left, VarAccess right) {\n  exists(AssignExpr assign | assign.getDest() = left and assign.getSource() = right)\n  or\n  exists(VarAccess outerleft, VarAccess outerright |\n    toCompare(outerleft, outerright) and\n    left = outerleft.getQualifier() and\n    right = outerright.getQualifier()\n  )\n}\n\npredicate local(RefType enclosingType, VarAccess v) {\n  enclosingType = v.getQualifier().(ThisAccess).getType()\n  or\n  not exists(v.getQualifier()) and enclosingType = v.getEnclosingCallable().getDeclaringType()\n}\n\npragma[nomagic]\npredicate sameVariable(VarAccess left, VarAccess right) {\n  toCompare(left, right) and\n  pragma[only_bind_out](left.getVariable()) = pragma[only_bind_out](right.getVariable()) and\n  (\n    exists(Expr q1, Expr q2 |\n      q1 = left.getQualifier() and\n      sameVariable(q1, q2) and\n      q2 = right.getQualifier()\n    )\n    or\n    exists(RefType enclosingType |\n      local(enclosingType, pragma[only_bind_out](left)) and\n      local(enclosingType, pragma[only_bind_out](right))\n    )\n  )\n}\n\nfrom AssignExpr assign\nwhere sameVariable(assign.getDest(), assign.getSource())\nselect assign,\n  \"This expression assigns \" + assign.getDest().(VarAccess).getVariable().getName() + \" to itself.\"",
        "description": "Assigning a variable to itself has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/SelfAssignment.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m\nwhere\n  m.hasName(\"hashcode\") and\n  m.hasNoParameters() and\n  m.fromSource()\nselect m, \"Should this method be called 'hashCode' rather than 'hashcode'?\"",
        "description": "A method named 'hashcode' may be intended to be named 'hashCode'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/HashCodeTypo.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass SourceStringLiteral extends StringLiteral {\n  SourceStringLiteral() { this.getCompilationUnit().fromSource() }\n}\n\nfrom SourceStringLiteral s, string word\nwhere\n  // Match ` word\" + \"word2` taking punctuation after `word` into account.\n  // `word2` is only matched on the first character whereas `word` is matched\n  // completely to distinguish grammatical punctuation after which a space is\n  // needed, and intra-identifier punctuation in, for example, a fully\n  // qualified java class name.\n  pragma[only_bind_into](s)\n      .getLiteral()\n      .regexpCapture(\".* (([-A-Za-z/'\\\\.:,]*[a-zA-Z]|[0-9]+)[\\\\.:,;!?']*)\\\"[^\\\"]*\\\\+[^\\\"]*\\\"[a-zA-Z].*\",\n        1) = word and\n  not word.regexpMatch(\".*[,\\\\.:].*[a-zA-Z].*[^a-zA-Z]\")\nselect s, \"This string appears to be missing a space after '\" + word + \"'.\"",
        "description": "Joining strings at compile-time to construct a string literal so that two words are concatenated without a separating space usually indicates a text error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/MissingSpaceTypo.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m\nwhere\n  m.hasName(\"tostring\") and\n  m.hasNoParameters()\nselect m, \"Should this method be called 'toString' rather than 'tostring'?\"",
        "description": "A method named 'tostring' may be intended to be named 'toString'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/ToStringTypo.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ConstructorCall c, string format\nwhere\n  c.getConstructedType().hasQualifiedName(\"java.text\", \"SimpleDateFormat\") and\n  format = c.getArgument(0).(StringLiteral).getValue() and\n  format.matches(\"%Y%\") and\n  format.matches(\"%M%\")\nselect c, \"Date formatter is passed a suspicious pattern \\\"\" + format + \"\\\".\"",
        "description": "Using a data format that includes both 'M' and 'Y' is likely to give unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/SuspiciousDateFormat.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.controlflow.Guards\nimport semmle.code.java.dataflow.SSA\n\npredicate instanceOfCheck(InstanceOfExpr ioe, VarAccess va, RefType t) {\n  ioe.getExpr() = va and\n  ioe.getCheckedType().getSourceDeclaration() = t\n}\n\npredicate requiresInstanceOf(Expr e, VarAccess va, RefType t) {\n  // `e` is a cast of the form `(t)va`\n  e.(CastExpr).getExpr() = va and t = e.getType().(RefType).getSourceDeclaration()\n  or\n  // `e` is `va instanceof t`\n  instanceOfCheck(e, va, t)\n}\n\npredicate contradictoryTypeCheck(Expr e, Variable v, RefType t, RefType sup, Expr cond) {\n  exists(SsaVariable ssa |\n    ssa.getSourceVariable().getVariable() = v and\n    requiresInstanceOf(e, ssa.getAUse(), t) and\n    sup = t.getAnAncestor() and\n    instanceOfCheck(cond, ssa.getAUse(), sup) and\n    cond.(Guard).controls(e.getBasicBlock(), false) and\n    not t instanceof ErrorType and\n    not sup instanceof ErrorType\n  )\n}\n\nfrom Expr e, Variable v, RefType t, RefType sup, Expr cond\nwhere contradictoryTypeCheck(e, v, t, sup, cond)\nselect e, \"This access of $@ cannot be of type $@, since $@ ensures that it is not of type $@.\", v,\n  v.getName(), t, t.getName(), cond, \"this expression\", sup, sup.getName()",
        "description": "Contradictory dynamic type checks in `instanceof` expressions and casts may cause dead code or even runtime errors, and usually indicate a logic error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/ContradictoryTypeChecks.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m\nwhere\n  m.hasName(m.getDeclaringType().getName()) and\n  m.fromSource()\nselect m, \"This method has the same name as its declaring class. Should it be a constructor?\"",
        "description": "A method that has the same name as its declaring type may have been intended to be a constructor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/ConstructorTypo.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ForStmt inner, Variable iteration, ForStmt outer\nwhere\n  iteration = inner.getAnIterationVariable() and\n  iteration = outer.getAnIterationVariable() and\n  inner.getEnclosingStmt+() = outer and\n  inner.getBasicBlock().getASuccessor+() = outer.getCondition().getBasicBlock()\nselect inner.getCondition(), \"Nested for statement uses loop variable $@ of enclosing $@.\",\n  iteration, iteration.getName(), outer, \"for statement\"",
        "description": "Nested loops in which the iteration variable is the same for each loop are difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Likely Typos/NestedLoopsSameVariable.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ThreadClass extends Class {\n  ThreadClass() { this.hasQualifiedName(\"java.lang\", \"Thread\") }\n\n  /**\n   * Any constructor of `java.lang.Thread` _without_ a parameter of type `Runnable`;\n   * these require overriding the `Thread.run()` method in order to do anything useful.\n   */\n  Constructor getAConstructorWithoutRunnableParam() {\n    result = this.getAConstructor() and\n    (\n      result.getNumberOfParameters() = 0\n      or\n      result.getNumberOfParameters() = 1 and\n      result.getParameter(0).getType().(RefType).hasQualifiedName(\"java.lang\", \"String\")\n      or\n      result.getNumberOfParameters() = 2 and\n      result.getParameter(0).getType().(RefType).hasQualifiedName(\"java.lang\", \"ThreadGroup\") and\n      result.getParameter(1).getType().(RefType).hasQualifiedName(\"java.lang\", \"String\")\n    )\n  }\n\n  /**\n   * Any constructor of `java.lang.Thread` _with_ a parameter of type `Runnable`;\n   * these ensure that the `Thread.run()` method calls the `Runnable.run()` method.\n   */\n  Constructor getAConstructorWithRunnableParam() {\n    result = this.getAConstructor() and\n    not exists(Constructor c | c = result | result = this.getAConstructorWithoutRunnableParam())\n  }\n}\n\nfrom ClassInstanceExpr cie, ThreadClass thread, Class emptythread\nwhere\n  emptythread.hasSupertype*(thread) and\n  not exists(Class middle, Method run |\n    run.hasName(\"run\") and\n    run.isPublic() and\n    not run.isAbstract() and\n    run.hasNoParameters() and\n    middle.getAMethod() = run and\n    middle.hasSupertype+(thread) and\n    emptythread.hasSupertype*(middle)\n  ) and\n  not cie.getConstructor().callsConstructor*(thread.getAConstructorWithRunnableParam()) and\n  cie.getType().(RefType).getSourceDeclaration() = emptythread\nselect cie,\n  \"Thread \" + emptythread.getName() + \" has a useless empty run() inherited from java.lang.Thread.\"",
        "description": "Thread instances that neither get an argument of type 'Runnable' passed to their constructor nor override the 'Thread.run' method are likely to have no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/EmptyRunMethodInThread.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate withinInitializer(Expr e) {\n  e.getEnclosingCallable().hasName(\"<clinit>\") or\n  e.getEnclosingCallable() instanceof Constructor\n}\n\npredicate locallySynchronized(MethodCall ma) {\n  ma.getEnclosingStmt().getEnclosingStmt+() instanceof SynchronizedStmt\n}\n\npredicate hasUnsynchronizedCall(Method m) {\n  m.isPublic() and not m.isSynchronized()\n  or\n  exists(MethodCall ma, Method caller | ma.getMethod() = m and caller = ma.getEnclosingCallable() |\n    hasUnsynchronizedCall(caller) and\n    not caller.isSynchronized() and\n    not locallySynchronized(ma)\n  )\n}\n\npredicate withinLocalSynchronization(Expr e) {\n  e.getEnclosingCallable().isSynchronized() or\n  e.getEnclosingStmt().getEnclosingStmt+() instanceof SynchronizedStmt\n}\n\nclass MyField extends Field {\n  MyField() {\n    this.fromSource() and\n    not this.isFinal() and\n    not this.isVolatile() and\n    not this.getDeclaringType() instanceof EnumType\n  }\n\n  int getNumSynchedAccesses() {\n    result =\n      count(Expr synched | synched = this.getAnAccess() and withinLocalSynchronization(synched))\n  }\n\n  int getNumAccesses() { result = count(this.getAnAccess()) }\n\n  float getPercentSynchedAccesses() {\n    result = this.getNumSynchedAccesses().(float) / this.getNumAccesses()\n  }\n}\n\nfrom MyField f, Expr e, int percent\nwhere\n  e = f.getAnAccess() and\n  not withinInitializer(e) and\n  not withinLocalSynchronization(e) and\n  hasUnsynchronizedCall(e.getEnclosingCallable()) and\n  f.getNumSynchedAccesses() > 0 and\n  percent = (f.getPercentSynchedAccesses() * 100).floor() and\n  percent > 80\nselect e,\n  \"Unsynchronized access to $@, but \" + percent.toString() +\n    \"% of accesses to this field are synchronized.\", f,\n  f.getDeclaringType().getName() + \".\" + f.getName()",
        "description": "If a field is mostly accessed in a synchronized context, but occasionally accessed in a non-synchronized way, the non-synchronized accesses may lead to race conditions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/InconsistentAccess.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DoubleCheckedLocking\n\npredicate allFieldsFinal(Class c) { forex(Field f | c.inherits(f) | f.isFinal()) }\n\npredicate immutableFieldType(Type t) {\n  allFieldsFinal(t) or\n  t instanceof ImmutableType\n}\n\nfrom IfStmt if1, IfStmt if2, SynchronizedStmt sync, Field f\nwhere\n  doubleCheckedLocking(if1, if2, sync, f) and\n  not f.isVolatile() and\n  not (\n    // Non-volatile double-checked locking is ok when the object is immutable and\n    // there is only a single non-synchronized field read.\n    immutableFieldType(f.getType()) and\n    1 =\n      strictcount(FieldAccess fa |\n        fa.getField() = f and\n        fa.getEnclosingCallable() = sync.getEnclosingCallable() and\n        not fa.getEnclosingStmt().getEnclosingStmt*() = sync.getBlock()\n      )\n  )\nselect sync, \"Double-checked locking on the non-volatile field $@ is not thread-safe.\", f,\n  f.toString()",
        "description": "A repeated check on a non-volatile field is not thread-safe, and could result in unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/DoubleCheckedLocking.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass WaitMethod extends Method {\n  WaitMethod() {\n    this.getName() = \"wait\" and\n    this.getDeclaringType() instanceof TypeObject\n  }\n}\n\nfrom MethodCall ma\nwhere\n  ma.getMethod() instanceof WaitMethod and\n  not ma.getEnclosingStmt().getEnclosingStmt*() instanceof LoopStmt\nselect ma, \"To avoid spurious wake-ups, 'wait' should only be called inside a loop.\"",
        "description": "Calling 'wait' outside a loop may result in the program continuing before the expected condition is met.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/WaitOutsideLoop.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass RunMethod extends Method {\n  RunMethod() {\n    this.hasName(\"run\") and\n    this.hasNoParameters() and\n    this.getDeclaringType().getAnAncestor().hasQualifiedName(\"java.lang\", \"Thread\")\n  }\n}\n\nfrom MethodCall m, RunMethod run\nwhere\n  m.getMethod() = run and\n  not m.getEnclosingCallable() instanceof RunMethod\nselect m, \"Calling 'Thread.run()' rather than 'Thread.start()' will not spawn a new thread.\"",
        "description": "Directly calling a 'Thread' object's 'run' method does not start a separate thread but executes the method within the current thread.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/CallsToRunnableRun.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass YieldMethod extends Method {\n  YieldMethod() {\n    this.getName() = \"yield\" and\n    this.getDeclaringType().hasQualifiedName(\"java.lang\", \"Thread\")\n  }\n}\n\nclass YieldMethodCall extends MethodCall {\n  YieldMethodCall() { this.getMethod() instanceof YieldMethod }\n}\n\nfrom YieldMethodCall yield\nwhere yield.getCompilationUnit().fromSource()\nselect yield,\n  \"Do not use Thread.yield(). It is non-portable and will most likely not have the desired effect.\"",
        "description": "Calling 'Thread.yield' may have no effect, and is not a reliable way to prevent a thread from taking up too much execution time.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/YieldCalls.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass PriorityMethod extends Method {\n  PriorityMethod() {\n    (this.getName() = \"setPriority\" or this.getName() = \"getPriority\") and\n    this.getDeclaringType().hasQualifiedName(\"java.lang\", \"Thread\")\n  }\n}\n\nclass PriorityMethodCall extends MethodCall {\n  PriorityMethodCall() { this.getMethod() instanceof PriorityMethod }\n}\n\nfrom PriorityMethodCall ma\nwhere ma.getCompilationUnit().fromSource()\nselect ma, \"Avoid using thread priorities. The effect is unpredictable and not portable.\"",
        "description": "Setting thread priorities to control interactions between threads is not portable, and may not have the desired effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/PriorityCalls.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Method m\nwhere\n  m.getDeclaringType().getAnAncestor() instanceof TypeSerializable and\n  m.hasName(\"writeObject\") and\n  m.getNumberOfParameters() = 1 and\n  m.getAParamType() instanceof TypeObjectOutputStream and\n  m.isSynchronized() and\n  not exists(Method s |\n    m.getDeclaringType().inherits(s) and\n    s.isSynchronized() and\n    s != m\n  )\nselect m, \"Class's writeObject() method is synchronized but nothing else is.\"",
        "description": "Classes with a synchronized 'writeObject' method but no other synchronized methods usually lack a sufficient level of synchronization.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/SynchWriteObject.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass MethodRequiresSynch extends Method {\n  MethodRequiresSynch() {\n    (\n      this.hasName(\"wait\") or\n      this.hasName(\"notify\") or\n      this.hasName(\"notifyAll\")\n    ) and\n    this.getDeclaringType().hasQualifiedName(\"java.lang\", \"Object\")\n  }\n}\n\nprivate predicate synchronizedCallable(Callable c) {\n  c.isSynchronized()\n  or\n  c.isPrivate() and\n  forall(MethodCall parent | parent.getCallee() = c |\n    synchronizedThisAccess(parent, c.getDeclaringType())\n  )\n}\n\nprivate predicate synchronizedThisAccess(MethodCall ma, Type thisType) {\n  // Are we inside a synchronized method?\n  exists(Callable c |\n    c = ma.getEnclosingCallable() and\n    c.getDeclaringType() = thisType and\n    synchronizedCallable(c)\n  )\n  or\n  // Is there an enclosing `synchronized` statement?\n  exists(SynchronizedStmt s, ThisAccess x |\n    s.getAChild*() = ma.getEnclosingStmt() and\n    s.getExpr() = x and\n    x.getType() = thisType\n  )\n}\n\npredicate synchronizedVarAccess(VarAccess x) {\n  exists(SynchronizedStmt s, VarAccess y |\n    s.getAChild*() = x.getEnclosingStmt() and\n    s.getExpr() = y and\n    y.getVariable() = x.getVariable() and\n    y.toString() = x.toString()\n  )\n}\n\nprivate predicate unsynchronizedExplicitThisAccess(MethodCall ma) {\n  exists(ThisAccess x |\n    x = ma.getQualifier() and\n    not synchronizedThisAccess(ma, x.getType())\n  )\n}\n\nprivate predicate unsynchronizedImplicitThisAccess(MethodCall ma) {\n  not ma.hasQualifier() and\n  not synchronizedThisAccess(ma, ma.getEnclosingCallable().getDeclaringType())\n}\n\nprivate predicate unsynchronizedVarAccess(MethodCall ma) {\n  exists(VarAccess x |\n    x = ma.getQualifier() and\n    not synchronizedVarAccess(x)\n  )\n}\n\nfrom MethodCall ma, Method m\nwhere\n  m = ma.getMethod() and\n  m instanceof MethodRequiresSynch and\n  (\n    unsynchronizedExplicitThisAccess(ma) or\n    unsynchronizedImplicitThisAccess(ma) or\n    unsynchronizedVarAccess(ma)\n  )\nselect ma, \"Calling \" + m.getName() + \" on an unsynchronized object.\"",
        "description": "Calling 'wait', 'notify', or 'notifyAll' on an object which has not been locked (with a synchronized method or statement) will throw.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/NotifyWithoutSynch.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nprivate Field synchField(SynchronizedStmt s) { result = s.getExpr().(VarAccess).getVariable() }\n\nprivate Field assignmentToField(Assignment a) { result = a.getDest().(VarAccess).getVariable() }\n\nfrom SynchronizedStmt s, Field f, Assignment a\nwhere\n  synchField(s) = f and\n  assignmentToField(a) = f and\n  a.getEnclosingStmt().getEnclosingStmt*() = s\nselect a, \"Synchronization on field $@ in futile attempt to guard that field.\", f,\n  f.getDeclaringType().getName() + \".\" + f.getName()",
        "description": "Synchronizing on a field and updating that field while the lock is held is unlikely to provide the desired thread safety.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/FutileSynchOnField.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate isSynchronizedByBlock(Method m) {\n  exists(SynchronizedStmt sync, Expr on | sync = m.getBody().getAChild*() and on = sync.getExpr() |\n    if m.isStatic()\n    then on.(TypeLiteral).getReferencedType() = m.getDeclaringType()\n    else on.(ThisAccess).getType().(RefType).getSourceDeclaration() = m.getDeclaringType()\n  )\n}\n\npragma[nomagic]\npredicate bothAccessVolatileField(Method set, Method get) {\n  exists(Field f | f.isVolatile() |\n    f = get.(GetterMethod).getField() and\n    f.getAnAccess().(FieldWrite).getEnclosingCallable() = set\n  )\n}\n\nfrom Method set, Method get\nwhere\n  set.getDeclaringType() = get.getDeclaringType() and\n  set.getName().matches(\"set%\") and\n  get.getName() = \"get\" + set.getName().substring(3, set.getName().length()) and\n  set.isSynchronized() and\n  not (get.isSynchronized() or isSynchronizedByBlock(get)) and\n  not bothAccessVolatileField(set, get) and\n  set.fromSource()\nselect get, \"This get method is unsynchronized, but the corresponding $@ is synchronized.\", set,\n  \"set method\"",
        "description": "If a class has a synchronized 'set' method, and a similarly-named 'get' method is not also synchronized, calls to the 'get' method may not return a consistent state for the object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/SynchSetUnsynchGet.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport DoubleCheckedLocking\n\npredicate whitelistedMethod(Method m) {\n  m.getDeclaringType().hasQualifiedName(\"java.io\", _) and\n  m.hasName(\"println\")\n}\n\nclass SideEffect extends Expr {\n  SideEffect() {\n    this instanceof MethodCall and\n    not whitelistedMethod(this.(MethodCall).getMethod())\n    or\n    this.(Assignment).getDest() instanceof FieldAccess\n  }\n}\n\nfrom IfStmt if1, IfStmt if2, SynchronizedStmt sync, Field f, AssignExpr a, SideEffect se\nwhere\n  doubleCheckedLocking(if1, if2, sync, f) and\n  a.getEnclosingStmt().getEnclosingStmt*() = if2.getThen() and\n  se.getEnclosingStmt().getEnclosingStmt*() = sync.getBlock() and\n  a.getControlFlowNode().getASuccessor+().asExpr() = se and\n  a.getDest().(FieldAccess).getField() = f\nselect a,\n  \"Potential race condition. This assignment to $@ is visible to other threads before the subsequent statements are executed.\",\n  f, f.toString()",
        "description": "Performing additional initialization on an object after assignment to a shared variable guarded by double-checked locking is not thread-safe, and could result in unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/DoubleCheckedLockingWithInitRace.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass NullEQExpr extends ValueOrReferenceEqualsExpr {\n  NullEQExpr() { exists(NullLiteral l | l.getParent() = this) }\n}\n\nclass StaticFieldInit extends AssignExpr {\n  StaticFieldInit() { exists(Field f | f.isStatic() | f.getAnAccess() = this.getDest()) }\n\n  Field getField() { result.getAnAccess() = this.getDest() }\n\n  IfStmt getAnEnclosingNullCheck() {\n    result.getThen().getAChild*() = this.getEnclosingStmt() and\n    result.getCondition().(NullEQExpr).getAChildExpr() = this.getField().getAnAccess()\n  }\n\n  IfStmt getNearestNullCheck() {\n    result = this.getAnEnclosingNullCheck() and\n    not result.getAChild+() = this.getAnEnclosingNullCheck()\n  }\n}\n\nclass LockObjectField extends Field {\n  LockObjectField() {\n    this.isStatic() and\n    forex(Callable init | init = this.getAnAssignedValue().getEnclosingCallable() |\n      init instanceof StaticInitializer\n    )\n  }\n}\n\nclass ValidSynchStmt extends Stmt {\n  ValidSynchStmt() {\n    // It's OK to lock the enclosing class.\n    this.(SynchronizedStmt).getExpr().(TypeLiteral).getReferencedType() =\n      this.getEnclosingCallable().getDeclaringType()\n    or\n    // It's OK to lock on a \"lock object field\".\n    this.(SynchronizedStmt).getExpr().(FieldRead).getField() instanceof LockObjectField\n    or\n    // Locking via `ReentrantLock` lock object instead of synchronized statement.\n    exists(TryStmt try, LockObjectField lockField |\n      this = try.getBlock() and\n      lockField.getType().(RefType).hasQualifiedName(\"java.util.concurrent.locks\", \"ReentrantLock\") and\n      exists(MethodCall lockAction |\n        lockAction.getQualifier() = lockField.getAnAccess() and\n        lockAction.getMethod().getName() = \"lock\" and\n        dominates(lockAction.getControlFlowNode(), this.getControlFlowNode())\n      ) and\n      exists(MethodCall unlockAction |\n        unlockAction.getQualifier() = lockField.getAnAccess() and\n        unlockAction.getMethod().getName() = \"unlock\" and\n        postDominates(unlockAction.getControlFlowNode(), this.getControlFlowNode())\n      )\n    )\n  }\n}\n\nclass StaticMethod extends Method {\n  StaticMethod() { this.isStatic() }\n\n  predicate bodyIsSynchronized() {\n    this.isSynchronized() or\n    this.getBody().getAChild() instanceof ValidSynchStmt\n  }\n}\n\nfrom StaticMethod method, IfStmt i, StaticFieldInit init, string message\nwhere\n  i = init.getNearestNullCheck() and\n  method = i.getEnclosingCallable() and\n  not method.bodyIsSynchronized() and\n  not method instanceof StaticInitializer and\n  // There must be an unsynchronized read.\n  exists(IfStmt unsyncNullCheck | unsyncNullCheck = init.getAnEnclosingNullCheck() |\n    not unsyncNullCheck.getEnclosingStmt+() instanceof ValidSynchStmt\n  ) and\n  if i.getEnclosingStmt+() instanceof ValidSynchStmt\n  then (\n    not init.getField().isVolatile() and\n    message = \"The field must be volatile.\"\n  ) else (\n    if i.getEnclosingStmt+() instanceof SynchronizedStmt\n    then message = \"Bad synchronization.\"\n    else message = \"Missing synchronization.\"\n  )\nselect init, \"Incorrect lazy initialization of static field $@: \" + message, init.getField() as f,\n  f.getName()",
        "description": "Initializing a static field without synchronization can be problematic in a multi-threaded context.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/LazyInitStaticField.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass WaitMethod extends Method {\n  WaitMethod() {\n    this.hasName(\"wait\") and\n    this.hasNoParameters() and\n    this.getDeclaringType().hasQualifiedName(\"java.lang\", \"Object\")\n  }\n}\n\nclass ConditionInterface extends Interface {\n  ConditionInterface() { this.hasQualifiedName(\"java.util.concurrent.locks\", \"Condition\") }\n}\n\nfrom MethodCall ma, ConditionInterface condition\nwhere\n  ma.getMethod() instanceof WaitMethod and\n  ma.getQualifier().getType().(RefType).hasSupertype*(condition)\nselect ma, \"Waiting for a condition should use Condition.await, not Object.wait.\"",
        "description": "Calling 'wait' on a 'Condition' interface may result in unexpected behavior and is probably a typographical error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/CallsToConditionWait.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass SleepMethod extends Method {\n  SleepMethod() {\n    this.getName() = \"sleep\" and\n    this.getDeclaringType().hasQualifiedName(\"java.lang\", \"Thread\")\n  }\n}\n\nclass SleepMethodCall extends MethodCall {\n  SleepMethodCall() { this.getMethod() instanceof SleepMethod }\n}\n\nclass WaitMethod extends Method {\n  WaitMethod() {\n    this.getName() = \"wait\" and\n    this.getDeclaringType() instanceof TypeObject\n  }\n}\n\nclass ConcurrentMethod extends Method {\n  ConcurrentMethod() { this.getDeclaringType().getQualifiedName().matches(\"java.util.concurrent%\") }\n}\n\nclass CommunicationMethod extends Method {\n  CommunicationMethod() {\n    this instanceof WaitMethod or\n    this instanceof ConcurrentMethod\n  }\n}\n\npredicate callsCommunicationMethod(Method source) {\n  source instanceof CommunicationMethod\n  or\n  exists(MethodCall a, Method overridingMethod, Method target |\n    callsCommunicationMethod(overridingMethod) and\n    overridingMethod.overridesOrInstantiates*(target) and\n    target = a.getMethod() and\n    a.getEnclosingCallable() = source\n  )\n}\n\nclass DangerStmt extends Stmt {\n  DangerStmt() { exists(SleepMethodCall sleep | sleep.getEnclosingStmt() = this) }\n}\n\nfrom WhileStmt s, DangerStmt d\nwhere\n  d.getEnclosingStmt+() = s and\n  not exists(MethodCall call | callsCommunicationMethod(call.getMethod()) |\n    call.getEnclosingStmt().getEnclosingStmt*() = s\n  )\nselect d, \"Prefer wait/notify or java.util.concurrent to communicate between threads.\"",
        "description": "Calling 'Thread.sleep' to control thread interaction is less effective than waiting for a notification and may also result in race conditions. Merely synchronizing over shared variables in a loop to control thread interaction may waste system resources and cause performance problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/BusyWait.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass InvokeInterfaceOrVirtualMethodCall extends MethodCall {\n  InvokeInterfaceOrVirtualMethodCall() {\n    this.getMethod().getDeclaringType() instanceof Interface or\n    not this.hasQualifier() or\n    not this.getQualifier() instanceof SuperAccess\n  }\n}\n\nfrom InvokeInterfaceOrVirtualMethodCall ma, Method m\nwhere\n  ma.getMethod() = m and\n  m.hasName(\"notify\") and\n  m.hasNoParameters()\nselect ma, \"Using notify rather than notifyAll.\"",
        "description": "Calling 'notify' instead of 'notifyAll' may fail to wake up the correct thread and cannot wake up multiple threads.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/NotifyNotNotifyAll.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nprivate predicate cannotBeExtended(RefType t) {\n  t.isFinal()\n  or\n  // If the class is private, all possible subclasses are known.\n  t.isPrivate() and\n  not exists(RefType sub | sub != t | sub.getAnAncestor() = t)\n}\n\nfrom MethodCall m, Constructor c, Class clazz\nwhere\n  m.getMethod().getDeclaringType().hasQualifiedName(\"java.lang\", \"Thread\") and\n  m.getMethod().getName() = \"start\" and\n  m.getEnclosingCallable() = c and\n  c.getDeclaringType() = clazz and\n  not cannotBeExtended(clazz)\nselect m, \"Class $@ starts a thread in its constructor.\", clazz, clazz.getName()",
        "description": "Starting a thread within a constructor may cause the thread to start before any subclass constructor has completed its initialization, causing unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/StartInConstructor.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.DataFlow\n\nclass Sink extends Call {\n  Sink() {\n    this.getCallee()\n        .hasQualifiedName(\"java.util.concurrent\", \"ThreadPoolExecutor\", \"setCorePoolSize\") or\n    this.getCallee()\n        .hasQualifiedName(\"java.util.concurrent\", \"ScheduledThreadPoolExecutor\",\n          \"ScheduledThreadPoolExecutor\")\n  }\n}\n\nfrom IntegerLiteral zero, Sink set\nwhere\n  DataFlow::localFlow(DataFlow::exprNode(zero), DataFlow::exprNode(set.getArgument(0))) and\n  zero.getIntValue() = 0\nselect set, \"ScheduledThreadPoolExecutor.corePoolSize is set to have 0 threads.\"",
        "description": "Setting `java.util.concurrent.ScheduledThreadPoolExecutor` to have 0 threads serves no purpose and may indicate programmer error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/ScheduledThreadPoolExecutorZeroThread.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Field f, Class dateFormat\nwhere\n  f.isStatic() and\n  (f.isPublic() or f.isProtected()) and\n  dateFormat.hasQualifiedName(\"java.text\", \"DateFormat\") and\n  f.getType().(RefType).hasSupertype*(dateFormat) and\n  exists(MethodCall m | m.getQualifier().(VarAccess).getVariable() = f)\nselect f,\n  \"Found static field of type \" + f.getType().getName() + \" in \" + f.getDeclaringType().getName() +\n    \".\"",
        "description": "Static fields of type 'DateFormat' (or its descendants) should be avoided because the class 'DateFormat' is not thread-safe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/DateFormatThreadUnsafe.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom SynchronizedStmt synch, Type type\nwhere\n  synch.getExpr().getType() = type and\n  (type instanceof BoxedType or type instanceof TypeString)\nselect synch.getExpr(), \"Do not synchronize on objects of type \" + type + \".\"",
        "description": "Synchronizing on boxed types or strings may lead to deadlock since an instance of that type is likely to be shared between many parts of the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/SynchOnBoxedType.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall ma, Method sleep\nwhere\n  ma.getMethod() = sleep and\n  sleep.hasName(\"sleep\") and\n  sleep.getDeclaringType().hasQualifiedName(\"java.lang\", \"Thread\") and\n  (\n    ma.getEnclosingStmt().getEnclosingStmt*() instanceof SynchronizedStmt or\n    ma.getEnclosingCallable().isSynchronized()\n  )\nselect ma, \"This calls 'Thread.sleep()' with a lock held.\"",
        "description": "Calling 'Thread.sleep' with a lock held may lead to very poor performance or even deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/SleepWithLock.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate delegatingSuperCall(Expr e, Method target) {\n  exists(MethodCall call | call = e |\n    call.getQualifier() instanceof SuperAccess and\n    call.getCallee() = target and\n    forall(Expr arg | arg = call.getAnArgument() | arg instanceof VarAccess)\n  )\n  or\n  delegatingSuperCall(e.(CastingExpr).getExpr(), target)\n}\n\npredicate delegatingOverride(Method sub, Method sup) {\n  exists(Stmt stmt |\n    // The body of `sub` consists of a single statement...\n    stmt = sub.getBody().(SingletonBlock).getStmt() and\n    (\n      // ...that is either a delegating call to `sup` (with a possible cast)...\n      delegatingSuperCall(stmt.(ExprStmt).getExpr(), sup)\n      or\n      // ...or a `return` statement containing such a call.\n      delegatingSuperCall(stmt.(ReturnStmt).getResult(), sup)\n    )\n  )\n}\n\nfrom Method sub, Method sup, Class supSrc\nwhere\n  sub.overrides(sup) and\n  sub.fromSource() and\n  sup.isSynchronized() and\n  not sub.isSynchronized() and\n  not delegatingOverride(sub, sup) and\n  supSrc = sup.getDeclaringType().getSourceDeclaration()\nselect sub,\n  \"Method '\" + sub.getName() + \"' overrides a synchronized method in $@ but is not synchronized.\",\n  supSrc, supSrc.getQualifiedName()",
        "description": "If a synchronized method is overridden in a subclass, and the overriding method is not synchronized, the thread-safety of the subclass may be broken.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/NonSynchronizedOverride.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.controlflow.Guards\nimport semmle.code.java.dataflow.SSA\nimport semmle.code.java.frameworks.Mockito\n\nclass LockType extends RefType {\n  LockType() {\n    this.getAMethod().hasName(\"lock\") and\n    this.getAMethod().hasName(\"unlock\")\n  }\n\n  Method getLockMethod() {\n    result.getDeclaringType() = this and\n    (result.hasName(\"lock\") or result.hasName(\"tryLock\"))\n  }\n\n  Method getUnlockMethod() {\n    result.getDeclaringType() = this and\n    result.hasName(\"unlock\")\n  }\n\n  Method getIsHeldByCurrentThreadMethod() {\n    result.getDeclaringType() = this and\n    result.hasName(\"isHeldByCurrentThread\")\n  }\n\n  MethodCall getLockAccess() {\n    result.getMethod() = this.getLockMethod() and\n    // Not part of a Mockito verification call\n    not result instanceof MockitoVerifiedMethodCall\n  }\n\n  MethodCall getUnlockAccess() {\n    result.getMethod() = this.getUnlockMethod() and\n    // Not part of a Mockito verification call\n    not result instanceof MockitoVerifiedMethodCall\n  }\n\n  MethodCall getIsHeldByCurrentThreadAccess() {\n    result.getMethod() = this.getIsHeldByCurrentThreadMethod() and\n    // Not part of a Mockito verification call\n    not result instanceof MockitoVerifiedMethodCall\n  }\n}\n\npredicate lockBlock(LockType t, BasicBlock b, int locks) {\n  locks = strictcount(int i | b.getNode(i).asExpr() = t.getLockAccess())\n}\n\npredicate unlockBlock(LockType t, BasicBlock b, int unlocks) {\n  unlocks = strictcount(int i | b.getNode(i).asExpr() = t.getUnlockAccess())\n}\n\npredicate lockUnlockBlock(LockType t, BasicBlock b, int netlocks) {\n  lockBlock(t, b, netlocks) and not unlockBlock(t, b, _)\n  or\n  exists(int unlocks |\n    not lockBlock(t, b, _) and unlockBlock(t, b, unlocks) and netlocks = -unlocks\n  )\n  or\n  exists(int locks, int unlocks |\n    lockBlock(t, b, locks) and unlockBlock(t, b, unlocks) and netlocks = locks - unlocks\n  )\n}\n\npredicate failedLock(LockType t, BasicBlock lockblock, BasicBlock exblock) {\n  exists(ControlFlowNode lock |\n    lock = lockblock.getLastNode() and\n    (\n      lock.asExpr() = t.getLockAccess()\n      or\n      exists(SsaExplicitUpdate lockbool |\n        // Using the value of `t.getLockAccess()` ensures that it is a `tryLock` call.\n        lock.asExpr() = lockbool.getAUse() and\n        lockbool.getDefiningExpr().(VariableAssign).getSource() = t.getLockAccess()\n      )\n    ) and\n    (\n      lock.getAnExceptionSuccessor() = exblock.getFirstNode() or\n      lock.(ConditionNode).getAFalseSuccessor() = exblock.getFirstNode()\n    )\n  )\n}\n\npredicate heldByCurrentThreadCheck(LockType t, BasicBlock checkblock, BasicBlock falsesucc) {\n  exists(ConditionBlock conditionBlock |\n    conditionBlock.getCondition() = t.getIsHeldByCurrentThreadAccess()\n  |\n    conditionBlock = checkblock and\n    conditionBlock.getTestSuccessor(false) = falsesucc\n  )\n}\n\npredicate variableLockStateCheck(LockType t, BasicBlock checkblock, BasicBlock falsesucc) {\n  exists(ConditionBlock conditionBlock, VarAccess v |\n    v.getType() instanceof BooleanType and\n    // Ensure that a lock access is assigned to the variable\n    v.getVariable().getAnAssignedValue() = t.getLockAccess() and\n    // Ensure that the `true` successor of the condition block contains an unlock access\n    conditionBlock.getTestSuccessor(true) = t.getUnlockAccess().getBasicBlock() and\n    conditionBlock.getCondition() = v\n  |\n    conditionBlock = checkblock and\n    conditionBlock.getTestSuccessor(false) = falsesucc\n  )\n}\n\npredicate blockIsLocked(LockType t, BasicBlock src, BasicBlock b, int locks) {\n  lockUnlockBlock(t, b, locks) and src = b and locks > 0\n  or\n  exists(BasicBlock pred, int predlocks, int curlocks, int failedlock | pred = b.getAPredecessor() |\n    // The number of net locks from the `src` block to the predecessor block `pred` is `predlocks`.\n    blockIsLocked(t, src, pred, predlocks) and\n    // The recursive call ensures that at least one lock is held, so do not consider the false\n    // successor of the `isHeldByCurrentThread()` check or of `variableLockStateCheck`.\n    not heldByCurrentThreadCheck(t, pred, b) and\n    not variableLockStateCheck(t, pred, b) and\n    // Count a failed lock as an unlock so the net is zero.\n    (if failedLock(t, pred, b) then failedlock = 1 else failedlock = 0) and\n    (\n      not lockUnlockBlock(t, b, _) and curlocks = 0\n      or\n      lockUnlockBlock(t, b, curlocks)\n    ) and\n    locks = predlocks + curlocks - failedlock and\n    locks > 0 and\n    // Arbitrary bound in order to fail gracefully in case of locking in a loop.\n    locks < 10\n  )\n}\n\nfrom Callable c, LockType t, BasicBlock src, ExitBlock exit, MethodCall lock\nwhere\n  // Restrict results to those methods that actually attempt to unlock.\n  t.getUnlockAccess().getEnclosingCallable() = c and\n  blockIsLocked(t, src, exit, _) and\n  exit.getEnclosingCallable() = c and\n  lock = src.getANode().asExpr() and\n  lock = t.getLockAccess()\nselect lock, \"This lock might not be unlocked or might be locked more times than it is unlocked.\"",
        "description": "A lock that is acquired one or more times without a matching number of unlocks may cause a deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/UnreleasedLock.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass Synched extends Stmt {\n  Synched() {\n    this.getParent().(Method).isSynchronized() or\n    this instanceof SynchronizedStmt\n  }\n}\n\nfrom MethodCall ma, SynchronizedStmt synch\nwhere\n  ma.getMethod().hasName(\"wait\") and\n  ma.getMethod().getDeclaringType().hasQualifiedName(\"java.lang\", \"Object\") and\n  ma.getEnclosingStmt().getEnclosingStmt*() = synch and\n  synch.getEnclosingStmt+() instanceof Synched\nselect ma, \"This calls 'Object.wait()' with two locks held.\"",
        "description": "Calling 'Object.wait' while two locks are held may cause deadlock.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Concurrency/WaitWithTwoLocks.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npragma[nomagic]\npredicate mayThrow(Stmt s, RefType rt) {\n  s.(ThrowStmt).getExpr().getType() = rt\n  or\n  exists(Call call |\n    call.getEnclosingStmt() = s and\n    call.getCallee().getAnException().getType() = rt\n  )\n}\n\npragma[nomagic]\npredicate caughtBy(TryStmt try, Stmt s, RefType rt) {\n  mayThrow(s, rt) and\n  s.getEnclosingStmt+() = try.getBlock() and\n  caughtType(try, _).hasSubtype*(rt)\n}\n\npragma[nomagic]\npredicate nestedTry(TryStmt outer, TryStmt inner) { inner.getEnclosingStmt+() = outer.getBlock() }\n\nprivate predicate caughtInside(TryStmt t, Stmt s, RefType rt) {\n  exists(TryStmt innerTry |\n    nestedTry(t, innerTry) and\n    caughtBy(innerTry, s, rt)\n  )\n}\n\nprivate RefType getAThrownExceptionType(TryStmt t) {\n  exists(Method m, Exception e |\n    (\n      m = t.getAResourceDecl().getAVariable().getType().(RefType).getAMethod() or\n      m = t.getAResourceExpr().getType().(RefType).getAMethod()\n    ) and\n    m.hasName(\"close\") and\n    m.hasNoParameters() and\n    m.getAnException() = e and\n    result = e.getType()\n  )\n  or\n  exists(Call call, Exception e |\n    t.getBlock() = call.getEnclosingStmt().getEnclosingStmt*() or\n    t.getAResourceDecl() = call.getEnclosingStmt()\n  |\n    (\n      call.getCallee().getAnException() = e or\n      call.(GenericCall).getATypeArgument(call.getCallee().getAnException().getType()) = e.getType()\n    ) and\n    not caughtInside(t, call.getEnclosingStmt(), e.getType()) and\n    result = e.getType()\n  )\n  or\n  exists(ThrowStmt ts |\n    t.getBlock() = ts.getEnclosingStmt*() and\n    not caughtInside(t, ts, ts.getExpr().getType()) and\n    result = ts.getExpr().getType()\n  )\n}\n\nprivate RefType caughtType(TryStmt try, int index) {\n  exists(CatchClause cc | cc = try.getCatchClause(index) |\n    if cc.isMultiCatch()\n    then result = cc.getVariable().getTypeAccess().(UnionTypeAccess).getAnAlternative().getType()\n    else result = cc.getVariable().getType()\n  )\n}\n\nprivate predicate maybeUnchecked(RefType t) {\n  t.getAnAncestor().hasQualifiedName(\"java.lang\", \"RuntimeException\") or\n  t.getAnAncestor().hasQualifiedName(\"java.lang\", \"Error\") or\n  t.hasQualifiedName(\"java.lang\", \"Exception\") or\n  t.hasQualifiedName(\"java.lang\", \"Throwable\")\n}\n\npredicate overlappingExceptions(RefType e1, RefType e2) {\n  exists(RefType throwable | throwable.hasQualifiedName(\"java.lang\", \"Throwable\") |\n    throwable.hasSubtype*(e1) and\n    throwable.hasSubtype*(e2) and\n    e1.getADescendant() = e2.getADescendant()\n  )\n}\n\nfrom TryStmt try, int first, int second, RefType masking, RefType masked, string multiCatchMsg\nwhere\n  try.getFile().isJavaSourceFile() and\n  masking = caughtType(try, first) and\n  masking.getAStrictAncestor() = masked and\n  masked = caughtType(try, second) and\n  forall(RefType thrownType |\n    thrownType = getAThrownExceptionType(try) and\n    // If there's any overlap in the types, this catch block may be relevant.\n    overlappingExceptions(thrownType, masked)\n  |\n    exists(RefType priorCaughtType, int priorIdx |\n      priorIdx < second and\n      priorCaughtType = caughtType(try, priorIdx) and\n      thrownType.hasSupertype*(priorCaughtType)\n    )\n  ) and\n  not maybeUnchecked(masked) and\n  if try.getCatchClause(second).isMultiCatch()\n  then multiCatchMsg = \" for type \" + masked.getName()\n  else multiCatchMsg = \"\"\nselect try.getCatchClause(second),\n  \"This catch-clause is unreachable\" + multiCatchMsg + \"; it is masked $@.\",\n  try.getCatchClause(first),\n  \"by a previous catch-clause for exceptions of type '\" + masking.getName() + \"'\"",
        "description": "An unreachable 'catch' clause may indicate a mistake in exception handling or may be unnecessary.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/PartiallyMaskedCatch.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom FieldWrite fw, Field f, Callable c, string kind\nwhere\n  fw.getField() = f and\n  f.isStatic() and\n  c = fw.getSite() and\n  not c.isStatic() and\n  f.getDeclaringType() = c.getDeclaringType() and\n  c.fromSource() and\n  if c instanceof Constructor then kind = \"constructor for\" else kind = \"instance method\"\nselect fw, \"Write to static field \" + f.getName() + \" in \" + kind + \" \" + c.getName() + \".\"",
        "description": "Writing to a static field from an instance method is prone to race conditions unless you use synchronization. In addition, it makes it difficult to keep the static state consistent and affects code readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/StaticFieldWrittenByInstance.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ArrayCast extends CastExpr {\n  ArrayCast() {\n    this.getExpr() instanceof ArrayCreationExpr and\n    this.getType() instanceof Array\n  }\n\n  /** The type of the operand expression of this cast. */\n  Array getSourceType() { result = this.getExpr().getType() }\n\n  /** The result type of this cast. */\n  Array getTargetType() { result = this.getType() }\n\n  Type getSourceComponentType() { result = this.getSourceType().getComponentType() }\n\n  Type getTargetComponentType() { result = this.getTargetType().getComponentType() }\n}\n\npredicate uncheckedCastType(RefType t) {\n  t instanceof BoundedType or t instanceof ParameterizedType\n}\n\npredicate castFlow(ArrayCast ce, Variable v) {\n  ce = v.getAnAssignedValue()\n  or\n  exists(Variable mid | castFlow(ce, mid) and mid.getAnAccess() = v.getAnAssignedValue())\n}\n\npredicate returnedFrom(ArrayCast ce, Method m) {\n  exists(ReturnStmt ret | ret.getEnclosingCallable() = m | ret.getResult() = ce)\n  or\n  exists(Variable v | castFlow(ce, v) | returnedVariableFrom(v, m))\n}\n\npredicate returnedVariableFrom(Variable v, Method m) {\n  exists(ReturnStmt ret | ret.getResult() = v.getAnAccess() and ret.getEnclosingCallable() = m)\n}\n\npredicate rawTypeConversion(RawType source, ParameterizedType target) {\n  target.getErasure() = source.getErasure()\n}\n\nfrom ArrayCast ce, RefType target, RefType source, string message\nwhere\n  target = ce.getTargetComponentType() and\n  source = ce.getSourceComponentType() and\n  target.hasSupertype+(source) and\n  not rawTypeConversion(source, target) and\n  (\n    // No unchecked operations, so the cast would crash straight away.\n    not uncheckedCastType(target) and\n    message =\n      \"Impossible downcast: the cast from \" + source.getName() + \"[] to \" + target.getName() +\n        \"[] will always fail with a ClassCastException.\"\n    or\n    // For unchecked operations, the crash would not occur at the cast site,\n    // but only if/when the value is assigned to a variable of different array type.\n    // This would require tracking the flow of values, but we focus on finding problematic\n    // APIs. We keep two cases:\n    // - An array that is actually returned from the (non-private) method, or\n    // - an array that is assigned to a field returned from another (non-private) method.\n    uncheckedCastType(target) and\n    returnedFrom(ce, ce.getEnclosingCallable()) and\n    ce.getEnclosingCallable().getReturnType().(Array).getElementType() = target and\n    not ce.getEnclosingCallable().isPrivate() and\n    message =\n      \"Impossible downcast: this is returned by \" + ce.getEnclosingCallable().getName() +\n        \" as a value of type \" + target.getName() + \"[], but the array has type \" + source.getName()\n        + \"[]. Callers of \" + ce.getEnclosingCallable().getName() +\n        \" may fail with a ClassCastException.\"\n    or\n    exists(Method m, Variable v |\n      uncheckedCastType(target) and\n      castFlow(ce, v) and\n      returnedVariableFrom(v, m) and\n      m.getReturnType().(Array).getElementType() = target and\n      not m.isPrivate() and\n      message =\n        \"Impossible downcast: this is assigned to \" + v.getName() + \" which is returned by \" + m +\n          \" as a value of type \" + target.getName() + \"[], but the array has type \" +\n          source.getName() + \"[]. Callers of \" + m.getName() +\n          \" may fail with a ClassCastException.\"\n    )\n  )\nselect ce, message",
        "description": "Trying to cast an array of a particular type as an array of a subtype causes a 'ClassCastException' at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/ImpossibleCast.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom DoStmt do, ContinueStmt continue\nwhere\n  do.getCondition().(BooleanLiteral).getBooleanValue() = false and\n  continue.getTarget() = do\nselect continue, \"This 'continue' never re-runs the loop - the $@ is always false.\",\n  do.getCondition(), \"loop condition\"",
        "description": "A 'continue' statement only re-runs the loop if the loop-condition is true. Therefore using 'continue' in a loop with a constant false condition is misleading and usually a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/ContinueInFalseLoop.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom SynchronizedStmt sync\nwhere not exists(sync.getBlock().getAChild())\nselect sync, \"Empty synchronized block.\"",
        "description": "Empty synchronized blocks may indicate the presence of incomplete code or incorrect synchronization, and may lead to concurrency problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/EmptySynchronizedBlock.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Chaining\n\npredicate exclude(Method m) {\n  exists(string name | name = m.getName().toLowerCase() |\n    name.matches(\"get%\") or\n    name.matches(\"is%\") or\n    name.matches(\"has%\") or\n    name.matches(\"add%\")\n  )\n}\n\npredicate checkExpr(MethodCall callToCheck, MethodCall otherCall, string operation, Variable v) {\n  not exclude(otherCall.getMethod()) and\n  v.getAnAssignedValue() = callToCheck and\n  otherCall != callToCheck and\n  otherCall.getMethod().getName() = operation and\n  (\n    otherCall.getAnArgument() = getChainedAccess(v) or\n    otherCall.getQualifier() = getChainedAccess(v)\n  )\n}\n\npredicate implicitCheckExpr(MethodCall callToCheck, string operation, Variable v) {\n  exists(TryStmt try, LocalVariableDeclExpr decl |\n    try.getAResourceDecl().getAVariable() = decl and\n    decl.getVariable() = v and\n    decl.getInit() = callToCheck and\n    operation = \"close\"\n  )\n}\n\nExpr getChainedAccess(Variable v) {\n  result = v.getAnAccess()\n  or\n  exists(MethodCall chainedAccess | chainedAccess.getQualifier() = getChainedAccess(v) |\n    designedForChaining(chainedAccess.getMethod()) and result = chainedAccess\n  )\n}\n\npredicate checkedFunctionCall(MethodCall ma, string operation) {\n  relevantFunctionCall(ma, _) and\n  exists(Variable v | not v instanceof Field |\n    v.getAnAssignedValue() = ma and\n    (checkExpr(ma, _, operation, v) or implicitCheckExpr(ma, operation, v))\n  )\n}\n\npredicate relevantFunctionCall(MethodCall ma, Method m) {\n  ma.getMethod() = m and\n  exists(Variable v | v.getAnAssignedValue() = ma) and\n  not okToIgnore(ma)\n}\n\npredicate okToIgnore(MethodCall ma) { not ma.getCompilationUnit().fromSource() }\n\npredicate functionStats(Method m, string operation, int used, int total, int percentage) {\n  m.getReturnType() instanceof RefType and\n  // Calls to `m` where we also perform `operation`.\n  used = strictcount(MethodCall ma | checkedFunctionCall(ma, operation) and m = ma.getMethod()) and\n  // Calls to `m`.\n  total = strictcount(MethodCall ma | relevantFunctionCall(ma, m)) and\n  percentage = used * 100 / total\n}\n\nfrom MethodCall unchecked, Method m, string operation, int percent\nwhere\n  relevantFunctionCall(unchecked, m) and\n  not checkedFunctionCall(unchecked, operation) and\n  functionStats(m, operation, _, _, percent) and\n  percent >= 90 and\n  not m.getName() = operation and\n  not unchecked.getEnclosingStmt().(ExprStmt).isFieldDecl()\nselect unchecked,\n  \"After \" + percent.toString() + \"% of calls to \" + m.getName() + \" there is a call to \" +\n    operation + \" on the return value. The call may be missing in this case.\"",
        "description": "If the same operation is usually performed on the result of a method call, any cases where it is not performed may indicate resource leaks or other problems.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/InconsistentCallOnResult.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate unbracedTrailingBody(Stmt ctrlStructure, Stmt trailingBody) {\n  not trailingBody instanceof BlockStmt and\n  (\n    exists(IfStmt c | c = ctrlStructure |\n      trailingBody = c.getElse() and not trailingBody instanceof IfStmt\n      or\n      trailingBody = c.getThen() and not exists(c.getElse())\n    )\n    or\n    exists(LoopStmt c | c = ctrlStructure | not c instanceof DoStmt and trailingBody = c.getBody())\n  )\n}\n\n\nStmt nextInBlock(Stmt s) {\n  exists(BlockStmt b, int i |\n    b.getStmt(i) = s and\n    b.getStmt(i + 1) = result\n  )\n  or\n  exists(SwitchStmt b, int i |\n    b.getStmt(i) = s and\n    b.getStmt(i + 1) = result\n  )\n}\n\nStmt nonBlockParent(Stmt s) {\n  result = s.getParent() and\n  not result instanceof BlockStmt and\n  not result instanceof SwitchStmt\n}\n\npredicate ifElseIf(IfStmt s, IfStmt elseif) { s.getElse() = elseif }\n\npredicate shouldOutdent(\n  Stmt ctrl, Stmt body, Stmt succ, int bodycol, int succcol, int bodyline, int succline\n) {\n  unbracedTrailingBody(ctrl, body) and\n  succ = nextInBlock(nonBlockParent*(body)) and\n  bodycol = body.getLocation().getStartColumn() and\n  succcol = succ.getLocation().getStartColumn() and\n  bodyline = body.getLocation().getStartLine() and\n  succline = succ.getLocation().getStartLine()\n}\n\npredicate suspectIndentation(Stmt ctrl, Stmt body, Stmt succ) {\n  exists(int bodycol, int succcol, int ctrlcol, int bodyline, int succline |\n    shouldOutdent(ctrl, body, succ, bodycol, succcol, bodyline, succline) and\n    (bodycol = succcol or bodyline = succline) and\n    // Disregard cases when `ctrl`, `body`, and `succ` are all equally indented.\n    (ctrlcol < bodycol or bodycol < succcol) and\n    (\n      ctrlcol = ctrl.getLocation().getStartColumn()\n      or\n      exists(IfStmt s | ifElseIf+(s, ctrl) and ctrlcol = s.getLocation().getStartColumn())\n    )\n  )\n}\n\npredicate abortsControlFlow(Stmt s) {\n  s instanceof JumpStmt or\n  s instanceof ReturnStmt or\n  s instanceof ThrowStmt\n}\n\nfrom Stmt c, Stmt s, Stmt t\nwhere\n  suspectIndentation(c, s, t) and\n  // Exclude control-flow-aborting statements as these cases are less likely to be logic errors.\n  not abortsControlFlow(s) and\n  // Exclude the double semicolon case `if (cond) s;;`.\n  not t instanceof EmptyStmt and\n  // `LocalTypeDeclStmt`s yield false positives since their `Location` doesn't include the `class` keyword.\n  not t instanceof LocalTypeDeclStmt\nselect s,\n  \"Indentation suggests that $@ belongs to $@, but this is not the case; consider adding braces or adjusting indentation.\",\n  t, \"the next statement\", c, \"the control structure\"",
        "description": "If a control structure does not use braces, misleading indentation makes it difficult to see which statements are within its scope.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/UseBraces.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nEnumConstant nthMissing(SwitchStmt switch, int index) {\n  not exists(switch.getDefaultCase()) and\n  exists(EnumType enum |\n    switch.getExpr().getType() = enum and\n    result =\n      rank[index](EnumConstant ec |\n        ec.getDeclaringType() = enum and\n        not switch.getAConstCase().getValue() = ec.getAnAccess()\n      |\n        ec order by ec.getName()\n      )\n  )\n}\n\npredicate first3(string msg, SwitchStmt switch, EnumConstant e1, EnumConstant e2, EnumConstant e3) {\n  exists(int n | n = strictcount(nthMissing(switch, _)) |\n    if n > 3\n    then msg = \"Switch statement does not have a case for $@, $@, $@, or \" + (n - 3) + \" more.\"\n    else msg = \"Switch statement does not have a case for $@, $@, or $@.\"\n  ) and\n  e1 = nthMissing(switch, 1) and\n  e2 = nthMissing(switch, 2) and\n  e3 = nthMissing(switch, 3)\n}\n\npredicate only2(string msg, SwitchStmt switch, EnumConstant e1, EnumConstant e2) {\n  msg = \"Switch statement does not have a case for $@ or $@.\" and\n  e1 = nthMissing(switch, 1) and\n  e2 = nthMissing(switch, 2)\n}\n\npredicate only1(string msg, SwitchStmt switch, EnumConstant e) {\n  msg = \"Switch statement does not have a case for $@.\" and\n  e = nthMissing(switch, 1)\n}\n\nfrom string msg, SwitchStmt switch, EnumConstant e1, EnumConstant e2, EnumConstant e3\nwhere\n  if first3(_, switch, _, _, _)\n  then first3(msg, switch, e1, e2, e3)\n  else\n    if only2(_, switch, _, _)\n    then (\n      only2(msg, switch, e1, e2) and e1 = e3\n    ) else (\n      only1(msg, switch, e1) and e1 = e2 and e1 = e3\n    )\nselect switch, msg, e1, e1.getName(), e2, e2.getName(), e3, e3.getName()",
        "description": "A 'switch' statement that is based on an 'enum' type and does not have cases for all the 'enum' constants is usually a coding mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/MissingEnumInSwitch.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.Statement\n\nprivate BlockStmt emptyBlock() {\n  result.getNumStmt() = 0 and\n  result.getLocation().getNumberOfCommentLines() = 0\n}\n\nprivate predicate commentedLine(File file, int line) {\n  exists(JavadocText text, Location loc |\n    loc = text.getLocation() and\n    loc.getFile() = file and\n    loc.getStartLine() = line and\n    loc.getEndLine() = line\n  )\n}\n\nprivate EmptyStmt emptyStmt() {\n  not commentedLine(result.getFile(), result.getLocation().getStartLine())\n}\n\nStmt emptyBody() { result = emptyBlock() or result = emptyStmt() }\n\npredicate blockParent(Stmt empty, string msg) {\n  empty = emptyBody() and\n  (\n    empty.getParent() instanceof IfStmt and\n    msg = \"The body of an if statement should not be empty.\"\n    or\n    empty.getParent() instanceof LoopStmt and msg = \"The body of a loop should not be empty.\"\n    or\n    empty.getParent() instanceof BlockStmt and\n    empty instanceof BlockStmt and\n    msg = \"This block should not be empty.\"\n  )\n}\n\nfrom Stmt empty, string msg\nwhere\n  empty.getFile().isJavaSourceFile() and\n  empty = emptyBody() and\n  blockParent(empty, msg)\nselect empty, msg + \" Typographical error or missing code?\"",
        "description": "An undocumented empty block or statement hinders readability. It may also indicate incomplete code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/EmptyBlock.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Chaining\n\npredicate checkedMethodCall(MethodCall ma) {\n  relevantMethodCall(ma, _) and\n  not ma instanceof ValueDiscardingExpr\n}\n\npredicate isMockingMethod(Method m) {\n  isMustBeQualifierMockingMethod(m) or\n  isCardinalityClauseMethod(m) or\n  isStubberMethod(m) or\n  isReceiverClauseMethod(m)\n}\n\npredicate isReceiverClauseMethod(Method m) {\n  m.getDeclaringType().getAnAncestor().hasQualifiedName(\"org.jmock.syntax\", \"ReceiverClause\") and\n  m.hasName(\"of\")\n}\n\npredicate isCardinalityClauseMethod(Method m) {\n  m.getDeclaringType().getAnAncestor().hasQualifiedName(\"org.jmock.syntax\", \"CardinalityClause\") and\n  (\n    m.hasName(\"allowing\") or\n    m.hasName(\"ignoring\") or\n    m.hasName(\"never\") or\n    m.hasName(\"exactly\") or\n    m.hasName(\"atLeast\") or\n    m.hasName(\"between\") or\n    m.hasName(\"atMost\") or\n    m.hasName(\"one\") or\n    m.hasName(\"oneOf\")\n  )\n}\n\npredicate isStubberMethod(Method m) {\n  m.getDeclaringType().getAnAncestor().hasQualifiedName(\"org.mockito.stubbing\", \"Stubber\") and\n  (\n    m.hasName(\"when\") or\n    m.hasName(\"doThrow\") or\n    m.hasName(\"doAnswer\") or\n    m.hasName(\"doNothing\") or\n    m.hasName(\"doReturn\") or\n    m.hasName(\"doCallRealMethod\")\n  )\n}\n\npredicate isMustBeQualifierMockingMethod(Method m) {\n  m.getDeclaringType().getAnAncestor().hasQualifiedName(\"org.mockito\", \"Mockito\") and\n  m.hasName(\"verify\")\n}\n\npredicate relevantMethodCall(MethodCall ma, Method m) {\n  // For \"return value ignored\", all method calls are relevant.\n  not ma.getFile().isKotlinSourceFile() and\n  ma.getMethod() = m and\n  not m.getReturnType().hasName(\"void\") and\n  (not isMockingMethod(m) or isMustBeQualifierMockingMethod(m)) and\n  not isMockingMethod(ma.getQualifier().(MethodCall).getMethod())\n}\n\npredicate methodStats(Method m, int used, int total, int percentage) {\n  used = strictcount(MethodCall ma | checkedMethodCall(ma) and m = ma.getMethod()) and\n  total = strictcount(MethodCall ma | relevantMethodCall(ma, m)) and\n  percentage = used * 100 / total\n}\n\nint chainedUses(Method m) {\n  result =\n    count(MethodCall ma, MethodCall qual |\n      ma.getMethod() = m and\n      ma.getQualifier() = qual and\n      qual.getMethod() = m\n    )\n}\n\nfrom MethodCall unchecked, Method m, int percent, int total\nwhere\n  relevantMethodCall(unchecked, m) and\n  not checkedMethodCall(unchecked) and\n  methodStats(m, _, total, percent) and\n  percent >= 90 and\n  not designedForChaining(m) and\n  chainedUses(m) * 100 / total <= 45 // no more than 45% of calls to this method are chained\nselect unchecked,\n  \"The result of the call is ignored, but \" + percent.toString() + \"% of calls to \" + m.getName() +\n    \" use the return value.\"",
        "description": "If most of the calls to a method use the return value of that method, the calls that do not check the return value may be mistakes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Statements/ReturnValueIgnored.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nprivate predicate writtenInOneCallable(Field f) { strictcount(Callable m | m.writes(f)) = 1 }\n\nprivate FieldWrite fieldWriteOnlyIn(Callable m, Field f) {\n  result.getField() = f and\n  m.writes(f) and\n  writtenInOneCallable(f)\n}\n\nprivate FieldRead nonFinalFieldRead(Callable m, Field f) {\n  result.getField() = f and\n  result.getEnclosingCallable() = m and\n  not f.isFinal()\n}\n\nprivate MethodCall unqualifiedCallToNonAbstractMethod(Constructor c, Method m) {\n  result.getEnclosingCallable() = c and\n  (\n    not exists(result.getQualifier()) or\n    result.getQualifier().(ThisAccess).getType() = c.getDeclaringType()\n  ) and\n  m = result.getMethod() and\n  not m.isAbstract()\n}\n\nfrom\n  Constructor c, MethodCall ma, Method m, Method n, Field f, FieldRead fa, Constructor d,\n  FieldWrite fw\nwhere\n  // Method access in a constructor\n  // which is an access to the object being initialized, ...\n  ma = unqualifiedCallToNonAbstractMethod(c, m) and\n  // ... there exists an overriding method in a subtype,\n  n.overrides+(m) and\n  n.getDeclaringType().getAStrictAncestor() = c.getDeclaringType() and\n  // ... the method is in a supertype of c,\n  m.getDeclaringType() = c.getDeclaringType().getAnAncestor() and\n  // ... `n` reads a non-final field `f`,\n  fa = nonFinalFieldRead(n, f) and\n  // ... which is declared in a subtype of `c`,\n  f.getDeclaringType().getAStrictAncestor() = c.getDeclaringType() and\n  // ... `f` is written only in the subtype constructor, and\n  fw = fieldWriteOnlyIn(d, f) and\n  // ... the subtype constructor calls (possibly indirectly) the offending super constructor.\n  d.callsConstructor+(c)\nselect ma, \"One $@ $@ a $@ that is only $@ in the $@, so it is uninitialized in this $@.\", n,\n  \"overriding implementation\", fa, \"reads\", f, \"subclass field\", fw, \"initialized\", d,\n  \"subclass constructor\", c, \"super constructor\"",
        "description": "If a constructor calls a method that is overridden in a subclass, the result can be unpredictable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Inheritance/NoNonFinalInConstructor.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass ArithmeticExpr extends BinaryExpr {\n  ArithmeticExpr() {\n    this instanceof AddExpr or\n    this instanceof SubExpr or\n    this instanceof MulExpr or\n    this instanceof DivExpr or\n    this instanceof RemExpr\n  }\n}\n\nclass ShiftExpr extends BinaryExpr {\n  ShiftExpr() {\n    this instanceof LeftShiftExpr or\n    this instanceof RightShiftExpr or\n    this instanceof UnsignedRightShiftExpr\n  }\n}\n\nclass RelationExpr extends BinaryExpr {\n  RelationExpr() {\n    this instanceof EqualityTest or\n    this instanceof ComparisonExpr\n  }\n}\n\nclass LogicalExpr extends BinaryExpr {\n  LogicalExpr() {\n    this instanceof AndLogicalExpr or\n    this instanceof OrLogicalExpr\n  }\n}\n\nclass AssocNestedExpr extends BinaryExpr {\n  AssocNestedExpr() {\n    exists(BinaryExpr parent, int idx | this.isNthChildOf(parent, idx) |\n      // `+`, `*`, `&&`, `||` and the bitwise operations are associative.\n      (\n        this instanceof AddExpr or\n        this instanceof MulExpr or\n        this instanceof BitwiseExpr or\n        this instanceof LogicalExpr\n      ) and\n      parent.getKind() = this.getKind()\n      or\n      // Equality tests are associate over each other.\n      this instanceof EqualityTest and parent instanceof EqualityTest\n      or\n      // (x*y)/z = x*(y/z)\n      this instanceof MulExpr and parent instanceof DivExpr and idx = 0\n      or\n      // (x/y)%z = x/(y%z)\n      this instanceof DivExpr and parent instanceof RemExpr and idx = 0\n      or\n      // (x+y)-z = x+(y-z)\n      this instanceof AddExpr and parent instanceof SubExpr and idx = 0\n    )\n  }\n}\n\nclass HarmlessNestedExpr extends BinaryExpr {\n  HarmlessNestedExpr() {\n    exists(BinaryExpr parent | this = parent.getAChildExpr() |\n      parent instanceof RelationExpr and\n      (this instanceof ArithmeticExpr or this instanceof ShiftExpr)\n      or\n      parent instanceof LogicalExpr and this instanceof RelationExpr\n    )\n  }\n}\n\npredicate startOfBinaryRhs(BinaryExpr expr, int line, int col) {\n  exists(Location rloc | rloc = expr.getRightOperand().getLocation() |\n    rloc.getStartLine() = line and rloc.getStartColumn() = col\n  )\n}\n\npredicate endOfBinaryLhs(BinaryExpr expr, int line, int col) {\n  exists(Location lloc | lloc = expr.getLeftOperand().getLocation() |\n    lloc.getEndLine() = line and lloc.getEndColumn() = col\n  )\n}\n\nint getParensNextToOp(BinaryExpr expr) {\n  exists(Expr left, Expr right, int pleft, int pright |\n    left = expr.getLeftOperand() and\n    right = expr.getRightOperand() and\n    (if left.isParenthesized() then isParenthesized(left, pleft) else pleft = 0) and\n    (if right.isParenthesized() then isParenthesized(right, pright) else pright = 0) and\n    result = pleft + pright\n  )\n}\n\nint operatorWS(BinaryExpr expr) {\n  exists(int line, int lcol, int rcol, int parens |\n    endOfBinaryLhs(expr, line, lcol) and\n    startOfBinaryRhs(expr, line, rcol) and\n    parens = getParensNextToOp(expr) and\n    result = rcol - lcol + 1 - expr.getOp().length() - parens\n  )\n}\n\npredicate interestingNesting(BinaryExpr inner, BinaryExpr outer) {\n  inner = outer.getAChildExpr() and\n  not inner instanceof AssocNestedExpr and\n  not inner instanceof HarmlessNestedExpr and\n  not inner.isParenthesized()\n}\n\nfrom BinaryExpr inner, BinaryExpr outer, int wsouter, int wsinner\nwhere\n  interestingNesting(inner, outer) and\n  wsinner = operatorWS(inner) and\n  wsouter = operatorWS(outer) and\n  wsinner % 2 = 0 and\n  wsouter % 2 = 0 and\n  wsinner > wsouter\nselect outer, \"Whitespace around nested operators contradicts precedence.\"",
        "description": "Nested expressions where the formatting contradicts the grouping enforced by operator precedence are difficult to read and may even indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/WhitespaceContradictsPrecedence.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.arithmetic.Overflow\n\nclass DangerousAssignOpExpr extends AssignOp {\n  DangerousAssignOpExpr() {\n    this instanceof AssignAddExpr or\n    this instanceof AssignMulExpr\n  }\n}\n\npredicate problematicCasting(Type t, Expr e) { e.getType().(NumType).widerThan(t) }\n\nVariable getVariable(Expr dest) {\n  result = dest.(VarAccess).getVariable()\n  or\n  result = dest.(ArrayAccess).getArray().(VarAccess).getVariable()\n}\n\nfrom DangerousAssignOpExpr a, Expr e, Top v\nwhere\n  e = a.getSource() and\n  problematicCasting(a.getDest().getType(), e) and\n  (\n    v = getVariable(a.getDest())\n    or\n    // fallback, in case we can't easily determine the variable\n    not exists(getVariable(a.getDest())) and\n    v = a.getDest()\n  )\nselect a,\n  \"Implicit cast of source type \" + e.getType().getName() + \" to narrower destination type $@.\", v,\n  a.getDest().getType().getName()",
        "description": "Compound assignment statements (for example 'intvar += longvar') that implicitly cast a value of a wider type to a narrower type may result in information loss and numeric errors such as overflows.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/InformationLoss.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.RandomQuery\n\nfrom MethodCall ma, Method abs, Method nextIntOrLong, RandomDataSource nma\nwhere\n  ma.getMethod() = abs and\n  abs.hasName(\"abs\") and\n  abs.getDeclaringType().hasQualifiedName(\"java.lang\", \"Math\") and\n  ma.getAnArgument() = nma and\n  nma.getMethod() = nextIntOrLong and\n  nextIntOrLong.hasName([\"nextInt\", \"nextLong\"]) and\n  not nma.resultMayBeBounded()\nselect ma, \"Incorrect computation of abs of signed integral random value.\"",
        "description": "Calling 'Math.abs' to find the absolute value of a randomly generated integer is not guaranteed to return a non-negative integer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/BadAbsOfRandom.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.RangeUtils\nimport semmle.code.java.dataflow.RangeAnalysis\nimport semmle.code.java.Conversions\n\nfloat exprBound(Expr e) {\n  result = e.(ConstantIntegerExpr).getIntValue().(float).abs()\n  or\n  exists(float lower, float upper |\n    bounded(e, any(ZeroBound zb), lower, false, _) and\n    bounded(e, any(ZeroBound zb), upper, true, _) and\n    result = upper.abs().maximum(lower.abs())\n  )\n}\n\npredicate small(MulExpr e) {\n  exists(NumType t, float lhs, float rhs, float res | t = e.getType() |\n    lhs = exprBound(e.getLeftOperand()) and\n    rhs = exprBound(e.getRightOperand()) and\n    lhs * rhs = res and\n    res <= t.getOrdPrimitiveType().getMaxValue()\n  )\n}\n\nExpr getRestrictedParent(Expr e) {\n  result = e.getParent() and\n  (result instanceof ArithExpr or result instanceof ConditionalExpr)\n}\n\nfrom ConversionSite c, MulExpr e, NumType sourceType, NumType destType\nwhere\n  // e is nested inside c, with only parents that roughly \"preserve\" the value\n  getRestrictedParent*(e) = c and\n  // the destination type is wider than the type of the multiplication\n  e.getType() = sourceType and\n  c.getConversionTarget() = destType and\n  destType.widerThan(sourceType) and\n  // restrict attention to integral types\n  destType instanceof IntegralType and\n  // not a trivial conversion\n  not c.isTrivial() and\n  // not an explicit conversion, which is probably intended by a user\n  c.isImplicit() and\n  // not obviously small and ok\n  not small(e) and\n  e.getEnclosingCallable().fromSource()\nselect c,\n  \"Potential overflow in $@ before it is converted to \" + destType.getName() + \" by use in \" +\n    (\"a \" + c.kind()).regexpReplaceAll(\"^a ([aeiou])\", \"an $1\") + \".\", e,\n  sourceType.getName() + \" multiplication\"",
        "description": "Casting the result of a multiplication to a wider type instead of casting before the multiplication may cause overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/IntMultToLong.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nint integralTypeWidth(IntegralType t) {\n  if t.hasName(\"long\") or t.hasName(\"Long\") then result = 64 else result = 32\n}\n\nfrom LeftShiftExpr shift, IntegralType t, int v, string typname, int width\nwhere\n  shift.getLeftOperand().getType() = t and\n  shift.getRightOperand().(CompileTimeConstantExpr).getIntValue() = v and\n  width = integralTypeWidth(t) and\n  v >= width and\n  typname = (\"a \" + t.toString()).regexpReplaceAll(\"a ([aeiouAEIOU])\", \"an $1\")\nselect shift,\n  \"Left-shifting \" + typname + \" by more than \" + width + \" truncates the shift amount from \" + v +\n    \" to \" + (v % width)",
        "description": "Left-shifting an integer by more than its type width indicates a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/LShiftLargerThanTypeWidth.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom IntegerLiteral lit, string val\nwhere\n  lit.getLiteral() = val and\n  val.regexpMatch(\"0[0-7][0-7]+\") and\n  lit.getParent() instanceof BinaryExpr and\n  not lit.getParent() instanceof BitwiseExpr and\n  not lit.getParent() instanceof ComparisonExpr\nselect lit, \"Integer literal starts with 0.\"",
        "description": "An integer literal that starts with '0' may cause a problem. If the '0' is intentional, a programmer may misread the literal as a decimal literal. If the '0' is unintentional and a decimal literal is intended, the compiler treats the literal as an octal literal.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/OctalLiteral.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MulExpr e, RemExpr lhs\nwhere\n  e.getLeftOperand() = lhs and\n  not lhs.isParenthesized() and\n  e.getRightOperand().getType().hasName(\"int\")\nselect e, \"Result of a remainder operation multiplied by an integer.\"",
        "description": "Using the remainder operator with the multiplication operator without adding parentheses to clarify precedence may cause confusion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/MultiplyRemainder.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.security.RandomQuery\n\nfrom RandomDataSource ma\nwhere ma.getQualifier() instanceof ClassInstanceExpr\nselect ma, \"Random object created and used only once.\"",
        "description": "Creating an instance of 'Random' for each pseudo-random number required does not guarantee an evenly distributed sequence of random numbers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/RandomUsedOnce.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Collections\n\npredicate isDefinitelyPositive(Expr e) {\n  isDefinitelyPositive(e) or\n  e.(IntegerLiteral).getIntValue() >= 0 or\n  e.(MethodCall).getMethod() instanceof CollectionSizeMethod or\n  e.(MethodCall).getMethod() instanceof StringLengthMethod or\n  e.(FieldAccess).getField() instanceof ArrayLengthField\n}\n\nfrom BinaryExpr t, RemExpr lhs, IntegerLiteral rhs, string parity\nwhere\n  t.getLeftOperand() = lhs and\n  t.getRightOperand() = rhs and\n  not isDefinitelyPositive(lhs.getLeftOperand()) and\n  lhs.getRightOperand().(IntegerLiteral).getIntValue() = 2 and\n  (\n    t instanceof ValueOrReferenceEqualsExpr and rhs.getIntValue() = 1 and parity = \"oddness\"\n    or\n    t instanceof ValueOrReferenceNotEqualsExpr and rhs.getIntValue() = 1 and parity = \"evenness\"\n    or\n    t instanceof GTExpr and rhs.getIntValue() = 0 and parity = \"oddness\"\n  )\nselect t, \"Possibly invalid test for \" + parity + \". This will fail for negative numbers.\"",
        "description": "Code that uses 'x % 2 == 1' or 'x % 2 > 0' to check whether a number is odd does not work for negative numbers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/BadCheckOdd.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.kotlin.Serialization\n\nint eval(Expr e) { result = e.(CompileTimeConstantExpr).getIntValue() }\n\npredicate isConstantExp(Expr e) {\n  // A literal is constant.\n  e instanceof Literal\n  or\n  e instanceof TypeAccess\n  or\n  e instanceof ArrayTypeAccess\n  or\n  e instanceof WildcardTypeAccess\n  or\n  // A binary expression is constant if both its operands are.\n  exists(BinaryExpr b | b = e |\n    isConstantExp(b.getLeftOperand()) and\n    isConstantExp(b.getRightOperand())\n  )\n  or\n  // A cast expression is constant if its expression is.\n  exists(CastingExpr c | c = e | isConstantExp(c.getExpr()))\n  or\n  // Multiplication by 0 is constant.\n  exists(MulExpr m | m = e | eval(m.getAnOperand()) = 0)\n  or\n  // Integer remainder by 1 is constant.\n  exists(RemExpr r | r = e |\n    r.getLeftOperand().getType() instanceof IntegralType and\n    eval(r.getRightOperand()) = 1\n  )\n  or\n  exists(AndBitwiseExpr a | a = e | eval(a.getAnOperand()) = 0)\n  or\n  exists(AndLogicalExpr a | a = e | a.getAnOperand().(BooleanLiteral).getBooleanValue() = false)\n  or\n  exists(OrLogicalExpr o | o = e | o.getAnOperand().(BooleanLiteral).getBooleanValue() = true)\n}\n\nfrom Expr e\nwhere\n  isConstantExp(e) and\n  exists(Expr child | e.getAChildExpr() = child |\n    not isConstantExp(child) and\n    not child instanceof Annotation\n  ) and\n  not e instanceof CompileTimeConstantExpr and\n  // Exclude explicit zero multiplication.\n  not e.(MulExpr).getAnOperand().(IntegerLiteral).getIntValue() = 0 and\n  // Exclude expressions that appear to be disabled deliberately (e.g. `false && ...`).\n  not e.(AndLogicalExpr).getAnOperand().(BooleanLiteral).getBooleanValue() = false and\n  // Exclude expressions that are in serialization constructors, which are auto-generated.\n  not e.getEnclosingCallable() instanceof SerializationConstructor\nselect e, \"Expression always evaluates to the same value.\"",
        "description": "An expression that always evaluates to the same value, but which has a non-constant subexpression, indicates a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/ConstantExpAppearsNonConstant.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass CharType extends PrimitiveType {\n  CharType() { this.hasName(\"char\") }\n}\n\nprivate Type getABranchType(ConditionalExpr ce) { result = ce.getABranchExpr().getType() }\n\nfrom ConditionalExpr ce\nwhere\n  getABranchType(ce) instanceof CharType and\n  exists(Type t | t = getABranchType(ce) |\n    t instanceof PrimitiveType and\n    not t instanceof CharType\n  )\nselect ce, \"Mismatch between types of branches: $@ and $@.\", ce.getTrueExpr(),\n  ce.getTrueExpr().getType().getName(), ce.getFalseExpr(), ce.getFalseExpr().getType().getName()",
        "description": "Using the '(p?e1:e2)' operator with different primitive types for the second and third operands may cause unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Arithmetic/CondExprTypes.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom FinalizeMethod m, Class c, FinalizeMethod mSuper, Class cSuper\nwhere\n  m.getDeclaringType() = c and\n  mSuper.getDeclaringType() = cSuper and\n  c.getAStrictAncestor() = cSuper and\n  not cSuper instanceof TypeObject and\n  not exists(m.getBody().getAChild())\nselect m, \"Finalize in \" + c.getName() + \" nullifies finalize in \" + cSuper.getName() + \".\"",
        "description": "A 'finalize' method that does not call 'super.finalize' may leave cleanup actions undone.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Finalization/NullifiedSuperFinalize.ql",
        "language": "java"
    },
    {
        "query": "import CloseType\n\nfrom CloseableInitExpr cie, RefType t\nwhere\n  cie.getFile().isJavaSourceFile() and\n  badCloseableInit(cie) and\n  cie.getType() = t and\n  sqlType(t) and\n  not noNeedToClose(cie)\nselect cie, \"This \" + t.getName() + \" is not always closed on method exit.\"",
        "description": "A database resource that is opened but not closed may cause a resource leak.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Resource Leaks/CloseSql.ql",
        "language": "java"
    },
    {
        "query": "import CloseType\n\npredicate writerType(RefType t) {\n  exists(RefType sup | sup = t.getAnAncestor() |\n    sup.hasQualifiedName(\"java.io\", [\"Writer\", \"OutputStream\"])\n  )\n}\n\npredicate safeWriterType(RefType t) {\n  exists(RefType sup | sup = t.getAnAncestor() |\n    sup.hasQualifiedName(\"java.io\", [\"CharArrayWriter\", \"StringWriter\", \"ByteArrayOutputStream\"])\n  )\n}\n\nfrom ClassInstanceExpr cie, RefType t\nwhere\n  cie.getFile().isJavaSourceFile() and\n  badCloseableInit(cie) and\n  cie.getType() = t and\n  writerType(t) and\n  not safeWriterType(typeInDerivation(cie)) and\n  not noNeedToClose(cie)\nselect cie, \"This \" + t.getName() + \" is not always closed on method exit.\"",
        "description": "A resource that is opened for writing but not closed may cause a resource leak.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Resource Leaks/CloseWriter.ql",
        "language": "java"
    },
    {
        "query": "import CloseType\n\npredicate readerType(RefType t) {\n  exists(RefType sup | sup = t.getAnAncestor() |\n    sup.hasQualifiedName(\"java.io\", [\"Reader\", \"InputStream\"]) or\n    sup.hasQualifiedName(\"java.util.zip\", \"ZipFile\")\n  )\n}\n\npredicate safeReaderType(RefType t) {\n  exists(RefType sup | sup = t.getAnAncestor() |\n    sup.hasQualifiedName(\"java.io\", [\"CharArrayReader\", \"StringReader\", \"ByteArrayInputStream\"])\n    or\n    // Note: It is unclear which specific class this is supposed to match\n    sup.hasName(\"StringInputStream\")\n  )\n}\n\nfrom ClassInstanceExpr cie, RefType t\nwhere\n  cie.getFile().isJavaSourceFile() and\n  badCloseableInit(cie) and\n  cie.getType() = t and\n  readerType(t) and\n  not safeReaderType(typeInDerivation(cie)) and\n  not noNeedToClose(cie)\nselect cie, \"This \" + t.getName() + \" is not always closed on method exit.\"",
        "description": "A resource that is opened for reading but not closed may cause a resource leak.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Resource Leaks/CloseReader.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ComparisonExpr e\nwhere\n  e.isStrict() and\n  e.getGreaterOperand() instanceof BitwiseExpr and\n  e.getLesserOperand().(IntegerLiteral).getIntValue() = 0\nselect e, \"Potentially unsafe sign check of a bitwise operation.\"",
        "description": "Checking the sign of the result of a bitwise operation may yield unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/BitwiseSignCheck.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.Expr\nimport semmle.code.java.Statement\n\nclass BooleanExpr extends Expr {\n  BooleanExpr() {\n    this = any(ConditionalStmt s).getCondition() or\n    this = any(ConditionalExpr s).getCondition()\n  }\n}\n\nprivate predicate assignAndCheck(AssignExpr e) {\n  exists(BinaryExpr c | e = c.getAChildExpr() |\n    c instanceof ComparisonExpr or\n    c instanceof EqualityTest\n  )\n}\n\nfrom AssignExpr a\nwhere\n  exists(BooleanExpr expr | expr.getAChildExpr*() = a) and\n  not assignAndCheck(a)\nselect a, \"Assignment in a boolean expression.\"",
        "description": "Assignments in Boolean conditions can be confused with equality tests and make the condition more difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/NoAssignInBooleanExprs.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nprivate predicate implementsComparable(RefType t, RefType param) {\n  exists(ParameterizedType pt |\n    t.getAnAncestor() = pt and\n    pt.getSourceDeclaration().hasQualifiedName(\"java.lang\", \"Comparable\") and\n    param = pt.getATypeArgument() and\n    not param instanceof Wildcard and\n    not param instanceof TypeVariable\n  )\n}\n\nprivate predicate mostSpecificComparableTypeArgument(RefType t, RefType param) {\n  implementsComparable(t, param) and\n  not implementsComparable(t, param.getASubtype+())\n}\n\nprivate predicate mostSpecificComparableTypeArgumentOrTypeObject(RefType t, RefType param) {\n  if mostSpecificComparableTypeArgument(t, _)\n  then mostSpecificComparableTypeArgument(t, param)\n  else param instanceof TypeObject\n}\n\nprivate predicate compareTo(RefType declaring, Method m, RefType param) {\n  m.hasName(\"compareTo\") and\n  m.isPublic() and\n  m.getNumberOfParameters() = 1 and\n  m.fromSource() and\n  m.getAParamType() = param and\n  declaring = m.getDeclaringType() and\n  declaring.getAnAncestor().getSourceDeclaration().hasQualifiedName(\"java.lang\", \"Comparable\")\n}\n\nfrom Method m, Class t, Type actual, Type desired\nwhere\n  compareTo(t, m, actual) and\n  mostSpecificComparableTypeArgumentOrTypeObject(t, desired) and\n  actual != desired and\n  not compareTo(t, _, desired) and\n  not actual instanceof TypeVariable\nselect m,\n  \"The parameter of compareTo should have type '\" + desired.getName() +\n    \"' when implementing 'Comparable<\" + desired.getName() + \">'.\"",
        "description": "Defining 'Comparable.compareTo', where the parameter of 'compareTo' is not of the appropriate type, overloads 'compareTo' instead of overriding it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/CovariantCompareTo.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass EqualsCall extends MethodCall {\n  EqualsCall() { this.getMethod() instanceof EqualsMethod }\n\n  /**\n   * A whitelist of method accesses allowed to perform\n   * an incomparable-equals call.\n   */\n  predicate whitelisted() {\n    // Allow tests and assertions to verify that `equals` methods return `false`.\n    this.getParent*().(MethodCall).getMethod().getName().matches(\"assert%\") or\n    this.getEnclosingStmt() instanceof AssertStmt\n  }\n\n  /** Holds if the callee of this method access is `Object.equals`. */\n  predicate invokesObjectEquals() { this.getMethod().getDeclaringType() instanceof TypeObject }\n\n  /** Return the (static) type of the argument to `equals`. */\n  RefType getArgumentType() { result = this.getArgument(0).getType() }\n}\n\n\nfrom EqualsCall ma, RefType recvtp, RefType argtp\nwhere\n  not ma.whitelisted() and\n  (\n    if ma.invokesObjectEquals()\n    then recvtp = ma.getReceiverType()\n    else recvtp = ma.getMethod().getDeclaringType()\n  ) and\n  argtp = ma.getArgumentType() and\n  notHaveIntersection(recvtp, argtp)\nselect ma,\n  \"Call to equals() comparing incomparable types \" + recvtp.getName() + \" and \" + argtp.getName() +\n    \".\"",
        "description": "Calls of the form 'x.equals(y)', where the types of 'x' and 'y' are incomparable, should always return 'false'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/IncomparableEquals.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.controlflow.Guards\nimport semmle.code.java.dataflow.SSA\nimport semmle.code.java.dataflow.SignAnalysis\nimport semmle.code.java.dataflow.RangeAnalysis\n\npredicate constCond(BinaryExpr cond, boolean isTrue, Reason reason) {\n  exists(\n    ComparisonExpr comp, Expr lesser, Expr greater, Bound b, int d1, int d2, Reason r1, Reason r2\n  |\n    comp = cond and\n    lesser = comp.getLesserOperand() and\n    greater = comp.getGreaterOperand() and\n    bounded(lesser, b, d1, isTrue, r1) and\n    bounded(greater, b, d2, isTrue.booleanNot(), r2) and\n    (reason = r1 or reason = r2) and\n    (\n      r1 instanceof NoReason and r2 instanceof NoReason\n      or\n      not reason instanceof NoReason\n    )\n  |\n    isTrue = true and comp.isStrict() and d1 < d2\n    or\n    isTrue = true and not comp.isStrict() and d1 <= d2\n    or\n    isTrue = false and comp.isStrict() and d1 >= d2\n    or\n    isTrue = false and not comp.isStrict() and d1 > d2\n  )\n  or\n  exists(EqualityTest eq, Expr lhs, Expr rhs |\n    eq = cond and\n    lhs = eq.getLeftOperand() and\n    rhs = eq.getRightOperand()\n  |\n    exists(Bound b, int d1, int d2, boolean upper, Reason r1, Reason r2 |\n      bounded(lhs, b, d1, upper, r1) and\n      bounded(rhs, b, d2, upper.booleanNot(), r2) and\n      isTrue = eq.polarity().booleanNot() and\n      (reason = r1 or reason = r2) and\n      (\n        r1 instanceof NoReason and r2 instanceof NoReason\n        or\n        not reason instanceof NoReason\n      )\n    |\n      upper = true and d1 < d2 // lhs <= b + d1 < b + d2 <= rhs\n      or\n      upper = false and d1 > d2 // lhs >= b + d1 > b + d2 >= rhs\n    )\n    or\n    exists(Bound b, int d, Reason r1, Reason r2, Reason r3, Reason r4 |\n      bounded(lhs, b, d, true, r1) and\n      bounded(lhs, b, d, false, r2) and\n      bounded(rhs, b, d, true, r3) and\n      bounded(rhs, b, d, false, r4) and\n      isTrue = eq.polarity()\n    |\n      (reason = r1 or reason = r2 or reason = r3 or reason = r4) and\n      (\n        r1 instanceof NoReason and\n        r2 instanceof NoReason and\n        r3 instanceof NoReason and\n        r4 instanceof NoReason\n        or\n        not reason instanceof NoReason\n      )\n    )\n  )\n}\n\npredicate constCondSimple(BinaryExpr cond, boolean isTrue) {\n  constCond(cond, isTrue, any(NoReason nr))\n}\n\nExpr overFlowCand() {\n  exists(BinaryExpr bin |\n    result = bin and\n    positive(bin.getLeftOperand()) and\n    positive(bin.getRightOperand())\n  |\n    bin instanceof AddExpr or\n    bin instanceof MulExpr or\n    bin instanceof LeftShiftExpr\n  )\n  or\n  exists(AssignOp op |\n    result = op and\n    positive(op.getDest()) and\n    positive(op.getRhs())\n  |\n    op instanceof AssignAddExpr or\n    op instanceof AssignMulExpr or\n    op instanceof AssignLeftShiftExpr\n  )\n  or\n  exists(AddExpr add, CompileTimeConstantExpr c |\n    result = add and\n    add.hasOperands(overFlowCand(), c) and\n    c.getIntValue() >= 0\n  )\n  or\n  exists(AssignAddExpr add, CompileTimeConstantExpr c |\n    result = add and\n    add.getDest() = overFlowCand() and\n    add.getRhs() = c and\n    c.getIntValue() >= 0\n  )\n  or\n  exists(SsaExplicitUpdate x | result = x.getAUse() and x.getDefiningExpr() = overFlowCand())\n  or\n  result.(AssignExpr).getRhs() = overFlowCand()\n  or\n  result.(LocalVariableDeclExpr).getInit() = overFlowCand()\n  or\n  exists(ConditionalExpr c | c = result |\n    c.getTrueExpr() = overFlowCand() and\n    c.getFalseExpr() = overFlowCand()\n  )\n}\n\npredicate positiveOrNegative(Expr e) { positive(e) or negative(e) }\n\nExpr increaseOrDecreaseOfVar(SsaVariable v) {\n  exists(AssignAddExpr add |\n    result = add and\n    positiveOrNegative(add.getDest()) and\n    add.getRhs() = v.getAUse()\n  )\n  or\n  exists(AddExpr add, Expr e |\n    result = add and\n    add.hasOperands(v.getAUse(), e) and\n    positiveOrNegative(e)\n  )\n  or\n  exists(SubExpr sub |\n    result = sub and\n    sub.getLeftOperand() = v.getAUse() and\n    positiveOrNegative(sub.getRightOperand())\n  )\n  or\n  exists(SsaExplicitUpdate x |\n    result = x.getAUse() and x.getDefiningExpr() = increaseOrDecreaseOfVar(v)\n  )\n  or\n  result.(AssignExpr).getRhs() = increaseOrDecreaseOfVar(v)\n  or\n  result.(LocalVariableDeclExpr).getInit() = increaseOrDecreaseOfVar(v)\n}\n\npredicate overFlowTest(ComparisonExpr comp) {\n  (\n    exists(SsaVariable v | comp.hasOperands(increaseOrDecreaseOfVar(v), v.getAUse()))\n    or\n    comp.getLesserOperand() = overFlowCand() and\n    comp.getGreaterOperand().(IntegerLiteral).getIntValue() = 0\n  ) and\n  // exclude loop conditions as they are unlikely to be overflow tests\n  not comp.getEnclosingStmt() instanceof LoopStmt\n}\n\npredicate concurrentModificationTest(BinaryExpr test) {\n  exists(IfStmt ifstmt, ThrowStmt throw, RefType exc |\n    ifstmt.getCondition() = test and\n    (ifstmt.getThen() = throw or ifstmt.getThen().(SingletonBlock).getStmt() = throw) and\n    throw.getExpr().(ClassInstanceExpr).getConstructedType() = exc and\n    exc.hasQualifiedName(\"java.util\", \"ConcurrentModificationException\")\n  )\n}\n\npragma[nomagic]\npredicate guardedTest(EqualityTest test, Guard guard, boolean isEq, int i1, int i2) {\n  exists(SsaVariable v, CompileTimeConstantExpr c1, CompileTimeConstantExpr c2 |\n    guard.isEquality(v.getAUse(), c1, isEq) and\n    test.hasOperands(v.getAUse(), c2) and\n    i1 = c1.getIntValue() and\n    i2 = c2.getIntValue() and\n    v.getSourceVariable().getType() instanceof IntegralType\n  )\n}\n\npredicate uselessEqTest(EqualityTest test, boolean testIsTrue, Guard guard) {\n  exists(boolean guardIsTrue, boolean guardpolarity, int i |\n    guardedTest(test, guard, guardpolarity, i, i) and\n    guard.controls(test.getBasicBlock(), guardIsTrue) and\n    testIsTrue = guardIsTrue.booleanXor(guardpolarity.booleanXor(test.polarity()))\n  )\n}\n\nfrom BinaryExpr test, boolean testIsTrue, string reason, ExprParent reasonElem\nwhere\n  (\n    if uselessEqTest(test, _, _)\n    then\n      exists(EqualityTest r |\n        uselessEqTest(test, testIsTrue, r) and reason = \", because of $@\" and reasonElem = r\n      )\n    else\n      if constCondSimple(test, _)\n      then constCondSimple(test, testIsTrue) and reason = \"\" and reasonElem = test // dummy reason element\n      else\n        exists(CondReason r |\n          constCond(test, testIsTrue, r) and reason = \", because of $@\" and reasonElem = r.getCond()\n        )\n  ) and\n  not overFlowTest(test) and\n  not concurrentModificationTest(test) and\n  not exists(AssertStmt assert | assert.getExpr() = test.getParent*())\nselect test, \"Test is always \" + testIsTrue + reason + \".\", reasonElem, \"this condition\"",
        "description": "A comparison operation that always evaluates to true or always evaluates to false may indicate faulty logic and may result in dead code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/UselessComparisonTest.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall ma, Array recvtype, Method m\nwhere\n  recvtype = ma.getQualifier().getType() and\n  m = ma.getMethod() and\n  (\n    m instanceof HashCodeMethod\n    or\n    m instanceof EqualsMethod and\n    haveIntersection(recvtype, ma.getArgument(0).getType().(Array))\n  )\nselect ma,\n  \"The \" + m.getName() +\n    \" method on arrays only considers object identity and ignores array contents.\"",
        "description": "The 'equals' and 'hashCode' methods on arrays only consider object identity, not array contents, which is unlikely to be what is intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/EqualsArray.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass StringValue extends Expr {\n  StringValue() { this.getType() instanceof TypeString }\n\n  predicate isInterned() {\n    // A call to `String.intern()`.\n    exists(Method intern |\n      intern.getDeclaringType() instanceof TypeString and\n      intern.hasName(\"intern\") and\n      this.(MethodCall).getMethod() = intern\n    )\n    or\n    // Ternary conditional operator.\n    this.(ConditionalExpr).getTrueExpr().(StringValue).isInterned() and\n    this.(ConditionalExpr).getFalseExpr().(StringValue).isInterned()\n    or\n    // Values of type `String` that are compile-time constant expressions (JLS 15.28).\n    this instanceof CompileTimeConstantExpr\n    or\n    // Variables that are only ever assigned an interned `StringValue`.\n    variableValuesInterned(this.(VarAccess).getVariable())\n    or\n    // Method accesses whose results are all interned.\n    forex(ReturnStmt rs | rs.getEnclosingCallable() = this.(MethodCall).getMethod() |\n      rs.getResult().(StringValue).isInterned()\n    )\n  }\n}\n\npragma[noinline]\npredicate candidateVariable(Variable v) {\n  v.fromSource() and\n  // For parameters, assume they could be non-interned.\n  not v instanceof Parameter and\n  // If the string is modified with `+=`, then the new string is not interned\n  // even if the components are.\n  not exists(AssignOp append | append.getDest() = v.getAnAccess())\n}\n\npredicate variableValuesInterned(Variable v) {\n  candidateVariable(v) and\n  // All assignments to variables are interned.\n  forall(StringValue sv | sv = v.getAnAssignedValue() | sv.isInterned())\n}\n\nfrom ReferenceEqualityTest e, StringValue lhs, StringValue rhs\nwhere\n  e.getLeftOperand() = lhs and\n  e.getRightOperand() = rhs and\n  not (lhs.isInterned() and rhs.isInterned())\nselect e, \"String values compared with \" + e.getOp() + \".\"",
        "description": "Comparing two strings using the == or != operator compares object identity, which may not be intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/StringComparison.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate okForEquals(Class c) {\n  c.getAMethod() instanceof EqualsMethod\n  or\n  not exists(c.getAField()) and\n  okForEquals(c.getASupertype())\n}\n\npredicate checksReferenceEquality(EqualsMethod em) {\n  // `java.lang.Object.equals` is the prototypical reference equality implementation.\n  em.getDeclaringType() instanceof TypeObject\n  or\n  // Custom reference equality implementations observed in open-source projects.\n  exists(SingletonBlock blk, EQExpr eq |\n    blk = em.getBody() and\n    eq.getAnOperand() instanceof ThisAccess and\n    eq.getAnOperand().(VarAccess).getVariable() = em.getParameter(0) and\n    (\n      // `{ return (ojb==this); }`\n      eq = blk.getStmt().(ReturnStmt).getResult()\n      or\n      // `{ if (ojb==this) return true; else return false; }`\n      exists(IfStmt ifStmt | ifStmt = blk.getStmt() |\n        eq = ifStmt.getCondition() and\n        ifStmt.getThen().(ReturnStmt).getResult().(BooleanLiteral).getBooleanValue() = true and\n        ifStmt.getElse().(ReturnStmt).getResult().(BooleanLiteral).getBooleanValue() = false\n      )\n    )\n  )\n  or\n  // Check whether `em` delegates to another method checking reference equality.\n  // More precisely, we check whether the body of `em` is of the form `return super.equals(o);`,\n  // where `o` is the (only) parameter of `em`, and the invoked method is a reference equality check.\n  exists(SuperMethodCall sup |\n    sup = em.getBody().(SingletonBlock).getStmt().(ReturnStmt).getResult() and\n    sup.getArgument(0) = em.getParameter(0).getAnAccess() and\n    checksReferenceEquality(sup.getCallee())\n  )\n}\n\npredicate unsupportedEquals(EqualsMethod em) {\n  em.getBody().(SingletonBlock).getStmt() instanceof ThrowStmt\n}\n\npredicate overridesDelegateEquals(EqualsMethod em, Class c) {\n  exists(Method override, Method delegate |\n    // The `equals` method (declared in the supertype) contains\n    // a call to a `delegate` method on the same type ...\n    em.calls(delegate) and\n    delegate.getDeclaringType() = em.getDeclaringType() and\n    // ... and the `delegate` method is overridden in the subtype `c`\n    // by a method that reads at least one added field.\n    override.getDeclaringType() = c and\n    exists(Method overridden | overridden.getSourceDeclaration() = delegate |\n      override.overrides(overridden)\n    ) and\n    readsOwnField(override)\n  )\n}\n\npredicate readsOwnField(Method m) { m.reads(m.getDeclaringType().getAField()) }\n\nfrom Class c, InstanceField f, EqualsMethod em\nwhere\n  not exists(EqualsMethod m | m.getDeclaringType() = c) and\n  okForEquals(c.getASupertype()) and\n  exists(Method m | m.getSourceDeclaration() = em | c.inherits(m)) and\n  exists(em.getBody()) and\n  not checksReferenceEquality(em) and\n  not unsupportedEquals(em) and\n  not overridesDelegateEquals(em, c) and\n  f.getDeclaringType() = c and\n  c.fromSource() and\n  not c instanceof EnumType and\n  not f.isFinal()\nselect c, c.getName() + \" inherits $@ but adds $@.\", em.getSourceDeclaration(),\n  em.getDeclaringType().getName() + \".\" + em.getName(), f, \"the field \" + f.getName()",
        "description": "If a class overrides 'Object.equals', and a subclass defines additional fields to those it inherits but does not re-define 'equals', the results of 'equals' may be wrong.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/DefineEqualsWhenAddingFields.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.frameworks.Lombok\n\npredicate implementsComparableOn(RefType t, RefType typeArg) {\n  exists(RefType cmp |\n    t.getAnAncestor() = cmp and\n    cmp.getSourceDeclaration().hasQualifiedName(\"java.lang\", \"Comparable\")\n  |\n    // Either `t` extends `Comparable<T>`, in which case `typeArg` is `T`, ...\n    typeArg = cmp.(ParameterizedType).getATypeArgument() and not typeArg instanceof Wildcard\n    or\n    // ... or it extends the raw type `Comparable`, in which case `typeArg` is `Object`.\n    cmp instanceof RawType and typeArg instanceof TypeObject\n  )\n}\n\nclass CompareToMethod extends Method {\n  CompareToMethod() {\n    this.hasName(\"compareTo\") and\n    this.isPublic() and\n    this.getNumberOfParameters() = 1 and\n    // To implement `Comparable<T>.compareTo`, the parameter must either have type `T` or `Object`.\n    exists(RefType typeArg, Type firstParamType |\n      implementsComparableOn(this.getDeclaringType(), typeArg) and\n      firstParamType = this.getParameter(0).getType() and\n      (firstParamType = typeArg or firstParamType instanceof TypeObject)\n    )\n  }\n}\n\nfrom Class c, CompareToMethod compareToMethod\nwhere\n  c.fromSource() and\n  compareToMethod.fromSource() and\n  not exists(EqualsMethod em | em.getDeclaringType().getSourceDeclaration() = c) and\n  compareToMethod.getDeclaringType().getSourceDeclaration() = c and\n  // Exclude classes annotated with relevant Lombok annotations.\n  not c instanceof LombokEqualsAndHashCodeGeneratedClass\nselect c, \"This class declares $@ but inherits equals; the two could be inconsistent.\",\n  compareToMethod, \"compareTo\"",
        "description": "If a class overrides 'compareTo' but not 'equals', it may mean that 'compareTo' and 'equals' are inconsistent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/InconsistentCompareTo.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass CheckedCast extends CastExpr {\n  CheckedCast() {\n    exists(TryStmt try, RefType cce |\n      this.getEnclosingStmt().getEnclosingStmt+() = try and\n      try.getACatchClause().getVariable().getType() = cce and\n      cce.getQualifiedName() = \"java.lang.ClassCastException\"\n    )\n  }\n}\n\npredicate hasTypeTest(Variable v) {\n  any(InstanceOfExpr ioe).getExpr() = v.getAnAccess()\n  or\n  any(NotInstanceOfExpr nioe).getExpr() = v.getAnAccess()\n  or\n  any(SafeCastExpr sce).getExpr() = v.getAnAccess()\n  or\n  any(ClassExpr c).getExpr() = v.getAnAccess()\n  or\n  exists(MethodCall ma |\n    ma.getMethod().getName() = \"getClass\" and\n    ma.getQualifier() = v.getAnAccess()\n  )\n  or\n  any(CheckedCast cc).getExpr() = v.getAnAccess()\n  or\n  exists(Parameter p | hasTypeTest(p) and p.getAnArgument() = v.getAnAccess())\n}\n\nclass ReferenceEquals extends EqualsMethod {\n  ReferenceEquals() {\n    exists(BlockStmt b, ReturnStmt ret, EQExpr eq |\n      this.getBody() = b and\n      b.getStmt(0) = ret and\n      ret.getResult() = eq and\n      eq.getAnOperand() = this.getAParameter().getAnAccess() and\n      (eq.getAnOperand() instanceof ThisAccess or eq.getAnOperand() instanceof FieldAccess)\n    )\n  }\n}\n\nclass UnimplementedEquals extends EqualsMethod {\n  UnimplementedEquals() { this.getBody().getStmt(0) instanceof ThrowStmt }\n}\n\nfrom EqualsMethod m\nwhere\n  m.getFile().isJavaSourceFile() and\n  exists(m.getBody()) and\n  exists(Parameter p | p = m.getAParameter() |\n    // The parameter has no type test\n    not hasTypeTest(p) and\n    // If the parameter is passed to a method for which we don't have the source\n    // we assume it's ok\n    not exists(MethodCall ma |\n      not exists(ma.getMethod().getBody()) and\n      ma.getAnArgument() = p.getAnAccess()\n    )\n  ) and\n  not m.getDeclaringType() instanceof Interface and\n  // Exclude `equals` methods that implement reference-equality.\n  not m instanceof ReferenceEquals and\n  not m instanceof UnimplementedEquals\nselect m, \"This 'equals()' method does not check argument type.\"",
        "description": "An implementation of 'equals' that does not check the type of its argument may lead to failing casts.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/MissingInstanceofInEquals.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate nanField(Field f) {\n  f.getDeclaringType() instanceof FloatingPointType and\n  f.hasName(\"NaN\")\n}\n\nfrom EqualityTest eq, Field f, string classname\nwhere\n  eq.getAnOperand() = f.getAnAccess() and nanField(f) and f.getDeclaringType().hasName(classname)\nselect eq,\n  \"This comparison will always yield the same result since 'NaN != NaN'. Consider using \" +\n    classname + \".isNaN instead.\"",
        "description": "A comparison with 'NaN' using '==' or '!=' will always yield the same result and is unlikely to be intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/WrongNanComparison.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Equality\n\nfrom Class c, string message, Method existingMethod\nwhere\n  c.fromSource() and\n  (\n    not exists(EqualsMethod e | e.getDeclaringType() = c) and\n    exists(HashCodeMethod h | h.getDeclaringType() = c and h = existingMethod) and\n    message = \"Class \" + c.getName() + \" overrides $@ but not equals.\"\n    or\n    not exists(HashCodeMethod h | h.getDeclaringType() = c) and\n    // If the inherited `equals` is a refining `equals` then the superclass hash code is still valid.\n    exists(EqualsMethod e |\n      e.getDeclaringType() = c and e = existingMethod and not e instanceof RefiningEquals\n    ) and\n    message = \"Class \" + c.getName() + \" overrides $@ but not hashCode.\"\n  )\nselect c, message, existingMethod, existingMethod.getName()",
        "description": "If a class overrides only one of 'equals' and 'hashCode', it may mean that 'equals' and 'hashCode' are inconsistent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/InconsistentEqualsHashCode.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport Equality\n\npredicate eqNoHash(Class c) {\n  exists(Method m | m = c.getAMethod() |\n    m instanceof EqualsMethod and\n    // If the inherited `equals` is a refining `equals`\n    // then the superclass hash code is still valid.\n    not m instanceof RefiningEquals\n  ) and\n  not c.getAMethod() instanceof HashCodeMethod and\n  c.fromSource()\n}\n\npredicate hashingMethod(Method m) {\n  exists(string name, string names |\n    names = \"add,contains,containsKey,get,put,remove\" and\n    name = names.splitAt(\",\") and\n    m.getName() = name\n  )\n}\n\npredicate usedInHash(RefType t, Expr e) {\n  exists(RefType s |\n    s.getName().matches(\"%Hash%\") and not s.getSourceDeclaration().getName() = \"IdentityHashMap\"\n  |\n    exists(MethodCall ma |\n      ma.getQualifier().getType() = s and\n      ma.getArgument(0).getType() = t and\n      e = ma and\n      hashingMethod(ma.getMethod())\n    )\n    or\n    exists(ConstructorCall cc |\n      cc.getConstructedType() = s and\n      s.(ParameterizedType).getTypeArgument(0) = t and\n      cc = e\n    )\n  )\n}\n\nfrom RefType t, Expr e\nwhere\n  usedInHash(t, e) and\n  eqNoHash(t.getSourceDeclaration())\nselect e,\n  \"Type '\" + t.getName() + \"' does not define hashCode(), \" +\n    \"but is used in a hashing data-structure.\"",
        "description": "Classes that define an 'equals' method but no 'hashCode' method, and whose instances are stored in a hashing data structure, can lead to unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/HashedButNoHash.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom ReferenceEqualityTest c\nwhere\n  c.getLeftOperand().getType() instanceof BoxedType and\n  c.getRightOperand().getType() instanceof BoxedType and\n  not c.getAnOperand().getType().(RefType).hasQualifiedName(\"java.lang\", \"Boolean\")\nselect c, \"Suspicious reference comparison of boxed numerical values.\"",
        "description": "Comparing two boxed primitive values using the == or != operator compares object identity, which may not be intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/RefEqBoxed.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate comparison(BinaryExpr binop, Expr left, Expr right) {\n  (binop instanceof ComparisonExpr or binop instanceof EqualityTest) and\n  binop.getLeftOperand() = left and\n  binop.getRightOperand() = right\n}\n\npredicate toCompare(Expr left, Expr right) {\n  comparison(_, left, right) or\n  toCompare(left.getParent(), right.getParent())\n}\n\npragma[noinline]\npredicate varsToCompare(VarAccess left, VarAccess right, Variable v1, Variable v2) {\n  toCompare(left, right) and\n  left.getVariable() = v1 and\n  right.getVariable() = v2\n}\n\npredicate sameVariable(VarAccess left, VarAccess right, Variable v) {\n  varsToCompare(left, right, v, v) and\n  (\n    sameVariable(left.getQualifier(), right.getQualifier(), _)\n    or\n    left.isLocal() and right.isLocal()\n  )\n}\n\npredicate equal(Expr left, Expr right) {\n  toCompare(left, right) and\n  (\n    left.(Literal).getValue() = right.(Literal).getValue()\n    or\n    sameVariable(left, right, _)\n    or\n    exists(BinaryExpr bLeft, BinaryExpr bRight | bLeft = left and bRight = right |\n      bLeft.getKind() = bRight.getKind() and\n      equal(bLeft.getLeftOperand(), bRight.getLeftOperand()) and\n      equal(bLeft.getRightOperand(), bRight.getRightOperand())\n    )\n  )\n}\n\npredicate specialCase(EqualityTest comparison, string msg) {\n  exists(FloatingPointType fptp, string neg, string boxedName |\n    fptp = comparison.getAnOperand().getType() and\n    // Name of boxed type corresponding to `fptp`.\n    (if fptp.getName().toLowerCase() = \"float\" then boxedName = \"Float\" else boxedName = \"Double\") and\n    // Equality tests are tests for not-`NaN`, inequality tests for `NaN`.\n    (if comparison instanceof ValueOrReferenceEqualsExpr then neg = \"!\" else neg = \"\") and\n    msg = \"equivalent to \" + neg + boxedName + \".isNaN(\" + comparison.getLeftOperand() + \")\"\n  )\n}\n\nfrom BinaryExpr comparison, Expr left, Expr right, string msg, string equiv\nwhere\n  comparison(comparison, left, right) and\n  equal(left, right) and\n  (\n    specialCase(comparison, equiv) and msg = \"Comparison is \" + equiv\n    or\n    not specialCase(comparison, _) and\n    msg = \"Comparison of identical values \" + left + \" and \" + right and\n    equiv = \"\"\n  )\nselect comparison, msg + \".\"",
        "description": "If the same expression occurs on both sides of a comparison operator, the operator is redundant, and probably indicates a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/CompareIdenticalValues.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.Member\nimport semmle.code.java.JDK\n\nclass FinalFieldAccess extends VarAccess {\n  FinalFieldAccess() { this.getVariable().(Field).isFinal() }\n}\n\nclass ReferenceEqualityTestOnObject extends ReferenceEqualityTest {\n  ReferenceEqualityTestOnObject() {\n    this.getLeftOperand().getType() instanceof TypeObject and\n    this.getRightOperand().getType() instanceof TypeObject and\n    not this.getLeftOperand() instanceof FinalFieldAccess and\n    not this.getRightOperand() instanceof FinalFieldAccess\n  }\n}\n\nfrom ReferenceEqualityTestOnObject scw\nwhere\n  not exists(Variable left, Variable right, MethodCall equals |\n    left = scw.getLeftOperand().(VarAccess).getVariable() and\n    right = scw.getRightOperand().(VarAccess).getVariable() and\n    scw.getEnclosingCallable() = equals.getEnclosingCallable() and\n    equals.getMethod() instanceof EqualsMethod and\n    equals.getQualifier().(VarAccess).getVariable() = left and\n    equals.getAnArgument().(VarAccess).getVariable() = right\n  )\nselect scw, \"Avoid reference equality for java.lang.Object comparisons.\"",
        "description": "Reference comparisons (== or !=) with operands where the static type is 'Object' may not work as intended.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/ObjectComparison.ql",
        "language": "java"
    },
    {
        "query": "import java\n\npredicate instanceofInEquals(EqualsMethod m, InstanceOfExpr e) {\n  m.fromSource() and\n  e.getEnclosingCallable() = m and\n  e.getExpr().(VarAccess).getVariable() = m.getParameter() and\n  exists(RefType instanceofType |\n    instanceofType = e.getSyntacticCheckedType() and\n    not instanceofType.isFinal()\n  )\n}\n\nfrom EqualsMethod m, InstanceOfExpr e, EqualsMethod m2\nwhere\n  (instanceofInEquals(m, e) or instanceofInEquals(m2, e)) and\n  not m.getDeclaringType() instanceof TypeObject and\n  exists(m.getBody()) and\n  m2.fromSource() and\n  exists(Method overridden | overridden.getSourceDeclaration() = m | m2.overrides+(overridden))\nselect e,\n  \"Possible violation of equals contract due to use of instanceof in $@ and/or overriding $@.\", m,\n  m.getDeclaringType().getName() + \".\" + m.getName(), m2,\n  m2.getDeclaringType().getName() + \".\" + m2.getName()",
        "description": "Implementations of 'equals' that use 'instanceof' to test the type of the argument and are further overridden in a subclass are likely to violate the 'equals' contract.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/EqualsUsesInstanceOf.ql",
        "language": "java"
    },
    {
        "query": "import semmle.code.java.Type\nimport semmle.code.java.Expr\n\npredicate trivialLiteral(Literal e) {\n  e.getValue() = \"0.0\" or\n  e.getValue() = \"0\" or\n  e.getValue() = \"1.0\" or\n  e.getValue() = \"1\"\n}\n\npredicate definedConstant(Expr e) {\n  exists(Field f |\n    f.isStatic() and\n    (\n      f.getDeclaringType().hasName(\"Float\") or\n      f.getDeclaringType().hasName(\"Double\")\n    )\n  |\n    e = f.getAnAccess()\n  )\n}\n\n// The contract of `compareTo` would not really allow anything other than `<` or `>` on floats.\npredicate comparisonMethod(Method m) { m.getName() = \"compareTo\" }\n\n// Check for equalities of the form `a.x == b.x` or `a.x == x`, where `x` is assigned to `a.x`,\n// which are less interesting but occur often.\npredicate similarVarComparison(EqualityTest e) {\n  exists(Field f |\n    e.getLeftOperand() = f.getAnAccess() and\n    e.getRightOperand() = f.getAnAccess()\n  )\n  or\n  exists(Field f, Variable v |\n    e.getAnOperand() = f.getAnAccess() and\n    e.getAnOperand() = v.getAnAccess() and\n    f.getAnAssignedValue() = v.getAnAccess()\n  )\n}\n\nfrom EqualityTest ee\nwhere\n  ee.getAnOperand().getType() instanceof FloatingPointType and\n  not ee.getAnOperand() instanceof NullLiteral and\n  not trivialLiteral(ee.getAnOperand()) and\n  not definedConstant(ee.getAnOperand()) and\n  not similarVarComparison(ee) and\n  not comparisonMethod(ee.getEnclosingCallable())\nselect ee, \"Equality test on floating point values.\"",
        "description": "Equality tests on floating point values may lead to unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/NoComparisonOnFloats.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom RefType t, Method equals\nwhere\n  t.fromSource() and\n  equals = t.getAMethod() and\n  equals.hasName(\"equals\") and\n  equals.getNumberOfParameters() = 1 and\n  not t.getAMethod() instanceof EqualsMethod\nselect equals, \"To override the equals method, the parameter must be of type java.lang.Object.\"",
        "description": "Defining 'Object.equals', where the parameter of 'equals' is not of the appropriate type, overloads 'equals' instead of overriding it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Comparison/CovariantEquals.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom CloneMethod c, CloneMethod sc\nwhere\n  c.callsSuper(sc) and\n  c.fromSource() and\n  exists(sc.getBody()) and\n  not exists(CloneMethod ssc | sc.callsSuper(ssc))\nselect sc, \"This clone method does not call super.clone(), but is overridden and called $@.\", c,\n  \"in a subclass\"",
        "description": "A 'clone' method that is overridden in a subclass, and that does not itself call 'super.clone', causes calls to the subclass's 'clone' method to return an object of the wrong type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Cloning/MissingCallToSuperClone.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom Class t, TypeCloneable cloneable\nwhere\n  t.hasSupertype+(cloneable) and\n  not t.isAbstract() and\n  not t.getAMethod() instanceof CloneMethod and\n  exists(Field f | f.getDeclaringType() = t and not f.isStatic()) and\n  t.fromSource()\nselect t, \"No clone method, yet implements Cloneable.\"",
        "description": "A class that implements 'Cloneable' but does not override the 'clone' method will have undesired behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Cloning/MissingMethodClone.ql",
        "language": "java"
    },
    {
        "query": "import java\n\n// `suite()` methods in `TestCase`s also count as test methods.\nclass SuiteMethod extends Method {\n  SuiteMethod() {\n    this.getDeclaringType() instanceof JUnit38TestClass and\n    this.isPublic() and\n    this.isStatic() and\n    this.hasNoParameters()\n  }\n}\n\nfrom JUnit38TestClass j\nwhere\n  j.fromSource() and\n  not j.getAnAnnotation().getType().hasQualifiedName(\"org.junit\", \"Ignore\") and\n  not j.isAbstract() and\n  not exists(TestMethod t | t.getDeclaringType() = j) and\n  not exists(SuiteMethod s | s.getDeclaringType() = j)\nselect j, \"TestCase has no tests.\"",
        "description": "A test case class whose test methods are not recognized by JUnit 3.8 as valid declarations is not used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Frameworks/JUnit/TestCaseNoTests.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom TearDownMethod m1\nwhere\n  m1.fromSource() and\n  not m1.getDeclaringType().isAbstract() and\n  not exists(TearDownMethod m2 | m1.overrides(m2) and m1.callsSuper(m2))\nselect m1, \"TestCase implements tearDown but doesn't call super.tearDown().\"",
        "description": "A JUnit 3.8 test method that overrides 'tearDown' but does not call 'super.tearDown' may result in subsequent tests failing, or allow the current state to persist and affect subsequent tests.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Frameworks/JUnit/TearDownNoSuper.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom JUnit5InnerTestClass testClass\nwhere not testClass.hasAnnotation(\"org.junit.jupiter.api\", \"Nested\")\nselect testClass, \"This JUnit 5 inner test class lacks a '@Nested' annotation.\"",
        "description": "A JUnit 5 inner test class that is missing a `@Nested` annotation will be excluded from execution and may indicate a mistake from the programmer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Frameworks/JUnit/JUnit5MissingNestedAnnotation.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom TypeJUnitTestCase junitTestCase, TypeJUnitTest junitTest, Method m\nwhere\n  m.hasName(\"suite\") and\n  m.hasNoParameters() and\n  m.getDeclaringType().hasSupertype+(junitTestCase) and\n  (\n    not m.isPublic() or\n    not m.isStatic() or\n    not m.getReturnType().(RefType).getAnAncestor() = junitTest\n  )\nselect m, \"Bad declaration for suite method.\"",
        "description": "A 'suite' method in a JUnit 3.8 test that does not match the expected signature is not detected by JUnit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Frameworks/JUnit/BadSuiteMethod.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall ma, Method m, MainMethod main\nwhere\n  ma.getQualifier().getType().getCompilationUnit().getPackage().getName().matches(\"javax.swing%\") and\n  (\n    m.hasName(\"show\") and m.hasNoParameters()\n    or\n    m.hasName(\"pack\") and m.hasNoParameters()\n    or\n    m.hasName(\"setVisible\") and m.getNumberOfParameters() = 1\n  ) and\n  ma.getMethod() = m and\n  ma.getEnclosingCallable() = main\nselect ma,\n  \"Call to swing method in \" + main.getDeclaringType().getName() +\n    \" needs to be performed in Swing event thread.\"",
        "description": "Calling Swing methods from a thread other than the event-dispatching thread may result in multi-threading errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Frameworks/Swing/ThreadSafety.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass Adapter extends Class {\n  Adapter() {\n    this.getName().matches(\"%Adapter\") and\n    (\n      this.getPackage().hasName(\"java.awt.event\") or\n      this.getPackage().hasName(\"javax.swing.event\")\n    )\n  }\n}\n\npragma[nomagic]\npredicate candidate(Class c, Adapter adapter, Method m, string name) {\n  adapter = c.getASupertype() and\n  c = m.getDeclaringType() and\n  name = m.getName() and\n  // The method is not used for any other purpose.\n  not exists(MethodCall ma | ma.getMethod() = m)\n}\n\nfrom Class c, Adapter adapter, Method m, string name\nwhere\n  candidate(c, adapter, m, name) and\n  exists(Method original | adapter = original.getDeclaringType() | name = original.getName()) and\n  not exists(Method overridden | adapter = overridden.getDeclaringType() | m.overrides(overridden))\nselect m,\n  \"Method \" + m.getName() + \" attempts to override a method in \" + adapter.getName() +\n    \", but does not have the same argument types. \" + m.getName() +\n    \" will not be called when an event occurs.\"",
        "description": "In a class that extends a Swing or Abstract Window Toolkit event adapter, an event handler that does not have exactly the same name as the event handler that it overrides means that the overridden event handler is not called.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Frameworks/Swing/BadlyOverriddenAdapter.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall ma, Method changecase\nwhere\n  (\n    changecase.hasName(\"toUpperCase\") or\n    changecase.hasName(\"toLowerCase\")\n  ) and\n  changecase.hasNoParameters() and\n  changecase.getDeclaringType() instanceof TypeString and\n  ma.getMethod() = changecase\nselect ma, changecase.getName() + \" without locale parameter.\"",
        "description": "Calling 'String.toUpperCase()' or 'String.toLowerCase()' without specifying the locale may cause unexpected results for certain default locales.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/I18N/MissingLocaleArgument.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Collections\n\npredicate containerModification(string package, string type, int p, string signature, int i) {\n  package = \"java.util\" and\n  type = \"Collection\" and\n  p = 0 and\n  signature = \"remove(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Deque\" and\n  p = 0 and\n  signature = \"removeFirstOccurrence(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Deque\" and\n  p = 0 and\n  signature = \"removeLastOccurrence(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Dictionary\" and\n  p = 0 and\n  signature = \"remove(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Map\" and\n  p = 0 and\n  signature = \"remove(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Map\" and\n  p = 0 and\n  signature = \"remove(java.lang.Object,java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Map\" and\n  p = 1 and\n  signature = \"remove(java.lang.Object,java.lang.Object)\" and\n  i = 1\n  or\n  package = \"java.util\" and\n  type = \"Vector\" and\n  p = 0 and\n  signature = \"removeElement(java.lang.Object)\" and\n  i = 0\n}\n\nclass MismatchedContainerModification extends MethodCall {\n  MismatchedContainerModification() {\n    exists(string package, string type, int i |\n      containerModification(package, type, _, this.getCallee().getSignature(),\n        pragma[only_bind_into](i))\n    |\n      this.getCallee()\n          .getDeclaringType()\n          .getASourceSupertype*()\n          .getSourceDeclaration()\n          .hasQualifiedName(package, type) and\n      this.getCallee().getParameter(pragma[only_bind_into](i)).getType() instanceof TypeObject\n    )\n  }\n\n  /**\n   * Holds if `result` is one of the element types of the container accessed by this call\n   * and the argument at index `i` of this call is expected to have type `result`.\n   */\n  RefType getReceiverElementType(int i) {\n    exists(RefType t, GenericType g, string package, string type, int p |\n      containerModification(package, type, p, this.getCallee().getSignature(), i)\n    |\n      t = this.getCallee().getDeclaringType() and\n      t.getASourceSupertype*().getSourceDeclaration() = g and\n      g.hasQualifiedName(package, type) and\n      indirectlyInstantiates(t, g, p, result)\n    )\n  }\n\n  /**\n   * Gets the type of the argument at index `i` of this method access,\n   * boxed if it is a primitive.\n   */\n  RefType getArgumentType(int i) {\n    exists(Type argtp | argtp = this.getArgument(i).getType() |\n      result = argtp or result = argtp.(PrimitiveType).getBoxedType()\n    )\n  }\n}\n\nfrom MismatchedContainerModification ma, RefType elementtype, RefType argtype, int idx\nwhere\n  elementtype = ma.getReceiverElementType(idx).getSourceDeclaration() and\n  argtype = ma.getArgumentType(idx) and\n  notHaveIntersection(elementtype, argtype)\nselect ma.getArgument(idx),\n  \"Actual argument type '\" + argtype.getName() + \"'\" +\n    \" is incompatible with expected argument type '\" + elementtype.getName() + \"'.\"",
        "description": "Calling container modification methods such as 'Collection.remove' or 'Map.remove' with an object of a type that is incompatible with the corresponding container element type is unlikely to have any effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Collections/RemoveTypeMismatch.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Collections\n\npredicate containerAccess(string package, string type, int p, string signature, int i) {\n  package = \"java.util\" and\n  type = \"Collection\" and\n  p = 0 and\n  signature = \"contains(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Dictionary\" and\n  p = 0 and\n  signature = \"get(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Hashtable\" and\n  p = 1 and\n  signature = \"contains(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"List\" and\n  p = 0 and\n  signature = \"indexOf(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"List\" and\n  p = 0 and\n  signature = \"lastIndexOf(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Map\" and\n  p = 0 and\n  signature = \"get(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Map\" and\n  p = 0 and\n  signature = \"getOrDefault(java.lang.Object,java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Map\" and\n  p = 0 and\n  signature = \"containsKey(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Map\" and\n  p = 1 and\n  signature = \"containsValue(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Stack\" and\n  p = 0 and\n  signature = \"search(java.lang.Object)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Vector\" and\n  p = 0 and\n  signature = \"indexOf(java.lang.Object,int)\" and\n  i = 0\n  or\n  package = \"java.util\" and\n  type = \"Vector\" and\n  p = 0 and\n  signature = \"lastIndexOf(java.lang.Object,int)\" and\n  i = 0\n  or\n  package = \"java.util.concurrent\" and\n  type = \"ConcurrentHashMap\" and\n  p = 1 and\n  signature = \"contains(java.lang.Object)\" and\n  i = 0\n}\n\nclass MismatchedContainerAccess extends MethodCall {\n  MismatchedContainerAccess() {\n    exists(string package, string type, int i |\n      containerAccess(package, type, _, this.getCallee().getSignature(), pragma[only_bind_into](i))\n    |\n      this.getCallee()\n          .getDeclaringType()\n          .getSourceDeclaration()\n          .getASourceSupertype*()\n          .hasQualifiedName(package, type) and\n      this.getCallee().getParameter(pragma[only_bind_into](i)).getType() instanceof TypeObject\n    )\n  }\n\n  /**\n   * Holds if `result` is one of the element types of the container accessed by this call\n   * and the argument at index `i` of this call is expected to have type `result`.\n   */\n  RefType getReceiverElementType(int i) {\n    exists(RefType t, GenericType g, string package, string type, int p |\n      containerAccess(package, type, p, this.getCallee().getSignature(), i)\n    |\n      t = this.getCallee().getDeclaringType() and\n      t.getSourceDeclaration().getASourceSupertype*() = g and\n      g.hasQualifiedName(package, type) and\n      indirectlyInstantiates(t, g, p, result)\n    )\n  }\n\n  /**\n   * Gets the type of the argument at index `i` of this method access,\n   * boxed if it is a primitive.\n   */\n  RefType getArgumentType(int i) {\n    exists(Type argtp | argtp = this.getArgument(i).getType() |\n      result = argtp or result = argtp.(PrimitiveType).getBoxedType()\n    )\n  }\n}\n\nfrom MismatchedContainerAccess ma, RefType typearg, RefType argtype, int idx\nwhere\n  typearg = ma.getReceiverElementType(idx).getSourceDeclaration() and\n  argtype = ma.getArgumentType(idx) and\n  notHaveIntersection(typearg, argtype)\nselect ma.getArgument(idx),\n  \"Actual argument type '\" + argtype.getName() + \"'\" +\n    \" is incompatible with expected argument type '\" + typearg.getName() + \"'.\"",
        "description": "Calling container access methods such as 'Collection.contains' or 'Map.get' with an object of a type that is incompatible with the corresponding container element type is unlikely to return 'true'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Collections/ContainsTypeMismatch.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Reflection\nimport Containers\n\nfrom Variable v\nwhere\n  v.fromSource() and\n  v.getType() instanceof ContainerType and\n  // Exclude parameters and non-private fields.\n  (v instanceof LocalVariableDecl or v.(Field).isPrivate()) and\n  // Exclude fields that may be written to reflectively.\n  not reflectivelyWritten(v) and\n  // Every access to `v` is either...\n  forall(VarAccess va | va = v.getAnAccess() |\n    // ...an assignment storing a fresh container into `v`,\n    exists(AssignExpr assgn | va = assgn.getDest() | assgn.getSource() instanceof FreshContainer)\n    or\n    // ...a return (but only if `v` is a local variable)\n    v instanceof LocalVariableDecl and exists(ReturnStmt ret | ret.getResult() = va)\n    or\n    // ...or a call to a query method on `v`.\n    exists(MethodCall ma | va = ma.getQualifier() | ma.getMethod() instanceof ContainerQueryMethod)\n  ) and\n  // There is at least one call to a query method.\n  exists(MethodCall ma | v.getAnAccess() = ma.getQualifier() |\n    ma.getMethod() instanceof ContainerQueryMethod\n  ) and\n  // Also, any value that `v` is initialized to is a fresh container,\n  forall(Expr e | e = v.getAnAssignedValue() | e instanceof FreshContainer) and\n  // and `v` is not implicitly initialized.\n  not v.(LocalVariableDecl).getDeclExpr().hasImplicitInit()\nselect v, \"The contents of this container are never initialized.\"",
        "description": "Querying the contents of a collection or map that is never initialized is not normally useful.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Collections/ReadOnlyContainer.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.Reflection\nimport semmle.code.java.frameworks.Lombok\nimport Containers\n\nfrom Variable v\nwhere\n  v.fromSource() and\n  v.getType() instanceof ContainerType and\n  // Exclude parameters and non-private fields.\n  (v instanceof LocalVariableDecl or v.(Field).isPrivate()) and\n  // Exclude fields that may be read from reflectively.\n  not reflectivelyRead(v) and\n  // Exclude fields annotated with `@SuppressWarnings(\"unused\")`.\n  not v.getAnAnnotation().(SuppressWarningsAnnotation).getASuppressedWarning() = \"unused\" and\n  // Exclude fields with relevant Lombok annotations.\n  not v instanceof LombokGetterAnnotatedField and\n  // Every access to `v` is either...\n  forex(VarAccess va | va = v.getAnAccess() |\n    // ...an assignment storing a new container into `v`,\n    exists(AssignExpr assgn |\n      va = assgn.getDest() and assgn.getSource() instanceof ClassInstanceExpr\n    )\n    or\n    // ...or a call to a mutator method on `v` such that the result of the call is not checked.\n    exists(ContainerMutation cm | va = cm.getQualifier() and not cm.resultIsChecked())\n  ) and\n  // Also, any value that `v` is initialized to is a new container,\n  forall(Expr e | e = v.getAnAssignedValue() | e instanceof ClassInstanceExpr) and\n  // and `v` is not implicitly initialized\n  not v.(LocalVariableDecl).getDeclExpr().hasImplicitInit()\nselect v, \"The contents of this container are never accessed.\"",
        "description": "A collection or map whose contents are never queried or accessed is useless.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Collections/WriteOnlyContainer.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nclass SpecialCollectionCreation extends MethodCall {\n  SpecialCollectionCreation() {\n    exists(Method m, RefType rt | m = this.(MethodCall).getCallee() and rt = m.getDeclaringType() |\n      rt.hasQualifiedName(\"java.util\", \"Arrays\") and m.hasName(\"asList\")\n      or\n      rt.hasQualifiedName(\"java.util\", \"Collections\") and\n      m.getName().regexpMatch(\"singleton.*|unmodifiable.*\")\n    )\n  }\n}\n\npredicate containsSpecialCollection(Expr e, SpecialCollectionCreation origin) {\n  e = origin\n  or\n  exists(Variable v |\n    containsSpecialCollection(pragma[only_bind_into](v.getAnAssignedValue()), origin) and\n    e = v.getAnAccess()\n  )\n  or\n  exists(Call c, int i |\n    containsSpecialCollection(c.getArgument(i), origin) and\n    e = c.getCallee().getSourceDeclaration().getParameter(i).getAnAccess()\n  )\n  or\n  exists(Call c, ReturnStmt r | e = c |\n    r.getEnclosingCallable() = c.getCallee().getSourceDeclaration() and\n    containsSpecialCollection(r.getResult(), origin)\n  )\n}\n\npredicate iterOfSpecialCollection(Expr e, SpecialCollectionCreation origin) {\n  exists(MethodCall ma | ma = e |\n    containsSpecialCollection(ma.getQualifier(), origin) and\n    ma.getCallee().hasName(\"iterator\")\n  )\n  or\n  exists(Variable v |\n    iterOfSpecialCollection(pragma[only_bind_into](v.getAnAssignedValue()), origin) and\n    e = v.getAnAccess()\n  )\n  or\n  exists(Call c, int i |\n    iterOfSpecialCollection(c.getArgument(i), origin) and\n    e = c.getCallee().getSourceDeclaration().getParameter(i).getAnAccess()\n  )\n  or\n  exists(Call c, ReturnStmt r | e = c |\n    r.getEnclosingCallable() = c.getCallee().getSourceDeclaration() and\n    iterOfSpecialCollection(r.getResult(), origin)\n  )\n}\n\nfrom MethodCall remove, SpecialCollectionCreation scc\nwhere\n  remove.getCallee().hasName(\"remove\") and\n  iterOfSpecialCollection(remove.getQualifier(), scc)\nselect remove,\n  \"This call may fail when iterating over $@, since it does not support element removal.\", scc,\n  \"the collection\"",
        "description": "Attempting to invoke 'Iterator.remove' on an iterator over a collection that does not support element removal causes a runtime exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Collections/IteratorRemoveMayFail.ql",
        "language": "java"
    },
    {
        "query": "import java\nimport semmle.code.java.dataflow.SSA\nimport semmle.code.java.dataflow.RangeUtils\nimport semmle.code.java.dataflow.RangeAnalysis\n\npragma[nomagic]\npredicate ssaArrayLengthBound(SsaVariable arr, Bound b) {\n  exists(FieldAccess len |\n    len.getField() instanceof ArrayLengthField and\n    len.getQualifier() = arr.getAUse() and\n    b.getExpr() = len\n  )\n}\n\npredicate boundedArrayAccess(ArrayAccess aa, int k) {\n  exists(SsaVariable arr, Expr index, Bound b, int delta |\n    aa.getIndexExpr() = index and\n    aa.getArray() = arr.getAUse() and\n    bounded(index, b, delta, true, _)\n  |\n    ssaArrayLengthBound(arr, b) and\n    k = delta\n    or\n    exists(ArrayCreationExpr arraycreation | arraycreation = getArrayDef(arr) |\n      k = delta and\n      arraycreation.getDimension(0) = b.getExpr()\n      or\n      exists(int arrlen |\n        arraycreation.getFirstDimensionSize() = arrlen and\n        b instanceof ZeroBound and\n        k = delta - arrlen\n      )\n    )\n  )\n  or\n  exists(Field arr, Expr index, int delta, int arrlen |\n    aa.getIndexExpr() = index and\n    aa.getArray() = arr.getAnAccess() and\n    bounded(index, any(ZeroBound z), delta, true, _) and\n    arr.isFinal() and\n    arr.getInitializer().(ArrayCreationExpr).getFirstDimensionSize() = arrlen and\n    k = delta - arrlen\n  )\n}\n\npredicate bestArrayAccessBound(ArrayAccess aa, int k) {\n  k = min(int k0 | boundedArrayAccess(aa, k0))\n}\n\nfrom ArrayAccess aa, int k, string kstr\nwhere\n  bestArrayAccessBound(aa, k) and\n  k >= 0 and\n  if k = 0 then kstr = \"\" else kstr = \" + \" + k\nselect aa,\n  \"This array access might be out of bounds, as the index might be equal to the array length\" + kstr\n    + \".\"",
        "description": "Accessing an array with an index that is greater than or equal to the length of the array causes an 'ArrayIndexOutOfBoundsException'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Collections/ArrayIndexOutOfBounds.ql",
        "language": "java"
    },
    {
        "query": "import java\n\nfrom MethodCall c, Method m, ParameterizedClass p, AnnotationType t\nwhere\n  c.getMethod() = m and\n  m.hasName(\"isAnnotationPresent\") and\n  m.getNumberOfParameters() = 1 and\n  c.getArgument(0).getType() = p and\n  p.getATypeArgument() = t and\n  t.getRetentionPolicy() != \"RUNTIME\"\nselect c, \"Call to isAnnotationPresent where no annotation has the RUNTIME retention policy.\"",
        "description": "If an annotation has not been annotated with a 'RUNTIME' retention policy, checking for its presence at runtime is not possible.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/java/ql/src/Likely Bugs/Reflection/AnnotationPresentCheck.ql",
        "language": "java"
    },
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import codeql.ruby.ast.internal.TreeSitter\n\nclass AstNode extends Ruby::Token {\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n}\n\nclass SingleLineComment extends Ruby::Comment, AstNode {\n  SingleLineComment() {\n    // suppression comments must be single-line\n    this.getLocation().getStartLine() = this.getLocation().getEndLine()\n  }\n\n  /** Gets the suppression annotation in this comment. */\n  string getText() { result = this.getValue().suffix(1) }\n}\n\nimport AS::Make<AstNode, SingleLineComment>",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/AlertSuppression.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.filters.GeneratedCode\n\npredicate classify(File f, string category) {\n  f instanceof GeneratedCodeFile and category = \"generated\"\n}\n\nfrom File f, string category\nwhere classify(f, category)\nselect f, category",
        "description": "This query produces a list of all files in a database that are classified as generated code or test code. Used by LGTM.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/filters/ClassifyFiles.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.AST\nprivate import codeql.ruby.DataFlow\nprivate import codeql.ruby.ApiGraphs\n\nprivate class OpenSslHmacSource extends DataFlow::Node {\n  OpenSslHmacSource() {\n    exists(API::Node hmacNode | hmacNode = API::getTopLevelMember(\"OpenSSL\").getMember(\"HMAC\") |\n      this = hmacNode.getAMethodCall([\"hexdigest\", \"to_s\", \"digest\", \"base64digest\"])\n      or\n      this = hmacNode.getAnInstantiation()\n    )\n  }\n}\n\nprivate module UnsafeHmacComparison {\n  private module Config implements DataFlow::ConfigSig {\n    predicate isSource(DataFlow::Node source) { source instanceof OpenSslHmacSource }\n\n    // Holds if a given sink is an Equality Operation (== or !=)\n    predicate isSink(DataFlow::Node sink) {\n      any(EqualityOperation eqOp).getAnOperand() = sink.asExpr().getExpr()\n    }\n  }\n\n  import DataFlow::Global<Config>\n}\n\nprivate import UnsafeHmacComparison::PathGraph\n\nfrom UnsafeHmacComparison::PathNode source, UnsafeHmacComparison::PathNode sink\nwhere UnsafeHmacComparison::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This comparison is potentially vulnerable to a timing attack.\"",
        "description": "An HMAC is being compared using the equality operator.  This may be vulnerable to a cryptographic timing attack because the equality operation does not occur in constant time.\"",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/cwe-208/UnsafeHmacComparison.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.InsecureRandomnessQuery\nimport InsecureRandomnessFlow::PathGraph\n\nfrom InsecureRandomnessFlow::PathNode source, InsecureRandomnessFlow::PathNode sink\nwhere InsecureRandomnessFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This uses a cryptographically insecure random number generated at $@ in a security context.\",\n  source.getNode(), source.getNode().toString()",
        "description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/insecure-randomness/InsecureRandomness.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.DataFlow\nimport codeql.ruby.dataflow.internal.DataFlowPublic\nimport codeql.ruby.security.ConditionalBypassQuery\nimport codeql.ruby.security.SensitiveActions\nimport ConditionalBypassFlow::PathGraph\n\npredicate flowsToGuardExpr(DataFlow::Node nd, SensitiveActionGuardConditional guard) {\n  nd = guard\n  or\n  exists(DataFlow::Node succ | localFlowStep(nd, succ) | flowsToGuardExpr(succ, guard))\n}\n\nclass SensitiveActionGuardComparison extends ComparisonOperation {\n  SensitiveActionGuardConditional guard;\n\n  SensitiveActionGuardComparison() {\n    exists(DataFlow::Node node | this = node.asExpr().getExpr() | flowsToGuardExpr(node, guard))\n  }\n\n  /**\n   * Gets the guard that uses this comparison.\n   */\n  SensitiveActionGuardConditional getGuard() { result = guard }\n}\n\nclass SensitiveActionGuardComparisonOperand extends Sink {\n  SensitiveActionGuardComparison comparison;\n\n  SensitiveActionGuardComparisonOperand() { this.asExpr().getExpr() = comparison.getAnOperand() }\n\n  override SensitiveAction getAction() { result = comparison.getGuard().getAction() }\n}\n\npredicate isTaintedGuardForSensitiveAction(\n  ConditionalBypassFlow::PathNode sink, ConditionalBypassFlow::PathNode source,\n  SensitiveAction action\n) {\n  action = sink.getNode().(Sink).getAction() and\n  // exclude the intermediary sink\n  not sink.getNode() instanceof SensitiveActionGuardComparisonOperand and\n  ConditionalBypassFlow::flowPath(source, sink)\n}\n\nfrom\n  ConditionalBypassFlow::PathNode source, ConditionalBypassFlow::PathNode sink,\n  SensitiveAction action\nwhere isTaintedGuardForSensitiveAction(sink, source, action)\nselect sink.getNode(), source, sink, \"This condition guards a sensitive $@, but a $@ controls it.\",\n  action, \"action\", source.getNode(), \"user-provided value\"",
        "description": "Conditions controlled by the user are not suited for making security-related decisions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/cwe-807/ConditionalBypass.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.experimental.UnicodeBypassValidationQuery\nimport UnicodeBypassValidationFlow::PathGraph\n\nfrom UnicodeBypassValidationFlow::PathNode source, UnicodeBypassValidationFlow::PathNode sink\nwhere UnicodeBypassValidationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This $@ processes unsafely $@ and any logical validation in-between could be bypassed using special Unicode characters.\",\n  sink.getNode(), \"Unicode transformation (Unicode normalization)\", source.getNode(),\n  \"remote user-controlled data\"",
        "description": "A Unicode transformation is using a remote user-controlled data. The transformation is a Unicode normalization using the algorithms \"NFC\" or \"NFKC\". In all cases, the security measures implemented or the logical validation performed to escape any injection characters, to validate using regex patterns or to perform string-based checks, before the Unicode transformation are **bypassable** by special Unicode characters.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/cwe-176/UnicodeBypassValidation.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.ImproperMemoizationQuery\n\nfrom Method m, Parameter p, AssignLogicalOrExpr s\nwhere isImproperMemoizationMethod(m, p, s)\nselect m, \"A $@ in this memoization method does not form part of the memoization key.\", p,\n  \"parameter\"",
        "description": "Omitting a parameter from the key of a memoization method can lead to reading stale or incorrect data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/improper-memoization/ImproperMemoization.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.DataFlow\nimport codeql.ruby.controlflow.CfgNodes\nimport codeql.ruby.frameworks.ActionController\nimport codeql.ruby.TaintTracking\n\n// any `request` calls in an action method\nclass Request extends DataFlow::CallNode {\n  Request() {\n    this.getMethodName() = \"request\" and\n    this.asExpr().getExpr().getEnclosingMethod() instanceof ActionControllerActionMethod\n  }\n}\n\n// `request.env`\nclass RequestEnvMethod extends DataFlow::CallNode {\n  RequestEnvMethod() {\n    this.getMethodName() = \"env\" and\n    any(Request r).flowsTo(this.getReceiver())\n  }\n}\n\n// `request.request_method`\nclass RequestRequestMethod extends DataFlow::CallNode {\n  RequestRequestMethod() {\n    this.getMethodName() = \"request_method\" and\n    any(Request r).flowsTo(this.getReceiver())\n  }\n}\n\n// `request.method`\nclass RequestMethod extends DataFlow::CallNode {\n  RequestMethod() {\n    this.getMethodName() = \"method\" and\n    any(Request r).flowsTo(this.getReceiver())\n  }\n}\n\n// `request.raw_request_method`\nclass RequestRawRequestMethod extends DataFlow::CallNode {\n  RequestRawRequestMethod() {\n    this.getMethodName() = \"raw_request_method\" and\n    any(Request r).flowsTo(this.getReceiver())\n  }\n}\n\n// `request.request_method_symbol`\nclass RequestRequestMethodSymbol extends DataFlow::CallNode {\n  RequestRequestMethodSymbol() {\n    this.getMethodName() = \"request_method_symbol\" and\n    any(Request r).flowsTo(this.getReceiver())\n  }\n}\n\n// `request.get?`\nclass RequestGet extends DataFlow::CallNode {\n  RequestGet() {\n    this.getMethodName() = \"get?\" and\n    any(Request r).flowsTo(this.getReceiver())\n  }\n}\n\nprivate module HttpVerbConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof RequestMethod or\n    source instanceof RequestRequestMethod or\n    source instanceof RequestEnvMethod or\n    source instanceof RequestRawRequestMethod or\n    source instanceof RequestRequestMethodSymbol or\n    source instanceof RequestGet\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    exists(ExprNodes::ConditionalExprCfgNode c | c.getCondition() = sink.asExpr()) or\n    exists(ExprNodes::CaseExprCfgNode c | c.getValue() = sink.asExpr())\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n}\n\nprivate module HttpVerbFlow = TaintTracking::Global<HttpVerbConfig>;\n\nimport HttpVerbFlow::PathGraph\n\nfrom HttpVerbFlow::PathNode source, HttpVerbFlow::PathNode sink\nwhere HttpVerbFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Manually checking HTTP verbs is an indication that multiple requests are routed to the same controller action. This could lead to bypassing necessary authorization methods and other protections, like CSRF protection. Prefer using different controller actions for each HTTP method and relying Rails routing to handle mapping resources and verbs to specific methods.\"",
        "description": "Manually checking HTTP verbs is an indication that multiple requests are routed to the same controller action. This could lead to bypassing necessary authorization methods and other protections, like CSRF protection. Prefer using different controller actions for each HTTP method and relying Rails routing to handle mapping resources and verbs to specific methods.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/manually-check-http-verb/ManuallyCheckHttpVerb.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.ImproperLdapAuthQuery\nimport codeql.ruby.Concepts\nimport ImproperLdapAuthFlow::PathGraph\n\nfrom ImproperLdapAuthFlow::PathNode source, ImproperLdapAuthFlow::PathNode sink\nwhere ImproperLdapAuthFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This LDAP authentication depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "A user-controlled query carries no authentication",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/ldap-improper-auth/ImproperLdapAuth.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.TemplateInjectionQuery\nimport TemplateInjectionFlow::PathGraph\n\nfrom TemplateInjectionFlow::PathNode source, TemplateInjectionFlow::PathNode sink\nwhere TemplateInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This template depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a server-side template from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/template-injection/TemplateInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.ApiGraphs\nimport codeql.ruby.DataFlow\nimport codeql.ruby.dataflow.RemoteFlowSources\nimport codeql.ruby.TaintTracking\n\nclass DecompressionApiUse extends DataFlow::Node {\n  private DataFlow::CallNode call;\n\n  // this should find the first argument in calls to Zlib::Inflate.inflate or Zip::File.open_buffer\n  DecompressionApiUse() {\n    this = call.getArgument(0) and\n    (\n      call = API::getTopLevelMember(\"Zlib\").getMember(\"Inflate\").getAMethodCall(\"inflate\") or\n      call = API::getTopLevelMember(\"Zip\").getMember(\"File\").getAMethodCall(\"open_buffer\")\n    )\n  }\n\n  // returns calls to Zlib::Inflate.inflate or Zip::File.open_buffer\n  DataFlow::CallNode getCall() { result = call }\n}\n\nprivate module DecompressionApiConfig implements DataFlow::ConfigSig {\n  // this predicate will be used to constrain our query to find instances where only remote user-controlled data flows to the sink\n  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }\n\n  // our Decompression APIs defined above will be the sinks we use for this query\n  predicate isSink(DataFlow::Node sink) { sink instanceof DecompressionApiUse }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    result = sink.(DecompressionApiUse).getLocation()\n    or\n    result = sink.(DecompressionApiUse).getCall().getLocation()\n  }\n}\n\nprivate module DecompressionApiFlow = TaintTracking::Global<DecompressionApiConfig>;\n\nimport DecompressionApiFlow::PathGraph\n\nfrom DecompressionApiFlow::PathNode source, DecompressionApiFlow::PathNode sink\nwhere DecompressionApiFlow::flowPath(source, sink)\nselect sink.getNode().(DecompressionApiUse), source, sink,\n  \"This call to $@ is unsafe because user-controlled data is used to set the object being decompressed, which could lead to a denial of service attack or malicious code extracted from an unknown source.\",\n  sink.getNode().(DecompressionApiUse).getCall(),\n  sink.getNode().(DecompressionApiUse).getCall().getMethodName()",
        "description": "User-controlled data that flows into decompression library APIs could be dangerous",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/decompression-api/DecompressionApi.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.XpathInjectionQuery\nimport XpathInjectionFlow::PathGraph\n\nfrom XpathInjectionFlow::PathNode source, XpathInjectionFlow::PathNode sink\nwhere XpathInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"XPath expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a XPath query from user-controlled sources is vulnerable to insertion of malicious XPath code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/xpath-injection/XpathInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.experimental.ZipSlipQuery\nimport ZipSlipFlow::PathGraph\n\nfrom ZipSlipFlow::PathNode source, ZipSlipFlow::PathNode sink\nwhere ZipSlipFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This file extraction depends on a $@.\", source.getNode(),\n  \"potentially untrusted source\"",
        "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/cwe-022-zipslip/ZipSlip.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nprivate import codeql.ruby.Concepts\nprivate import codeql.ruby.DataFlow\nprivate import codeql.ruby.TaintTracking\nimport DecompressionBombs\n\nclass IoCopyStream extends DataFlow::CallNode {\n  IoCopyStream() { this = API::getTopLevelMember(\"IO\").getAMethodCall(\"copy_stream\") }\n\n  DataFlow::Node getAPathArgument() { result = this.getArgument(0) }\n}\n\nmodule BombsConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof DecompressionBomb::Sink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    any(DecompressionBomb::AdditionalTaintStep ats).isAdditionalTaintStep(nodeFrom, nodeTo)\n    or\n    exists(API::Node n | n = API::getTopLevelMember(\"File\").getMethod(\"open\") |\n      nodeFrom = n.getParameter(0).asSink() and\n      nodeTo = n.getReturn().asSource()\n    )\n    or\n    nodeFrom = nodeTo.(File::FileOpen).getAPathArgument()\n    or\n    exists(API::Node n | n = API::getTopLevelMember(\"StringIO\").getMethod(\"new\") |\n      nodeFrom = n.getParameter(0).asSink() and\n      nodeTo = n.getReturn().asSource()\n    )\n    or\n    nodeFrom = nodeTo.(IoCopyStream).getAPathArgument()\n    or\n    // following can be a global additional step\n    exists(DataFlow::CallNode cn |\n      cn.getMethodName() = \"open\" and\n      cn.getReceiver().getExprNode().getExpr() instanceof Ast::SelfVariableAccess\n    |\n      nodeFrom = cn.getArgument(0) and\n      nodeTo = cn\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Bombs = TaintTracking::Global<BombsConfig>;\n\nimport Bombs::PathGraph\n\nfrom Bombs::PathNode source, Bombs::PathNode sink\nwhere Bombs::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This file Decompression depends on a $@.\", source.getNode(),\n  \"potentially untrusted source\"",
        "description": "User-controlled data that flows into decompression library APIs without checking the compression rate is dangerous",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/CWE-522-DecompressionBombs/DecompressionBombs.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.LdapInjectionQuery\nimport LdapInjectionFlow::PathGraph\n\nfrom LdapInjectionFlow::PathNode source, LdapInjectionFlow::PathNode sink\nwhere LdapInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This LDAP query depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/ldap-injection/LdapInjection.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.Concepts\n\nfrom JwtEncoding jwtEncoding\nwhere not jwtEncoding.signsPayload()\nselect jwtEncoding.getPayload(), \"This JWT encoding uses an empty key or none algorithm.\"",
        "description": "The application uses an empty secret or algorithm while encoding a JWT Token.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/cwe-347/EmptyJWTSecret.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.Concepts\n\nfrom JwtDecoding jwtDecoding\nwhere not jwtDecoding.verifiesSignature()\nselect jwtDecoding.getPayload(), \"is not verified with a cryptographic secret or public key.\"",
        "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/cwe-347/MissingJWTVerification.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Concepts\nimport codeql.ruby.DataFlow\nimport codeql.ruby.TaintTracking\nimport codeql.ruby.frameworks.ActionController\n\nDataFlow::LocalSourceNode request() {\n  result = any(ActionControllerClass cls).getSelf().getAMethodCall(\"request\")\n}\n\nclass WeakParams extends DataFlow::CallNode {\n  WeakParams() {\n    this =\n      request()\n          .getAMethodCall([\n              \"path_parameters\", \"query_parameters\", \"request_parameters\", \"GET\", \"POST\"\n            ])\n  }\n}\n\nprivate module WeakParamsConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof WeakParams }\n\n  // the sink is an instance of a Model class that receives a method call\n  predicate isSink(DataFlow::Node node) { node = any(PersistentWriteAccess a).getValue() }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n}\n\nprivate module WeakParamsFlow = TaintTracking::Global<WeakParamsConfig>;\n\nimport WeakParamsFlow::PathGraph\n\nfrom WeakParamsFlow::PathNode source, WeakParamsFlow::PathNode sink\nwhere WeakParamsFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"By exposing all keys in request parameters or by blindy accessing them, unintended parameters could be used and lead to mass-assignment or have other unexpected side-effects. It is safer to follow the 'strong parameters' pattern in Rails, which is outlined here: https://api.rubyonrails.org/classes/ActionController/StrongParameters.html\"",
        "description": "Directly checking request parameters without following a strong params pattern can lead to unintentional avenues for injection attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/weak-params/WeakParams.ql",
        "language": "ruby"
    },
    {
        "query": "// This is an implementation of the Rubocop rule\n// https://github.com/rubocop/rubocop-performance/blob/master/lib/rubocop/cop/performance/detect.rb\nimport codeql.ruby.AST\nimport codeql.ruby.CFG\nimport codeql.ruby.dataflow.SSA\n\nclass EndCall extends MethodCall {\n  string detect;\n\n  EndCall() {\n    detect = \"detect\" and\n    (\n      this.getMethodName() = \"first\" and\n      this.getNumberOfArguments() = 0\n      or\n      this.getNumberOfArguments() = 1 and\n      this.getArgument(0).getConstantValue().isInt(0)\n    )\n    or\n    detect = \"reverse_detect\" and\n    (\n      this.getMethodName() = \"last\" and\n      this.getNumberOfArguments() = 0\n      or\n      this.getNumberOfArguments() = 1 and\n      this.getArgument(0).getConstantValue().isInt(-1)\n    )\n  }\n\n  string detectCall() { result = detect }\n}\n\nExpr getUniqueRead(Expr e) {\n  forex(CfgNode eNode | eNode.getAstNode() = e |\n    exists(Ssa::WriteDefinition def |\n      def.assigns(eNode) and\n      strictcount(def.getARead()) = 1 and\n      not def = any(Ssa::PhiNode phi).getAnInput() and\n      def.getARead().getAstNode() = result\n    )\n  )\n}\n\nclass SelectBlock extends MethodCall {\n  SelectBlock() {\n    this.getMethodName() in [\"select\", \"filter\", \"find_all\"] and\n    exists(this.getBlock())\n  }\n}\n\nfrom EndCall call, SelectBlock selectBlock\nwhere getUniqueRead*(selectBlock) = call.getReceiver()\nselect call, \"Replace this call and $@ with '\" + call.detectCall() + \"'.\", selectBlock,\n  \"'select' call\"",
        "description": "Use 'detect' instead of 'select' followed by 'first' or 'last'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/performance/UseDetect.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nimport codeql.ruby.security.UnsafeDeserializationQuery\nimport UnsafeCodeConstructionFlow::PathGraph\n\nfrom UnsafeCodeConstructionFlow::PathNode source, UnsafeCodeConstructionFlow::PathNode sink\nwhere UnsafeCodeConstructionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Unsafe deserialization depends on a $@.\", source.getNode(),\n  source.getNode().(UnsafeDeserialization::Source).describe()",
        "description": "Deserializing user-controlled yaml data may allow attackers to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/experimental/cwe-502/UnsafeYamlDeserialization.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\n\nfrom RubyFile f, int n\nwhere n = f.getNumberOfLines()\nselect f, n order by n desc",
        "description": "The number of lines in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/metrics/FLines.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\n\nfrom RubyFile f, int n\nwhere n = f.getNumberOfLinesOfCode()\nselect f, n order by n desc",
        "description": "Measures the number of lines of code in each file, ignoring lines that contain only comments or whitespace.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/metrics/FLinesOfCode.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\n\nfrom RubyFile f, int n\nwhere n = f.getNumberOfLinesOfComments()\nselect f, n order by n desc",
        "description": "Measures the number of lines of comments in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/metrics/FLinesOfComments.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.dataflow.SSA\nimport codeql.ruby.dataflow.internal.DataFlowDispatch\n\nfrom DefLoc loc, Expr src, Expr target, string kind\nwhere\n  ConstantDefLoc(src, target) = loc and kind = \"constant\"\n  or\n  MethodLoc(src, target) = loc and kind = \"method\"\n  or\n  LocalVariableLoc(src, target) = loc and kind = \"variable\"\n  or\n  InstanceVariableLoc(src, target) = loc and kind = \"instance variable\"\n  or\n  ClassVariableLoc(src, target) = loc and kind = \"class variable\"\nselect src, target, kind\n\nnewtype DefLoc =\n  /** A constant, module or class. */\n  ConstantDefLoc(ConstantReadAccess read, ConstantWriteAccess write) {\n    write = definitionOf(read.getAQualifiedName())\n  } or\n  /** A method call. */\n  MethodLoc(MethodCall call, Method meth) {\n    meth = call.getATarget()\n    or\n    // include implicit `initialize` calls\n    meth = getInitializeTarget(call.getAControlFlowNode())\n  } or\n  /** A local variable. */\n  LocalVariableLoc(VariableReadAccess read, VariableWriteAccess write) {\n    exists(Ssa::WriteDefinition w |\n      write = w.getWriteAccess().getAstNode() and\n      read = w.getARead().getExpr() and\n      not read.isSynthesized()\n    )\n  } or\n  /** An instance variable */\n  InstanceVariableLoc(InstanceVariableReadAccess read, InstanceVariableWriteAccess write) {\n    /*\n     * We consider instance variables to be \"defined\" in the initialize method of their enclosing class.\n     * If that method doesn't exist, we won't provide any jump-to-def information for the instance variable.\n     */\n\n    exists(Method m |\n      m.getAChild+() = write and\n      m.getName() = \"initialize\" and\n      write.getVariable() = read.getVariable()\n    )\n  } or\n  /** A class variable */\n  ClassVariableLoc(ClassVariableReadAccess read, ClassVariableWriteAccess write) {\n    read.getVariable() = write.getVariable() and\n    not exists(MethodBase m | m.getAChild+() = write)\n  }\n\npragma[noinline]\nConstantWriteAccess definitionOf(string fqn) {\n  fqn = any(ConstantReadAccess read).getAQualifiedName() and\n  result =\n    min(ConstantWriteAccess w, Location l |\n      w.getAQualifiedName() = fqn and l = w.getLocation()\n    |\n      w\n      order by\n        l.getFile().getAbsolutePath(), l.getStartLine(), l.getStartColumn(), l.getEndLine(),\n        l.getEndColumn()\n    )\n}",
        "description": "Jump to definition helper query.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/analysis/Definitions.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.UnsafeCodeConstructionQuery\nimport UnsafeCodeConstructionFlow::PathGraph\n\nfrom\n  UnsafeCodeConstructionFlow::PathNode source, UnsafeCodeConstructionFlow::PathNode sink,\n  Sink sinkNode\nwhere UnsafeCodeConstructionFlow::flowPath(source, sink) and sinkNode = sink.getNode()\nselect sink.getNode(), source, sink,\n  \"This \" + sinkNode.getSinkType() + \" which depends on $@ is later $@.\", source.getNode(),\n  \"library input\", sinkNode.getCodeSink(), \"interpreted as code\"",
        "description": "Using externally controlled strings to construct code may allow a malicious user to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-094/UnsafeCodeConstruction.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.AST\nprivate import codeql.ruby.security.CodeInjectionQuery\nimport DataFlow::DeduplicatePathGraph<CodeInjectionFlow::PathNode, CodeInjectionFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere CodeInjectionFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink, \"This code execution depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Interpreting unsanitized user input as code allows a malicious user to perform arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-094/CodeInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.StackTraceExposureQuery\nimport StackTraceExposureFlow::PathGraph\n\nfrom StackTraceExposureFlow::PathNode source, StackTraceExposureFlow::PathNode sink\nwhere StackTraceExposureFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"$@ can be exposed to an external user.\", source.getNode(),\n  \"Error information\"",
        "description": "Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-209/StackTraceExposure.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.UrlRedirectQuery\nimport UrlRedirectFlow::PathGraph\n\nfrom UrlRedirectFlow::PathNode source, UrlRedirectFlow::PathNode sink\nwhere UrlRedirectFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Untrusted URL redirection depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-601/UrlRedirect.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Concepts\n\nfrom Cryptography::CryptographicOperation operation, string msgPrefix\nwhere\n  exists(Cryptography::CryptographicAlgorithm algorithm |\n    algorithm = operation.getAlgorithm() and\n    algorithm.isWeak() and\n    msgPrefix = \"The cryptographic algorithm \" + algorithm.getName() and\n    not algorithm instanceof Cryptography::HashingAlgorithm\n  )\n  or\n  operation.getBlockMode().isWeak() and msgPrefix = \"The block mode \" + operation.getBlockMode()\nselect operation, \"$@ is broken or weak, and should not be used.\", operation.getInitialization(),\n  msgPrefix",
        "description": "Using broken or weak cryptographic algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-327/BrokenCryptoAlgorithm.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nimport codeql.ruby.security.WeakSensitiveDataHashingQuery\nimport WeakSensitiveDataHashingFlow::PathGraph\n\nfrom\n  WeakSensitiveDataHashingFlow::PathNode source, WeakSensitiveDataHashingFlow::PathNode sink,\n  string ending, string algorithmName, string classification\nwhere\n  normalHashFunctionFlowPath(source, sink) and\n  algorithmName = sink.getNode().(NormalHashFunction::Sink).getAlgorithmName() and\n  classification = source.getNode().(NormalHashFunction::Source).getClassification() and\n  ending = \".\"\n  or\n  computationallyExpensiveHashFunctionFlowPath(source, sink) and\n  algorithmName = sink.getNode().(ComputationallyExpensiveHashFunction::Sink).getAlgorithmName() and\n  classification =\n    source.getNode().(ComputationallyExpensiveHashFunction::Source).getClassification() and\n  (\n    sink.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n    ending = \".\"\n    or\n    not sink.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n    ending =\n      \" for \" + classification +\n        \" hashing, since it is not a computationally expensive hash function.\"\n  )\nselect sink.getNode(), source, sink,\n  \"$@ is used in a hashing algorithm (\" + algorithmName + \") that is insecure\" + ending,\n  source.getNode(), \"Sensitive data (\" + classification + \")\"",
        "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-327/WeakSensitiveDataHashing.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.DataFlow\nimport codeql.ruby.security.ServerSideRequestForgeryQuery\nimport ServerSideRequestForgeryFlow::PathGraph\n\nfrom ServerSideRequestForgeryFlow::PathNode source, ServerSideRequestForgeryFlow::PathNode sink\nwhere ServerSideRequestForgeryFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"The URL of this request depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Making a network request with user-controlled data in the URL allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-918/ServerSideRequestForgery.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Concepts\nimport codeql.ruby.Frameworks\n\nfrom CookieSecurityConfigurationSetting s\nselect s, s.getSecurityWarningMessage()",
        "description": "Misconfiguring how cookies are encrypted or sent can expose a user to various attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-732/WeakCookieConfiguration.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Concepts\nimport codeql.ruby.DataFlow\nimport codeql.ruby.ApiGraphs\n\nbindingset[p]\nint world_permission(int p) { result = p.bitAnd(7) }\n\n// 70 oct = 56 dec\nbindingset[p]\nint group_permission(int p) { result = p.bitAnd(56) }\n\nbindingset[p]\nstring access(int p) {\n  p.bitAnd(2) != 0 and result = \"writable\"\n  or\n  p.bitAnd(4) != 0 and result = \"readable\"\n}\n\nclass PermissivePermissionsExpr extends Expr {\n  // TODO: non-literal expressions?\n  PermissivePermissionsExpr() {\n    exists(int perm, string acc |\n      perm = this.(IntegerLiteral).getValue() and\n      (acc = access(world_permission(perm)) or acc = access(group_permission(perm)))\n    )\n    or\n    // adding/setting read or write permissions for all/group/other\n    this.(StringLiteral)\n        .getConstantValue()\n        .getString()\n        .regexpMatch(\".*[ago][^-=+]*[+=][xXst]*[rw].*\")\n  }\n}\n\nprivate module PermissivePermissionsConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source.asExpr().getExpr() instanceof PermissivePermissionsExpr\n  }\n\n  additional predicate sinkDef(DataFlow::Node sink, FileSystemPermissionModification mod) {\n    mod.getAPermissionNode() = sink\n  }\n\n  predicate isSink(DataFlow::Node sink) { sinkDef(sink, _) }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSinkLocation(DataFlow::Node sink) {\n    exists(FileSystemPermissionModification mod |\n      sinkDef(sink, mod) and\n      result = mod.getLocation()\n    )\n  }\n}\n\nprivate module PermissivePermissionsFlow = DataFlow::Global<PermissivePermissionsConfig>;\n\nimport PermissivePermissionsFlow::PathGraph\n\nfrom\n  PermissivePermissionsFlow::PathNode source, PermissivePermissionsFlow::PathNode sink,\n  FileSystemPermissionModification mod\nwhere\n  PermissivePermissionsFlow::flowPath(source, sink) and\n  PermissivePermissionsConfig::sinkDef(sink.getNode(), mod)\nselect source.getNode(), source, sink,\n  \"This overly permissive mask used in $@ allows read or write access to others.\", mod,\n  mod.toString()",
        "description": "Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-732/WeakFilePermissions.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nimport codeql.ruby.security.SensitiveGetQueryQuery\nimport codeql.ruby.security.SensitiveGetQueryCustomizations::SensitiveGetQuery\nimport codeql.ruby.security.SensitiveActions\n\nfrom Source source, DataFlow::Node sink\nwhere SensitiveGetQueryFlow::flow(source, sink)\nselect source, \"$@ for GET requests uses query parameter as sensitive data.\", source.getHandler(),\n  \"Route handler\"",
        "description": "Placing sensitive data in a GET request increases the risk of the data being exposed to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-598/SensitiveGetQuery.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.security.HardcodedDataInterpretedAsCodeQuery\nimport HardcodedDataInterpretedAsCodeFlow::PathGraph\n\nfrom\n  HardcodedDataInterpretedAsCodeFlow::PathNode source,\n  HardcodedDataInterpretedAsCodeFlow::PathNode sink\nwhere HardcodedDataInterpretedAsCodeFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"$@ is interpreted as \" + sink.getNode().(Sink).getKind() + \".\", source.getNode(),\n  \"Hard-coded data\"",
        "description": "Transforming hard-coded data (such as hexadecimal constants) into code to be executed is a technique often associated with backdoors and should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-506/HardcodedDataInterpretedAsCode.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.SqlInjectionQuery\nimport SqlInjectionFlow::PathGraph\n\nfrom SqlInjectionFlow::PathNode source, SqlInjectionFlow::PathNode sink\nwhere SqlInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This SQL query depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-089/SqlInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.regexp.RegExpTreeView\nimport codeql.ruby.Regexp\nprivate import codeql.ruby.security.regexp.HostnameRegexp as HostnameRegexp\nprivate import codeql.regex.MissingRegExpAnchor as MissingRegExpAnchor\nprivate import codeql.ruby.regexp.RegExpTreeView::RegexTreeView as TreeImpl\n\nprivate module Impl implements\n  MissingRegExpAnchor::MissingRegExpAnchorSig<TreeImpl, HostnameRegexp::Impl>\n{\n  predicate isUsedAsReplace(RegExpPatternSource pattern) {\n    exists(DataFlow::CallNode mcn, DataFlow::Node arg, string name |\n      name = mcn.getMethodName() and\n      arg = mcn.getArgument(0)\n    |\n      (\n        pattern.getAParse().(DataFlow::LocalSourceNode).flowsTo(arg) or\n        pattern.getAParse() = arg\n      ) and\n      name = [\"sub\", \"sub!\", \"gsub\", \"gsub!\"]\n    )\n  }\n\n  string getEndAnchorText() { result = \"\\\\z\" }\n}\n\nimport MissingRegExpAnchor::Make<TreeImpl, HostnameRegexp::Impl, Impl>\n\nfrom DataFlow::Node nd, string msg\nwhere\n  isUnanchoredHostnameRegExp(nd, msg) or\n  isSemiAnchoredHostnameRegExp(nd, msg) or\n  isLineAnchoredHostnameRegExp(nd, msg) or\n  hasMisleadingAnchorPrecedence(nd, msg)\nselect nd, msg",
        "description": "Regular expressions without anchors can be vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-020/MissingRegExpAnchor.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.security.regexp.HostnameRegexp as HostnameRegxp\n\nquery predicate problems = HostnameRegxp::incompleteHostnameRegExp/4;",
        "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-020/IncompleteHostnameRegExp.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.regexp.MissingFullAnchorQuery\nimport MissingFullAnchorFlow::PathGraph\n\nfrom MissingFullAnchorFlow::PathNode source, MissingFullAnchorFlow::PathNode sink, Sink sinkNode\nwhere MissingFullAnchorFlow::flowPath(source, sink) and sink.getNode() = sinkNode\nselect sink, source, sink, \"This value depends on $@, and is $@ against a $@.\", source.getNode(),\n  source.getNode().(Source).describe(), sinkNode.getCallNode(), \"checked\", sinkNode.getRegex(),\n  \"badly anchored regular expression\"",
        "description": "Regular expressions anchored using `^` or `$` are vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-020/MissingFullAnchor.ql",
        "language": "ruby"
    },
    {
        "query": "import IncompleteUrlSubstringSanitization",
        "description": "Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-020/IncompleteUrlSubstringSanitization.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.regexp.RegExpTreeView::RegexTreeView as TreeView\nimport codeql.regex.OverlyLargeRangeQuery::Make<TreeView>\n\nTreeView::RegExpCharacterClass potentialMisparsedCharClass() {\n  // some escapes, e.g. [\\000-\\037] are currently misparsed.\n  result.getAChild().(TreeView::RegExpNormalChar).getValue() = \"\\\\\"\n  or\n  // nested char classes are currently misparsed\n  result.getAChild().(TreeView::RegExpNormalChar).getValue() = \"[\"\n}\n\nfrom TreeView::RegExpCharacterRange range, string reason\nwhere\n  problem(range, reason) and\n  not range.getParent() = potentialMisparsedCharClass()\nselect range, \"Suspicious character range that \" + reason + \".\"",
        "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-020/OverlyLargeRange.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Concepts\nimport codeql.ruby.DataFlow\n\nfrom\n  Http::Client::Request request, DataFlow::Node disablingNode, DataFlow::Node origin, string ending\nwhere\n  request.disablesCertificateValidation(disablingNode, origin) and\n  // Showing the origin is only useful when it's a different node than the one disabling\n  // certificate validation, for example in `requests.get(..., verify=arg)`, `arg` would\n  // be the `disablingNode`, and the `origin` would be the place were `arg` got its\n  // value from.\n  //\n  // NOTE: We compare the locations instead of DataFlow::Nodes directly, since for\n  // snippet `Excon.defaults[:ssl_verify_peer] = false`, `disablingNode = argumentNode`\n  // does NOT hold.\n  if disablingNode.getLocation() = origin.getLocation() then ending = \".\" else ending = \" by $@.\"\nselect request, \"This request may run without certificate validation because $@\" + ending,\n  disablingNode, \"validation is disabled\", origin, \"this value\"",
        "description": "Making a request without certificate validation can allow man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-295/RequestWithoutValidation.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.LogInjectionQuery\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode source, LogInjectionFlow::PathNode sink\nwhere LogInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Log entry depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-117/LogInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.DataFlow\nimport codeql.ruby.controlflow.CfgNodes\nimport codeql.ruby.frameworks.core.String\nimport codeql.ruby.Regexp as RE\nimport codeql.ruby.dataflow.internal.DataFlowPrivate as DataFlowPrivate\n\nstring metachar() { result = \"'\\\"\\\\&<>\\n\\r\\t*|{}[]%$\".charAt(_) }\n\npredicate isSimple(RE::RegExpTerm t) {\n  t instanceof RE::RegExpConstant\n  or\n  isSimple(t.(RE::RegExpGroup).getAChild()) // N.B. a group has only one child\n  or\n  isSimpleCharacterClass(t)\n  or\n  isSimpleAlt(t)\n}\n\npredicate isSimpleCharacterClass(RE::RegExpCharacterClass t) {\n  not t.isInverted() and\n  forall(RE::RegExpTerm ch | ch = t.getAChild() | isSimple(ch))\n}\n\npredicate isSimpleAlt(RE::RegExpAlt t) {\n  forall(RE::RegExpTerm ch | ch = t.getAChild() | isSimple(ch))\n}\n\npredicate isBackslashEscape(StringSubstitutionCall sub) {\n  sub.isGlobal() and\n  (exists(sub.getPatternString()) or exists(sub.getPatternRegExp().getRegExpTerm())) and\n  (\n    // Replacement with `\\` followed by a backref such as `\\&`, `\\1`, etc. The\n    // replacement argument to the substitution call will look like '\\\\\\\\\\0',\n    // '\\\\\\\\\\\\0', or \"\\\\\\\\\\\\0\". Those examples all have the same string value\n    // (i.e. after Ruby's unescaping) of `\\\\\\0`. Then, to account for the\n    // backslash escaping in both QL's string syntax and its regexp engine, each\n    // of those three backslashes becomes `\\\\\\\\` in the following:\n    sub.getReplacementString().regexpMatch(\"\\\\\\\\\\\\\\\\\\\\\\\\(&|\\\\d)\")\n    or\n    // replacement of `c` with `\\c`\n    exists(string c | sub.replaces(c, \"\\\\\" + c))\n  )\n}\n\npredicate allBackslashesEscaped(DataFlow::Node node) {\n  exists(StringSubstitutionCall sub | node = sub |\n    // check whether `sub` itself escapes backslashes\n    isBackslashEscape(sub) and\n    (\n      sub.getAReplacedString() = \"\\\\\"\n      or\n      // if it's a complex regexp, we conservatively assume that it probably escapes backslashes\n      exists(RE::RegExpTerm root | root = sub.getPatternRegExp().getRegExpTerm() |\n        not isSimple(root)\n      )\n    )\n  )\n  or\n  // flow through string methods\n  exists(ExprNodes::MethodCallCfgNode mc, string m, DataFlow::Node receiver |\n    m =\n      [\n        \"sub\", \"gsub\", \"slice\", \"[]\", \"strip\", \"lstrip\", \"rstrip\", \"chomp\", \"chop\", \"downcase\",\n        \"upcase\", \"sub!\", \"gsub!\", \"slice!\", \"strip!\", \"lstrip!\", \"rstrip!\", \"chomp!\", \"chop!\",\n        \"downcase!\", \"upcase!\",\n      ]\n  |\n    mc = node.asExpr() and\n    m = mc.getExpr().getMethodName() and\n    receiver.asExpr() = mc.getReceiver() and\n    allBackslashesEscaped(receiver)\n  )\n  or\n  // general data flow\n  allBackslashesEscaped(node.getAPredecessor())\n  or\n  // general data flow from a (destructive) [g]sub!\n  exists(StringSubstitutionCall sub |\n    sub.isDestructive() and\n    allBackslashesEscaped(sub) and\n    node.(DataFlow::PostUpdateNode).getPreUpdateNode() = sub.getReceiver()\n  )\n}\n\npredicate removesFirstOccurrence(StringSubstitutionCall sub, string str) {\n  not sub.isGlobal() and sub.replaces(str, \"\")\n}\n\nDataFlow::CallNode getAMethodCall(StringSubstitutionCall call) {\n  exists(DataFlow::Node receiver | receiver = result.getReceiver() |\n    // for a non-destructive string substitution, is there flow from it to the\n    // receiver of another method call?\n    not call.isDestructive() and\n    DataFlow::localFlow(call, receiver)\n    or\n    // for a destructive string substitution, is there flow from its\n    // post-update receiver to the receiver of another method call?\n    call.isDestructive() and\n    exists(DataFlow::PostUpdateNode post |\n      post.getPreUpdateNode() = call.getReceiver() and\n      DataFlow::localFlowStep+(post, receiver)\n    )\n  )\n}\n\npredicate isDelimiterUnwrapper(StringSubstitutionCall leftUnwrap, StringSubstitutionCall rightUnwrap) {\n  exists(string left, string right |\n    left = \"[\" and right = \"]\"\n    or\n    left = \"{\" and right = \"}\"\n    or\n    left = \"(\" and right = \")\"\n    or\n    left = \"\\\"\" and right = \"\\\"\"\n    or\n    left = \"'\" and right = \"'\"\n  |\n    removesFirstOccurrence(leftUnwrap, left) and\n    removesFirstOccurrence(rightUnwrap, right) and\n    rightUnwrap = getAMethodCall(leftUnwrap)\n  )\n}\n\npredicate whitelistedRemoval(StringSubstitutionCall sub) {\n  not sub.isGlobal() and\n  exists(string s | s = \"\\n\" or s = \"%\" or s = \"$\" |\n    sub.replaces(s, \"\") and\n    not exists(StringSubstitutionCall other |\n      other = getAMethodCall(sub) or\n      sub = getAMethodCall(other)\n    )\n  )\n}\n\nfrom StringSubstitutionCall sub, DataFlow::Node old, string msg\nwhere\n  old = sub.getPatternArgument() and\n  (\n    not sub.isGlobal() and\n    msg = \"This replaces only the first occurrence of \" + old + \".\" and\n    // only flag if this is likely to be a sanitizer or URL encoder or decoder\n    exists(string m | m = sub.getAReplacedString() |\n      // sanitizer\n      m = metachar()\n      or\n      exists(string urlEscapePattern | urlEscapePattern = \"(%[0-9A-Fa-f]{2})+\" |\n        // URL decoder\n        m.regexpMatch(urlEscapePattern)\n        or\n        // URL encoder\n        sub.getReplacementString().regexpMatch(urlEscapePattern)\n      )\n      or\n      // path sanitizer\n      (m = \"..\" or m = \"/..\" or m = \"../\" or m = \"/../\")\n    ) and\n    // don't flag replace operations in a loop\n    not sub.asExpr().(ExprNodes::MethodCallCfgNode).getReceiver() = sub.asExpr().getASuccessor+() and\n    // don't flag unwrapper\n    not isDelimiterUnwrapper(sub, _) and\n    not isDelimiterUnwrapper(_, sub) and\n    // don't flag replacements of certain characters with whitespace\n    not whitelistedRemoval(sub)\n    or\n    isBackslashEscape(sub) and\n    not allBackslashesEscaped(sub) and\n    msg = \"This does not escape backslash characters in the input.\"\n  )\nselect sub, msg",
        "description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-116/IncompleteSanitization.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.regexp.RegExpTreeView::RegexTreeView as TreeView\nimport codeql.regex.nfa.BadTagFilterQuery::Make<TreeView>\n\nfrom HtmlMatchingRegExp regexp, string msg\nwhere msg = min(string m | isBadRegexpFilter(regexp, m) | m order by m.length(), m) // there might be multiple, we arbitrarily pick the shortest one\nselect regexp, msg",
        "description": "Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-116/BadTagFilter.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.IncompleteMultiCharacterSanitizationQuery",
        "description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-116/IncompleteMultiCharacterSanitization.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.MassAssignmentQuery\nimport MassAssignmentFlow::PathGraph\n\nfrom MassAssignmentFlow::PathNode source, MassAssignmentFlow::PathNode sink\nwhere MassAssignmentFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This mass assignment operation can assign user-controlled attributes from $@.\", source.getNode(),\n  \"this remote flow source\"",
        "description": "Using mass assignment with user-controlled attributes allows unintended parameters to be set.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-915/MassAssignment.ql",
        "language": "ruby"
    },
    {
        "query": "private import codeql.ruby.regexp.RegExpTreeView::RegexTreeView as TreeView\nimport codeql.regex.nfa.ExponentialBackTracking::Make<TreeView>\n\nfrom TreeView::RegExpTerm t, string pump, State s, string prefixMsg\nwhere hasReDoSResult(t, pump, s, prefixMsg)\nselect t,\n  \"This part of the regular expression may cause exponential backtracking on strings \" + prefixMsg +\n    \"containing many repetitions of '\" + pump + \"'.\"",
        "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-1333/ReDoS.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.regexp.RegExpInjectionQuery\nimport RegExpInjectionFlow::PathGraph\n\nfrom RegExpInjectionFlow::PathNode source, RegExpInjectionFlow::PathNode sink\nwhere RegExpInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This regular expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "User input should not be used in regular expressions without first being escaped. Otherwise, a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-1333/RegExpInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.regexp.PolynomialReDoSCustomizations::PolynomialReDoS as PR\nimport codeql.ruby.security.regexp.PolynomialReDoSQuery\nimport PolynomialReDoSFlow::PathGraph\n\nfrom\n  PolynomialReDoSFlow::PathNode source, PolynomialReDoSFlow::PathNode sink, PR::Sink sinkNode,\n  PR::PolynomialBackTrackingTerm regexp\nwhere\n  PolynomialReDoSFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  regexp = sinkNode.getRegExp()\nselect sinkNode.getHighlight(), source, sink,\n  \"This $@ that depends on a $@ may run slow on strings \" + regexp.getPrefixMessage() +\n    \"with many repetitions of '\" + regexp.getPumpString() + \"'.\", regexp, \"regular expression\",\n  source.getNode(), source.getNode().(PR::Source).describe()",
        "description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-1333/PolynomialReDoS.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.DataFlow\nimport codeql.ruby.security.HttpToFileAccessQuery\nimport HttpToFileAccessFlow::PathGraph\n\nfrom HttpToFileAccessFlow::PathNode source, HttpToFileAccessFlow::PathNode sink\nwhere HttpToFileAccessFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Write to file system depends on $@.\", source.getNode(),\n  \"untrusted data\"",
        "description": "Writing network data directly to the file system allows arbitrary file upload and might indicate a backdoor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-912/HttpToFileAccess.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.CleartextStorageQuery\nimport codeql.ruby.security.CleartextStorageCustomizations::CleartextStorage\nimport CleartextStorageFlow::PathGraph\n\nfrom CleartextStorageFlow::PathNode source, CleartextStorageFlow::PathNode sink\nwhere CleartextStorageFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This stores sensitive data returned by $@ as clear text.\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "Storing sensitive information without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-312/CleartextStorage.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.CleartextLoggingQuery\nimport CleartextLoggingFlow::PathGraph\n\nfrom CleartextLoggingFlow::PathNode source, CleartextLoggingFlow::PathNode sink\nwhere CleartextLoggingFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This logs sensitive data returned by $@ as clear text.\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-312/CleartextLogging.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.DataFlow\nimport codeql.ruby.TaintTracking\nimport codeql.ruby.controlflow.CfgNodes\n\nprivate string getValueText(StringLiteral sl) { result = sl.getConstantValue().getString() }\n\nbindingset[char, fraction]\npredicate fewer_characters_than(StringLiteral str, string char, float fraction) {\n  exists(string text, int chars |\n    text = getValueText(str) and\n    chars = count(int i | text.charAt(i) = char)\n  |\n    /* Allow one character */\n    chars = 1 or\n    chars < text.length() * fraction\n  )\n}\n\npredicate possible_reflective_name(string name) {\n  // TODO: implement this?\n  none()\n}\n\nint char_count(StringLiteral str) { result = count(string c | c = getValueText(str).charAt(_)) }\n\npredicate capitalized_word(StringLiteral str) { getValueText(str).regexpMatch(\"[A-Z][a-z]+\") }\n\npredicate format_string(StringLiteral str) { getValueText(str).matches(\"%{%}%\") }\n\npredicate maybeCredential(Expr e) {\n  /* A string that is not too short and unlikely to be text or an identifier. */\n  exists(StringLiteral str | str = e |\n    /* At least 10 characters */\n    getValueText(str).length() > 9 and\n    /* Not too much whitespace */\n    fewer_characters_than(str, \" \", 0.05) and\n    /* or underscores */\n    fewer_characters_than(str, \"_\", 0.2) and\n    /* Not too repetitive */\n    exists(int chars | chars = char_count(str) |\n      chars > 15 or\n      chars * 3 > getValueText(str).length() * 2\n    ) and\n    not possible_reflective_name(getValueText(str)) and\n    not capitalized_word(str) and\n    not format_string(str)\n  )\n  or\n  /* Or, an integer with over 32 bits */\n  exists(IntegerLiteral lit | lit = e |\n    not exists(lit.getValue()) and\n    /* Not a set of flags or round number */\n    not lit.toString().matches(\"%00%\")\n  )\n}\n\nclass HardcodedValueSource extends DataFlow::Node {\n  HardcodedValueSource() { maybeCredential(this.asExpr().getExpr()) }\n}\n\nprivate string getACredentialRegExp() {\n  result = \"(?i).*pass(wd|word|code|phrase)(?!.*question).*\" or\n  result = \"(?i).*(puid|username|userid).*\" or\n  result = \"(?i).*(cert)(?!.*(format|name)).*\"\n}\n\nbindingset[name]\nprivate predicate maybeCredentialName(string name) {\n  name.regexpMatch(getACredentialRegExp()) and\n  not name.matches(\"%file\")\n}\n\n// Positional parameter\nprivate DataFlow::Node credentialParameter() {\n  exists(Method m, NamedParameter p |\n    result.asParameter() = p and\n    p = m.getAParameter() and\n    maybeCredentialName(p.getName())\n  )\n}\n\n// Keyword argument\nprivate Expr credentialKeywordArgument() {\n  exists(MethodCall mc, string argKey |\n    result = mc.getKeywordArgument(argKey) and\n    maybeCredentialName(argKey)\n  )\n}\n\n// An equality check against a credential value\nprivate Expr credentialComparison() {\n  exists(EqualityOperation op, VariableReadAccess vra |\n    maybeCredentialName(vra.getVariable().getName()) and\n    (\n      op.getLeftOperand() = result and\n      op.getRightOperand() = vra\n      or\n      op.getLeftOperand() = vra and op.getRightOperand() = result\n    )\n  )\n}\n\nprivate predicate isCredentialSink(DataFlow::Node node) {\n  node = credentialParameter()\n  or\n  node.asExpr().getExpr() = credentialKeywordArgument()\n  or\n  node.asExpr().getExpr() = credentialComparison()\n}\n\nclass CredentialSink extends DataFlow::Node {\n  CredentialSink() { isCredentialSink(this) }\n}\n\nprivate module HardcodedCredentialsConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof HardcodedValueSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof CredentialSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(ExprNodes::BinaryOperationCfgNode binop |\n      (\n        binop.getLeftOperand() = node1.asExpr() or\n        binop.getRightOperand() = node1.asExpr()\n      ) and\n      binop = node2.asExpr() and\n      // string concatenation\n      binop.getExpr() instanceof AddExpr\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nprivate module HardcodedCredentialsFlow = DataFlow::Global<HardcodedCredentialsConfig>;\n\nimport HardcodedCredentialsFlow::PathGraph\n\nfrom HardcodedCredentialsFlow::PathNode source, HardcodedCredentialsFlow::PathNode sink\nwhere HardcodedCredentialsFlow::flowPath(source, sink)\nselect source.getNode(), source, sink, \"This hardcoded value is $@.\", sink.getNode(),\n  \"used as credentials\"",
        "description": "Credentials are hard coded in the source code of the application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-798/HardcodedCredentials.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.DataFlow\nimport codeql.ruby.security.TaintedFormatStringQuery\nimport TaintedFormatStringFlow::PathGraph\n\nfrom TaintedFormatStringFlow::PathNode source, TaintedFormatStringFlow::PathNode sink\nwhere TaintedFormatStringFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Format string depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using external input in format strings can lead to garbled output.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-134/TaintedFormatString.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Concepts\nimport codeql.ruby.frameworks.ActionController\nimport codeql.ruby.frameworks.Gemfile\nimport codeql.ruby.DataFlow\n\nprivate predicate protectFromForgeryCall(\n  ActionControllerClass definedIn, ActionControllerClass child,\n  ActionController::ProtectFromForgeryCall call\n) {\n  definedIn.getSelf().flowsTo(call.getReceiver()) and child = definedIn.getADescendent()\n}\n\nprivate predicate railsPreVersion5_2() {\n  exists(Gemfile::Gem g |\n    g.getName() = [\"rails\", \"actionpack\"] and g.getAVersionConstraint().before(\"5.2\")\n  )\n}\n\nprivate float getRailsConfigDefaultVersion() {\n  exists(DataFlow::CallNode config, DataFlow::CallNode loadDefaultsCall |\n    DataFlow::getConstant(\"Rails\")\n        .getConstant(\"Application\")\n        .getADescendentModule()\n        .getAnImmediateReference()\n        .flowsTo(config.getReceiver()) and\n    config.getMethodName() = \"config\" and\n    loadDefaultsCall.getReceiver() = config and\n    loadDefaultsCall.getMethodName() = \"load_defaults\" and\n    result = loadDefaultsCall.getArgument(0).getConstantValue().getFloat()\n  )\n}\n\nfrom ActionControllerClass c\nwhere\n  not protectFromForgeryCall(_, c, _) and\n  (\n    // Rails versions prior to 5.2 require CSRF protection to be explicitly enabled.\n    railsPreVersion5_2()\n    or\n    // For Rails >= 5.2, CSRF protection is enabled by default if there is a `load_defaults` call in the root application class\n    // which specifies a version >= 5.2.\n    not getRailsConfigDefaultVersion() >= 5.2\n  ) and\n  // Only generate alerts for the topmost controller in the tree.\n  not exists(ActionControllerClass parent | c = parent.getAnImmediateDescendent())\nselect c, \"Potential CSRF vulnerability due to forgery protection not being enabled.\"",
        "description": "Not enabling CSRF protection may make the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-352/CSRFProtectionNotEnabled.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Concepts\n\nfrom CsrfProtectionSetting s\nwhere s.getVerificationSetting() = false\nselect s, \"Potential CSRF vulnerability due to forgery protection being disabled or weakened.\"",
        "description": "Disabling or weakening CSRF protection may make the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-352/CSRFProtectionDisabled.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.InsecureDependencyQuery\n\nfrom Expr url, string msg\nwhere insecureDependencyUrl(url, msg)\nselect url, msg",
        "description": "Using unencrypted protocols to fetch dependencies can leave an application open to man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-300/InsecureDependencyResolution.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nimport codeql.ruby.security.UnsafeDeserializationQuery\nimport UnsafeCodeConstructionFlow::PathGraph\n\nfrom UnsafeCodeConstructionFlow::PathNode source, UnsafeCodeConstructionFlow::PathNode sink\nwhere UnsafeCodeConstructionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Unsafe deserialization depends on a $@.\", source.getNode(),\n  source.getNode().(UnsafeDeserialization::Source).describe()",
        "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-502/UnsafeDeserialization.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nimport codeql.ruby.security.PathInjectionQuery\nimport PathInjectionFlow::PathGraph\n\nfrom PathInjectionFlow::PathNode source, PathInjectionFlow::PathNode sink\nwhere PathInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-022/PathInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.dataflow.RemoteFlowSources\nimport codeql.ruby.TaintTracking\nimport codeql.ruby.Concepts\nimport codeql.ruby.DataFlow\n\nclass UnsafeXxeSink extends DataFlow::ExprNode {\n  UnsafeXxeSink() {\n    exists(XmlParserCall parse |\n      parse.getInput() = this and\n      parse.externalEntitiesEnabled()\n    )\n  }\n}\n\nprivate module XxeConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof UnsafeXxeSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nprivate module XxeFlow = TaintTracking::Global<XxeConfig>;\n\nimport XxeFlow::PathGraph\n\nfrom XxeFlow::PathNode source, XxeFlow::PathNode sink\nwhere XxeFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against external entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-611/Xxe.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.CommandInjectionQuery\nimport CommandInjectionFlow::PathGraph\n\nfrom CommandInjectionFlow::PathNode source, CommandInjectionFlow::PathNode sink, Source sourceNode\nwhere\n  CommandInjectionFlow::flowPath(source, sink) and\n  sourceNode = source.getNode()\nselect sink.getNode(), source, sink, \"This command depends on a $@.\", sourceNode,\n  sourceNode.getSourceType()",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-078/CommandInjection.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.DataFlow\nimport codeql.ruby.security.KernelOpenQuery\nimport KernelOpenFlow::PathGraph\n\nfrom\n  KernelOpenFlow::PathNode source, KernelOpenFlow::PathNode sink, DataFlow::Node sourceNode,\n  DataFlow::CallNode call\nwhere\n  KernelOpenFlow::flowPath(source, sink) and\n  sourceNode = source.getNode() and\n  call.getArgument(0) = sink.getNode()\nselect sink.getNode(), source, sink,\n  \"This call to \" + call.(AmbiguousPathCall).getName() +\n    \" depends on a $@. Consider replacing it with \" + call.(AmbiguousPathCall).getReplacement() +\n    \".\", source.getNode(), \"user-provided value\"",
        "description": "Using `Kernel.open`, `IO.read`, `IO.write`, `IO.binread`, `IO.binwrite`, `IO.foreach`, `IO.readlines`, or `URI.open` may allow a malicious user to execute arbitrary system commands.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-078/KernelOpen.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.KernelOpenQuery\nimport codeql.ruby.AST\nimport codeql.ruby.ApiGraphs\nimport codeql.ruby.DataFlow\n\nfrom AmbiguousPathCall call\nwhere\n  call.getNumberOfArguments() > 0 and\n  not hasConstantPrefix(call.getPathArgument()) and\n  not call.getPathArgument().getALocalSource() =\n    API::getTopLevelMember(\"File\").getAMethodCall(\"join\")\nselect call,\n  \"Call to \" + call.getName() + \" with a non-constant value. Consider replacing it with \" +\n    call.getReplacement() + \".\"\n\npredicate hasConstantPrefix(DataFlow::Node node) {\n  hasConstantPrefix(node.getALocalSource())\n  or\n  // if it's a format string, then the first argument is not a constant string\n  node.asExpr().getExpr().(StringlikeLiteral).getComponent(0) instanceof StringTextComponent\n  or\n  // it is not a constant string argument\n  exists(node.getConstantValue())\n  or\n  // not a concatenation that starts with a constant string\n  exists(DataFlow::ExprNode prefix |\n    node.asExpr().getExpr().(AddExpr).getLeftOperand() = prefix.asExpr().getExpr() and\n    hasConstantPrefix(prefix)\n  )\n  or\n  // is a .freeze call on a constant string\n  exists(DataFlow::CallNode call | node = call and call.getMethodName() = \"freeze\" |\n    hasConstantPrefix(call.getReceiver())\n  )\n  or\n  // is a constant read of a constant string\n  exists(DataFlow::Node constant |\n    constant.asExpr().getExpr() = node.asExpr().getExpr().(ConstantReadAccess).getValue() and\n    hasConstantPrefix(constant)\n  )\n}",
        "description": "Using `Kernel.open`, `IO.read`, `IO.write`, `IO.binread`, `IO.binwrite`, `IO.foreach`, `IO.readlines`, or `URI.open` may allow a malicious user to execute arbitrary system commands.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-078/NonConstantKernelOpen.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.UnsafeShellCommandConstructionQuery\nimport UnsafeShellCommandConstructionFlow::PathGraph\n\nfrom\n  UnsafeShellCommandConstructionFlow::PathNode source,\n  UnsafeShellCommandConstructionFlow::PathNode sink, Sink sinkNode\nwhere\n  UnsafeShellCommandConstructionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode()\nselect sinkNode.getStringConstruction(), source, sink,\n  \"This \" + sinkNode.describe() + \" which depends on $@ is later used in a $@.\", source.getNode(),\n  \"library input\", sinkNode.getCommandExecution(), \"shell command\"",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-078/UnsafeShellCommandConstruction.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.InsecureDownloadQuery\nimport InsecureDownloadFlow::PathGraph\n\nfrom InsecureDownloadFlow::PathNode source, InsecureDownloadFlow::PathNode sink\nwhere InsecureDownloadFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"$@ of sensitive file from $@.\",\n  sink.getNode().(Sink).getDownloadCall(), \"Download\", source.getNode(), \"HTTP source\"",
        "description": "Downloading executables and other sensitive files over an insecure connection may allow man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-829/InsecureDownload.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.ReflectedXSSQuery\nimport ReflectedXssFlow::PathGraph\n\nfrom ReflectedXssFlow::PathNode source, ReflectedXssFlow::PathNode sink\nwhere ReflectedXssFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Cross-site scripting vulnerability due to a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-079/ReflectedXSS.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.security.UnsafeHtmlConstructionQuery\nimport UnsafeHtmlConstructionFlow::PathGraph\n\nfrom\n  UnsafeHtmlConstructionFlow::PathNode source, UnsafeHtmlConstructionFlow::PathNode sink,\n  Sink sinkNode\nwhere UnsafeHtmlConstructionFlow::flowPath(source, sink) and sink.getNode() = sinkNode\nselect sinkNode, source, sink,\n  \"This \" + sinkNode.getSinkType() + \" which depends on $@ might later allow $@.\", source.getNode(),\n  \"library input\", sinkNode.getXssSink(), \"cross-site scripting\"",
        "description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-079/UnsafeHtmlConstruction.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.security.StoredXSSQuery\nimport StoredXssFlow::PathGraph\n\nfrom StoredXssFlow::PathNode source, StoredXssFlow::PathNode sink\nwhere StoredXssFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Stored cross-site scripting vulnerability due to $@.\",\n  source.getNode(), \"stored value\"",
        "description": "Using uncontrolled stored values in HTML allows for a stored cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/security/cwe-079/StoredXSS.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.dataflow.FlowSummary\n\nfrom Call invoke, SummarizedCallable f\nwhere f.getACall() = invoke or f.getACallSimple() = invoke\nselect invoke, \"Call to \" + f",
        "description": "A call site for which we have a summarized callable",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/meta/SummarizedCallableCallSites.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\n\nfrom Call invoke, Callable f\nwhere invoke.getATarget() = f\nselect invoke, \"Call to $@\", f, f.toString()",
        "description": "An edge in the call graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/meta/CallGraph.ql",
        "language": "ruby"
    },
    {
        "query": "import internal.TaintMetrics\n\nfrom string kind\nselect relevantTaintSink(kind), kind + \" sink\"",
        "description": "Sinks that are sensitive to untrusted data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/meta/TaintSinks.ql",
        "language": "ruby"
    },
    {
        "query": "import internal.TaintMetrics\nimport codeql.ruby.DataFlow\nimport codeql.ruby.TaintTracking\n\nprivate module BasicTaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node = relevantTaintSource(_) }\n\n  predicate isSink(DataFlow::Node node) {\n    // To reduce noise from synthetic nodes, only count nodes that have an associated expression.\n    exists(node.asExpr().getExpr())\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) { none() }\n}\n\nprivate module BasicTaintFlow = TaintTracking::Global<BasicTaintConfig>;\n\nfrom DataFlow::Node node\nwhere BasicTaintFlow::flow(_, node)\nselect node, \"Tainted node\"",
        "description": "Nodes reachable from a remote flow source via default taint-tracking steps.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/meta/TaintedNodes.ql",
        "language": "ruby"
    },
    {
        "query": "import internal.TaintMetrics\n\nfrom string kind\nselect relevantTaintSource(kind), kind",
        "description": "Sources of untrusted input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/meta/TaintSources.ql",
        "language": "ruby"
    },
    {
        "query": "private import internal.Types\nprivate import internal.Summaries\n\nquery predicate typeModel = Types::typeModel/3;\n\nquery predicate sourceModel(string type, string path, string kind) { none() }\n\nquery predicate sinkModel(string type, string path, string kind) { none() }\n\nquery predicate summaryModel = Summaries::summaryModel/5;\n\nquery predicate typeVariableModel(string name, string path) { none() }",
        "description": "Queries to generate source, sink, summary and type models.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/modeling/GenerateModel.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.dataflow.SSA\n\nclass RelevantParameterVariable extends LocalVariable {\n  RelevantParameterVariable() {\n    exists(Parameter p |\n      this = p.getAVariable() and\n      not this.getName().charAt(0) = \"_\"\n    )\n  }\n}\n\nfrom RelevantParameterVariable v\nwhere\n  not exists(Ssa::WriteDefinition def | def.getWriteAccess().getAstNode() = v.getDefiningAccess())\nselect v, \"The parameter '\" + v.getName() + \"' is never used.\"",
        "description": "A parameter that is not used later on, or whose value is always overwritten, can be removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/variables/UnusedParameter.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.dataflow.SSA\nimport codeql.ruby.controlflow.internal.Guards as Guards\nimport codeql.ruby.controlflow.CfgNodes\nimport codeql.ruby.ast.internal.Variable\n\nprivate predicate isInBooleanContext(AstNode n) {\n  exists(ConditionalExpr i |\n    n = i.getCondition()\n    or\n    isInBooleanContext(i) and\n    n = i.getBranch(_)\n  )\n  or\n  n = any(ConditionalLoop parent).getCondition()\n  or\n  n = any(InClause parent).getCondition()\n  or\n  n = any(LogicalAndExpr op).getAnOperand()\n  or\n  n = any(LogicalOrExpr op).getAnOperand()\n  or\n  n = any(NotExpr op).getOperand()\n  or\n  n = any(StmtSequence parent | isInBooleanContext(parent)).getLastStmt()\n  or\n  exists(CaseExpr c, WhenClause w |\n    not exists(c.getValue()) and\n    c.getABranch() = w\n  |\n    w.getPattern(_) = n\n    or\n    w = n\n  )\n}\n\nprivate predicate isGuarded(LocalVariableReadAccess read) {\n  exists(AstCfgNode guard, boolean branch |\n    Guards::guardControlsBlock(guard, read.getAControlFlowNode().getBasicBlock(), branch)\n  |\n    // guard is `var`\n    guard.getAstNode() = read.getVariable().getAnAccess() and\n    branch = true\n    or\n    // guard is `var.nil?`\n    exists(MethodCall c | guard.getAstNode() = c |\n      c.getReceiver() = read.getVariable().getAnAccess() and\n      c.getMethodName() = \"nil?\"\n    ) and\n    branch = false\n  )\n}\n\nprivate predicate isNilChecked(LocalVariableReadAccess read) {\n  exists(MethodCall c | c.getReceiver() = read |\n    c.getMethodName() = \"nil?\"\n    or\n    c.isSafeNavigation()\n  )\n}\n\nprivate predicate isNilMethodName(string name) {\n  name in [\n      \"inspect\", \"instance_of?\", \"is_a?\", \"kind_of?\", \"method\", \"nil?\", \"rationalize\", \"to_a\",\n      \"to_c\", \"to_f\", \"to_h\", \"to_i\", \"to_r\", \"to_s\"\n    ]\n}\n\nclass RelevantLocalVariableReadAccess extends LocalVariableReadAccess instanceof TVariableAccessReal\n{\n  RelevantLocalVariableReadAccess() {\n    not isInBooleanContext(this) and\n    not isNilChecked(this) and\n    not isGuarded(this) and\n    this = any(MethodCall m | not isNilMethodName(m.getMethodName())).getReceiver()\n  }\n}\n\nfrom RelevantLocalVariableReadAccess read, LocalVariable v\nwhere\n  v = read.getVariable() and\n  exists(Ssa::Definition def |\n    def.getAnUltimateDefinition() instanceof Ssa::UninitializedDefinition and\n    read = def.getARead().getExpr()\n  )\nselect read, \"Local variable $@ may be used before it is initialized.\", v, v.getName()",
        "description": "Using a local variable before it is initialized gives the variable a default 'nil' value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/variables/UninitializedLocal.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.CFG\nimport codeql.ruby.dataflow.SSA\nimport codeql.ruby.ApiGraphs\n\npragma[nomagic]\nprivate predicate hasErbResultCall(CfgScope scope) {\n  scope = API::getTopLevelMember(\"ERB\").getInstance().getAMethodCall(\"result\").asExpr().getScope()\n}\n\nclass RelevantLocalVariableWriteAccess extends LocalVariableWriteAccess {\n  RelevantLocalVariableWriteAccess() {\n    not this.getVariable().getName().charAt(0) = \"_\" and\n    not this = any(Parameter p).getAVariable().getDefiningAccess() and\n    not hasErbResultCall(this.getCfgScope()) and\n    not exists(RetryStmt r | r.getCfgScope() = this.getCfgScope()) and\n    not exists(MethodCall c |\n      c.getReceiver() instanceof SelfVariableAccess and\n      c.getMethodName() = \"binding\" and\n      c.getCfgScope() = this.getCfgScope()\n    )\n  }\n}\n\nfrom RelevantLocalVariableWriteAccess write, LocalVariable v\nwhere\n  v = write.getVariable() and\n  exists(write.getAControlFlowNode()) and\n  not exists(Ssa::WriteDefinition def | def.getWriteAccess().getAstNode() = write)\nselect write, \"This assignment to $@ is useless, since its value is never read.\", v, v.getName()",
        "description": "An assignment to a local variable that is not used later on, or whose value is always overwritten, has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/variables/DeadStoreOfLocal.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Diagnostics\n\nint getSeverity() { result = 2 }\n\nfrom ExtractionError error, File f\nwhere\n  f = error.getLocation().getFile() and\n  exists(f.getRelativePath())\nselect error, \"Extraction failed in \" + f + \" with error \" + error.getMessage(), getSeverity()",
        "description": "List all extraction errors for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/diagnostics/ExtractionErrors.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Diagnostics\n\nfrom File f\nwhere exists(f.getRelativePath())\nselect f, \"\"",
        "description": "Lists all files in the source code directory that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/diagnostics/ExtractedFiles.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.ruby.Diagnostics\n\nint getSeverity() { result = 1 }\n\nfrom ExtractionWarning warning, File f\nwhere\n  f = warning.getLocation().getFile() and\n  exists(f.getRelativePath())\nselect warning, \"Extraction warning in \" + f + \" with message \" + warning.getMessage(),\n  getSeverity()",
        "description": "List all extraction warnings for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/diagnostics/ExtractionWarnings.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nimport codeql.ruby.ApiGraphs\n\nquery int numberOfModuleBases() { result = count(Ast::ModuleBase cls) }\n\nquery int numberOfClasses() { result = count(Ast::ClassDeclaration cls) }\n\nquery int numberOfMethods() { result = count(Ast::MethodBase method) }\n\nquery int numberOfCallables() { result = count(Ast::Callable c) }\n\nquery int numberOfMethodCalls() { result = count(Ast::MethodCall call) }\n\nquery int numberOfCalls() { result = count(Ast::Call call) }\n\nsignature module HistogramSig {\n  bindingset[this]\n  class Bucket;\n\n  int getCounts(Bucket bucket);\n}\n\nmodule MakeHistogram<HistogramSig H> {\n  predicate histogram(int bucketSize, int frequency) {\n    frequency = strictcount(H::Bucket bucket | H::getCounts(bucket) = bucketSize)\n  }\n}\n\nmodule MethodNames implements HistogramSig {\n  class Bucket = string;\n\n  int getCounts(string name) {\n    result = strictcount(Ast::MethodBase method | method.getName() = name) and\n    name != \"initialize\"\n  }\n}\n\nquery predicate numberOfMethodsWithNameHistogram = MakeHistogram<MethodNames>::histogram/2;\n\nmodule CallTargets implements HistogramSig {\n  class Bucket = Ast::Call;\n\n  int getCounts(Ast::Call call) { result = count(call.getATarget()) }\n}\n\nquery predicate numberOfCallTargetsHistogram = MakeHistogram<CallTargets>::histogram/2;\n\nmodule Callers implements HistogramSig {\n  class Bucket = Ast::Callable;\n\n  int getCounts(Ast::Callable callable) {\n    result = count(Ast::Call call | call.getATarget() = callable)\n  }\n}\n\nquery predicate numberOfCallersHistogram = MakeHistogram<Callers>::histogram/2;\n\nprivate DataFlow::MethodNode getAnOverriddenMethod(DataFlow::MethodNode method) {\n  exists(DataFlow::ModuleNode cls, string name |\n    method = cls.getInstanceMethod(name) and\n    result = cls.getAnAncestor().getInstanceMethod(name) and\n    result != method\n  )\n}\n\nmodule MethodOverrides implements HistogramSig {\n  class Bucket = DataFlow::MethodNode;\n\n  int getCounts(DataFlow::MethodNode method) { result = count(getAnOverriddenMethod(method)) }\n}\n\nquery predicate numberOfOverriddenMethodsHistogram = MakeHistogram<MethodOverrides>::histogram/2;\n\nmodule MethodOverriddenBy implements HistogramSig {\n  class Bucket = DataFlow::MethodNode;\n\n  int getCounts(DataFlow::MethodNode method) {\n    result = count(DataFlow::MethodNode overrider | method = getAnOverriddenMethod(overrider))\n  }\n}\n\nquery predicate numberOfOverridingMethodsHistogram = MakeHistogram<MethodOverriddenBy>::histogram/2;\n\nmodule Ancestors implements HistogramSig {\n  class Bucket = DataFlow::ModuleNode;\n\n  int getCounts(DataFlow::ModuleNode mod) {\n    result =\n      count(DataFlow::ModuleNode ancestor | ancestor = mod.getAnAncestor() and ancestor != mod)\n  }\n}\n\nquery predicate numberOfAncestorsHistogram = MakeHistogram<Ancestors>::histogram/2;\n\nmodule Descendents implements HistogramSig {\n  class Bucket = DataFlow::ModuleNode;\n\n  int getCounts(DataFlow::ModuleNode mod) {\n    not mod.getQualifiedName() = [\"Object\", \"Kernel\", \"BasicObject\", \"Class\", \"Module\"] and\n    result =\n      count(DataFlow::ModuleNode descendent |\n        descendent = mod.getADescendent() and descendent != mod\n      )\n  }\n}\n\nquery predicate numberOfDescendentsHistogram = MakeHistogram<Descendents>::histogram/2;",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/diagnostics/PerformanceDiagnostics.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nprivate import codeql.ruby.AST\nimport codeql.ruby.ast.internal.Constant\nimport codeql.ruby.Concepts\nimport codeql.ruby.frameworks.ActiveRecord\nprivate import codeql.ruby.TaintTracking\nprivate import codeql.ruby.controlflow.internal.Guards as Guards\n\nstring getALoopMethodName() {\n  result in [\n      \"each\", \"reverse_each\", \"map\", \"map!\", \"foreach\", \"flat_map\", \"in_batches\", \"one?\", \"all?\",\n      \"collect\", \"collect!\", \"select\", \"select!\", \"reject\", \"reject!\"\n    ]\n}\n\nclass LoopingCall extends DataFlow::CallNode {\n  Callable loopScope;\n\n  LoopingCall() {\n    this.getMethodName() = getALoopMethodName() and\n    loopScope = this.getBlock().asCallable().asCallableAstNode()\n  }\n\n  /** Holds if `c` is executed as part of the body of this loop. */\n  predicate executesCall(DataFlow::CallNode c) { c.asExpr().getScope() = loopScope }\n}\n\npredicate usedInLoopControlGuard(ActiveRecordInstance ar) {\n  exists(DataFlow::Node insideGuard, Cfg::CfgNodes::ExprCfgNode guard |\n    // For a guard like `cond && ar`, the whole guard will not be tainted\n    // so we need to look at the taint of the individual parts.\n    insideGuard.asExpr().getExpr() = guard.getExpr().getAChild*()\n  |\n    TaintTracking::localTaint(ar, insideGuard) and\n    guardForLoopControl(guard, _)\n  )\n}\n\npredicate guardForLoopControl(Cfg::CfgNodes::ExprCfgNode guard, Cfg::CfgNodes::AstCfgNode break) {\n  Guards::guardControlsBlock(guard, break.getBasicBlock(), _) and\n  (\n    break.(Cfg::CfgNodes::ExprNodes::MethodCallCfgNode).getMethodName() = \"raise\"\n    or\n    break instanceof Cfg::CfgNodes::ReturningCfgNode\n  )\n}\n\nfrom LoopingCall loop, ActiveRecordModelFinderCall call\nwhere\n  loop.executesCall(call) and\n  // Disregard loops over constants\n  not isArrayConstant(loop.getReceiver().asExpr(), _) and\n  // Disregard cases where the looping is influenced by the query result\n  not usedInLoopControlGuard(call) and\n  // Only report calls that are likely to be expensive\n  not call.getMethodName() in [\"new\", \"create\"]\nselect call,\n  \"This call to a database query operation happens inside $@, and could be hoisted to a single call outside the loop.\",\n  loop, \"this loop\"",
        "description": "Database queries in a loop can lead to an unnecessary amount of database calls and poor performance.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/performance/DatabaseQueryInLoop.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.files.FileSystem\n\nselect count(File f |\n    exists(f.getRelativePath()) and\n    not f instanceof SuccessfullyExtractedFile\n  )",
        "description": "The total number of Ruby code files that we extracted, but where at least one extraction error (or warning) occurred in the process.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/summary/NumberOfFilesExtractedWithErrors.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\n\nselect sum(RubyFile f | exists(f.getRelativePath()) | f.getNumberOfLinesOfCode())",
        "description": "The total number of lines of Ruby code from the source code directory, including external libraries and auto-generated files. This is a useful metric of the size of a database. This query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/summary/LinesOfCode.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\nimport codeql.files.FileSystem\n\nselect count(SuccessfullyExtractedFile f | exists(f.getRelativePath()))",
        "description": "The total number of Ruby code files that we extracted without encountering any extraction errors (or warnings).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/summary/NumberOfSuccessfullyExtractedFiles.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\n\nselect sum(RubyFile f |\n    f.fromSource() and\n    exists(f.getRelativePath()) and\n    not f.getAbsolutePath().matches(\"%/vendor/%\")\n  |\n    f.getNumberOfLinesOfCode()\n  )",
        "description": "The total number of lines of Ruby code from the source code directory, excluding external library and auto-generated files. This query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/queries/summary/LinesOfUserCode.ql",
        "language": "ruby"
    },
    {
        "query": "import ruby\nimport codeql.ruby.AST\nimport ModelEditor\n\nfrom Endpoint endpoint\nselect endpoint, endpoint.getNamespace(), endpoint.getType(), endpoint.getName(),\n  endpoint.getParameters(), endpoint.getSupportedStatus(), endpoint.getFileName(),\n  endpoint.getSupportedType()",
        "description": "A list of endpoints accessible (methods and attributes) for consumers of the library. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/utils/modeleditor/FrameworkModeEndpoints.ql",
        "language": "ruby"
    },
    {
        "query": "import codeql.ruby.AST\n\n// This query is empty as Application Mode is not yet supported for Ruby.\nfrom\n  Call usage, string package, string type, string name, string parameters, boolean supported,\n  string namespace, string version, string supportedType, string classification\nwhere none()\nselect usage, package, namespace, type, name, parameters, supported, namespace, version,\n  supportedType, classification",
        "description": "A list of 3rd party endpoints (methods and attributes) used in the codebase. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/utils/modeleditor/ApplicationModeEndpoints.ql",
        "language": "ruby"
    },
    {
        "query": "private import ruby\nprivate import codeql.ruby.AST\nprivate import codeql.ruby.ApiGraphs\nprivate import queries.modeling.internal.Util as Util\nprivate import ModelEditor\n\npredicate simpleParameters(string type, string path, string value, DataFlow::Node node) {\n  exists(DataFlow::MethodNode methodNode, DataFlow::ParameterNode paramNode |\n    methodNode.getLocation().getFile() instanceof Util::RelevantFile and\n    (\n      // Check that this parameter belongs to this method\n      // Block parameter explicitly excluded because it's already included\n      // as part of the blockArguments predicate\n      paramNode = Util::getAnyParameter(methodNode) and\n      paramNode != methodNode.getBlockParameter() and\n      // The self parameter of a constructor is not a parameter that can be used in any models\n      (not isConstructor(methodNode) or paramNode != methodNode.getSelfParameter())\n    )\n  |\n    Util::pathToMethod(methodNode, type, path) and\n    value = Util::getArgumentPath(paramNode) and\n    node = paramNode\n  )\n}\n\npredicate blockArguments(string type, string path, string value, DataFlow::Node node) {\n  exists(DataFlow::MethodNode methodNode, DataFlow::CallNode callNode |\n    methodNode.getLocation().getFile() instanceof Util::RelevantFile and\n    callNode = methodNode.getABlockCall()\n  |\n    (\n      exists(DataFlow::VariableAccessNode argNode, int i |\n        argNode = callNode.getPositionalArgument(i)\n      |\n        value = \"Argument[block].Parameter[\" + i + \"]\" and\n        node = argNode\n      )\n      or\n      exists(DataFlow::ExprNode argNode, string keyword |\n        argNode = callNode.getKeywordArgument(keyword)\n      |\n        value = \"Argument[block].Parameter[\" + keyword + \":]\" and\n        node = argNode\n      )\n      or\n      value = \"Argument[block]\" and\n      node = callNode\n    ) and\n    Util::pathToMethod(methodNode, type, path)\n  )\n}\n\npredicate returnValue(string type, string path, string value, DataFlow::Node node) {\n  exists(DataFlow::MethodNode methodNode, DataFlow::Node returnNode |\n    methodNode.getLocation().getFile() instanceof Util::RelevantFile and\n    returnNode = methodNode.getAReturnNode() and\n    not isConstructor(methodNode)\n  |\n    Util::pathToMethod(methodNode, type, path) and\n    value = \"ReturnValue\" and\n    node = returnNode\n  )\n  or\n  // A constructor has a return node for every statement, but we always want\n  // to return 1 node for the ReturnValue, so we return the self parameter\n  // instead.\n  exists(DataFlow::MethodNode methodNode |\n    methodNode.getLocation().getFile() instanceof Util::RelevantFile and\n    isConstructor(methodNode)\n  |\n    Util::pathToMethod(methodNode, type, path) and\n    value = \"ReturnValue\" and\n    node = methodNode.getSelfParameter()\n  )\n}\n\npredicate inputAccessPaths(\n  string type, string path, string value, DataFlow::Node node, string defType\n) {\n  simpleParameters(type, path, value, node) and defType = \"parameter\"\n  or\n  blockArguments(type, path, value, node) and defType = \"parameter\"\n}\n\npredicate outputAccessPaths(\n  string type, string path, string value, DataFlow::Node node, string defType\n) {\n  simpleParameters(type, path, value, node) and defType = \"parameter\"\n  or\n  blockArguments(type, path, value, node) and defType = \"parameter\"\n  or\n  returnValue(type, path, value, node) and defType = \"return\"\n}\n\nquery predicate input = inputAccessPaths/5;\n\nquery predicate output = outputAccessPaths/5;",
        "description": "A list of access paths for input and output parameters of a method. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/ruby/ql/src/utils/modeleditor/FrameworkModeAccessPaths.ql",
        "language": "ruby"
    },
    {
        "query": "import rust\n\nclass CtorAttr extends Attr {\n  string whichAttr;\n\n  CtorAttr() {\n    whichAttr = this.getMeta().getPath().getText() and\n    whichAttr = [\"ctor\", \"dtor\"]\n  }\n\n  string getWhichAttr() { result = whichAttr }\n}\n\nclass StdCall extends Expr {\n  StdCall() {\n    this.(CallExprBase).getStaticTarget().getCanonicalPath().matches([\"std::%\", \"<std::%\"])\n  }\n}\n\nclass PathElement = AstNode;\n\npredicate edgesFwd(PathElement pred, PathElement succ) {\n  // attribute (source) -> function in macro expansion\n  exists(Function f |\n    pred.(CtorAttr) = f.getAnAttr() and\n    (\n      f.getAttributeMacroExpansion().getAnItem() = succ.(Callable)\n      or\n      // if for some reason the ctor/dtor macro expansion failed, fall back to looking into the unexpanded item\n      not f.hasAttributeMacroExpansion() and f = succ.(Callable)\n    )\n  )\n  or\n  // [forwards reachable] callable -> enclosed call\n  edgesFwd(_, pred) and\n  pred = succ.(CallExprBase).getEnclosingCallable()\n  or\n  // [forwards reachable] call -> target callable\n  edgesFwd(_, pred) and\n  pred.(CallExprBase).getStaticTarget() = succ\n}\n\nquery predicate edges(PathElement pred, PathElement succ) {\n  edgesFwd(pred, succ) and\n  (\n    succ instanceof StdCall // sink\n    or\n    edges(succ, _) // backwards reachable from a sink\n  )\n}\n\nfrom CtorAttr source, StdCall sink\nwhere edges+(source, sink)\nselect sink, source, sink,\n  \"Call to \" + sink.toString() + \" from the standard library in a function with the \" +\n    source.getWhichAttr() + \" attribute.\"",
        "description": "Calling functions in the Rust std library from a ctor or dtor function is not safe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-696/BadCtorInitialization.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.WeakSensitiveDataHashingExtensions\n\nmodule NormalHashFunctionFlow {\n  import NormalHashFunction\n\n  private module Config implements DataFlow::ConfigSig {\n    predicate isSource(DataFlow::Node source) { source instanceof Source }\n\n    predicate isSink(DataFlow::Node sink) { sink instanceof Sink }\n\n    predicate isBarrier(DataFlow::Node node) { node instanceof Barrier }\n\n    predicate isBarrierIn(DataFlow::Node node) {\n      // make sources barriers so that we only report the closest instance\n      isSource(node)\n    }\n\n    predicate isBarrierOut(DataFlow::Node node) {\n      // make sinks barriers so that we only report the closest instance\n      isSink(node)\n    }\n  }\n\n  import TaintTracking::Global<Config>\n}\n\nmodule ComputationallyExpensiveHashFunctionFlow {\n  import ComputationallyExpensiveHashFunction\n\n  private module Config implements DataFlow::ConfigSig {\n    predicate isSource(DataFlow::Node source) { source instanceof Source }\n\n    predicate isSink(DataFlow::Node sink) { sink instanceof Sink }\n\n    predicate isBarrier(DataFlow::Node node) { node instanceof Barrier }\n\n    predicate isBarrierIn(DataFlow::Node node) {\n      // make sources barriers so that we only report the closest instance\n      isSource(node)\n    }\n\n    predicate isBarrierOut(DataFlow::Node node) {\n      // make sinks barriers so that we only report the closest instance\n      isSink(node)\n    }\n  }\n\n  import TaintTracking::Global<Config>\n}\n\nmodule WeakSensitiveDataHashingFlow =\n  DataFlow::MergePathGraph<NormalHashFunctionFlow::PathNode,\n    ComputationallyExpensiveHashFunctionFlow::PathNode, NormalHashFunctionFlow::PathGraph,\n    ComputationallyExpensiveHashFunctionFlow::PathGraph>;\n\nimport WeakSensitiveDataHashingFlow::PathGraph\n\nfrom\n  WeakSensitiveDataHashingFlow::PathNode source, WeakSensitiveDataHashingFlow::PathNode sink,\n  string ending, string algorithmName, string classification\nwhere\n  NormalHashFunctionFlow::flowPath(source.asPathNode1(), sink.asPathNode1()) and\n  algorithmName = sink.getNode().(NormalHashFunction::Sink).getAlgorithmName() and\n  classification = source.getNode().(NormalHashFunction::Source).getClassification() and\n  ending = \".\"\n  or\n  ComputationallyExpensiveHashFunctionFlow::flowPath(source.asPathNode2(), sink.asPathNode2()) and\n  algorithmName = sink.getNode().(ComputationallyExpensiveHashFunction::Sink).getAlgorithmName() and\n  classification =\n    source.getNode().(ComputationallyExpensiveHashFunction::Source).getClassification() and\n  (\n    sink.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n    ending = \".\"\n    or\n    not sink.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n    ending =\n      \" for \" + classification +\n        \" hashing, since it is not a computationally expensive hash function.\"\n  )\nselect sink.getNode(), source, sink,\n  \"$@ is used in a hashing algorithm (\" + algorithmName + \") that is insecure\" + ending,\n  source.getNode(), \"Sensitive data (\" + classification + \")\"",
        "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-328/WeakSensitiveDataHashing.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.UseOfHttpExtensions\n\nmodule UseOfHttpConfig implements DataFlow::ConfigSig {\n  import UseOfHttp\n\n  predicate isSource(DataFlow::Node node) { node instanceof Source }\n\n  predicate isSink(DataFlow::Node node) { node instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule UseOfHttpFlow = TaintTracking::Global<UseOfHttpConfig>;\n\nimport UseOfHttpFlow::PathGraph\n\nfrom UseOfHttpFlow::PathNode sourceNode, UseOfHttpFlow::PathNode sinkNode\nwhere UseOfHttpFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"This URL may be constructed with the HTTP protocol, from $@.\", sourceNode.getNode(),\n  \"this HTTP URL\"",
        "description": "Non-HTTPS connections can be intercepted by third parties.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-319/UseOfHttp.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.Concepts\n\nfrom Cryptography::CryptographicOperation operation, string msgPrefix\nwhere\n  exists(Cryptography::EncryptionAlgorithm algorithm | algorithm = operation.getAlgorithm() |\n    algorithm.isWeak() and\n    msgPrefix = \"The cryptographic algorithm \" + algorithm.getName()\n  )\n  or\n  operation.getBlockMode().isWeak() and msgPrefix = \"The block mode \" + operation.getBlockMode()\nselect operation, \"$@ is broken or weak, and should not be used.\", operation.getInitialization(),\n  msgPrefix",
        "description": "Using broken or weak cryptographic algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-327/BrokenCryptoAlgorithm.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.CleartextTransmissionExtensions\n\nmodule CleartextTransmissionConfig implements DataFlow::ConfigSig {\n  import CleartextTransmission\n\n  predicate isSource(DataFlow::Node node) { node instanceof Source }\n\n  predicate isSink(DataFlow::Node node) { node instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    any(AdditionalFlowStep s).step(nodeFrom, nodeTo)\n  }\n\n  predicate isBarrierIn(DataFlow::Node node) {\n    // make sources barriers so that we only report the closest instance\n    isSource(node)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule CleartextTransmissionFlow = TaintTracking::Global<CleartextTransmissionConfig>;\n\nimport CleartextTransmissionFlow::PathGraph\n\nfrom CleartextTransmissionFlow::PathNode sourceNode, CleartextTransmissionFlow::PathNode sinkNode\nwhere CleartextTransmissionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"This '\" + sinkNode.getNode().toString() +\n    \"' operation transmits data which may contain unencrypted sensitive data from $@.\", sourceNode,\n  sourceNode.getNode().toString()",
        "description": "Transmitting sensitive information across a network in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-311/CleartextTransmission.ql",
        "language": "rust"
    },
    {
        "query": "private import rust\nprivate import codeql.rust.dataflow.TaintTracking\nprivate import codeql.rust.dataflow.DataFlow\nprivate import codeql.rust.security.RequestForgeryExtensions\n\nmodule RequestForgeryConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RequestForgery::Source }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof RequestForgery::Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof RequestForgery::Barrier }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule RequestForgeryFlow = TaintTracking::Global<RequestForgeryConfig>;\n\nimport RequestForgeryFlow::PathGraph\n\nfrom RequestForgeryFlow::PathNode source, RequestForgeryFlow::PathNode sink\nwhere RequestForgeryFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"The URL of this request depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Making a network request with user-controlled data in the URL allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-918/RequestForgery.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.AccessAfterLifetimeExtensions\nimport AccessAfterLifetimeFlow::PathGraph\n\nmodule AccessAfterLifetimeConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof AccessAfterLifetime::Source }\n\n  predicate isSink(DataFlow::Node node) { node instanceof AccessAfterLifetime::Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof AccessAfterLifetime::Barrier }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node source) {\n    exists(Variable target, DataFlow::Node sink | result = target.getLocation() |\n      isSink(sink) and\n      narrowDereferenceAfterLifetime(source, sink, target)\n    )\n  }\n}\n\nmodule AccessAfterLifetimeFlow = TaintTracking::Global<AccessAfterLifetimeConfig>;\n\npragma[inline]\npredicate narrowDereferenceAfterLifetime(DataFlow::Node source, DataFlow::Node sink, Variable target) {\n  // check that the dereference is outside the lifetime of the target\n  AccessAfterLifetime::dereferenceAfterLifetime(source, sink, target) and\n  // include only results inside `unsafe` blocks, as other results tend to be false positives\n  (\n    sink.asExpr().getExpr().getEnclosingBlock*().isUnsafe() or\n    sink.asExpr().getExpr().getEnclosingCallable().(Function).isUnsafe()\n  ) and\n  // exclude cases with sources / sinks in macros, since these results are difficult to interpret\n  not source.asExpr().getExpr().isFromMacroExpansion() and\n  not sink.asExpr().getExpr().isFromMacroExpansion()\n}\n\nfrom\n  AccessAfterLifetimeFlow::PathNode sourceNode, AccessAfterLifetimeFlow::PathNode sinkNode,\n  Variable target\nwhere\n  // flow from a pointer or reference to the dereference\n  AccessAfterLifetimeFlow::flowPath(sourceNode, sinkNode) and\n  // check that the dereference is outside the lifetime of the target\n  narrowDereferenceAfterLifetime(sourceNode.getNode(), sinkNode.getNode(), target)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"Access of a pointer to $@ after its lifetime has ended.\", target, target.toString()",
        "description": "Dereferencing a pointer after the lifetime of its target has ended causes undefined behavior and may result in memory corruption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-825/AccessAfterLifetime.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.AccessInvalidPointerExtensions\nimport AccessInvalidPointerFlow::PathGraph\n\nmodule AccessInvalidPointerConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof AccessInvalidPointer::Source }\n\n  predicate isSink(DataFlow::Node node) { node instanceof AccessInvalidPointer::Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof AccessInvalidPointer::Barrier }\n\n  predicate isBarrierOut(DataFlow::Node node) {\n    // make sinks barriers so that we only report the closest instance\n    isSink(node)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule AccessInvalidPointerFlow = TaintTracking::Global<AccessInvalidPointerConfig>;\n\nfrom AccessInvalidPointerFlow::PathNode sourceNode, AccessInvalidPointerFlow::PathNode sinkNode\nwhere AccessInvalidPointerFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"This operation dereferences a pointer that may be $@.\", sourceNode.getNode(), \"invalid\"",
        "description": "Dereferencing an invalid or dangling pointer causes undefined behavior and may result in memory corruption.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-825/AccessInvalidPointer.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.SqlInjectionExtensions\n\nmodule SqlInjectionConfig implements DataFlow::ConfigSig {\n  import SqlInjection\n\n  predicate isSource(DataFlow::Node node) { node instanceof Source }\n\n  predicate isSink(DataFlow::Node node) { node instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule SqlInjectionFlow = TaintTracking::Global<SqlInjectionConfig>;\n\nimport SqlInjectionFlow::PathGraph\n\nfrom SqlInjectionFlow::PathNode sourceNode, SqlInjectionFlow::PathNode sinkNode\nwhere SqlInjectionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode, \"This query depends on a $@.\",\n  sourceNode.getNode(), \"user-provided value\"",
        "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by attackers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-089/SqlInjection.ql",
        "language": "rust"
    },
    {
        "query": "private import rust\nprivate import codeql.rust.dataflow.DataFlow\nprivate import codeql.rust.dataflow.TaintTracking\nprivate import codeql.rust.security.regex.RegexInjectionExtensions\n\nmodule RegexInjectionConfig implements DataFlow::ConfigSig {\n  import RegexInjection\n\n  predicate isSource(DataFlow::Node source) { source instanceof Source }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    any(AdditionalFlowStep s).step(nodeFrom, nodeTo)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule RegexInjectionFlow = TaintTracking::Global<RegexInjectionConfig>;\n\nprivate import RegexInjectionFlow::PathGraph\n\nfrom RegexInjectionFlow::PathNode sourceNode, RegexInjectionFlow::PathNode sinkNode\nwhere RegexInjectionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"This regular expression is constructed from a $@.\", sourceNode.getNode(), \"user-provided value\"",
        "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could modify the meaning of the expression, causing it to match unexpected strings.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-020/RegexInjection.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.Concepts\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.dataflow.internal.DataFlowImpl\nimport codeql.rust.security.UncontrolledAllocationSizeExtensions\n\nmodule UncontrolledAllocationConfig implements DataFlow::ConfigSig {\n  import UncontrolledAllocationSize\n\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule UncontrolledAllocationFlow = TaintTracking::Global<UncontrolledAllocationConfig>;\n\nimport UncontrolledAllocationFlow::PathGraph\n\nfrom UncontrolledAllocationFlow::PathNode source, UncontrolledAllocationFlow::PathNode sink\nwhere UncontrolledAllocationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This allocation size is derived from a $@ and could allocate arbitrary amounts of memory.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Allocating memory with a size controlled by an external user can result in arbitrary amounts of memory being allocated, leading to a crash or a denial-of-service (DoS) attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-770/UncontrolledAllocationSize.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.LogInjectionExtensions\n\nmodule LogInjectionConfig implements DataFlow::ConfigSig {\n  import LogInjection\n\n  predicate isSource(DataFlow::Node node) { node instanceof Source }\n\n  predicate isSink(DataFlow::Node node) { node instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule LogInjectionFlow = TaintTracking::Global<LogInjectionConfig>;\n\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode sourceNode, LogInjectionFlow::PathNode sinkNode\nwhere LogInjectionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode, \"Log entry depends on a $@.\", sourceNode.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-117/LogInjection.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.CleartextStorageDatabaseExtensions\n\nmodule CleartextStorageDatabaseConfig implements DataFlow::ConfigSig {\n  import CleartextStorageDatabase\n\n  predicate isSource(DataFlow::Node node) { node instanceof Source }\n\n  predicate isSink(DataFlow::Node node) { node instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate isBarrierIn(DataFlow::Node node) {\n    // make sources barriers so that we only report the closest instance\n    isSource(node)\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    // flow from `a` to `&a`\n    node2.asExpr().getExpr().(RefExpr).getExpr() = node1.asExpr().getExpr()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule CleartextStorageDatabaseFlow = TaintTracking::Global<CleartextStorageDatabaseConfig>;\n\nimport CleartextStorageDatabaseFlow::PathGraph\n\nfrom\n  CleartextStorageDatabaseFlow::PathNode sourceNode, CleartextStorageDatabaseFlow::PathNode sinkNode\nwhere CleartextStorageDatabaseFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"This database operation may read or write unencrypted sensitive data from $@.\", sourceNode,\n  sourceNode.getNode().toString()",
        "description": "Storing sensitive information in a non-encrypted database can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-312/CleartextStorageDatabase.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.security.CleartextLoggingExtensions\n\nmodule CleartextLoggingConfig implements DataFlow::ConfigSig {\n  import CleartextLogging\n\n  predicate isSource(DataFlow::Node source) { source instanceof Source }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate isBarrierIn(DataFlow::Node node) {\n    // make sources barriers so that we only report the closest instance\n    isSource(node)\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    // flow from `a` to `&a`\n    node2.asExpr().getExpr().(RefExpr).getExpr() = node1.asExpr().getExpr()\n  }\n\n  predicate allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c) {\n    // flow out from tuple content at sinks.\n    isSink(node) and\n    c.getAReadContent() instanceof DataFlow::TuplePositionContent\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule CleartextLoggingFlow = TaintTracking::Global<CleartextLoggingConfig>;\n\nimport CleartextLoggingFlow::PathGraph\n\nfrom CleartextLoggingFlow::PathNode source, CleartextLoggingFlow::PathNode sink\nwhere CleartextLoggingFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This operation writes $@ to a log file.\", source,\n  source.getNode().toString()",
        "description": "Logging sensitive information in plaintext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-312/CleartextLogging.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.security.HardcodedCryptographicValueExtensions\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.dataflow.internal.DataFlowImpl\nimport codeql.rust.dataflow.internal.Content\n\nmodule HardcodedCryptographicValueConfig implements DataFlow::ConfigSig {\n  import HardcodedCryptographicValue\n\n  predicate isSource(DataFlow::Node source) { source instanceof Source }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof Sink }\n\n  predicate isBarrier(DataFlow::Node barrier) { barrier instanceof Barrier }\n\n  predicate isBarrierIn(DataFlow::Node node) {\n    // make sources barriers so that we only report the closest instance\n    // (this combined with sources for `ArrayListExpr` means we only get one source in\n    //  case like `[0, 0, 0, 0]`)\n    isSource(node)\n  }\n}\n\nmodule HardcodedCryptographicValueFlow = TaintTracking::Global<HardcodedCryptographicValueConfig>;\n\nimport HardcodedCryptographicValueFlow::PathGraph\n\nfrom\n  HardcodedCryptographicValueFlow::PathNode source, HardcodedCryptographicValueFlow::PathNode sink\nwhere HardcodedCryptographicValueFlow::flowPath(source, sink)\nselect source.getNode(), source, sink, \"This hard-coded value is used as $@.\", sink,\n  sink.getNode().(HardcodedCryptographicValueConfig::Sink).getKind().getDescription()",
        "description": "Using hard-coded keys, passwords, salts or initialization vectors is not secure.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-798/HardcodedCryptographicValue.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.dataflow.TaintTracking\nimport codeql.rust.dataflow.internal.DataFlowImpl as DataflowImpl\nimport codeql.rust.Concepts\nimport codeql.rust.security.TaintedPathExtensions\n\nnewtype NormalizationState =\n  /** A state signifying that the file path has not been normalized. */\n  NotNormalized() or\n  /** A state signifying that the file path has been normalized, but not checked. */\n  NormalizedUnchecked()\n\nmodule TaintedPathConfig implements DataFlow::StateConfigSig {\n  class FlowState = NormalizationState;\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    source instanceof TaintedPath::Source and state instanceof NotNormalized\n  }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    sink instanceof TaintedPath::Sink and\n    (\n      state instanceof NotNormalized or\n      state instanceof NormalizedUnchecked\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node instanceof TaintedPath::Barrier or node instanceof TaintedPath::SanitizerGuard\n  }\n\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    // Block `NotNormalized` paths here, since they change state to `NormalizedUnchecked`\n    (\n      node instanceof Path::PathNormalization or\n      DataflowImpl::optionalBarrier(node, \"normalize-path\")\n    ) and\n    state instanceof NotNormalized\n    or\n    node instanceof Path::SafeAccessCheck and\n    state instanceof NormalizedUnchecked\n  }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node nodeFrom, FlowState stateFrom, DataFlow::Node nodeTo, FlowState stateTo\n  ) {\n    (\n      nodeFrom = nodeTo.(Path::PathNormalization).getPathArg() or\n      DataflowImpl::optionalStep(nodeFrom, \"normalize-path\", nodeTo)\n    ) and\n    stateFrom instanceof NotNormalized and\n    stateTo instanceof NormalizedUnchecked\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule TaintedPathFlow = TaintTracking::GlobalWithState<TaintedPathConfig>;\n\nimport TaintedPathFlow::PathGraph\n\nfrom TaintedPathFlow::PathNode source, TaintedPathFlow::PathNode sink\nwhere TaintedPathFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/security/CWE-022/TaintedPath.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.controlflow.ControlFlowGraph\nimport codeql.rust.controlflow.internal.ControlFlowGraphImpl as ControlFlowGraphImpl\n\nprivate predicate succ(AstNode a, AstNode b) {\n  exists(ControlFlowGraphImpl::ControlFlowTree cft | cft.succ(a, b, _))\n}\n\npredicate hiddenNode(AstNode n) {\n  // isolated node (not intended to be part of the CFG)\n  not succ(n, _) and\n  not succ(_, n)\n  or\n  n instanceof ControlFlowGraphImpl::PostOrderTree and // location is counter-intuitive\n  not n instanceof MacroExpr\n  or\n  n.isInMacroExpansion()\n}\n\nprivate predicate succHidden(AstNode a, AstNode b) {\n  hiddenNode(a) and\n  succ(a, b)\n}\n\nprivate predicate succWithHiding(AstNode a, AstNode b) {\n  exists(AstNode mid |\n    not hiddenNode(a) and\n    succ(a, mid) and\n    succHidden*(mid, b) and\n    not hiddenNode(b)\n  )\n}\n\npredicate reachable(AstNode n) { n = any(CfgNode cfn).getAstNode() }\n\nprivate predicate firstUnreachable(AstNode n) {\n  not reachable(n) and\n  not hiddenNode(n) and\n  forall(AstNode pred | succWithHiding(pred, n) | reachable(pred))\n}\n\nfrom AstNode n\nwhere\n  firstUnreachable(n) and\n  exists(n.getFile().getRelativePath()) // in source\nselect n, \"This code is never reached.\"",
        "description": "Code that cannot be reached should be deleted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/unusedentities/UnreachableCode.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.Ssa\nimport codeql.rust.dataflow.internal.SsaImpl\nimport UnusedVariable\n\nfrom AstNode write, Ssa::Variable v\nwhere\n  variableWrite(_, write, v) and\n  not v instanceof DiscardVariable and\n  not write.isInMacroExpansion() and\n  not isAllowableUnused(v) and\n  // SSA definitions are only created for live writes\n  not write = any(Ssa::WriteDefinition def).getWriteAccess().getAstNode() and\n  // avoid overlap with the unused variable query\n  not isUnused(v)\nselect write, \"Variable $@ is assigned a value that is never used.\", v, v.getText()",
        "description": "Unused values may be an indication that the code is incomplete or has a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/unusedentities/UnusedValue.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport UnusedVariable\n\nfrom Variable v\nwhere\n  isUnused(v) and\n  not isAllowableUnused(v) and\n  not v instanceof DiscardVariable\nselect v, \"Variable '\" + v + \"' is not used.\"",
        "description": "Unused variables may be an indication that the code is incomplete or has a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/unusedentities/UnusedVariable.ql",
        "language": "rust"
    },
    {
        "query": "import codeql.rust.Diagnostics\nimport codeql.files.FileSystem\n\nint getSeverity() { result = 2 }\n\nfrom ExtractionError error, ExtractedFile f\nwhere\n  f = error.getLocation().getFile() and\n  exists(f.getRelativePath())\nselect error, \"Extraction failed in \" + f + \" with error \" + error.getMessage(), getSeverity()",
        "description": "List all extraction errors for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/ExtractionErrors.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.controlflow.internal.CfgConsistency as Consistency\n\n// see also `rust/diagnostics/cfg-consistency`, which lists the\n// individual inconsistency results.\nfrom string type, int num\nwhere num = Consistency::getCfgInconsistencyCounts(type)\nselect type, num",
        "description": "Counts the number of control flow graph inconsistencies of each type.  This query is intended for internal use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/CfgConsistencyCounts.ql",
        "language": "rust"
    },
    {
        "query": "import codeql.rust.dataflow.internal.DataFlowConsistency as Consistency\n\n// see also `rust/diagnostics/data-flow-consistency`, which lists the\n// individual inconsistency results.\nfrom string type, int num\nwhere num = Consistency::getInconsistencyCounts(type)\nselect type, num",
        "description": "Counts the number of data flow inconsistencies of each type.  This query is intended for internal use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/DataFlowConsistencyCounts.ql",
        "language": "rust"
    },
    {
        "query": "import rust\n\nbindingset[i]\nstring multipleString(int i) {\n  i = 1 and result = \"\"\n  or\n  i > 1 and result = \" (x\" + i.toString() + \")\"\n}\n\nfrom string name, int c\nwhere c = strictcount(Unextracted e | e.toString() = name)\n// we don't have locations, so just list the number of each type of\n// `Unextracted` element.\nselect name + multipleString(c)",
        "description": "List all elements that weren't extracted due to unimplemented features or parse errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/UnextractedElements.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.internal.AstConsistency as Consistency\n\n// see also `rust/diagnostics/ast-consistency`, which lists the\n// individual inconsistency results.\nfrom string type, int num\nwhere num = Consistency::getAstInconsistencyCounts(type)\nselect type, num",
        "description": "Counts the number of abstract syntax tree inconsistencies of each type.  This query is intended for internal use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/AstConsistencyCounts.ql",
        "language": "rust"
    },
    {
        "query": "private import codeql.rust.internal.TypeInferenceConsistency as Consistency\n\n// see also `rust/diagnostics/type-inference-consistency`, which lists the\n// individual inconsistency results.\nfrom string type, int num\nwhere num = Consistency::getTypeInferenceInconsistencyCounts(type)\nselect type, num",
        "description": "Counts the number of type inference inconsistencies of each type.  This query is intended for internal use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/TypeInferenceConsistencyCounts.ql",
        "language": "rust"
    },
    {
        "query": "import rust\n\nfrom MacroCall mc\nwhere mc.fromSource() and not mc.hasMacroCallExpansion()\nselect mc, \"Macro call was not resolved to a target.\"",
        "description": "List all macro calls that were not resolved to a target.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/UnresolvedMacroCalls.ql",
        "language": "rust"
    },
    {
        "query": "import rust\n\nfrom ExtractedFile f\nwhere exists(f.getRelativePath())\nselect f, \"File successfully extracted.\"",
        "description": "Lists all files in the source code directory that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/ExtractedFiles.ql",
        "language": "rust"
    },
    {
        "query": "import codeql.rust.Diagnostics\nimport codeql.files.FileSystem\n\nint getSeverity() { result = 1 }\n\nfrom ExtractionWarning warning, File f\nwhere\n  f = warning.getLocation().getFile() and\n  exists(f.getRelativePath())\nselect warning, \"Extraction warning in \" + f + \" with message \" + warning.getMessage(),\n  getSeverity()",
        "description": "List all extraction warnings for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/ExtractionWarnings.ql",
        "language": "rust"
    },
    {
        "query": "private import codeql.rust.dataflow.internal.SsaImpl::Consistency as SsaConsistency\n\n// see also `rust/diagnostics/ssa-consistency`, which lists the\n// individual inconsistency results.\nfrom string type, int num\nwhere num = SsaConsistency::getInconsistencyCounts(type)\nselect type, num",
        "description": "Counts the number of static single assignment inconsistencies of each type.  This query is intended for internal use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/diagnostics/SsaConsistencyCounts.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport DatabaseQuality\nimport codeql.util.Unit\n\nprivate predicate diagnostic(string msg, float value, float threshold) {\n  CallTargetStatsReport::percentageOfOk(msg, value) and threshold = 50\n  or\n  MacroCallTargetStatsReport::percentageOfOk(msg, value) and threshold = 50\n}\n\nprivate string getDbHealth() {\n  result =\n    strictconcat(string msg, float value, float threshold |\n      diagnostic(msg, value, threshold)\n    |\n      msg + \": \" + value.floor() + \" % (threshold \" + threshold.floor() + \" %)\", \". \"\n    )\n}\n\nclass DbQualityDiagnostic extends Unit {\n  DbQualityDiagnostic() {\n    exists(float percentageGood, float threshold |\n      diagnostic(_, percentageGood, threshold) and\n      percentageGood < threshold\n    )\n  }\n\n  string toString() {\n    result =\n      \"Scanning Rust code completed successfully, but the scan encountered issues. \" +\n        \"This may be caused by problems identifying dependencies or use of generated source code. \" +\n        \"Some metrics of the database quality are: \" + getDbHealth() + \". \" +\n        \"Ideally these metrics should be above their thresholds. \" +\n        \"Addressing these issues is advisable to avoid false-positives or missing results.\"\n  }\n}\n\nquery predicate diagnosticAttributes(DbQualityDiagnostic e, string key, string value) {\n  exists(e) and // Quieten warning about unconstrained 'e'\n  key = [\"visibilityCliSummaryTable\", \"visibilityTelemetry\", \"visibilityStatusPage\"] and\n  value = \"true\"\n}\n\nfrom DbQualityDiagnostic d\nselect d, d.toString(), 1",
        "description": "Low Rust analysis quality",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/telemetry/DatabaseQualityDiagnostics.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport DatabaseQuality\nimport codeql.rust.Diagnostics\n\npredicate fileCount(string key, int value) {\n  key = \"Number of files\" and\n  value = strictcount(File f)\n}\n\npredicate fileCountByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Number of files with extension \" + extension and\n    value = strictcount(File f | f.getExtension() = extension)\n  )\n}\n\npredicate numberOfLinesOfCode(string key, int value) {\n  key = \"Number of lines of code\" and\n  value = strictsum(File f | any() | f.getNumberOfLinesOfCode())\n}\n\npredicate numberOfLinesOfCodeByExtension(string key, int value) {\n  exists(string extension |\n    key = \"Number of lines of code with extension \" + extension and\n    value = strictsum(File f | f.getExtension() = extension | f.getNumberOfLinesOfCode())\n  )\n}\n\npredicate extractorDiagnostics(string key, int value) {\n  exists(int severity |\n    key = \"Number of diagnostics with severity \" + severity.toString() and\n    value = strictcount(Diagnostic d | d.getSeverity() = severity)\n  )\n}\n\nfrom string key, float value\nwhere\n  (\n    fileCount(key, value) or\n    fileCountByExtension(key, value) or\n    numberOfLinesOfCode(key, value) or\n    numberOfLinesOfCodeByExtension(key, value) or\n    extractorDiagnostics(key, value) or\n    CallTargetStatsReport::numberOfOk(key, value) or\n    CallTargetStatsReport::numberOfNotOk(key, value) or\n    CallTargetStatsReport::percentageOfOk(key, value) or\n    MacroCallTargetStatsReport::numberOfOk(key, value) or\n    MacroCallTargetStatsReport::numberOfNotOk(key, value) or\n    MacroCallTargetStatsReport::percentageOfOk(key, value)\n  ) and\n  /* Infinity */\n  value != 1.0 / 0.0 and\n  /* -Infinity */\n  value != -1.0 / 0.0 and\n  /* NaN */\n  value != 0.0 / 0.0\nselect key, value",
        "description": "Information about the extraction for a Rust database",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/telemetry/ExtractorInformation.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport Stats\n\nfrom string key, int value\nwhere\n  elementStats(key, value)\n  or\n  extractionStats(key, value)\n  or\n  inconsistencyStats(key, value)\n  or\n  typeInferenceInconsistencyStats(key, value)\n  or\n  taintStats(key, value)\nselect key, value order by key",
        "description": "A table of summary statistics about a database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/SummaryStats.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.Concepts\nimport codeql.rust.security.WeakSensitiveDataHashingExtensions\n\nstring getAlgorithmType(Cryptography::CryptographicAlgorithm alg) {\n  alg instanceof Cryptography::EncryptionAlgorithm and result = \"EncryptionAlgorithm\"\n  or\n  alg instanceof Cryptography::HashingAlgorithm and result = \"HashingAlgorithm\"\n  or\n  alg instanceof Cryptography::PasswordHashingAlgorithm and result = \"PasswordHashingAlgorithm\"\n}\n\nstring getAlgorithmFeature(Cryptography::CryptographicAlgorithm alg) {\n  alg.isWeak() and result = \"WEAK\"\n}\n\nstring describeAlgorithm(Cryptography::CryptographicAlgorithm alg) {\n  result =\n    getAlgorithmType(alg) + \" \" + alg.getName() + \" \" + concat(getAlgorithmFeature(alg), \", \")\n}\n\nstring getOperationFeature(Cryptography::CryptographicOperation op) {\n  result = \"inputs:\" + strictcount(op.getAnInput()).toString() or\n  result = \"blockmodes:\" + strictcount(op.getBlockMode()).toString()\n}\n\nstring describeOperation(Cryptography::CryptographicOperation op) {\n  result = describeAlgorithm(op.getAlgorithm()) + \" \" + concat(getOperationFeature(op), \", \")\n  or\n  not exists(op.getAlgorithm()) and\n  result = \"(unknown) \" + concat(getOperationFeature(op), \", \")\n}\n\nfrom Cryptography::CryptographicOperation operation\nselect operation, describeOperation(operation)",
        "description": "List all cryptographic operations found in the database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/CryptographicOperations.ql",
        "language": "rust"
    },
    {
        "query": "import codeql.files.FileSystem\n\nselect count(ExtractedFile f |\n    exists(f.getRelativePath()) and\n    not f instanceof SuccessfullyExtractedFile\n  )",
        "description": "The total number of Rust files in the source code directory that were extracted, but where at least one extraction error (or warning) occurred in the process.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/NumberOfFilesExtractedWithErrors.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport Stats\n\nselect getLinesOfCode()",
        "description": "The total number of lines of Rust code across all files, including any libraries and auto-generated files that the extractor sees. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/LinesOfCode.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.internal.TypeInference\n\nfrom int atLimit\nwhere\n  atLimit =\n    count(AstNode n, TypePath path |\n      exists(inferType(n, path)) and path.length() = getTypePathLimit()\n    |\n      n\n    )\nselect atLimit",
        "description": "Counts the number of AST nodes with a type at the type path length limit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/NodesWithTypeAtLengthLimit.ql",
        "language": "rust"
    },
    {
        "query": "import rust\n\nfrom File f, int n\nwhere\n  exists(f.getRelativePath()) and\n  n = f.getNumberOfLinesOfCode()\nselect f, n order by n desc",
        "description": "Measures the number of lines of code in each file from the source directory, ignoring lines that contain only comments or whitespace.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/LinesOfUserCodeInFiles.ql",
        "language": "rust"
    },
    {
        "query": "import codeql.files.FileSystem\n\nselect count(SuccessfullyExtractedFile f | exists(f.getRelativePath()))",
        "description": "The total number of Rust files in the source code directory that were extracted without encountering any extraction errors (or warnings).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/NumberOfSuccessfullyExtractedFiles.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport Stats\n\nselect getLinesOfUserCode()",
        "description": "The total number of lines of Rust code from the source code directory. This query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/LinesOfUserCode.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.Concepts\n\nfrom ThreatModelSource s, string defaultString\nwhere\n  if s instanceof ActiveThreatModelSource then defaultString = \" (DEFAULT)\" else defaultString = \"\"\nselect s,\n  \"Flow source '\" + s.getSourceType() + \"' of type \" + s.getThreatModel() + defaultString + \".\"",
        "description": "List all sources of untrusted input that have been idenfitied in the database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/TaintSources.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.security.SensitiveData\n\nfrom SensitiveData d\nselect d, \"Sensitive data (\" + d.getClassification() + \"): \" + d.toString()",
        "description": "List all sensitive data found in the database. Sensitive data is anything that should not be sent in unencrypted form.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/SensitiveData.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.Concepts\nimport Stats\nimport codeql.rust.security.AccessInvalidPointerExtensions\nimport codeql.rust.security.CleartextLoggingExtensions\n\nfrom QuerySink s\nwhere\n  not s instanceof AccessInvalidPointer::Sink and\n  not s instanceof CleartextLogging::Sink\nselect s, \"Sink for \" + concat(s.getSinkType(), \", \") + \".\"",
        "description": "Lists query sinks that are found in the database. Query sinks are flow sinks that are used as possible locations for query results. Cryptographic operations are excluded (see `rust/summary/cryptographic-operations` instead), as are certain sink types that are ubiquitous in most code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/QuerySinks.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport Stats\n\nfrom string key, int value\nwhere\n  extractionStats(key, value)\n  or\n  inconsistencyStats(key, value)\nselect key, value order by key",
        "description": "A table of summary statistics about a database, with data that has been found to be noisy on tests removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/SummaryStatsReduced.ql",
        "language": "rust"
    },
    {
        "query": "import rust\nimport codeql.rust.dataflow.DataFlow\nimport codeql.rust.Concepts\nimport Stats\n\nfrom string kind, int num\nwhere num = strictcount(QuerySink s | s.getSinkType() = kind)\nselect kind, num",
        "description": "Lists the number of query sinks of each type found in the database. Query sinks are flow sinks that are used as possible locations for query results. Cryptographic operations are excluded.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/queries/summary/QuerySinkCounts.ql",
        "language": "rust"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string noflow\nwhere noflow = Heuristic::captureNoFlow(api)\nselect noflow order by noflow",
        "description": "Finds neutral models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/utils/modelgenerator/CaptureNeutralModels.ql",
        "language": "rust"
    },
    {
        "query": "import internal.CaptureModels\nimport SinkModels\n\nfrom DataFlowSinkTargetApi api, string sink\nwhere sink = Heuristic::captureSink(api)\nselect sink order by sink",
        "description": "Finds public methods that act as sinks as they flow into a known sink.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/utils/modelgenerator/CaptureSinkModels.ql",
        "language": "rust"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = ContentSensitive::captureFlow(api, _, _, _, _)\nselect flow order by flow",
        "description": "Finds applicable content based summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/utils/modelgenerator/CaptureContentSummaryModels.ql",
        "language": "rust"
    },
    {
        "query": "import internal.CaptureModels\nimport SummaryModels\n\nfrom DataFlowSummaryTargetApi api, string flow\nwhere flow = captureFlow(api, _)\nselect flow order by flow",
        "description": "Finds applicable summary models to be used by other queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/utils/modelgenerator/CaptureSummaryModels.ql",
        "language": "rust"
    },
    {
        "query": "import internal.CaptureModels\nimport SourceModels\n\nfrom DataFlowSourceTargetApi api, string source\nwhere source = Heuristic::captureSource(api)\nselect source order by source",
        "description": "Finds APIs that act as sources as they expose already known sources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/utils/modelgenerator/CaptureSourceModels.ql",
        "language": "rust"
    },
    {
        "query": "private import codeql.rust.dataflow.DataFlow\nimport utils.modelgenerator.internal.CaptureModels\nimport SummaryModels\nimport PartialFlow::PartialPathGraph\n\nint explorationLimit() { result = 3 }\n\nmodule PartialFlow = Heuristic::PropagateTaintFlow::FlowExplorationFwd<explorationLimit/0>;\n\nfrom\n  PartialFlow::PartialPathNode source, PartialFlow::PartialPathNode sink,\n  DataFlowSummaryTargetApi api, DataFlow::ParameterNode p\nwhere\n  PartialFlow::partialFlow(source, sink, _) and\n  p = source.getNode() and\n  p.asParameter() = api.getFunction().getParamList().getAParamBase()\nselect sink.getNode(), source, sink, \"There is flow from a $@ to $@.\", source.getNode(),\n  \"parameter\", sink.getNode(), \"intermediate value\"",
        "description": "Capture Summary Models Partial Path",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/utils/modelgenerator/debug/CaptureSummaryModelsPartialPath.ql",
        "language": "rust"
    },
    {
        "query": "private import codeql.rust.dataflow.DataFlow\nimport utils.modelgenerator.internal.CaptureModels\nimport SummaryModels\nimport Heuristic::PropagateTaintFlow::PathGraph\n\nfrom\n  Heuristic::PropagateTaintFlow::PathNode source, Heuristic::PropagateTaintFlow::PathNode sink,\n  DataFlowSummaryTargetApi api, DataFlow::Node p, DataFlow::Node returnNodeExt\nwhere\n  Heuristic::PropagateTaintFlow::flowPath(source, sink) and\n  p = source.getNode() and\n  returnNodeExt = sink.getNode() and\n  Heuristic::captureThroughFlow0(api, p, returnNodeExt)\nselect sink.getNode(), source, sink, \"There is flow from $@ to the $@.\", source.getNode(),\n  \"parameter\", sink.getNode(), \"return value\"",
        "description": "Capture Summary Models Path",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/rust/ql/src/utils/modelgenerator/debug/CaptureSummaryModelsPath.ql",
        "language": "rust"
    },
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import semmle.python.Comment as P\n\nclass AstNode instanceof P::AstNode {\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    super.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n\n  string toString() { result = super.toString() }\n}\n\nclass SingleLineComment instanceof P::Comment {\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    super.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n\n  string getText() { result = super.getContents() }\n\n  string toString() { result = super.toString() }\n}\n\nimport AS::Make<AstNode, SingleLineComment>\n\nclass NoqaSuppressionComment extends SuppressionComment instanceof SingleLineComment {\n  NoqaSuppressionComment() {\n    SingleLineComment.super.getText().regexpMatch(\"(?i)\\\\s*noqa\\\\s*([^:].*)?\")\n  }\n\n  override string getAnnotation() { result = \"lgtm\" }\n\n  override predicate covers(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.hasLocationInfo(filepath, startline, _, endline, endcolumn) and\n    startcolumn = 1\n  }\n}",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/AlertSuppression.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.filters.GeneratedCode\nimport semmle.python.filters.Tests\n\npredicate classify(File f, string tag) {\n  f instanceof GeneratedFile and tag = \"generated\"\n  or\n  exists(TestScope t | t.getLocation().getFile() = f) and tag = \"test\"\n}\n\nfrom File f, string tag\nwhere classify(f, tag)\nselect f, tag",
        "description": "This query produces a list of all files in a snapshot that are classified as generated code or test code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Filters/ClassifyFiles.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, int n\nwhere n = m.getMetrics().getNumberOfLines()\nselect m, n order by n desc",
        "description": "The number of lines in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FLines.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom FunctionMetrics func\nselect func, func.getNumberOfCalls() as n order by n desc",
        "description": "The total number of calls in a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FunctionNumberOfCalls.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ModuleValue m, int n\nwhere n = count(ModuleValue imp | imp = m.getAnImportedModule+() and imp != m)\nselect m.getScope(), n",
        "description": "The number of modules imported by this file - either directly by an import statement, or indirectly (by being imported by an imported module).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/TransitiveImports.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom FunctionMetrics func\nselect func, func.getNumberOfParametersWithoutDefault() as n order by n desc",
        "description": "The number of parameters of a function that do not have default values defined.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/NumberOfParametersWithoutDefault.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, ModuleMetrics mm\nwhere mm = m.getMetrics() and mm.getNumberOfLines() > 0\nselect m,\n  100.0 * (mm.getNumberOfLinesOfDocStrings().(float) / mm.getNumberOfLines().(float)) as ratio\n  order by ratio desc",
        "description": "The percentage of lines in a file that contain docstrings.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/DocStringRatio.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, int n\nwhere n = count(Function f | f.getEnclosingModule() = m and f.getName() != \"lambda\")\nselect m, n order by n desc",
        "description": "Measures the number of functions and methods in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FFunctionsAndMethods.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom File f, int n\nwhere none()\nselect f, n order by n desc",
        "description": "The number of lines in a file, including code, comment and whitespace lines, which are duplicated in at least one other place.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FLinesOfDuplicatedCode.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, ModuleMetrics mm\nwhere mm = m.getMetrics() and mm.getNumberOfLines() > 0\nselect m, 100.0 * (mm.getNumberOfLinesOfComments().(float) / mm.getNumberOfLines().(float)) as ratio\n  order by ratio desc",
        "description": "The percentage of lines in a file that contain comments. Note that docstrings are reported by a separate metric.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/CommentRatio.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Function func, int complexity\nwhere complexity = func.getMetrics().getCyclomaticComplexity()\nselect func, complexity order by complexity desc",
        "description": "The cyclomatic complexity per function (an indication of how many tests are necessary, based on the number of branching statements).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/CyclomaticComplexity.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ClassMetrics cls\nselect cls, cls.getEfferentCoupling() as n order by n desc",
        "description": "The number of classes that this class depends upon.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/ClassEfferentCoupling.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, int n\nwhere n = m.getMetrics().getNumberOfLinesOfCode()\nselect m, n order by n desc",
        "description": "Measures the number of lines of code in each file (ignoring lines that contain only docstrings, comments or are blank).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FLinesOfCode.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ClassMetrics cls\nselect cls, cls.getLackOfCohesionCK() as n order by n desc",
        "description": "Lack of cohesion in the methods of a class, as defined by Chidamber and Kemerer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/LackofCohesionInMethodsCK.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ClassMetrics cls\nselect cls, cls.getAfferentCoupling() as n order by n desc",
        "description": "The number of classes that depend on a class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/ClassAfferentCoupling.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ClassMetrics cls\nselect cls, cls.getLackOfCohesionHM() as n order by n desc",
        "description": "Lack of cohesion of a class, as defined by Hitz and Montazeri.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/LackofCohesionInMethodsHM.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, int n\nwhere n = count(Stmt s | s.getEnclosingModule() = m)\nselect m, n order by n desc",
        "description": "The number of statements in this module",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/NumberOfStatements.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.filters.Tests\n\nfrom Module m, int n\nwhere n = strictcount(Test test | test.getEnclosingModule() = m)\nselect m.getFile(), n order by n desc",
        "description": "The number of test methods defined in a module",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FNumberOfTests.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Function f\nselect f, f.getMetrics().getNumberOfLinesOfCode() as n order by n desc",
        "description": "The number of lines of code in a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/CLinesOfCode.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ModuleMetrics m\nselect m, m.getEfferentCoupling() as n order by n desc",
        "description": "The number of modules that this module depends upon.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/ModuleEfferentCoupling.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, int n\nwhere n = count(Class c | c.getEnclosingModule() = m)\nselect m, n order by n desc",
        "description": "Measures the number of classes in a file",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FClasses.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ModuleMetrics m\nselect m, m.getAfferentCoupling() as n order by n desc",
        "description": "The number of modules that depend on a module.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/ModuleAfferentCoupling.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, int n\nwhere\n  n = m.getMetrics().getNumberOfLinesOfComments() + m.getMetrics().getNumberOfLinesOfDocStrings()\nselect m, n order by n desc",
        "description": "Measures the number of lines of comments in each file (including docstrings, and ignoring lines that contain only code or are blank).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FLinesOfComments.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom File f, int n\nwhere none()\nselect f, n order by n desc",
        "description": "The number of lines in a file, including code, comment and whitespace lines, which are similar in at least one other place.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FLinesOfSimilarCode.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom FunctionMetrics func\nselect func, func.getStatementNestingDepth() as n order by n desc",
        "description": "The maximum nesting depth of statements in a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/FunctionStatementNestingDepth.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ModuleValue m, int n\nwhere n = count(ModuleValue imp | imp = m.getAnImportedModule())\nselect m.getScope(), n",
        "description": "The number of modules directly imported by this file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/DirectImports.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Extents\n\nfrom RangeFunction f\nselect f.getLocation(), f",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Internal/CallableExtents.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Function f\nselect f, \"Function \" + f.getName()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Internal/CallableDisplayStrings.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Function f\nselect f, f.getLocation().getFile()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Internal/CallableSourceLinks.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Class c\nselect c, c.getLocation().getFile()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Internal/ClassSourceLinks.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nclass BuiltinType extends Name {\n  BuiltinType() { this.getId() in [\"int\", \"float\", \"str\", \"bool\", \"bytes\", \"None\"] }\n}\n\nnewtype TAnnotatable =\n  TAnnotatedFunction(FunctionExpr f) { exists(f.getReturns()) } or\n  TAnnotatedParameter(Parameter p) { exists(p.getAnnotation()) } or\n  TAnnotatedAssignment(AnnAssign a) { exists(a.getAnnotation()) }\n\nabstract class Annotatable extends TAnnotatable {\n  string toString() { result = \"Annotatable\" }\n\n  abstract Expr getAnnotation();\n}\n\nclass AnnotatedFunction extends TAnnotatedFunction, Annotatable {\n  FunctionExpr function;\n\n  AnnotatedFunction() { this = TAnnotatedFunction(function) }\n\n  override Expr getAnnotation() { result = function.getReturns() }\n}\n\nclass AnnotatedParameter extends TAnnotatedParameter, Annotatable {\n  Parameter parameter;\n\n  AnnotatedParameter() { this = TAnnotatedParameter(parameter) }\n\n  override Expr getAnnotation() { result = parameter.getAnnotation() }\n}\n\nclass AnnotatedAssignment extends TAnnotatedAssignment, Annotatable {\n  AnnAssign assignment;\n\n  AnnotatedAssignment() { this = TAnnotatedAssignment(assignment) }\n\n  override Expr getAnnotation() { result = assignment.getAnnotation() }\n}\n\npredicate is_forward_declaration(Expr e) { e instanceof StringLiteral }\n\npredicate is_complex_type(Expr e) {\n  e instanceof Subscript and not is_optional_type(e)\n  or\n  e instanceof Tuple\n  or\n  e instanceof List\n}\n\npredicate is_optional_type(Subscript e) { e.getObject().(Name).getId() = \"Optional\" }\n\npredicate is_simple_type(Expr e) {\n  e instanceof Name and not e instanceof BuiltinType\n  or\n  is_simple_type(e.(Attribute).getObject())\n}\n\npredicate is_builtin_type(Expr e) { e instanceof BuiltinType }\n\npredicate type_count(\n  string kind, int total, int built_in_count, int forward_declaration_count, int simple_type_count,\n  int complex_type_count, int optional_type_count\n) {\n  kind = \"Parameter annotation\" and\n  total = count(AnnotatedParameter p) and\n  built_in_count = count(AnnotatedParameter p | is_builtin_type(p.getAnnotation())) and\n  forward_declaration_count =\n    count(AnnotatedParameter p | is_forward_declaration(p.getAnnotation())) and\n  simple_type_count = count(AnnotatedParameter p | is_simple_type(p.getAnnotation())) and\n  complex_type_count = count(AnnotatedParameter p | is_complex_type(p.getAnnotation())) and\n  optional_type_count = count(AnnotatedParameter p | is_optional_type(p.getAnnotation()))\n  or\n  kind = \"Return type annotation\" and\n  total = count(AnnotatedFunction f) and\n  built_in_count = count(AnnotatedFunction f | is_builtin_type(f.getAnnotation())) and\n  forward_declaration_count = count(AnnotatedFunction f | is_forward_declaration(f.getAnnotation())) and\n  simple_type_count = count(AnnotatedFunction f | is_simple_type(f.getAnnotation())) and\n  complex_type_count = count(AnnotatedFunction f | is_complex_type(f.getAnnotation())) and\n  optional_type_count = count(AnnotatedFunction f | is_optional_type(f.getAnnotation()))\n  or\n  kind = \"Annotated assignment\" and\n  total = count(AnnotatedAssignment a) and\n  built_in_count = count(AnnotatedAssignment a | is_builtin_type(a.getAnnotation())) and\n  forward_declaration_count =\n    count(AnnotatedAssignment a | is_forward_declaration(a.getAnnotation())) and\n  simple_type_count = count(AnnotatedAssignment a | is_simple_type(a.getAnnotation())) and\n  complex_type_count = count(AnnotatedAssignment a | is_complex_type(a.getAnnotation())) and\n  optional_type_count = count(AnnotatedAssignment a | is_optional_type(a.getAnnotation()))\n}\n\nfrom\n  string message, int total, int built_in, int forward_decl, int simple, int complex, int optional\nwhere type_count(message, total, built_in, forward_decl, simple, complex, optional)\nselect message, total, built_in, forward_decl, simple, complex, optional",
        "description": "Counts of various kinds of type annotations in Python code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Internal/TypeAnnotations.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Class c\nselect c, c.getName()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Internal/ClassDisplayStrings.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Extents\n\nfrom RangeClass c\nselect c.getLocation(), c",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Internal/ClassExtents.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dependencies.TechInventory\n\n\npredicate src_package_count(File sourceFile, ExternalPackage package, int total) {\n  total =\n    strictcount(AstNode src |\n      dependency(src, package) and\n      src.getLocation().getFile() = sourceFile\n    )\n}\n\nfrom File sourceFile, int total, string entity, ExternalPackage package\nwhere\n  src_package_count(sourceFile, package, total) and\n  entity = munge(sourceFile, package)\nselect entity, total order by total desc",
        "description": "Count the number of dependencies that a Python source file has on external packages.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Dependencies/ExternalDependencies.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dependencies.TechInventory\n\n\nfrom File sourceFile, string entity\nwhere\n  exists(PackageObject package, AstNode src |\n    dependency(src, package) and\n    src.getLocation().getFile() = sourceFile and\n    entity = munge(sourceFile, package)\n  )\nselect entity, sourceFile",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/Dependencies/ExternalDependenciesSourceLinks.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Commit c\nwhere not artificialChange(c)\nselect c.getRevisionName(), 1",
        "description": "Number of commits",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HNumberOfCommits.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Module m, int n\nwhere\n  n =\n    sum(Commit entry, int churn |\n      churn = entry.getRecentDeletionsForFile(m.getFile()) and not artificialChange(entry)\n    |\n      churn\n    ) and\n  exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, n order by n desc",
        "description": "Number of deleted lines per file, across the revision history in the database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HLinesDeleted.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\npredicate inRange(Commit first, Commit second) {\n  first.getAnAffectedFile() = second.getAnAffectedFile() and\n  first != second and\n  exists(int n |\n    n = first.getDate().daysTo(second.getDate()) and\n    n >= 0 and\n    n < 5\n  )\n}\n\nint recommitsForFile(File f) {\n  result =\n    count(Commit recommit |\n      f = recommit.getAnAffectedFile() and\n      exists(Commit prev | inRange(prev, recommit))\n    )\n}\n\nfrom Module m\nwhere exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, recommitsForFile(m.getFile())",
        "description": "A re-commit is taken to mean a commit to a file that was touched less than five days ago.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HNumberOfReCommits.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Commit c\nwhere c.daysToNow() <= 180 and not artificialChange(c)\nselect c.getRevisionName(), 1",
        "description": "Number of recent commits",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HNumberOfRecentCommits.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nint committedFiles(Commit commit) { result = count(commit.getAnAffectedFile()) }\n\nfrom Module m\nwhere exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m,\n  avg(Commit commit, int toAvg |\n    commit.getAnAffectedFile() = m.getFile() and toAvg = committedFiles(commit) - 1\n  |\n    toAvg\n  )",
        "description": "The average number of other files that are touched whenever a file is affected by a commit",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HNumberOfCoCommits.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Module m\nwhere exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, count(Author author | author.getAnEditedFile() = m.getFile())",
        "description": "Number of distinct authors for each file",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HNumberOfAuthors.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Module m, int n\nwhere\n  n =\n    sum(Commit entry, int churn |\n      churn = entry.getRecentChurnForFile(m.getFile()) and not artificialChange(entry)\n    |\n      churn\n    ) and\n  exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, n order by n desc",
        "description": "Number of churned lines per file, across the revision history in the database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HChurn.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Module m\nwhere exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m,\n  count(Author author |\n    exists(Commit e |\n      e = author.getACommit() and\n      m.getFile() = e.getAnAffectedFile() and\n      e.daysToNow() <= 180 and\n      not artificialChange(e)\n    )\n  )",
        "description": "Number of distinct authors that have recently made changes",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HNumberOfRecentAuthors.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Module m\nwhere\n  exists(Commit e |\n    e.getAnAffectedFile() = m.getFile() and e.daysToNow() <= 180 and not artificialChange(e)\n  ) and\n  exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, 1",
        "description": "Number of files recently edited",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HNumberOfRecentChangedFiles.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Module m, int n\nwhere\n  n =\n    sum(Commit entry, int churn |\n      churn = entry.getRecentAdditionsForFile(m.getFile()) and not artificialChange(entry)\n    |\n      churn\n    ) and\n  exists(m.getMetrics().getNumberOfLinesOfCode())\nselect m, n order by n desc",
        "description": "Number of added lines per file, across the revision history in the database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/History/HLinesAdded.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Commit c, File f\nwhere f.fromSource() and f = c.getAnAffectedFile()\nselect c.getRevisionName(), f",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/External/CommitSourceLinks.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport external.VCS\n\nfrom Commit c\nselect c.getRevisionName(), c.getMessage() + \"(\" + c.getDate().toString() + \")\"",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Metrics/External/CommitDisplayStrings.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\nprivate module TimingAttackAgainstHashConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ProduceCryptoCall }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof NonConstantTimeComparisonSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule TimingAttackAgainstHashFlow = TaintTracking::Global<TimingAttackAgainstHashConfig>;\n\nimport TimingAttackAgainstHashFlow::PathGraph\n\nfrom TimingAttackAgainstHashFlow::PathNode source, TimingAttackAgainstHashFlow::PathNode sink\nwhere\n  TimingAttackAgainstHashFlow::flowPath(source, sink) and\n  sink.getNode().(NonConstantTimeComparisonSink).includesUserInput()\nselect sink.getNode(), source, sink, \"Timing attack against $@ validation.\", source.getNode(),\n  source.getNode().(ProduceCryptoCall).getResultType() + \" message\"",
        "description": "When checking a Hash over a message, a constant-time algorithm should be used. Otherwise, an attacker may be able to forge a valid Hash for an arbitrary message by running a timing attack if they can send to the validation procedure. A successful attack can result in authentication bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-208/TimingAttackAgainstHash/TimingAttackAgainstHash.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\nprivate module PossibleTimingAttackAgainstHashConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ProduceCryptoCall }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof NonConstantTimeComparisonSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule PossibleTimingAttackAgainstHashFlow =\n  TaintTracking::Global<PossibleTimingAttackAgainstHashConfig>;\n\nimport PossibleTimingAttackAgainstHashFlow::PathGraph\n\nfrom\n  PossibleTimingAttackAgainstHashFlow::PathNode source,\n  PossibleTimingAttackAgainstHashFlow::PathNode sink\nwhere PossibleTimingAttackAgainstHashFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Possible Timing attack against $@ validation.\",\n  source.getNode(), source.getNode().(ProduceCryptoCall).getResultType() + \" message\"",
        "description": "When checking a Hash over a message, a constant-time algorithm should be used. Otherwise, an attacker may be able to forge a valid Hash for an arbitrary message by running a timing attack if they can send to the validation procedure. A successful attack can result in authentication bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-208/TimingAttackAgainstHash/PossibleTimingAttackAgainstHash.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\nimport TimingAttackAgainstSensitiveInfoFlow::PathGraph\n\nprivate module TimingAttackAgainstSensitiveInfoConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof SecretSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof NonConstantTimeComparisonSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule TimingAttackAgainstSensitiveInfoFlow =\n  TaintTracking::Global<TimingAttackAgainstSensitiveInfoConfig>;\n\nfrom\n  TimingAttackAgainstSensitiveInfoFlow::PathNode source,\n  TimingAttackAgainstSensitiveInfoFlow::PathNode sink\nwhere\n  TimingAttackAgainstSensitiveInfoFlow::flowPath(source, sink) and\n  (\n    source.getNode().(SecretSource).includesUserInput() or\n    sink.getNode().(NonConstantTimeComparisonSink).includesUserInput()\n  )\nselect sink.getNode(), source, sink, \"Timing attack against $@ validation.\", source.getNode(),\n  \"client-supplied token\"",
        "description": "Use of a non-constant-time verification routine to check the value of an secret, possibly allowing a timing attack to retrieve sensitive information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-208/TimingAttackAgainstSensitiveInfo/TimingAttackAgainstSensitiveInfo.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\nprivate module PossibleTimingAttackAgainstSensitiveInfoConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof SecretSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof NonConstantTimeComparisonSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule PossibleTimingAttackAgainstSensitiveInfoFlow =\n  TaintTracking::Global<PossibleTimingAttackAgainstSensitiveInfoConfig>;\n\nimport PossibleTimingAttackAgainstSensitiveInfoFlow::PathGraph\n\nfrom\n  PossibleTimingAttackAgainstSensitiveInfoFlow::PathNode source,\n  PossibleTimingAttackAgainstSensitiveInfoFlow::PathNode sink\nwhere PossibleTimingAttackAgainstSensitiveInfoFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Timing attack against $@ validation.\", source.getNode(),\n  \"client-supplied token\"",
        "description": "Use of a non-constant-time verification routine to check the value of an secret, possibly allowing a timing attack to retrieve sensitive information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-208/TimingAttackAgainstSensitiveInfo/PossibleTimingAttackAgainstSensitiveInfo.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport experimental.semmle.python.security.TimingAttack\n\nprivate module TimingAttackAgainstHeaderValueConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ClientSuppliedSecret }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof CompareSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule TimingAttackAgainstHeaderValueFlow =\n  TaintTracking::Global<TimingAttackAgainstHeaderValueConfig>;\n\nimport TimingAttackAgainstHeaderValueFlow::PathGraph\n\nfrom\n  TimingAttackAgainstHeaderValueFlow::PathNode source,\n  TimingAttackAgainstHeaderValueFlow::PathNode sink\nwhere\n  TimingAttackAgainstHeaderValueFlow::flowPath(source, sink) and\n  not sink.getNode().(CompareSink).flowtolen()\nselect sink.getNode(), source, sink, \"Timing attack against $@ validation.\", source.getNode(),\n  \"client-supplied token\"",
        "description": "Use of a non-constant-time verification routine to check the value of an HTTP header, possibly allowing a timing attack to infer the header's expected value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-208/TimingAttackAgainstHeaderValue/TimingAttackAgainstHeaderValue.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.dataflow.new.RemoteFlowSources\nimport semmle.python.Concepts\n\nmodule Js2PyFlowConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node node) {\n    API::moduleImport(\"js2py\").getMember([\"eval_js\", \"eval_js6\", \"EvalJs\"]).getACall().getArg(_) =\n      node\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule Js2PyFlow = TaintTracking::Global<Js2PyFlowConfig>;\n\nimport Js2PyFlow::PathGraph\n\nfrom Js2PyFlow::PathNode source, Js2PyFlow::PathNode sink\nwhere\n  Js2PyFlow::flowPath(source, sink) and\n  not exists(API::moduleImport(\"js2py\").getMember(\"disable_pyimport\").getACall())\nselect sink, source, sink, \"This input to Js2Py depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Passing user supplied arguments to a Javascript to Python translation engine such as Js2Py can lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-094/Js2Py.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport UnicodeBypassValidationQuery\nimport UnicodeBypassValidationFlow::PathGraph\n\nfrom UnicodeBypassValidationFlow::PathNode source, UnicodeBypassValidationFlow::PathNode sink\nwhere UnicodeBypassValidationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This $@ processes unsafely $@ and any logical validation in-between could be bypassed using special Unicode characters.\",\n  sink.getNode(), \"Unicode transformation (Unicode normalization)\", source.getNode(),\n  \"remote user-controlled data\"",
        "description": "A Unicode transformation is using a remote user-controlled data. The transformation is a Unicode normalization using the algorithms \"NFC\" or \"NFKC\". In all cases, the security measures implemented or the logical validation performed to escape any injection characters, to validate using regex patterns or to perform string-based checks, before the Unicode transformation are **bypassable** by special Unicode characters.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-176/UnicodeBypassValidation.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nAPI::Node getBlobServiceClient(boolean isSource) {\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getReturn()\n  or\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobServiceClient\")\n        .getMember(\"from_connection_string\")\n        .getReturn()\n}\n\nAPI::CallNode getTransitionToContainerClient() {\n  result = getBlobServiceClient(_).getMember(\"get_container_client\").getACall()\n  or\n  result = getBlobClient(_).getMember(\"_get_container_client\").getACall()\n}\n\nAPI::Node getContainerClient(boolean isSource) {\n  isSource = false and\n  result = getTransitionToContainerClient().getReturn()\n  or\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getReturn()\n  or\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"ContainerClient\")\n        .getMember([\"from_connection_string\", \"from_container_url\"])\n        .getReturn()\n}\n\nAPI::CallNode getTransitionToBlobClient() {\n  result = [getBlobServiceClient(_), getContainerClient(_)].getMember(\"get_blob_client\").getACall()\n}\n\nAPI::Node getBlobClient(boolean isSource) {\n  isSource = false and\n  result = getTransitionToBlobClient().getReturn()\n  or\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getReturn()\n  or\n  isSource = true and\n  result =\n    API::moduleImport(\"azure\")\n        .getMember(\"storage\")\n        .getMember(\"blob\")\n        .getMember(\"BlobClient\")\n        .getMember([\"from_connection_string\", \"from_blob_url\"])\n        .getReturn()\n}\n\nAPI::Node anyClient(boolean isSource) {\n  result in [getBlobServiceClient(isSource), getContainerClient(isSource), getBlobClient(isSource)]\n}\n\nnewtype TAzureFlowState =\n  MkUsesV1Encryption() or\n  MkUsesNoEncryption()\n\nprivate module AzureBlobClientConfig implements DataFlow::StateConfigSig {\n  class FlowState = TAzureFlowState;\n\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    state = MkUsesNoEncryption() and\n    node = anyClient(true).asSource()\n  }\n\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    exists(state) and\n    exists(DataFlow::AttrWrite attr |\n      node = anyClient(_).getAValueReachableFromSource() and\n      attr.accesses(node, \"encryption_version\") and\n      attr.getValue().asExpr().(StringLiteral).getText() in [\"'2.0'\", \"2.0\"]\n    )\n    or\n    // small optimization to block flow with no encryption out of the post-update node\n    // for the attribute assignment.\n    isAdditionalFlowStep(_, MkUsesNoEncryption(), node, MkUsesV1Encryption()) and\n    state = MkUsesNoEncryption()\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::MethodCallNode call |\n      call in [getTransitionToContainerClient(), getTransitionToBlobClient()] and\n      node1 = call.getObject() and\n      node2 = call\n    )\n  }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    node1 = node2.(DataFlow::PostUpdateNode).getPreUpdateNode() and\n    state1 = MkUsesNoEncryption() and\n    state2 = MkUsesV1Encryption() and\n    exists(DataFlow::AttrWrite attr |\n      node1 = anyClient(_).getAValueReachableFromSource() and\n      attr.accesses(node1, [\"key_encryption_key\", \"key_resolver_function\"])\n    )\n  }\n\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    state = MkUsesV1Encryption() and\n    exists(DataFlow::MethodCallNode call |\n      call = getBlobClient(_).getMember(\"upload_blob\").getACall() and\n      node = call.getObject()\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node sink) { none() }\n}\n\nmodule AzureBlobClientFlow = DataFlow::GlobalWithState<AzureBlobClientConfig>;\n\nimport AzureBlobClientFlow::PathGraph\n\nfrom AzureBlobClientFlow::PathNode source, AzureBlobClientFlow::PathNode sink\nwhere AzureBlobClientFlow::flowPath(source, sink)\nselect sink, source, sink, \"Unsafe usage of v1 version of Azure Storage client-side encryption\"",
        "description": "Using version v1 of Azure Storage client-side encryption is insecure, and may enable an attacker to decrypt encrypted data",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-327/Azure/UnsafeUsageOfClientSideEncryptionVersion.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Concepts\nprivate import semmle.python.dataflow.new.DataFlow\n\npredicate containsStar(DataFlow::Node array) {\n  array.asExpr() instanceof List and\n  array.asExpr().getASubExpression().(StringLiteral).getText() in [\"*\", \"null\"]\n  or\n  array.asExpr().(StringLiteral).getText() in [\"*\", \"null\"]\n}\n\npredicate isCorsMiddleware(Http::Server::CorsMiddleware middleware) {\n  middleware.getMiddlewareName() = \"CORSMiddleware\"\n}\n\npredicate credentialsAllowed(Http::Server::CorsMiddleware middleware) {\n  middleware.getCredentialsAllowed().asExpr() instanceof True\n}\n\nfrom Http::Server::CorsMiddleware a\nwhere\n  credentialsAllowed(a) and\n  containsStar(a.getOrigins().getALocalSource()) and\n  isCorsMiddleware(a)\nselect a,\n  \"This CORS middleware uses a vulnerable configuration that allows arbitrary websites to make authenticated cross-site requests\"",
        "description": "Disabling or weakening SOP protection may make the application vulnerable to a CORS attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-942/CorsMisconfigurationMiddleware.ql",
        "language": "python"
    },
    {
        "query": "// determine precision above\nimport python\nimport experimental.semmle.python.security.LdapInsecureAuth\nimport LdapInsecureAuthFlow::PathGraph\n\nfrom LdapInsecureAuthFlow::PathNode source, LdapInsecureAuthFlow::PathNode sink\nwhere LdapInsecureAuthFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This LDAP host is authenticated insecurely.\"",
        "description": "Python LDAP Insecure LDAP Authentication",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-522/LdapInsecureAuth.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.Security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\nfrom UnsafeUnpackFlow::PathNode source, UnsafeUnpackFlow::PathNode sink\nwhere UnsafeUnpackFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Unsafe extraction from a malicious tarball retrieved from a remote location.\"",
        "description": "Extracting files from a potentially malicious tarball using `shutil.unpack_archive()` without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten. More precisely, if the tarball comes from a user controlled location either a remote one or cli argument.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-022bis/UnsafeUnpack.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport TarSlipImprovFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.internal.Attributes\nimport semmle.python.dataflow.new.BarrierGuards\nimport semmle.python.dataflow.new.RemoteFlowSources\n\nAPI::Node tarfileOpen() {\n  result in [\n      API::moduleImport(\"tarfile\").getMember([\"open\", \"TarFile\"]),\n      API::moduleImport(\"tarfile\").getMember(\"TarFile\").getASubclass().getMember(\"open\")\n    ]\n}\n\nclass AllTarfileOpens extends API::CallNode {\n  AllTarfileOpens() {\n    this = tarfileOpen().getACall()\n    or\n    exists(API::Node closing, Node arg |\n      closing = API::moduleImport(\"contextlib\").getMember(\"closing\") and\n      this = closing.getACall() and\n      arg = this.getArg(0) and\n      arg = tarfileOpen().getACall()\n    )\n  }\n}\n\nprivate module TarSlipImprovConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source = tarfileOpen().getACall() }\n\n  predicate isSink(DataFlow::Node sink) {\n    (\n      // A sink capturing method calls to `extractall` without `members` argument.\n      // For a call to `file.extractall` without `members` argument, `file` is considered a sink.\n      exists(MethodCallNode call, AllTarfileOpens atfo |\n        call = atfo.getReturn().getMember(\"extractall\").getACall() and\n        not exists(call.getArgByName(\"members\")) and\n        sink = call.getObject()\n      )\n      or\n      // A sink capturing method calls to `extractall` with `members` argument.\n      // For a call to `file.extractall` with `members` argument, `file` is considered a sink if not\n      // a the `members` argument contains a NameConstant as None, a List or call to the method `getmembers`.\n      // Otherwise, the argument of `members` is considered a sink.\n      exists(MethodCallNode call, Node arg, AllTarfileOpens atfo |\n        call = atfo.getReturn().getMember(\"extractall\").getACall() and\n        arg = call.getArgByName(\"members\") and\n        if\n          arg.asCfgNode() instanceof NameConstantNode or\n          arg.asCfgNode() instanceof ListNode\n        then sink = call.getObject()\n        else\n          if arg.(MethodCallNode).getMethodName() = \"getmembers\"\n          then sink = arg.(MethodCallNode).getObject()\n          else sink = call.getArgByName(\"members\")\n      )\n      or\n      // An argument to `extract` is considered a sink.\n      exists(AllTarfileOpens atfo |\n        sink = atfo.getReturn().getMember(\"extract\").getACall().getArg(0)\n      )\n      or\n      //An argument to `_extract_member` is considered a sink.\n      exists(MethodCallNode call, AllTarfileOpens atfo |\n        call = atfo.getReturn().getMember(\"_extract_member\").getACall() and\n        call.getArg(1).(AttrRead).accesses(sink, \"name\")\n      )\n    ) and\n    not sink.getScope().getLocation().getFile().inStdlib()\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    nodeTo.(MethodCallNode).calls(nodeFrom, \"getmembers\") and\n    nodeFrom instanceof AllTarfileOpens\n    or\n    // To handle the case of `with closing(tarfile.open()) as file:`\n    // we add a step from the first argument of `closing` to the call to `closing`,\n    // whenever that first argument is a return of `tarfile.open()`.\n    nodeTo = API::moduleImport(\"contextlib\").getMember(\"closing\").getACall() and\n    nodeFrom = nodeTo.(API::CallNode).getArg(0) and\n    nodeFrom = tarfileOpen().getReturn().getAValueReachableFromSource()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule TarSlipImprovFlow = TaintTracking::Global<TarSlipImprovConfig>;\n\nfrom TarSlipImprovFlow::PathNode source, TarSlipImprovFlow::PathNode sink\nwhere TarSlipImprovFlow::flowPath(source, sink)\nselect sink, source, sink, \"Extraction of tarfile from $@ to a potentially untrusted source $@.\",\n  source.getNode(), source.getNode().toString(), sink.getNode(), sink.getNode().toString()",
        "description": "Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-022bis/TarSlipImprov.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.semmle.python.security.RemoteCommandExecution\nimport RemoteCommandExecutionFlow::PathGraph\n\nfrom RemoteCommandExecutionFlow::PathNode source, RemoteCommandExecutionFlow::PathNode sink\nwhere RemoteCommandExecutionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This code execution depends on a $@.\", source.getNode(),\n  \"a user-provided value\"",
        "description": "user provided command can lead to execute code on a external server that can be belong to other users or admins",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-074/remoteCommandExecution/RemoteCommandExecution.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.semmle.python.security.DecompressionBomb\nimport BombsFlow::PathGraph\n\nfrom BombsFlow::PathNode source, BombsFlow::PathNode sink\nwhere BombsFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This uncontrolled file extraction is $@.\", source.getNode(),\n  \"depends on this user controlled data\"",
        "description": "Uncontrolled data that flows into decompression library APIs without checking the compression rate is dangerous",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-409/DecompressionBombs.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport XsltInjectionQuery\nimport XsltInjectionFlow::PathGraph\n\nfrom XsltInjectionFlow::PathNode source, XsltInjectionFlow::PathNode sink\nwhere XsltInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This XSLT query depends on $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a XSLT query from user-controlled sources is vulnerable to insertion of malicious XSLT code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-091/XsltInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport WebAppConstantSecretKeyDjango\nimport WebAppConstantSecretKeyFlask\nimport semmle.python.filters.Tests\n\nnewtype TFrameWork =\n  Flask() or\n  Django()\n\nprivate module WebAppConstantSecretKeyConfig implements DataFlow::StateConfigSig {\n  class FlowState = TFrameWork;\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    state = Flask() and FlaskConstantSecretKeyConfig::isSource(source)\n    or\n    state = Django() and DjangoConstantSecretKeyConfig::isSource(source)\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node.getLocation().getFile().inStdlib()\n    or\n    // To reduce FP rate, the following was added\n    node.getLocation()\n        .getFile()\n        .getRelativePath()\n        .matches([\"%test%\", \"%demo%\", \"%example%\", \"%sample%\"]) and\n    // but that also meant all data-flow nodes in query tests were excluded... so we had\n    // to add this:\n    not node.getLocation().getFile().getRelativePath().matches(\"%query-tests/Security/CWE-287%\")\n  }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    state = Flask() and FlaskConstantSecretKeyConfig::isSink(sink)\n    or\n    state = Django() and DjangoConstantSecretKeyConfig::isSink(sink)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule WebAppConstantSecretKeyFlow = TaintTracking::GlobalWithState<WebAppConstantSecretKeyConfig>;\n\nimport WebAppConstantSecretKeyFlow::PathGraph\n\nfrom WebAppConstantSecretKeyFlow::PathNode source, WebAppConstantSecretKeyFlow::PathNode sink\nwhere WebAppConstantSecretKeyFlow::flowPath(source, sink)\nselect sink, source, sink, \"The SECRET_KEY config variable is assigned by $@.\", source,\n  \" this constant String\"",
        "description": "Initializing SECRET_KEY of Flask application with Constant value files can lead to Authentication bypass",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-287-ConstantSecretKey/WebAppConstantSecretKey.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\n\nclass PredictableResultSource extends DataFlow::Node {\n  PredictableResultSource() {\n    exists(API::Node uuidCallRet |\n      uuidCallRet = API::moduleImport(\"uuid\").getMember([\"uuid1\", \"uuid3\", \"uuid5\"]).getReturn()\n    |\n      this = uuidCallRet.asSource()\n      or\n      this = uuidCallRet.getMember([\"hex\", \"bytes\", \"bytes_le\"]).asSource()\n    )\n  }\n}\n\nclass TokenAssignmentValueSink extends DataFlow::Node {\n  TokenAssignmentValueSink() {\n    exists(string name | name.toLowerCase().matches([\"%token\", \"%code\"]) |\n      exists(DefinitionNode n | n.getValue() = this.asCfgNode() | name = n.(NameNode).getId())\n      or\n      exists(DataFlow::AttrWrite aw | aw.getValue() = this | name = aw.getAttributeName())\n    )\n  }\n}\n\nprivate module TokenBuiltFromUuidConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof PredictableResultSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof TokenAssignmentValueSink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) {\n    exists(DataFlow::CallCfgNode call |\n      call = API::builtin(\"str\").getACall() and\n      nodeFrom = call.getArg(0) and\n      nodeTo = call\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule TokenBuiltFromUuidFlow = TaintTracking::Global<TokenBuiltFromUuidConfig>;\n\nimport TokenBuiltFromUuidFlow::PathGraph\n\nfrom TokenBuiltFromUuidFlow::PathNode source, TokenBuiltFromUuidFlow::PathNode sink\nwhere TokenBuiltFromUuidFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Token built from $@.\", source.getNode(), \"predictable value\"",
        "description": "Tokens used for sensitive tasks, such as, password recovery, and email confirmation, should not use predictable values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-340/TokenBuiltFromUUID.ql",
        "language": "python"
    },
    {
        "query": "// determine precision above\nimport python\nimport experimental.semmle.python.Concepts\nimport experimental.semmle.python.frameworks.JWT\n\nfrom JwtEncoding jwtEncoding, string affectedComponent\nwhere\n  affectedComponent = \"algorithm\" and\n  isEmptyOrNone(jwtEncoding.getAlgorithm())\n  or\n  affectedComponent = \"key\" and\n  isEmptyOrNone(jwtEncoding.getKey())\nselect jwtEncoding, \"This JWT encoding has an empty \" + affectedComponent + \".\"",
        "description": "The application uses an empty secret or algorithm while encoding a JWT Token.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-347/JWTEmptyKeyOrAlgorithm.ql",
        "language": "python"
    },
    {
        "query": "// determine precision above\nimport python\nimport experimental.semmle.python.Concepts\n\nfrom JwtDecoding jwtDecoding\nwhere not jwtDecoding.verifiesSignature()\nselect jwtDecoding.getPayload(), \"is not verified with a cryptographic secret or public key.\"",
        "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-347/JWTMissingSecretOrPublicKeyVerification.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.RemoteFlowSources\n\n// The Unicode compatibility normalization calls from unicodedata, unidecode, pyunormalize\n// and textnorm modules. The use of argIdx is to constraint the argument being normalized.\nclass UnicodeCompatibilityNormalize extends API::CallNode {\n  int argIdx;\n\n  UnicodeCompatibilityNormalize() {\n    (\n      this = API::moduleImport(\"unicodedata\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember(\"normalize\").getACall() and\n      this.getParameter(0).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n    ) and\n    argIdx = 1\n    or\n    (\n      this = API::moduleImport(\"textnorm\").getMember(\"normalize_unicode\").getACall() and\n      this.getParameter(1).getAValueReachingSink().asExpr().(StringLiteral).getText() in [\n          \"NFKC\", \"NFKD\"\n        ]\n      or\n      this = API::moduleImport(\"unidecode\").getMember(\"unidecode\").getACall()\n      or\n      this = API::moduleImport(\"pyunormalize\").getMember([\"NFKC\", \"NFKD\"]).getACall()\n    ) and\n    argIdx = 0\n  }\n\n  DataFlow::Node getPathArg() { result = this.getArg(argIdx) }\n}\n\npredicate underAValue(DataFlow::GuardNode g, ControlFlowNode node, boolean branch) {\n  exists(CompareNode cn | cn = g |\n    exists(API::CallNode lenCall, Cmpop op, Node n |\n      lenCall = n.getALocalSource() and\n      (\n        // arg <= LIMIT OR arg < LIMIT\n        (op instanceof LtE or op instanceof Lt) and\n        branch = true and\n        cn.operands(n.asCfgNode(), op, _)\n        or\n        // LIMIT >= arg OR LIMIT > arg\n        (op instanceof GtE or op instanceof Gt) and\n        branch = true and\n        cn.operands(_, op, n.asCfgNode())\n        or\n        // not arg >= LIMIT OR not arg > LIMIT\n        (op instanceof GtE or op instanceof Gt) and\n        branch = false and\n        cn.operands(n.asCfgNode(), op, _)\n        or\n        // not LIMIT <= arg OR not LIMIT < arg\n        (op instanceof LtE or op instanceof Lt) and\n        branch = false and\n        cn.operands(_, op, n.asCfgNode())\n      )\n    |\n      lenCall = API::builtin(\"len\").getACall() and\n      node = lenCall.getArg(0).asCfgNode()\n    ) //and\n    //not cn.getLocation().getFile().inStdlib()\n  )\n}\n\nprivate module UnicodeDoSConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }\n\n  predicate isBarrier(DataFlow::Node sanitizer) {\n    // underAValue is a check to ensure that the length of the user-provided value is limited to a certain amount\n    sanitizer = DataFlow::BarrierGuard<underAValue/3>::getABarrierNode()\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    // Any call to the Unicode compatibility normalization is a costly operation\n    sink = any(UnicodeCompatibilityNormalize ucn).getPathArg()\n    or\n    // The call to secure_filename() from pallets/werkzeug uses the Unicode compatibility normalization\n    // under the hood, https://github.com/pallets/werkzeug/blob/d3dd65a27388fbd39d146caacf2563639ba622f0/src/werkzeug/utils.py#L218\n    sink = API::moduleImport(\"werkzeug\").getMember(\"secure_filename\").getACall().getArg(_)\n    or\n    sink =\n      API::moduleImport(\"werkzeug\")\n          .getMember(\"utils\")\n          .getMember(\"secure_filename\")\n          .getACall()\n          .getArg(_)\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule UnicodeDoSFlow = TaintTracking::Global<UnicodeDoSConfig>;\n\nimport UnicodeDoSFlow::PathGraph\n\nfrom UnicodeDoSFlow::PathNode source, UnicodeDoSFlow::PathNode sink\nwhere UnicodeDoSFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This $@ can reach a $@.\", source.getNode(),\n  \"user-provided value\", sink.getNode(), \"costly Unicode normalization operation\"",
        "description": "A remote user-controlled data can reach a costly Unicode normalization with either form NFKC or NFKD. On Windows OS, with an attack such as the One Million Unicode Characters, this could lead to a denial of service. And, with the use of special Unicode characters, like U+2100 (\u2100) or U+2105 (\u2105), the payload size could be tripled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-770/UnicodeDoS.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.Flow\nimport semmle.python.dataflow.new.RemoteFlowSources\n\nprivate predicate maybeInteresting(ControlFlowNode c) {\n  // Check if the name of the variable which calls the function matches the heuristic.\n  // This would typically occur at the sink.\n  // This should deal with cases like\n  // `origin.startswith(\"bla\")`\n  heuristics(c.(CallNode).getFunction().(AttrNode).getObject().(NameNode).getId())\n  or\n  // Check if the name of the variable passed as an argument to the functions matches the heuristic. This would typically occur at the sink.\n  // This should deal with cases like\n  // `bla.startswith(origin)`\n  heuristics(c.(CallNode).getArg(0).(NameNode).getId())\n  or\n  // Check if the value gets written to any interesting variable. This would typically occur at the source.\n  // This should deal with cases like\n  // `origin = request.headers.get('My-custom-header')`\n  exists(Variable v | heuristics(v.getId()) | c.getASuccessor*().getNode() = v.getAStore())\n}\n\nprivate class StringStartswithCall extends ControlFlowNode {\n  StringStartswithCall() { this.(CallNode).getFunction().(AttrNode).getName() = \"startswith\" }\n}\n\nbindingset[s]\npredicate heuristics(string s) { s.matches([\"%origin%\", \"%cors%\"]) }\n\nclass CherryPyRequest extends RemoteFlowSource::Range {\n  CherryPyRequest() {\n    this =\n      API::moduleImport(\"cherrypy\")\n          .getMember(\"request\")\n          .getMember([\n              \"charset\", \"content_type\", \"filename\", \"fp\", \"name\", \"params\", \"headers\", \"length\",\n            ])\n          .asSource()\n  }\n\n  override string getSourceType() { result = \"cherrypy.request\" }\n}\n\nmodule CorsBypassConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof RemoteFlowSource }\n\n  predicate isSink(DataFlow::Node node) {\n    exists(StringStartswithCall s |\n      node.asCfgNode() = s.(CallNode).getArg(0) or\n      node.asCfgNode() = s.(CallNode).getFunction().(AttrNode).getObject()\n    )\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(API::CallNode c, API::Node n |\n      n = API::moduleImport(\"cherrypy\").getMember(\"request\").getMember(\"headers\") and\n      c = n.getMember(\"get\").getACall()\n    |\n      c.getReturn().asSource() = node2 and n.asSource() = node1\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n\n  Location getASelectedSourceLocation(DataFlow::Node sink) { none() }\n}\n\nmodule CorsFlow = TaintTracking::Global<CorsBypassConfig>;\n\nimport CorsFlow::PathGraph\n\nfrom CorsFlow::PathNode source, CorsFlow::PathNode sink\nwhere\n  CorsFlow::flowPath(source, sink) and\n  (\n    maybeInteresting(source.getNode().asCfgNode())\n    or\n    maybeInteresting(sink.getNode().asCfgNode())\n  )\nselect sink, source, sink,\n  \"Potentially incorrect string comparison which could lead to a CORS bypass.\"",
        "description": "Checking user supplied origin headers using weak comparators like 'string.startswith' may lead to CORS policy bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-346/CorsBypass.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.ApiGraphs\nimport ClientSuppliedIpUsedInSecurityCheckLib\nimport ClientSuppliedIpUsedInSecurityCheckFlow::PathGraph\n\nprivate module ClientSuppliedIpUsedInSecurityCheckConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source instanceof ClientSuppliedIpUsedInSecurityCheck\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof PossibleSecurityCheck }\n\n  predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {\n    exists(DataFlow::CallCfgNode ccn |\n      ccn = API::moduleImport(\"netaddr\").getMember(\"IPAddress\").getACall() and\n      ccn.getArg(0) = pred and\n      ccn = succ\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    // `client_supplied_ip.split(\",\")[n]` for `n` > 0\n    exists(Subscript ss |\n      not ss.getIndex().(IntegerLiteral).getText() = \"0\" and\n      ss.getObject().(Call).getFunc().(Attribute).getName() = \"split\" and\n      ss.getObject().(Call).getAnArg().(StringLiteral).getText() = \",\" and\n      ss = node.asExpr()\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule ClientSuppliedIpUsedInSecurityCheckFlow =\n  TaintTracking::Global<ClientSuppliedIpUsedInSecurityCheckConfig>;\n\nfrom\n  ClientSuppliedIpUsedInSecurityCheckFlow::PathNode source,\n  ClientSuppliedIpUsedInSecurityCheckFlow::PathNode sink\nwhere ClientSuppliedIpUsedInSecurityCheckFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"IP address spoofing might include code from $@.\",\n  source.getNode(), \"this user input\"",
        "description": "A remote endpoint identifier is read from an HTTP header. Attackers can modify the value of the identifier to forge the client ip.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-348/ClientSuppliedIpUsedInSecurityCheck.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.semmle.python.security.InsecureRandomness\nimport semmle.python.dataflow.new.DataFlow\nimport InsecureRandomness::Flow::PathGraph\n\nfrom InsecureRandomness::Flow::PathNode source, InsecureRandomness::Flow::PathNode sink\nwhere InsecureRandomness::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Cryptographically insecure $@ in a security context.\",\n  source.getNode(), \"random value\"",
        "description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-338/InsecureRandomness.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CsvInjectionFlow::PathGraph\nimport semmle.python.dataflow.new.DataFlow\nimport experimental.semmle.python.security.injection.CsvInjection\n\nfrom CsvInjectionFlow::PathNode source, CsvInjectionFlow::PathNode sink\nwhere CsvInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Csv injection might include code from $@.\", source.getNode(),\n  \"this user input\"",
        "description": "From user-controlled data saved in CSV files, it is easy to attempt information disclosure or other malicious activities when automated by spreadsheet software",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-1236/CsvInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.semmle.python.security.ZipSlip\nimport ZipSlipFlow::PathGraph\n\nfrom ZipSlipFlow::PathNode source, ZipSlipFlow::PathNode sink\nwhere ZipSlipFlow::flowPath(source, sink)\nselect source.getNode(), source, sink,\n  \"This unsanitized archive entry, which may contain '..', is used in a $@.\", sink.getNode(),\n  \"file system operation\"",
        "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-022/ZipSlip.ql",
        "language": "python"
    },
    {
        "query": "private import python\nprivate import semmle.python.Concepts\nprivate import semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode call\nwhere\n  call = API::moduleImport(\"xmlrpc\").getMember(\"server\").getMember(\"SimpleXMLRPCServer\").getACall()\nselect call, \"SimpleXMLRPCServer is vulnerable to XML bombs.\"",
        "description": "SimpleXMLRPCServer is vulnerable to denial of service attacks from untrusted user input",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-611/SimpleXmlRpcServer.ql",
        "language": "python"
    },
    {
        "query": "// determine precision above\nimport python\nimport experimental.semmle.python.security.dataflow.EmailXss\nimport EmailXssFlow::PathGraph\n\nfrom EmailXssFlow::PathNode source, EmailXssFlow::PathNode sink\nwhere EmailXssFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Cross-site scripting vulnerability due to $@.\",\n  source.getNode(), \"a user-provided value\"",
        "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-079/EmailXss.ql",
        "language": "python"
    },
    {
        "query": "// Determine precision above\nimport python\nimport experimental.semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\n\npredicate authenticatesImproperly(LdapBind ldapBind) {\n  (\n    DataFlow::localFlow(DataFlow::exprNode(any(None noneName)), ldapBind.getPassword()) or\n    not exists(ldapBind.getPassword())\n  )\n  or\n  exists(StringLiteral emptyString |\n    emptyString.getText() = \"\" and\n    DataFlow::localFlow(DataFlow::exprNode(emptyString), ldapBind.getPassword())\n  )\n}\n\nfrom LdapBind ldapBind\nwhere authenticatesImproperly(ldapBind)\nselect ldapBind, \"The following LDAP bind operation is executed without authentication.\"",
        "description": "A user-controlled query carries no authentication",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Security/CWE-287/ImproperLdapAuth.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricPadding pad, string name\nwhere\n  name = pad.getPaddingName() and\n  not name = [\"OAEP\", \"KEM\", \"PSS\"]\nselect pad, \"Use of unapproved, weak, or unknown asymmetric padding algorithm or API: \" + name",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakAsymmetricPadding.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom CryptographicArtifact op, string msg\nwhere\n  // False positive hack, some projects are directly including all of cryptography,\n  // filter any match that is in cryptography/hazmat\n  // Specifically happening for ECB being used in keywrap operations internally to the cryptography keywrap/unwrap API\n  not op.asExpr()\n      .getLocation()\n      .getFile()\n      .getAbsolutePath()\n      .toString()\n      .matches(\"%cryptography/hazmat/%\") and\n  (\n    op instanceof BlockMode and\n    // ECB is only allowed for KeyWrapOperations, i.e., only alert on ECB is not a KeyWrapOperation\n    (op.(BlockMode).getBlockModeName() = \"ECB\" implies not op instanceof KeyWrapOperation) and\n    exists(string name | name = op.(BlockMode).getBlockModeName() |\n      // Only CBC, CTS, XTS modes are allowed.\n      //  https://liquid.microsoft.com/Web/Object/Read/MS.Security/Requirements/Microsoft.Security.Cryptography.10002\n      not name = [\"CBC\", \"CTS\", \"XTS\"] and\n      if name = unknownAlgorithm()\n      then msg = \"Use of unrecognized block mode algorithm.\"\n      else\n        if name in [\"GCM\", \"CCM\"]\n        then\n          msg =\n            \"Use of block mode algorithm \" + name +\n              \" requires special crypto board approval/review.\"\n        else msg = \"Use of unapproved block mode algorithm or API \" + name + \".\"\n    )\n    or\n    op instanceof SymmetricCipher and\n    not op.(SymmetricCipher).hasBlockMode() and\n    msg = \"Cipher has unspecified block mode algorithm.\"\n  )\nselect op, msg",
        "description": "Finds uses of symmetric encryption block modes that are weak, obsolete, or otherwise unaccepted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakBlockMode.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\nfrom KeyDerivationOperation op, string msg, DataFlow::Node derivedKeySizeSrc\nwhere\n  // NOTE/ASSUMPTION: if the key size is not specified or explicitly None, it is common that the size is derived from the hash used.\n  //       The only acceptable hashes are currently \"SHA256\", \"SHA384\", \"SHA512\", which are all large enough.\n  //       We will currently rely on other acceptable hash queries therefore to determine if the size is\n  //       is sufficient where the key is not specified.\n  derivedKeySizeSrc = op.getDerivedKeySizeSrc() and\n  not derivedKeySizeSrc.asExpr() instanceof None and\n  (\n    exists(derivedKeySizeSrc.asExpr().(IntegerLiteral).getValue()) and\n    derivedKeySizeSrc.asExpr().(IntegerLiteral).getValue() < 16 and\n    msg = \"Derived key size is too small. \"\n    or\n    not exists(derivedKeySizeSrc.asExpr().(IntegerLiteral).getValue()) and\n    msg = \"Derived key size is not a statically verifiable size. \"\n  )\nselect op, msg + \"Derived key size must be a minimum of 16 (bytes). Derived Key Size Config: $@\",\n  derivedKeySizeSrc.asExpr(), derivedKeySizeSrc.asExpr().toString()",
        "description": "KDF derived keys should be a minimum of 128 bits (16 bytes).",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakKDFKeyLength.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm op, string msg, string name\nwhere\n  (\n    name = op.getCurveName() and\n    name = unknownAlgorithm() and\n    msg = \"Use of unrecognized curve algorithm.\"\n    or\n    name != unknownAlgorithm() and\n    name = op.getCurveName() and\n    not name =\n      [\n        \"SECP256R1\", \"PRIME256V1\", //P-256\n        \"SECP384R1\", //P-384\n        \"SECP521R1\", //P-521\n        \"ED25519\", \"X25519\"\n      ] and\n    msg = \"Use of weak curve algorithm \" + name + \".\"\n  )\nselect op, msg",
        "description": "Finds uses of cryptography algorithms that are unapproved or otherwise weak.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakEllipticCurve.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\nfrom KeyDerivationOperation op, DataFlow::Node saltSrc\nwhere\n  op.requiresSalt() and\n  not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = saltSrc and\n  saltSrc = op.getSaltConfigSrc()\nselect op, \"Salt configuration is not from an accepted random source: $@. Must be os.urandom\",\n  saltSrc, saltSrc.toString()",
        "description": "KDF salts must be generated by an approved random number generator (os.urandom)",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakKDFSaltGen.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\nfrom KeyDerivationOperation op, DataFlow::Node modeConfSrc\nwhere\n  op.requiresMode() and\n  modeConfSrc = op.getModeSrc() and\n  not modeConfSrc =\n    API::moduleImport(\"cryptography\")\n        .getMember(\"hazmat\")\n        .getMember(\"primitives\")\n        .getMember(\"kdf\")\n        .getMember(\"kbkdf\")\n        .getMember(\"Mode\")\n        .getMember(\"CounterMode\")\n        .asSource()\nselect op, \"Key derivation mode is not set to CounterMode. Mode Config: $@\", modeConfSrc,\n  modeConfSrc.toString()",
        "description": "KDF mode, if specified, must be CounterMode",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakKDFMode.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricKeyGen op, DataFlow::Node configSrc, string algName\nwhere\n  not op.hasKeySize(configSrc) and\n  configSrc = op.getKeyConfigSrc() and\n  algName = op.getAlgorithm().getName()\nselect op,\n  \"Non-statically verifiable key size used for key generation for algorithm \" + algName.toString() +\n    \" at config source $@\", configSrc, configSrc.toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/UnknownAsymmetricKeyGen.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\nfrom KeyDerivationOperation op, DataFlow::Node randConfSrc, API::CallNode call, string msg\nwhere\n  op.requiresSalt() and\n  API::moduleImport(\"os\").getMember(\"urandom\").getACall() = call and\n  call = op.getSaltConfigSrc() and\n  randConfSrc = Utils::getUltimateSrcFromApiNode(call.getParameter(0, \"size\")) and\n  (\n    not exists(randConfSrc.asExpr().(IntegerLiteral).getValue()) and\n    msg = \"Salt config is not a statically verifiable size. \"\n    or\n    randConfSrc.asExpr().(IntegerLiteral).getValue() < 16 and\n    msg = \"Salt config is insufficiently large. \"\n  )\nselect op,\n  msg + \"Salt size must be a minimum of 16 (bytes). os.urandom Config: $@, Size Config: $@\", call,\n  call.toString(), randConfSrc, randConfSrc.toString()",
        "description": "KDF salts should be a minimum of 128 bits (16 bytes). This alerts if a constant traces to to a salt length sink less than 128-bits or if the value that traces to a salt length sink is not known statically.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakKDFSaltSize.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom BlockMode op, string msg, DataFlow::Node conf\nwhere\n  not op instanceof CryptographyModule::Encryption::SymmetricEncryption::Fernet::CryptographyFernet and\n  (\n    not op.hasIVorNonce() or\n    not API::moduleImport(\"os\").getMember(\"urandom\").getACall() = op.getIVorNonce()\n  ) and\n  (\n    if not op.hasIVorNonce()\n    then conf = op and msg = \"Block mode is missing IV/Nonce initialization.\"\n    else conf = op.getIVorNonce()\n  ) and\n  msg = \"Block mode is not using an accepted IV/Nonce initialization: $@\"\nselect op, msg, conf, conf.toString()",
        "description": "Finds initialization vectors or nonces used by block modes that are weak, obsolete, or otherwise unaccepted. Looks for IVs or nonces that are not generated by a cryptographically secure random number generator NOTE: for simplicity, if an IV or nonce is not known or not form os.urandom it is flagged. More specific considerations, such as correct use of nonces are currently not handled. In particular, GCM requires the use of a nonce. Using urandom is possible but may still be configured incorrectly. We currently assume that GCM is flagged as a block mode regardless through a separate query, and such uses will need to be reivewed by the crypto board. Additionally, some functions, which infer a mode and IV may be flagged by this query. For now, we will rely on users suppressing these cases rather than filtering them out. The exception is Fernet, which is explicitly ignored since it's implementation uses os.urandom.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakBlockModeIVorNonce.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom HashAlgorithm op, string name, string msg\nwhere\n  name = op.getHashName() and\n  not name = [\"SHA256\", \"SHA384\", \"SHA512\"] and\n  if name = unknownAlgorithm()\n  then msg = \"Use of unrecognized hash algorithm.\"\n  else msg = \"Use of unapproved hash algorithm or API \" + name + \".\"\nselect op, msg",
        "description": "Finds uses of cryptography algorithms that are unapproved or otherwise weak.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakHashes.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricKeyGen op, DataFlow::Node configSrc, int keySize, string algName\nwhere\n  keySize = op.getKeySizeInBits(configSrc) and\n  keySize < 2048 and\n  algName = op.getAlgorithm().getName() and\n  // Can't be an elliptic curve\n  not isEllipticCurveAlgorithm(algName, _)\nselect op,\n  \"Use of weak asymmetric key size (int bits)\" + keySize.toString() + \" for algorithm \" +\n    algName.toString() + \" at config source $@\", configSrc, configSrc.toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakAsymmetricKeyGen.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm op, string name, string msg\nwhere\n  name = op.getEncryptionName() and\n  not name = [\"AES\", \"AES128\", \"AES192\", \"AES256\"] and\n  if name = unknownAlgorithm()\n  then msg = \"Use of unrecognized symmetric encryption algorithm.\"\n  else msg = \"Use of unapproved symmetric encryption algorithm or API \" + name + \".\"\nselect op, msg",
        "description": "Finds uses of symmetric cryptography algorithms that are weak, obsolete, or otherwise unaccepted. The key lengths allowed are 128, 192, and 256 bits. These are all the key lengths supported by AES, so any application of AES is considered acceptable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakSymmetricEncryption.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom KeyDerivationAlgorithm op\nwhere\n  not op.getKDFName() =\n    [\n      \"PBKDF2\", \"PBKDF2HMAC\", \"KBKDF\", \"KBKDFHMAC\", \"KBKDFCMAC\", \"CONCATKDF\", \"CONCATKDFHASH\",\n      \"CONCATKDFHMAC\"\n    ]\nselect op, \"Use of unapproved, weak, or unknown key derivation algorithm or API.\"",
        "description": "Approved KDF algorithms must one of the following [\"PBKDF2\" , \"PBKDF2HMAC\", \"KBKDF\", \"KBKDFHMAC\", \"CONCATKDF\", \"CONCATKDFHASH\"]",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakKDFAlgorithm.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\nprivate import experimental.cryptography.utils.Utils as Utils\n\nfrom KeyDerivationOperation op, string msg, DataFlow::Node iterConfSrc\nwhere\n  op.requiresIteration() and\n  iterConfSrc = op.getIterationSizeSrc() and\n  (\n    exists(iterConfSrc.asExpr().(IntegerLiteral).getValue()) and\n    iterConfSrc.asExpr().(IntegerLiteral).getValue() < 10000 and\n    msg = \"Iteration count is too low. \"\n    or\n    not exists(iterConfSrc.asExpr().(IntegerLiteral).getValue()) and\n    msg = \"Iteration count is not a statically verifiable size. \"\n  )\nselect op, msg + \"Iteration count must be a minimum of 10000. Iteration Config: $@\",\n  iterConfSrc.asExpr(), iterConfSrc.asExpr().toString()",
        "description": "When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k). This query will alert if the iteration count is less than 10000 (i.e., a constant <100000 is observed) or if the source for the iteration count is not known statically.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/example_alerts/WeakKDFIteration.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricEncryptionAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getEncryptionName()",
        "description": "Finds all potential usage of asymmeric keys for encryption or key exchange using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/AsymmetricEncryptionAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom BlockMode alg\nwhere not alg.hasIVorNonce()\nselect alg, \"Block mode with unknown IV or Nonce configuration\"",
        "description": "Finds all potentially unknown sources for initialization vectors (IV) or nonce used in block ciphers while using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/BlockModeUnknownIVsOrNonces.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricPadding alg\nselect alg, \"Use of algorithm \" + alg.getPaddingName()",
        "description": "Finds all potential usage of padding schemes used with symmeric algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/SymmetricPaddingAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricPadding alg\nselect alg, \"Use of algorithm \" + alg.getPaddingName()",
        "description": "Finds all potential usage of padding schemes used with asymmeric algorithms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/AsymmetricPaddingAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom BlockMode alg\nselect alg.getIVorNonce().asExpr(), \"Block mode IV/Nonce source\"",
        "description": "Finds all potential sources for initialization vectors (IV) or nonce used in block ciphers while using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/BlockModeKnownIVsOrNonces.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricKeyGen op, DataFlow::Node confSrc\nwhere op.getKeyConfigSrc() = confSrc\nselect op,\n  \"Asymmetric key generation for algorithm \" + op.getAlgorithm().getName() +\n    \" with key config source $@\", confSrc, confSrc.toString()",
        "description": "Finds all known potential sources for asymmetric key generation while using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/AsymmetricKeyGenOperation.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom SigningAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of signing algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/SigningAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom KeyExchangeAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of key exchange using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/KeyExchangeAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom EllipticCurveAlgorithm alg\nselect alg,\n  \"Use of algorithm \" + alg.getCurveName() + \" with key size (in bits) \" +\n    alg.getCurveBitSize().toString()",
        "description": "Finds all potential usage of elliptic curve algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/EllipticCurveAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom SymmetricEncryptionAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getEncryptionName()",
        "description": "Finds all potential usage of symmetric encryption algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/SymmetricEncryptionAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AsymmetricAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of asymmeric keys (RSA & ECC) using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/AllAsymmetricAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom BlockMode alg\nselect alg, \"Use of algorithm \" + alg.getBlockModeName()",
        "description": "Finds all potential block cipher modes of operations using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/BlockModeAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom CryptographicAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of cryptographic algorithms usage using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/AllCryptoAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom AuthenticatedEncryptionAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getAuthticatedEncryptionName()",
        "description": "Finds all potential usage of authenticated encryption schemes using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/AuthenticatedEncryptionAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom HashAlgorithm alg\nselect alg, \"Use of algorithm \" + alg.getName()",
        "description": "Finds all potential usage of cryptographic hash algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/HashingAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport experimental.cryptography.Concepts\n\nfrom KeyDerivationOperation op\n// TODO: pull out all configuration from the operation?\nselect op,\n  \"Use of key derivation algorithm \" + op.getAlgorithm().(KeyDerivationAlgorithm).getKDFName()",
        "description": "Finds all potential usage of key derivation using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/new_models/KeyDerivationAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Concepts\n\nfrom Cryptography::CryptographicOperation operation, string algName\nwhere algName = operation.getBlockMode()\nselect operation, \"Use of algorithm \" + algName",
        "description": "Finds all potential block cipher modes of operations using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/old_models/BlockModeAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Concepts\n\nfrom Cryptography::CryptographicOperation operation, string algName\nwhere\n  algName = operation.getAlgorithm().getName()\n  or\n  algName = operation.getBlockMode()\nselect operation, \"Use of algorithm \" + algName",
        "description": "Finds all potential usage of cryptographic algorithms usage using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/old_models/AllCryptoAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Concepts\n\nfrom Cryptography::CryptographicOperation operation, Cryptography::CryptographicAlgorithm algorithm\nwhere\n  algorithm = operation.getAlgorithm() and\n  (\n    algorithm instanceof Cryptography::HashingAlgorithm or\n    algorithm instanceof Cryptography::PasswordHashingAlgorithm\n  )\nselect operation, \"Use of algorithm \" + operation.getAlgorithm().getName()",
        "description": "Finds all potential usage of cryptographic hash algorithms using the supported libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/cryptography/inventory/old_models/HashingAlgorithms.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate lower_case_class(Class c) {\n  exists(string first_char |\n    first_char = c.getName().prefix(1) and\n    not first_char = first_char.toUpperCase()\n  )\n}\n\nfrom Class c\nwhere\n  c.inSource() and\n  lower_case_class(c) and\n  not exists(Class c1 |\n    c1 != c and\n    c1.getLocation().getFile() = c.getLocation().getFile() and\n    lower_case_class(c1)\n  )\nselect c, \"Class names should start in uppercase.\"",
        "description": "A class name that begins with a lowercase letter decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Classes/NamingConventionsClasses.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate upper_case_function(Function func) {\n  exists(string first_char |\n    first_char = func.getName().prefix(1) and\n    not first_char = first_char.toLowerCase()\n  )\n}\n\nfrom Function func\nwhere\n  func.inSource() and\n  upper_case_function(func) and\n  not exists(Function func1 |\n    func1 != func and\n    func1.getLocation().getFile() = func.getLocation().getFile() and\n    upper_case_function(func1)\n  )\nselect func, \"Function names should start in lowercase.\"",
        "description": "A function name that begins with an uppercase letter decreases readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/experimental/Functions/NamingConventionsFunctions.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate is_old_octal(IntegerLiteral i) {\n  exists(string text | text = i.getText() |\n    text.charAt(0) = \"0\" and\n    not text = \"00\" and\n    exists(text.charAt(1).toInt()) and\n    /* Do not flag file permission masks */\n    exists(int len | len = text.length() |\n      len != 4 and\n      len != 5 and\n      len != 7\n    )\n  )\n}\n\nfrom IntegerLiteral i\nwhere is_old_octal(i)\nselect i, \"Confusing octal literal, use 0o\" + i.getText().suffix(1) + \" instead.\"",
        "description": "Octal literal with a leading 0 is easily misread as a decimal value",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Lexical/OldOctalLiteral.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Lexical.CommentedOutCode\n\nfrom CommentedOutCodeBlock c\nwhere not c.maybeExampleCode()\nselect c, \"This comment appears to contain commented-out code.\"",
        "description": "Commented-out code makes the remaining code more difficult to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Lexical/CommentedOutCode.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Lexical.CommentedOutCode\n\nfrom File f, int n\nwhere n = count(CommentedOutCodeLine c | not c.maybeExampleCode() and c.getLocation().getFile() = f)\nselect f, n order by n desc",
        "description": "The number of lines of commented out code per file",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Lexical/FCommentedOutCode.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Comment c\nwhere c.getText().matches(\"%TODO%\") or c.getText().matches(\"%TO DO%\")\nselect c, c.getText()",
        "description": "Writing comments that include 'TODO' tends to lead to a build up of partially implemented features.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Lexical/ToDoComment.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Class cls, string reason\nwhere exists(ClassObject c | c.getPyClass() = cls | c.failedInference(reason))\nselect cls, \"Inference of class hierarchy failed for class '\" + cls.getName() + \"': \" + reason + \".\"",
        "description": "Inability to infer the inheritance hierarchy for a class will impair analysis.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/TypeHierarchyFailure.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport analysis.DefinitionTracking\n\npredicate want_to_have_definition(Expr e) {\n  /* not builtin object like len, tuple, etc. */\n  not exists(Value builtin | e.pointsTo(builtin) and builtin.isBuiltin()) and\n  (\n    e instanceof Name and e.(Name).getCtx() instanceof Load\n    or\n    e instanceof Attribute and e.(Attribute).getCtx() instanceof Load\n    or\n    e instanceof ImportMember\n    or\n    e instanceof ImportExpr\n  )\n}\n\nfrom int yes, int no\nwhere\n  yes = count(Expr e | want_to_have_definition(e) and exists(getUniqueDefinition(e))) and\n  no = count(Expr e | want_to_have_definition(e) and not exists(getUniqueDefinition(e)))\nselect yes, no, yes * 100 / (yes + no) + \"%\"",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/RatioOfDefinitions.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\n\nfrom ClassValue cls, string reason\nwhere Types::failedInference(cls, reason)\nselect cls, reason",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/FailedInference.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\nint depth(ControlFlowNode f, Object value, ClassObject cls) {\n  exists(PointsToContext ctx |\n    PointsTo::points_to(f, ctx, value, cls, _) and\n    result = ctx.getDepth()\n  )\n}\n\nint shallowest(ControlFlowNode f, Object value, ClassObject cls) {\n  result = min(int x | x = depth(f, value, cls))\n}\n\nfrom int total_facts, int total_size, int depth, float efficiency\nwhere\n  total_facts =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls | depth = shallowest(f, value, cls)) and\n  total_size =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls, PointsToContext ctx,\n      ControlFlowNode orig |\n      PointsTo::points_to(f, ctx, value, cls, orig) and\n      depth = ctx.getDepth()\n    ) and\n  efficiency = 100.0 * total_facts / total_size\nselect depth, total_facts, total_size, efficiency",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/ContextMarginalEfficiency.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\n\nfrom int size\nwhere size = count(ControlFlowNode f | not PointsToInternal::reachableBlock(f.getBasicBlock(), _))\nselect size",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/Pruned.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\nfrom int total_facts, int total_size, int depth, float efficiency\nwhere\n  total_facts =\n    strictcount(ControlFlowNode call, CallableValue func |\n      exists(PointsToContext ctx |\n        call = func.getACall(ctx) and\n        depth = ctx.getDepth() and\n        not exists(PointsToContext shallower |\n          call = func.getACall(shallower) and\n          shallower.getDepth() < depth\n        )\n      )\n    ) and\n  total_size =\n    strictcount(ControlFlowNode call, CallableValue func, PointsToContext ctx |\n      call = func.getACall(ctx) and\n      depth = ctx.getDepth()\n    ) and\n  efficiency = 100.0 * total_facts / total_size\nselect depth, total_facts, total_size, efficiency",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/CallGraphMarginalEfficiency.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom string key, string value\nwhere\n  key = \"Extractor version\" and py_flags_versioned(\"extractor.version\", value, _)\n  or\n  key = \"Snapshot build time\" and\n  exists(date d | snapshotDate(d) and value = d.toString())\n  or\n  key = \"Interpreter version\" and\n  exists(string major, string minor |\n    py_flags_versioned(\"extractor_python_version.major\", major, _) and\n    py_flags_versioned(\"extractor_python_version.minor\", minor, _) and\n    value = major + \".\" + minor\n  )\n  or\n  key = \"Build platform\" and\n  exists(string raw | py_flags_versioned(\"sys.platform\", raw, _) |\n    if raw = \"win32\"\n    then value = \"Windows\"\n    else\n      if raw = \"linux2\"\n      then value = \"Linux\"\n      else\n        if raw = \"darwin\"\n        then value = \"OSX\"\n        else value = raw\n  )\n  or\n  key = \"Source location\" and sourceLocationPrefix(value)\n  or\n  key = \"Lines of code (source)\" and\n  value =\n    sum(ModuleMetrics m | exists(m.getFile().getRelativePath()) | m.getNumberOfLinesOfCode())\n        .toString()\n  or\n  key = \"Lines of code (total)\" and\n  value = sum(ModuleMetrics m | any() | m.getNumberOfLinesOfCode()).toString()\nselect key, value",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/Summary.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\n\npredicate points_to_failure(Expr e) {\n  exists(ControlFlowNode f | f = e.getAFlowNode() | not PointsTo::pointsTo(f, _, _, _))\n}\n\npredicate key_points_to_failure(Expr e) {\n  points_to_failure(e) and\n  not points_to_failure(e.getASubExpression()) and\n  not exists(SsaVariable ssa | ssa.getAUse() = e.getAFlowNode() |\n    points_to_failure(ssa.getAnUltimateDefinition().getDefinition().getNode())\n  ) and\n  not exists(Assign a | a.getATarget() = e)\n}\n\nfrom Attribute e\nwhere key_points_to_failure(e) and not exists(Call c | c.getFunc() = e)\nselect e, \"Expression does not 'point-to' any object, but all its sources do.\"",
        "description": "Expression does not \"point-to\" an object which prevents further points-to analysis.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/KeyPointsToFailure.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ControlFlowNode f, Object o\nwhere\n  f.refersTo(o) and\n  not f.refersTo(o, _, _)\nselect o, \"Type inference fails for 'object'.\"",
        "description": "Type inference fails for 'object' which reduces recall for many queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/TypeInferenceFailure.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Expr e\nwhere exists(ControlFlowNode f | f = e.getAFlowNode() | not f.refersTo(_))\nselect e, \"Expression does not 'point-to' any object.\"",
        "description": "Expression does not \"point-to\" an object which prevents type inference.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/PointsToFailure.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport analysis.DefinitionTracking\n\npredicate uniqueness_error(int number, string what, string problem) {\n  what in [\n      \"toString\", \"getLocation\", \"getNode\", \"getDefinition\", \"getEntryNode\", \"getOrigin\",\n      \"getAnInferredType\"\n    ] and\n  (\n    number = 0 and problem = \"no results for \" + what + \"()\"\n    or\n    number in [2 .. 10] and problem = number.toString() + \" results for \" + what + \"()\"\n  )\n}\n\npredicate ast_consistency(string clsname, string problem, string what) {\n  exists(AstNode a | clsname = a.getAQlClass() |\n    uniqueness_error(count(a.toString()), \"toString\", problem) and\n    what = \"at \" + a.getLocation().toString()\n    or\n    uniqueness_error(strictcount(a.getLocation()), \"getLocation\", problem) and\n    what = a.getLocation().toString()\n    or\n    not exists(a.getLocation()) and\n    not a.(Module).isPackage() and\n    problem = \"no location\" and\n    what = a.toString()\n  )\n}\n\npredicate location_consistency(string clsname, string problem, string what) {\n  exists(Location l | clsname = l.getAQlClass() |\n    uniqueness_error(count(l.toString()), \"toString\", problem) and what = \"at \" + l.toString()\n    or\n    not exists(l.toString()) and\n    problem = \"no toString\" and\n    (\n      exists(AstNode thing | thing.getLocation() = l |\n        what = \"a location of a \" + thing.getAQlClass()\n      )\n      or\n      not exists(AstNode thing | thing.getLocation() = l) and\n      what = \"a location\"\n    )\n    or\n    l.getEndLine() < l.getStartLine() and\n    problem = \"end line before start line\" and\n    what = \"at \" + l.toString()\n    or\n    l.getEndLine() = l.getStartLine() and\n    l.getEndColumn() < l.getStartColumn() and\n    problem = \"end column before start column\" and\n    what = \"at \" + l.toString()\n  )\n}\n\npredicate cfg_consistency(string clsname, string problem, string what) {\n  exists(ControlFlowNode f | clsname = f.getAQlClass() |\n    uniqueness_error(count(f.getNode()), \"getNode\", problem) and\n    what = \"at \" + f.getLocation().toString()\n    or\n    not exists(f.getLocation()) and\n    not exists(Module p | p.isPackage() | p.getEntryNode() = f or p.getAnExitNode() = f) and\n    problem = \"no location\" and\n    what = f.toString()\n    or\n    uniqueness_error(count(f.(AttrNode).getObject()), \"getValue\", problem) and\n    what = \"at \" + f.getLocation().toString()\n  )\n}\n\npredicate scope_consistency(string clsname, string problem, string what) {\n  exists(Scope s | clsname = s.getAQlClass() |\n    uniqueness_error(count(s.getEntryNode()), \"getEntryNode\", problem) and\n    what = \"at \" + s.getLocation().toString()\n    or\n    uniqueness_error(count(s.toString()), \"toString\", problem) and\n    what = \"at \" + s.getLocation().toString()\n    or\n    uniqueness_error(strictcount(s.getLocation()), \"getLocation\", problem) and\n    what = \"at \" + s.getLocation().toString()\n    or\n    not exists(s.getLocation()) and\n    problem = \"no location\" and\n    what = s.toString() and\n    not s.(Module).isPackage()\n  )\n}\n\nstring best_description_builtin_object(Object o) {\n  o.isBuiltin() and\n  (\n    result = o.toString()\n    or\n    not exists(o.toString()) and py_cobjectnames(o, result)\n    or\n    not exists(o.toString()) and\n    not py_cobjectnames(o, _) and\n    result = \"builtin object of type \" + o.getAnInferredType().toString()\n    or\n    not exists(o.toString()) and\n    not py_cobjectnames(o, _) and\n    not exists(o.getAnInferredType().toString()) and\n    result = \"builtin object\"\n  )\n}\n\nprivate predicate introspected_builtin_object(Object o) {\n  /*\n   * Only check objects from the extractor, missing data for objects generated from C source code analysis is OK.\n   * as it will be ignored if it doesn't match up with the introspected form.\n   */\n\n  py_cobject_sources(o, 0)\n}\n\npredicate builtin_object_consistency(string clsname, string problem, string what) {\n  exists(Object o |\n    clsname = o.getAQlClass() and\n    what = best_description_builtin_object(o) and\n    introspected_builtin_object(o)\n  |\n    not exists(o.getAnInferredType()) and\n    not py_cobjectnames(o, _) and\n    problem = \"neither name nor type\"\n    or\n    uniqueness_error(count(string name | py_cobjectnames(o, name)), \"name\", problem)\n    or\n    not exists(o.getAnInferredType()) and problem = \"no results for getAnInferredType\"\n    or\n    not exists(o.toString()) and\n    problem = \"no toString\" and\n    not exists(string name | name.matches(\"\\\\_semmle%\") | py_special_objects(o, name)) and\n    not o = unknownValue()\n  )\n}\n\npredicate source_object_consistency(string clsname, string problem, string what) {\n  exists(Object o | clsname = o.getAQlClass() and not o.isBuiltin() |\n    uniqueness_error(count(o.getOrigin()), \"getOrigin\", problem) and\n    what = \"at \" + o.getOrigin().getLocation().toString()\n    or\n    not exists(o.getOrigin().getLocation()) and problem = \"no location\" and what = \"??\"\n    or\n    not exists(o.toString()) and\n    problem = \"no toString\" and\n    what = \"at \" + o.getOrigin().getLocation().toString()\n    or\n    strictcount(o.toString()) > 1 and problem = \"multiple toStrings()\" and what = o.toString()\n  )\n}\n\npredicate ssa_consistency(string clsname, string problem, string what) {\n  /* Zero or one definitions of each SSA variable */\n  exists(SsaVariable var | clsname = var.getAQlClass() |\n    uniqueness_error(strictcount(var.getDefinition()), \"getDefinition\", problem) and\n    what = var.getId()\n  )\n  or\n  /* Dominance criterion: Definition *must* dominate *all* uses. */\n  exists(SsaVariable var, ControlFlowNode defn, ControlFlowNode use |\n    defn = var.getDefinition() and use = var.getAUse()\n  |\n    not defn.strictlyDominates(use) and\n    not defn = use and\n    /* Phi nodes which share a flow node with a use come *before* the use */\n    not (exists(var.getAPhiInput()) and defn = use) and\n    clsname = var.getAQlClass() and\n    problem = \"a definition which does not dominate a use at \" + use.getLocation() and\n    what = var.getId() + \" at \" + var.getLocation()\n  )\n  or\n  /* Minimality of phi nodes */\n  exists(SsaVariable var |\n    strictcount(var.getAPhiInput()) = 1 and\n    var.getAPhiInput()\n        .getDefinition()\n        .getBasicBlock()\n        .strictlyDominates(var.getDefinition().getBasicBlock())\n  |\n    clsname = var.getAQlClass() and\n    problem = \" a definition which is dominated by the definition of an incoming phi edge.\" and\n    what = var.getId() + \" at \" + var.getLocation()\n  )\n}\n\npredicate function_object_consistency(string clsname, string problem, string what) {\n  exists(FunctionObject func | clsname = func.getAQlClass() |\n    what = func.getName() and\n    (\n      not exists(func.descriptiveString()) and problem = \"no descriptiveString()\"\n      or\n      exists(int c | c = strictcount(func.descriptiveString()) and c > 1 |\n        problem = c + \"descriptiveString()s\"\n      )\n    )\n    or\n    not exists(func.getName()) and what = \"?\" and problem = \"no name\"\n  )\n}\n\npredicate multiple_origins_per_object(Object obj) {\n  not obj.isC() and\n  not obj instanceof ModuleObject and\n  exists(ControlFlowNode use, Context ctx |\n    strictcount(ControlFlowNode orig | use.refersTo(ctx, obj, _, orig)) > 1\n  )\n}\n\npredicate intermediate_origins(ControlFlowNode use, ControlFlowNode inter, Object obj) {\n  exists(ControlFlowNode orig, Context ctx | not inter = orig |\n    use.refersTo(ctx, obj, _, inter) and\n    inter.refersTo(ctx, obj, _, orig) and\n    // It can sometimes happen that two different modules (e.g. cPickle and Pickle)\n    // have the same attribute, but different origins.\n    not strictcount(Object val | inter.(AttrNode).getObject().refersTo(val)) > 1\n  )\n}\n\npredicate points_to_consistency(string clsname, string problem, string what) {\n  exists(Object obj |\n    multiple_origins_per_object(obj) and\n    clsname = obj.getAQlClass() and\n    problem = \"multiple origins for an object\" and\n    what = obj.toString()\n  )\n  or\n  exists(ControlFlowNode use, ControlFlowNode inter |\n    intermediate_origins(use, inter, _) and\n    clsname = use.getAQlClass() and\n    problem = \"has intermediate origin \" + inter and\n    what = use.toString()\n  )\n}\n\npredicate jump_to_definition_consistency(string clsname, string problem, string what) {\n  problem = \"multiple (jump-to) definitions\" and\n  exists(Expr use |\n    strictcount(getUniqueDefinition(use)) > 1 and\n    clsname = use.getAQlClass() and\n    what = use.toString()\n  )\n}\n\npredicate file_consistency(string clsname, string problem, string what) {\n  exists(File file, Folder folder |\n    clsname = file.getAQlClass() and\n    problem = \"has same name as a folder\" and\n    what = file.getAbsolutePath() and\n    what = folder.getAbsolutePath()\n  )\n  or\n  exists(Container f |\n    clsname = f.getAQlClass() and\n    uniqueness_error(count(f.toString()), \"toString\", problem) and\n    what = \"file \" + f.getAbsolutePath()\n  )\n}\n\npredicate class_value_consistency(string clsname, string problem, string what) {\n  exists(ClassValue value, ClassValue sup, string attr |\n    what = value.getName() and\n    sup = value.getASuperType() and\n    exists(sup.lookup(attr)) and\n    not value.failedInference(_) and\n    not exists(value.lookup(attr)) and\n    clsname = value.getAQlClass() and\n    problem = \"no attribute '\" + attr + \"', but super type '\" + sup.getName() + \"' does.\"\n  )\n}\n\nfrom string clsname, string problem, string what\nwhere\n  ast_consistency(clsname, problem, what) or\n  location_consistency(clsname, problem, what) or\n  scope_consistency(clsname, problem, what) or\n  cfg_consistency(clsname, problem, what) or\n  ssa_consistency(clsname, problem, what) or\n  builtin_object_consistency(clsname, problem, what) or\n  source_object_consistency(clsname, problem, what) or\n  function_object_consistency(clsname, problem, what) or\n  points_to_consistency(clsname, problem, what) or\n  jump_to_definition_consistency(clsname, problem, what) or\n  file_consistency(clsname, problem, what) or\n  class_value_consistency(clsname, problem, what)\nselect clsname + \" \" + what + \" has \" + problem",
        "description": "General consistency check to be run on any and all code. Should never produce any results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/Consistency.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nImportExpr alternative_import(ImportExpr ie) {\n  exists(Alias thisalias, Alias otheralias |\n    (thisalias.getValue() = ie or thisalias.getValue().(ImportMember).getModule() = ie) and\n    (otheralias.getValue() = result or otheralias.getValue().(ImportMember).getModule() = result) and\n    (\n      exists(If i | i.getBody().contains(ie) and i.getOrelse().contains(result))\n      or\n      exists(If i | i.getBody().contains(result) and i.getOrelse().contains(ie))\n      or\n      exists(Try t | t.getBody().contains(ie) and t.getAHandler().contains(result))\n      or\n      exists(Try t | t.getBody().contains(result) and t.getAHandler().contains(ie))\n    )\n  )\n}\n\nstring os_specific_import(ImportExpr ie) {\n  exists(string name | name = ie.getImportedModuleName() |\n    name.matches(\"org.python.%\") and result = \"java\"\n    or\n    name.matches(\"java.%\") and result = \"java\"\n    or\n    name.matches(\"Carbon.%\") and result = \"darwin\"\n    or\n    result = \"win32\" and\n    (\n      name = \"_winapi\" or\n      name = \"_win32api\" or\n      name = \"_winreg\" or\n      name = \"nt\" or\n      name.matches(\"win32%\") or\n      name = \"ntpath\"\n    )\n    or\n    result = \"linux2\" and\n    (name = \"posix\" or name = \"posixpath\")\n    or\n    result = \"unsupported\" and\n    (name = \"__pypy__\" or name = \"ce\" or name.matches(\"riscos%\"))\n  )\n}\n\nstring get_os() { py_flags_versioned(\"sys.platform\", result, major_version().toString()) }\n\npredicate ok_to_fail(ImportExpr ie) {\n  alternative_import(ie).refersTo(_)\n  or\n  os_specific_import(ie) != get_os()\n}\n\nclass VersionTest extends ControlFlowNode {\n  VersionTest() {\n    exists(string name |\n      name.matches(\"%version%\") and\n      this.(CompareNode).getAChild+().pointsTo(Module::named(\"sys\").attr(name))\n    )\n  }\n\n  override string toString() { result = \"VersionTest\" }\n}\n\nclass VersionGuard extends ConditionBlock {\n  VersionGuard() { this.getLastNode() instanceof VersionTest }\n}\n\nfrom ImportExpr ie\nwhere\n  not ie.refersTo(_) and\n  exists(Context c | c.appliesTo(ie.getAFlowNode())) and\n  not ok_to_fail(ie) and\n  not exists(VersionGuard guard | guard.controls(ie.getAFlowNode().getBasicBlock(), _))\nselect ie, \"Unable to resolve import of '\" + ie.getImportedModuleName() + \"'.\"",
        "description": "An unresolved import may result in reduced coverage and accuracy of analysis.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/ImportFailure.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport analysis.DefinitionTracking\n\nfrom NiceLocationExpr use, Definition defn, string kind\nwhere defn = definitionOf(use, kind)\nselect use, defn, kind",
        "description": "Jump to definition helper query.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/Definitions.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\nfrom int total_facts, int total_size, int depth, float efficiency\nwhere\n  total_facts =\n    strictcount(ControlFlowNode call, CallableValue func |\n      exists(PointsToContext ctx |\n        call = func.getACall(ctx) and\n        depth = ctx.getDepth()\n      )\n    ) and\n  total_size =\n    strictcount(ControlFlowNode call, CallableValue func, PointsToContext ctx |\n      call = func.getACall(ctx) and\n      depth = ctx.getDepth()\n    ) and\n  efficiency = 100.0 * total_facts / total_size\nselect depth, total_facts, total_size, efficiency",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/CallGraphEfficiency.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\npredicate trivial(ControlFlowNode f) {\n  f.getNode() instanceof Parameter\n  or\n  f instanceof NameConstantNode\n  or\n  f.getNode() instanceof ImmutableLiteral\n}\n\nfrom int interesting_facts, int interesting_facts_in_source, int total_size, float efficiency\nwhere\n  interesting_facts =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls |\n      f.refersTo(value, cls, _) and not trivial(f)\n    ) and\n  interesting_facts_in_source =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls |\n      f.refersTo(value, cls, _) and\n      not trivial(f) and\n      exists(f.getScope().getEnclosingModule().getFile().getRelativePath())\n    ) and\n  total_size =\n    strictcount(ControlFlowNode f, PointsToContext ctx, Object value, ClassObject cls,\n      ControlFlowNode orig | PointsTo::points_to(f, ctx, value, cls, orig)) and\n  efficiency = 100.0 * interesting_facts_in_source / total_size\nselect interesting_facts, interesting_facts_in_source, total_size, efficiency",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/Efficiency.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\nimport semmle.python.pointsto.PointsToContext\n\nfrom int total_facts, int total_size, int depth, float efficiency\nwhere\n  total_facts =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls |\n      exists(PointsToContext ctx |\n        PointsTo::points_to(f, ctx, value, cls, _) and\n        depth = ctx.getDepth()\n      )\n    ) and\n  total_size =\n    strictcount(ControlFlowNode f, Object value, ClassObject cls, PointsToContext ctx,\n      ControlFlowNode orig |\n      PointsTo::points_to(f, ctx, value, cls, orig) and\n      depth = ctx.getDepth()\n    ) and\n  efficiency = 100.0 * total_facts / total_size\nselect depth, total_facts, total_size, efficiency",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/analysis/ContextEfficiency.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.CodeInjectionQuery\nimport CodeInjectionFlow::PathGraph\n\nfrom CodeInjectionFlow::PathNode source, CodeInjectionFlow::PathNode sink\nwhere CodeInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This code execution depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Interpreting unsanitized user input as code allows a malicious user to perform arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-094/CodeInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.StackTraceExposureQuery\nimport StackTraceExposureFlow::PathGraph\n\nfrom StackTraceExposureFlow::PathNode source, StackTraceExposureFlow::PathNode sink\nwhere StackTraceExposureFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"$@ flows to this location and may be exposed to an external user.\", source.getNode(),\n  \"Stack trace information\"",
        "description": "Leaking information about an exception, such as messages and stack traces, to an external user can expose implementation details that are useful to an attacker for developing a subsequent exploit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-209/StackTraceExposure.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.UrlRedirectQuery\nimport UrlRedirectFlow::PathGraph\n\nfrom UrlRedirectFlow::PathNode source, UrlRedirectFlow::PathNode sink\nwhere UrlRedirectFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Untrusted URL redirection depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-601/UrlRedirect.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Concepts\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.filters.Tests\n\nfrom Cryptography::PublicKey::KeyGeneration keyGen, int keySize, DataFlow::Node origin\nwhere\n  keySize = keyGen.getKeySizeWithOrigin(origin) and\n  keySize < keyGen.minimumSecureKeySize() and\n  not origin.getScope().getScope*() instanceof TestScope\nselect keyGen,\n  \"Creation of an \" + keyGen.getName() + \" key uses $@ bits, which is below \" +\n    keyGen.minimumSecureKeySize() + \" and considered breakable.\", origin, keySize.toString()",
        "description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-326/WeakCryptoKey.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.HttpHeaderInjectionQuery\nimport HeaderInjectionFlow::PathGraph\n\nfrom HeaderInjectionFlow::PathNode source, HeaderInjectionFlow::PathNode sink\nwhere HeaderInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This HTTP header is constructed from a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Writing user input directly to an HTTP header makes code vulnerable to attack by header splitting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-113/HeaderInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.NoSqlInjectionQuery\nimport NoSqlInjectionFlow::PathGraph\n\nfrom NoSqlInjectionFlow::PathNode source, NoSqlInjectionFlow::PathNode sink\nwhere NoSqlInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This NoSQL query contains an unsanitized $@.\", source,\n  \"user-provided value\"",
        "description": "Building a NoSQL query from user-controlled sources is vulnerable to insertion of malicious NoSQL code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-943/NoSqlInjection.ql",
        "language": "python"
    },
    {
        "query": "// Connections are generally created based on a context which controls the range of acceptable\n// protocols. This query reports the deprecated way of creating connections without referring\n// to a context (via `ssl.wrap_socket`). Doing this and not specifying which protocols are\n// acceptable means that connections will be created with the insecure default settings.\n//\n// Detecting that a connection is created with a context that has not been suitably configured\n// is handled by the data-flow query py/insecure-protocol.\nimport python\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode call\nwhere\n  call = API::moduleImport(\"ssl\").getMember(\"wrap_socket\").getACall() and\n  not exists(call.getArgByName(\"ssl_version\"))\nselect call,\n  \"Call to deprecated method ssl.wrap_socket does not specify a protocol, which may result in an insecure default being used.\"",
        "description": "Leaving the SSL/TLS version unspecified may result in an insecure default protocol being used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-327/InsecureDefaultProtocol.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Concepts\n\nfrom Cryptography::CryptographicOperation operation, string msgPrefix\nwhere\n  // `Cryptography::HashingAlgorithm` and `Cryptography::PasswordHashingAlgorithm` are\n  // handled by `py/weak-sensitive-data-hashing`\n  exists(Cryptography::EncryptionAlgorithm algorithm | algorithm = operation.getAlgorithm() |\n    algorithm.isWeak() and\n    msgPrefix = \"The cryptographic algorithm \" + algorithm.getName()\n  )\n  or\n  operation.getBlockMode().isWeak() and msgPrefix = \"The block mode \" + operation.getBlockMode()\nselect operation, \"$@ is broken or weak, and should not be used.\", operation.getInitialization(),\n  msgPrefix",
        "description": "Using broken or weak cryptographic algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-327/BrokenCryptoAlgorithm.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport FluentApiModel\n\n// Helper for pretty printer `configName`.\n// This is a consequence of missing pretty printing.\n// We do not want to evaluate our bespoke pretty printer\n// for all `DataFlow::Node`s so we define a sub class of interesting ones.\nclass ProtocolConfiguration extends DataFlow::Node {\n  ProtocolConfiguration() {\n    unsafe_connection_creation_with_context(_, _, this, _)\n    or\n    unsafe_connection_creation_without_context(this, _)\n    or\n    unsafe_context_creation(this, _)\n  }\n\n  DataFlow::Node getNode() { result = this.(DataFlow::CallCfgNode).getFunction() }\n}\n\n// Helper for pretty printer `callName`.\n// This is a consequence of missing pretty printing.\n// We do not want to evaluate our bespoke pretty printer\n// for all `DataFlow::Node`s so we define a sub class of interesting ones.\nclass Nameable extends DataFlow::Node {\n  Nameable() {\n    this = any(ProtocolConfiguration pc).getNode()\n    or\n    this = any(Nameable attr).(DataFlow::AttrRef).getObject()\n  }\n}\n\nstring callName(Nameable call) {\n  result = call.asExpr().(Name).getId()\n  or\n  exists(DataFlow::AttrRef a | a = call |\n    result = callName(a.getObject()) + \".\" + a.getAttributeName()\n  )\n}\n\nstring configName(ProtocolConfiguration protocolConfiguration) {\n  result = \"call to \" + callName(protocolConfiguration.(DataFlow::CallCfgNode).getFunction())\n  or\n  not protocolConfiguration instanceof DataFlow::CallCfgNode and\n  not protocolConfiguration instanceof ContextCreation and\n  result = \"context modification\"\n}\n\nstring verb(boolean specific) {\n  specific = true and result = \"specified\"\n  or\n  specific = false and result = \"allowed\"\n}\n\nfrom\n  DataFlow::Node connectionCreation, string insecure_version, DataFlow::Node protocolConfiguration,\n  boolean specific\nwhere\n  unsafe_connection_creation_with_context(connectionCreation, insecure_version,\n    protocolConfiguration, specific)\n  or\n  unsafe_connection_creation_without_context(connectionCreation, insecure_version) and\n  protocolConfiguration = connectionCreation and\n  specific = true\n  or\n  unsafe_context_creation(protocolConfiguration, insecure_version) and\n  connectionCreation = protocolConfiguration and\n  specific = true\nselect connectionCreation,\n  \"Insecure SSL/TLS protocol version \" + insecure_version + \" \" + verb(specific) + \" by $@.\",\n  protocolConfiguration, configName(protocolConfiguration)",
        "description": "Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-327/InsecureProtocol.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.WeakSensitiveDataHashingQuery\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport WeakSensitiveDataHashingFlow::PathGraph\n\nfrom\n  WeakSensitiveDataHashingFlow::PathNode source, WeakSensitiveDataHashingFlow::PathNode sink,\n  string ending, string algorithmName, string classification\nwhere\n  normalHashFunctionFlowPath(source, sink) and\n  algorithmName = sink.getNode().(NormalHashFunction::Sink).getAlgorithmName() and\n  classification = source.getNode().(NormalHashFunction::Source).getClassification() and\n  ending = \".\"\n  or\n  computationallyExpensiveHashFunctionFlowPath(source, sink) and\n  algorithmName = sink.getNode().(ComputationallyExpensiveHashFunction::Sink).getAlgorithmName() and\n  classification =\n    source.getNode().(ComputationallyExpensiveHashFunction::Source).getClassification() and\n  (\n    sink.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n    ending = \".\"\n    or\n    not sink.getNode().(ComputationallyExpensiveHashFunction::Sink).isComputationallyExpensive() and\n    ending =\n      \" for \" + classification +\n        \" hashing, since it is not a computationally expensive hash function.\"\n  )\nselect sink.getNode(), source, sink,\n  \"$@ is used in a hashing algorithm (\" + algorithmName + \") that is insecure\" + ending,\n  source.getNode(), \"Sensitive data (\" + classification + \")\"",
        "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-327/WeakSensitiveDataHashing.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\nimport PartialServerSideRequestForgeryFlow::PathGraph\n\nfrom\n  PartialServerSideRequestForgeryFlow::PathNode source,\n  PartialServerSideRequestForgeryFlow::PathNode sink, Http::Client::Request request\nwhere\n  request = sink.getNode().(Sink).getRequest() and\n  PartialServerSideRequestForgeryFlow::flowPath(source, sink) and\n  not fullyControlledRequest(request)\nselect request, source, sink, \"Part of the URL of this request depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Making a network request to a URL that is partially user-controlled allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-918/PartialServerSideRequestForgery.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.ServerSideRequestForgeryQuery\nimport FullServerSideRequestForgeryFlow::PathGraph\n\nfrom\n  FullServerSideRequestForgeryFlow::PathNode source,\n  FullServerSideRequestForgeryFlow::PathNode sink, Http::Client::Request request\nwhere\n  request = sink.getNode().(Sink).getRequest() and\n  FullServerSideRequestForgeryFlow::flowPath(source, sink) and\n  fullyControlledRequest(request)\nselect request, source, sink, \"The full URL of this request depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Making a network request to a URL that is fully user-controlled allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-918/FullServerSideRequestForgery.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\n\nbindingset[p]\nint world_permission(int p) { result = p % 8 }\n\nbindingset[p]\nint group_permission(int p) { result = (p / 8) % 8 }\n\nbindingset[p]\nstring access(int p) {\n  p % 4 >= 2 and result = \"writable\"\n  or\n  p % 4 < 2 and p != 0 and result = \"readable\"\n}\n\nbindingset[p]\nstring permissive_permission(int p) {\n  result = \"world \" + access(world_permission(p))\n  or\n  world_permission(p) = 0 and result = \"group \" + access(group_permission(p))\n}\n\npredicate chmod_call(API::CallNode call, string name, int mode) {\n  call = API::moduleImport(\"os\").getMember(\"chmod\").getACall() and\n  mode = call.getParameter(1, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  name = \"chmod\"\n}\n\npredicate open_call(API::CallNode call, string name, int mode) {\n  call = API::moduleImport(\"os\").getMember(\"open\").getACall() and\n  mode = call.getParameter(2, \"mode\").getAValueReachingSink().asExpr().(IntegerLiteral).getValue() and\n  name = \"open\"\n}\n\nfrom API::CallNode call, string name, int mode, string permission\nwhere\n  (chmod_call(call, name, mode) or open_call(call, name, mode)) and\n  permission = permissive_permission(mode)\nselect call, \"Overly permissive mask in \" + name + \" sets file to \" + permission + \".\"",
        "description": "Allowing files to be readable or writable by users other than the owner may allow sensitive information to be accessed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-732/WeakFilePermissions.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport PamAuthorizationFlow::PathGraph\nimport semmle.python.ApiGraphs\nimport semmle.python.security.dataflow.PamAuthorizationQuery\n\nfrom PamAuthorizationFlow::PathNode source, PamAuthorizationFlow::PathNode sink\nwhere PamAuthorizationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This PAM authentication depends on a $@, and 'pam_acct_mgmt' is not called afterwards.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Not using `pam_acct_mgmt` after `pam_authenticate` to check the validity of a login can lead to authorization bypass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-285/PamAuthorization.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.Concepts\n\npredicate hasProblem(Http::Server::CookieWrite cookie, string alert, int idx) {\n  cookie.hasSecureFlag(false) and\n  alert = \"Secure\" and\n  idx = 0\n  or\n  cookie.hasHttpOnlyFlag(false) and\n  alert = \"HttpOnly\" and\n  idx = 1\n  or\n  cookie.hasSameSiteAttribute(any(Http::Server::CookieWrite::SameSiteNone v)) and\n  alert = \"SameSite\" and\n  idx = 2\n}\n\npredicate hasAlert(Http::Server::CookieWrite cookie, string alert) {\n  exists(int numProblems | numProblems = strictcount(string p | hasProblem(cookie, p, _)) |\n    numProblems = 1 and\n    alert = any(string prob | hasProblem(cookie, prob, _)) + \" attribute\"\n    or\n    numProblems = 2 and\n    alert =\n      strictconcat(string prob, int idx | hasProblem(cookie, prob, idx) | prob, \" and \" order by idx)\n        + \" attributes\"\n    or\n    numProblems = 3 and\n    alert = \"Secure, HttpOnly, and SameSite attributes\"\n  )\n}\n\nfrom Http::Server::CookieWrite cookie, string alert\nwhere hasAlert(cookie, alert)\nselect cookie, \"Cookie is added without the \" + alert + \" properly set.\"",
        "description": "Insecure cookies may be sent in cleartext, which makes them vulnerable to interception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-614/InsecureCookie.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.SqlInjectionQuery\nimport SqlInjectionFlow::PathGraph\n\nfrom SqlInjectionFlow::PathNode source, SqlInjectionFlow::PathNode sink\nwhere SqlInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This SQL query depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a SQL query from user-controlled sources is vulnerable to insertion of malicious SQL code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-089/SqlInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.TemplateInjectionQuery\nimport TemplateInjectionFlow::PathGraph\n\nfrom TemplateInjectionFlow::PathNode source, TemplateInjectionFlow::PathNode sink\nwhere TemplateInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This template construction depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Using user-controlled data to create a template can lead to remote code execution or cross site scripting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-074/TemplateInjection.ql",
        "language": "python"
    },
    {
        "query": "private import semmle.python.security.regexp.HostnameRegex as HostnameRegex\n\nquery predicate problems = HostnameRegex::incompleteHostnameRegExp/4;",
        "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-020/IncompleteHostnameRegExp.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.CookieInjectionQuery\nimport CookieInjectionFlow::PathGraph\n\nfrom CookieInjectionFlow::PathNode source, CookieInjectionFlow::PathNode sink\nwhere CookieInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Cookie is constructed from a $@.\", source.getNode(),\n  \"user-supplied input\"",
        "description": "Constructing cookies from user input may allow an attacker to perform a Cookie Poisoning attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-020/CookieInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.regex\n\nprivate string commonTopLevelDomainRegex() { result = \"com|org|edu|gov|uk|net|io\" }\n\npredicate looksLikeUrl(StringLiteral s) {\n  exists(string text | text = s.getText() |\n    text.regexpMatch(\"(?i)([a-z]*:?//)?\\\\.?([a-z0-9-]+\\\\.)+(\" + commonTopLevelDomainRegex() +\n        \")(:[0-9]+)?/?\")\n    or\n    // target is a HTTP URL to a domain on any TLD\n    text.regexpMatch(\"(?i)https?://([a-z0-9-]+\\\\.)+([a-z]+)(:[0-9]+)?/?\")\n  )\n}\n\npredicate incomplete_sanitization(Expr sanitizer, StringLiteral url) {\n  looksLikeUrl(url) and\n  (\n    sanitizer.(Compare).compares(url, any(In i), _)\n    or\n    unsafe_call_to_startswith(sanitizer, url)\n    or\n    unsafe_call_to_endswith(sanitizer, url)\n  )\n}\n\npredicate unsafe_call_to_startswith(Call sanitizer, StringLiteral url) {\n  sanitizer.getFunc().(Attribute).getName() = \"startswith\" and\n  sanitizer.getArg(0) = url and\n  not url.getText().regexpMatch(\"(?i)https?://[\\\\.a-z0-9-]+/.*\")\n}\n\npredicate unsafe_call_to_endswith(Call sanitizer, StringLiteral url) {\n  sanitizer.getFunc().(Attribute).getName() = \"endswith\" and\n  sanitizer.getArg(0) = url and\n  not url.getText().regexpMatch(\"(?i)\\\\.([a-z0-9-]+)(\\\\.[a-z0-9-]+)+\")\n}\n\nfrom Expr sanitizer, StringLiteral url\nwhere incomplete_sanitization(sanitizer, url)\nselect sanitizer, \"The string $@ may be at an arbitrary position in the sanitized URL.\", url,\n  url.getText()",
        "description": "Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-020/IncompleteUrlSubstringSanitization.ql",
        "language": "python"
    },
    {
        "query": "private import semmle.python.regexp.RegexTreeView::RegexTreeView as TreeView\nimport codeql.regex.OverlyLargeRangeQuery::Make<TreeView>\n\nfrom TreeView::RegExpCharacterRange range, string reason\nwhere problem(range, reason)\nselect range, \"Suspicious character range that \" + reason + \".\"",
        "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-020/OverlyLargeRange.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\nimport semmle.python.frameworks.Flask\n\nfrom API::CallNode call\nwhere\n  call = Flask::FlaskApp::instance().getMember(\"run\").getACall() and\n  call.getParameter(2, \"debug\").getAValueReachingSink().asExpr().(ImmutableLiteral).booleanValue() =\n    true\nselect call,\n  \"A Flask app appears to be run in debug mode. This may allow an attacker to run arbitrary code through the debugger.\"",
        "description": "Running a Flask app in debug mode may allow an attacker to run arbitrary code through the Werkzeug debugger.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-215/FlaskDebug.ql",
        "language": "python"
    },
    {
        "query": "// Determine precision above\nimport python\nimport semmle.python.security.dataflow.LdapInjectionQuery\nimport LdapInjectionFlow::PathGraph\n\nfrom LdapInjectionFlow::PathNode source, LdapInjectionFlow::PathNode sink, string parameterName\nwhere\n  LdapInjectionDnFlow::flowPath(source.asPathNode1(), sink.asPathNode1()) and\n  parameterName = \"DN\"\n  or\n  LdapInjectionFilterFlow::flowPath(source.asPathNode2(), sink.asPathNode2()) and\n  parameterName = \"filter\"\nselect sink.getNode(), source, sink,\n  \"LDAP query parameter (\" + parameterName + \") depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an LDAP query from user-controlled sources is vulnerable to insertion of malicious LDAP code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-090/LdapInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nprivate string vulnerableHostname() {\n  result in [\n      // IPv4\n      \"0.0.0.0\", \"\",\n      // IPv6\n      \"::\", \"::0\"\n    ]\n}\n\nprivate DataFlow::TypeTrackingNode vulnerableHostnameRef(DataFlow::TypeTracker t, string hostname) {\n  t.start() and\n  exists(StringLiteral allInterfacesStringLiteral | hostname = vulnerableHostname() |\n    allInterfacesStringLiteral.getText() = hostname and\n    result.asExpr() = allInterfacesStringLiteral\n  )\n  or\n  exists(DataFlow::TypeTracker t2 | result = vulnerableHostnameRef(t2, hostname).track(t2, t))\n}\n\nDataFlow::Node vulnerableHostnameRef(string hostname) {\n  vulnerableHostnameRef(DataFlow::TypeTracker::end(), hostname).flowsTo(result)\n}\n\nprivate DataFlow::TypeTrackingNode vulnerableAddressTuple(DataFlow::TypeTracker t, string hostname) {\n  t.start() and\n  result.asExpr() = any(Tuple tup | tup.getElt(0) = vulnerableHostnameRef(hostname).asExpr())\n  or\n  exists(DataFlow::TypeTracker t2 | result = vulnerableAddressTuple(t2, hostname).track(t2, t))\n}\n\nDataFlow::Node vulnerableAddressTuple(string hostname) {\n  vulnerableAddressTuple(DataFlow::TypeTracker::end(), hostname).flowsTo(result)\n}\n\nAPI::Node socketInstance() { result = API::moduleImport(\"socket\").getMember(\"socket\").getReturn() }\n\nfrom DataFlow::CallCfgNode bindCall, DataFlow::Node addressArg, string hostname\nwhere\n  bindCall = socketInstance().getMember(\"bind\").getACall() and\n  addressArg = bindCall.getArg(0) and\n  addressArg = vulnerableAddressTuple(hostname)\nselect bindCall.asExpr(), \"'\" + hostname + \"' binds a socket to all interfaces.\"",
        "description": "Binding a socket to all interfaces opens it up to traffic from any IPv4 address and is therefore associated with security risks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CVE-2018-1281/BindToAllInterfaces.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nprivate API::Node unsafe_paramiko_policy(string name) {\n  name in [\"AutoAddPolicy\", \"WarningPolicy\"] and\n  (\n    result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(name)\n    or\n    result = API::moduleImport(\"paramiko\").getMember(name)\n  )\n}\n\nprivate API::Node paramikoSshClientInstance() {\n  result = API::moduleImport(\"paramiko\").getMember(\"client\").getMember(\"SSHClient\").getReturn()\n  or\n  result = API::moduleImport(\"paramiko\").getMember(\"SSHClient\").getReturn()\n}\n\nfrom DataFlow::CallCfgNode call, DataFlow::Node arg, string name\nwhere\n  // see http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.set_missing_host_key_policy\n  call = paramikoSshClientInstance().getMember(\"set_missing_host_key_policy\").getACall() and\n  arg in [call.getArg(0), call.getArgByName(\"policy\")] and\n  (\n    arg = unsafe_paramiko_policy(name).getAValueReachableFromSource() or\n    arg = unsafe_paramiko_policy(name).getReturn().getAValueReachableFromSource()\n  )\nselect call, \"Setting missing host key policy to \" + name + \" may be unsafe.\"",
        "description": "Accepting unknown host keys can allow man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-295/MissingHostKeyValidation.ql",
        "language": "python"
    },
    {
        "query": "import python\nprivate import semmle.python.dataflow.new.DataFlow\nprivate import semmle.python.Concepts\n\nfrom\n  Http::Client::Request request, DataFlow::Node disablingNode, DataFlow::Node origin, string ending\nwhere\n  request.disablesCertificateValidation(disablingNode, origin) and\n  // Showing the origin is only useful when it's a different node than the one disabling\n  // certificate validation, for example in `requests.get(..., verify=arg)`, `arg` would\n  // be the `disablingNode`, and the `origin` would be the place were `arg` got its\n  // value from.\n  if disablingNode = origin then ending = \".\" else ending = \" by $@.\"\nselect request, \"This request may run without certificate validation because $@\" + ending,\n  disablingNode, \"it is disabled\", origin, \"this value\"",
        "description": "Making a request without certificate validation can allow man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-295/RequestWithoutValidation.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.LogInjectionQuery\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode source, LogInjectionFlow::PathNode sink\nwhere LogInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This log entry depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled data is vulnerable to insertion of forged log entries by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-117/LogInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\n\nAPI::Node temporary_name_function(string mod, string function) {\n  (\n    mod = \"tempfile\" and function = \"mktemp\"\n    or\n    mod = \"os\" and\n    (\n      function = \"tmpnam\"\n      or\n      function = \"tempnam\"\n    )\n  ) and\n  result = API::moduleImport(mod).getMember(function)\n}\n\nfrom Call c, string mod, string function\nwhere temporary_name_function(mod, function).getACall().asExpr() = c\nselect c, \"Call to deprecated function \" + mod + \".\" + function + \" may be insecure.\"",
        "description": "Creating a temporary file using this method may be insecure.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-377/InsecureTemporaryFile.ql",
        "language": "python"
    },
    {
        "query": "private import semmle.python.regexp.RegexTreeView::RegexTreeView as TreeView\nimport codeql.regex.nfa.BadTagFilterQuery::Make<TreeView>\n\nfrom HtmlMatchingRegExp regexp, string msg\nwhere msg = min(string m | isBadRegexpFilter(regexp, m) | m order by m.length(), m) // there might be multiple, we arbitrarily pick the shortest one\nselect regexp, msg",
        "description": "Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-116/BadTagFilter.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.XmlBombQuery\nimport XmlBombFlow::PathGraph\n\nfrom XmlBombFlow::PathNode source, XmlBombFlow::PathNode sink\nwhere XmlBombFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against uncontrolled entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user input as an XML document with arbitrary internal entity expansion is vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-776/XmlBomb.ql",
        "language": "python"
    },
    {
        "query": "import python\nprivate import semmle.python.dataflow.new.DataFlow\nimport CleartextStorageFlow::PathGraph\nimport semmle.python.security.dataflow.CleartextStorageQuery\n\nfrom\n  CleartextStorageFlow::PathNode source, CleartextStorageFlow::PathNode sink, string classification\nwhere\n  CleartextStorageFlow::flowPath(source, sink) and\n  classification = source.getNode().(Source).getClassification()\nselect sink.getNode(), source, sink, \"This expression stores $@ as clear text.\", source.getNode(),\n  \"sensitive data (\" + classification + \")\"",
        "description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-312/CleartextStorage.ql",
        "language": "python"
    },
    {
        "query": "import python\nprivate import semmle.python.dataflow.new.DataFlow\nimport CleartextLoggingFlow::PathGraph\nimport semmle.python.security.dataflow.CleartextLoggingQuery\n\nfrom\n  CleartextLoggingFlow::PathNode source, CleartextLoggingFlow::PathNode sink, string classification\nwhere\n  CleartextLoggingFlow::flowPath(source, sink) and\n  classification = source.getNode().(Source).getClassification()\nselect sink.getNode(), source, sink, \"This expression logs $@ as clear text.\", source.getNode(),\n  \"sensitive data (\" + classification + \")\"",
        "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-312/CleartextLogging.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.TaintTracking\nimport semmle.python.filters.Tests\nprivate import semmle.python.dataflow.new.internal.DataFlowDispatch as DataFlowDispatch\nprivate import semmle.python.dataflow.new.internal.Builtins::Builtins as Builtins\nprivate import semmle.python.frameworks.data.ModelsAsData\n\nbindingset[char, fraction]\npredicate fewer_characters_than(StringLiteral str, string char, float fraction) {\n  exists(string text, int chars |\n    text = str.getText() and\n    chars = count(int i | text.charAt(i) = char)\n  |\n    /* Allow one character */\n    chars = 1 or\n    chars < text.length() * fraction\n  )\n}\n\npredicate possible_reflective_name(string name) {\n  any(Function f).getName() = name\n  or\n  any(Class c).getName() = name\n  or\n  any(Module m).getName() = name\n  or\n  exists(Builtins::likelyBuiltin(name))\n}\n\nint char_count(StringLiteral str) { result = count(string c | c = str.getText().charAt(_)) }\n\npredicate capitalized_word(StringLiteral str) { str.getText().regexpMatch(\"[A-Z][a-z]+\") }\n\npredicate format_string(StringLiteral str) { str.getText().matches(\"%{%}%\") }\n\npredicate maybeCredential(ControlFlowNode f) {\n  /* A string that is not too short and unlikely to be text or an identifier. */\n  exists(StringLiteral str | str = f.getNode() |\n    /* At least 10 characters */\n    str.getText().length() > 9 and\n    /* Not too much whitespace */\n    fewer_characters_than(str, \" \", 0.05) and\n    /* or underscores */\n    fewer_characters_than(str, \"_\", 0.2) and\n    /* Not too repetitive */\n    exists(int chars | chars = char_count(str) |\n      chars > 15 or\n      chars * 3 > str.getText().length() * 2\n    ) and\n    not possible_reflective_name(str.getText()) and\n    not capitalized_word(str) and\n    not format_string(str)\n  )\n  or\n  /* Or, an integer with over 32 bits */\n  exists(IntegerLiteral lit | f.getNode() = lit |\n    not exists(lit.getValue()) and\n    /* Not a set of flags or round number */\n    not lit.getN().matches(\"%00%\")\n  )\n}\n\nclass HardcodedValueSource extends DataFlow::Node {\n  HardcodedValueSource() { maybeCredential(this.asCfgNode()) }\n}\n\nclass CredentialSink extends DataFlow::Node {\n  CredentialSink() {\n    exists(string s | s.matches(\"credentials-%\") |\n      // Actual sink-type will be things like `credentials-password` or `credentials-username`\n      this = ModelOutput::getASinkNode(s).asSink()\n    )\n    or\n    exists(string name |\n      name.regexpMatch(getACredentialRegex()) and\n      not name.matches(\"%file\")\n    |\n      exists(DataFlowDispatch::ArgumentPosition pos | pos.isKeyword(name) |\n        this.(DataFlow::ArgumentNode).argumentOf(_, pos)\n      )\n      or\n      exists(Keyword k | k.getArg() = name and k.getValue().getAFlowNode() = this.asCfgNode())\n      or\n      exists(CompareNode cmp, NameNode n | n.getId() = name |\n        cmp.operands(this.asCfgNode(), any(Eq eq), n)\n        or\n        cmp.operands(n, any(Eq eq), this.asCfgNode())\n      )\n    )\n  }\n}\n\nprivate string getACredentialRegex() {\n  result = \"(?i).*pass(wd|word|code|phrase)(?!.*question).*\" or\n  result = \"(?i).*(puid|username|userid).*\" or\n  result = \"(?i).*(cert)(?!.*(format|name)).*\"\n}\n\nprivate module HardcodedCredentialsConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof HardcodedValueSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof CredentialSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule HardcodedCredentialsFlow = TaintTracking::Global<HardcodedCredentialsConfig>;\n\nimport HardcodedCredentialsFlow::PathGraph\n\nfrom HardcodedCredentialsFlow::PathNode src, HardcodedCredentialsFlow::PathNode sink\nwhere\n  HardcodedCredentialsFlow::flowPath(src, sink) and\n  not any(TestScope test).contains(src.getNode().asCfgNode().getNode())\nselect src.getNode(), src, sink, \"This hardcoded value is $@.\", sink.getNode(),\n  \"used as credentials\"",
        "description": "Credentials are hard coded in the source code of the application.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-798/HardcodedCredentials.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Concepts\n\npredicate relevantSetting(Http::Server::CsrfProtectionSetting s) {\n  // rule out test code as this is a common place to turn off CSRF protection.\n  // We don't use normal `TestScope` to find test files, since we also want to match\n  // a settings file such as `.../integration-tests/settings.py`\n  not s.getLocation().getFile().getAbsolutePath().matches(\"%test%\")\n}\n\npredicate vulnerableSetting(Http::Server::CsrfProtectionSetting s) {\n  s.getVerificationSetting() = false and\n  not exists(Http::Server::CsrfLocalProtectionSetting p | p.csrfEnabled()) and\n  relevantSetting(s)\n}\n\nfrom Http::Server::CsrfProtectionSetting setting\nwhere\n  vulnerableSetting(setting) and\n  // We have seen examples of dummy projects with vulnerable settings alongside a main\n  // project with a protecting settings file. We want to rule out this scenario, so we\n  // require all non-test settings to be vulnerable.\n  forall(Http::Server::CsrfProtectionSetting s | relevantSetting(s) | vulnerableSetting(s))\nselect setting, \"Potential CSRF vulnerability due to forgery protection being disabled or weakened.\"",
        "description": "Disabling or weakening CSRF protection may make the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-352/CSRFProtectionDisabled.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport ExternalAPIs\nimport UntrustedDataToExternalApiFlow::PathGraph\n\nfrom\n  UntrustedDataToExternalApiFlow::PathNode source, UntrustedDataToExternalApiFlow::PathNode sink,\n  ExternalApiUsedWithUntrustedData externalApi\nwhere\n  sink.getNode() = externalApi.getUntrustedDataNode() and\n  UntrustedDataToExternalApiFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Call to \" + externalApi.toString() + \" with untrusted data from $@.\", source.getNode(),\n  source.toString()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-020-ExternalAPIs/UntrustedDataToExternalAPI.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport ExternalAPIs\n\nfrom ExternalApiUsedWithUntrustedData externalApi\nselect externalApi, count(externalApi.getUntrustedDataNode()) as numberOfUses,\n  externalApi.getNumberOfUntrustedSources() as numberOfUntrustedSources order by\n    numberOfUntrustedSources desc",
        "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-020-ExternalAPIs/ExternalAPIsUsedWithUntrustedData.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.UnsafeDeserializationQuery\nimport UnsafeDeserializationFlow::PathGraph\n\nfrom UnsafeDeserializationFlow::PathNode source, UnsafeDeserializationFlow::PathNode sink\nwhere UnsafeDeserializationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Unsafe deserialization depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-502/UnsafeDeserialization.ql",
        "language": "python"
    },
    {
        "query": "import python\nprivate import semmle.python.Concepts\nimport semmle.python.security.dataflow.RegexInjectionQuery\nimport RegexInjectionFlow::PathGraph\n\nfrom\n  RegexInjectionFlow::PathNode source, RegexInjectionFlow::PathNode sink,\n  RegexExecution regexExecution\nwhere\n  RegexInjectionFlow::flowPath(source, sink) and\n  regexExecution = sink.getNode().(Sink).getRegexExecution()\nselect sink.getNode(), source, sink,\n  \"This regular expression depends on a $@ and is executed by $@.\", source.getNode(),\n  \"user-provided value\", regexExecution, regexExecution.getName()",
        "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-730/RegexInjection.ql",
        "language": "python"
    },
    {
        "query": "private import semmle.python.regexp.RegexTreeView::RegexTreeView as TreeView\nimport codeql.regex.nfa.ExponentialBackTracking::Make<TreeView>\n\nfrom TreeView::RegExpTerm t, string pump, State s, string prefixMsg\nwhere\n  hasReDoSResult(t, pump, s, prefixMsg) and\n  // exclude verbose mode regexes for now\n  not t.getRegex().getAMode() = \"VERBOSE\"\nselect t,\n  \"This part of the regular expression may cause exponential backtracking on strings \" + prefixMsg +\n    \"containing many repetitions of '\" + pump + \"'.\"",
        "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-730/ReDoS.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.PolynomialReDoSQuery\nimport PolynomialReDoSFlow::PathGraph\n\nfrom\n  PolynomialReDoSFlow::PathNode source, PolynomialReDoSFlow::PathNode sink, Sink sinkNode,\n  PolynomialBackTrackingTerm regexp\nwhere\n  PolynomialReDoSFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  regexp = sinkNode.getABacktrackingTerm()\n//   not (\n//     source.getNode().(Source).getKind() = \"url\" and\n//     regexp.isAtEndLine()\n//   )\nselect sinkNode.getHighlight(), source, sink,\n  \"This $@ that depends on a $@ may run slow on strings \" + regexp.getPrefixMessage() +\n    \"with many repetitions of '\" + regexp.getPumpString() + \"'.\", regexp, \"regular expression\",\n  source.getNode(), \"user-provided value\"",
        "description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-730/PolynomialReDoS.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.PathInjectionQuery\nimport PathInjectionFlow::PathGraph\n\nfrom PathInjectionFlow::PathNode source, PathInjectionFlow::PathNode sink\nwhere PathInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-022/PathInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.TarSlipQuery\nimport TarSlipFlow::PathGraph\n\nfrom TarSlipFlow::PathNode source, TarSlipFlow::PathNode sink\nwhere TarSlipFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This file extraction depends on a $@.\", source.getNode(),\n  \"potentially untrusted source\"",
        "description": "Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-022/TarSlip.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.XxeQuery\nimport XxeFlow::PathGraph\n\nfrom XxeFlow::PathNode source, XxeFlow::PathNode sink\nwhere XxeFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against external entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-611/Xxe.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.CommandInjectionQuery\nimport CommandInjectionFlow::PathGraph\n\nfrom CommandInjectionFlow::PathNode source, CommandInjectionFlow::PathNode sink\nwhere CommandInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This command line depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-078/CommandInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.UnsafeShellCommandConstructionQuery\nimport UnsafeShellCommandConstructionFlow::PathGraph\n\nfrom\n  UnsafeShellCommandConstructionFlow::PathNode source,\n  UnsafeShellCommandConstructionFlow::PathNode sink, Sink sinkNode\nwhere\n  UnsafeShellCommandConstructionFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode()\nselect sinkNode.getStringConstruction(), source, sink,\n  \"This \" + sinkNode.describe() + \" which depends on $@ is later used in a $@.\", source.getNode(),\n  \"library input\", sinkNode.getCommandExecution(), \"shell command\"",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-078/UnsafeShellCommandConstruction.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.XpathInjectionQuery\nimport XpathInjectionFlow::PathGraph\n\nfrom XpathInjectionFlow::PathNode source, XpathInjectionFlow::PathNode sink\nwhere XpathInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"XPath expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a XPath query from user-controlled sources is vulnerable to insertion of malicious Xpath code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-643/XpathInjection.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.security.dataflow.ReflectedXssQuery\nimport ReflectedXssFlow::PathGraph\n\nfrom ReflectedXssFlow::PathNode source, ReflectedXssFlow::PathNode sink\nwhere ReflectedXssFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Cross-site scripting vulnerability due to a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-079/ReflectedXss.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\n\nprivate API::Node jinja2EnvironmentOrTemplate() {\n  result = API::moduleImport(\"jinja2\").getMember(\"Environment\")\n  or\n  result = API::moduleImport(\"jinja2\").getMember(\"Template\")\n}\n\nfrom API::CallNode call\nwhere\n  call = jinja2EnvironmentOrTemplate().getACall() and\n  not exists(call.asCfgNode().(CallNode).getNode().getStarargs()) and\n  not exists(call.asCfgNode().(CallNode).getNode().getKwargs()) and\n  (\n    not exists(call.getArgByName(\"autoescape\"))\n    or\n    call.getKeywordParameter(\"autoescape\")\n        .getAValueReachingSink()\n        .asExpr()\n        .(ImmutableLiteral)\n        .booleanValue() = false\n  )\nselect call, \"Using jinja2 templates with autoescape=False can potentially allow XSS attacks.\"",
        "description": "Using jinja2 templates with 'autoescape=False' can cause a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Security/CWE-079/Jinja2WithoutEscaping.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Equality\n\npredicate class_stores_to_attribute(ClassValue cls, SelfAttributeStore store, string name) {\n  exists(FunctionValue f |\n    f = cls.declaredAttribute(_) and store.getScope() = f.getScope() and store.getName() = name\n  ) and\n  /* Exclude classes used as metaclasses */\n  not cls.getASuperType() = ClassValue::type()\n}\n\npredicate should_override_eq(ClassValue cls, Value base_eq) {\n  not cls.declaresAttribute(\"__eq__\") and\n  exists(ClassValue sup | sup = cls.getABaseType() and sup.declaredAttribute(\"__eq__\") = base_eq |\n    not exists(GenericEqMethod eq | eq.getScope() = sup.getScope()) and\n    not exists(IdentityEqMethod eq | eq.getScope() = sup.getScope()) and\n    not base_eq.(FunctionValue).getScope() instanceof IdentityEqMethod and\n    not base_eq = ClassValue::object().declaredAttribute(\"__eq__\")\n  )\n}\n\npredicate superclassEqExpectsAttribute(ClassValue cls, FunctionValue base_eq, string attrname) {\n  not cls.declaresAttribute(\"__eq__\") and\n  exists(ClassValue sup | sup = cls.getABaseType() and sup.declaredAttribute(\"__eq__\") = base_eq |\n    exists(SelfAttributeRead store | store.getName() = attrname |\n      store.getScope() = base_eq.getScope()\n    )\n  )\n}\n\nfrom ClassValue cls, SelfAttributeStore store, Value base_eq\nwhere\n  class_stores_to_attribute(cls, store, _) and\n  should_override_eq(cls, base_eq) and\n  /* Don't report overridden unittest.TestCase. -- TestCase overrides __eq__, but subclasses do not really need to. */\n  not cls.getASuperType().getName() = \"TestCase\" and\n  not superclassEqExpectsAttribute(cls, base_eq, store.getName())\nselect cls,\n  \"The class '\" + cls.getName() + \"' does not override $@, but adds the new attribute $@.\", base_eq,\n  \"'__eq__'\", store, store.getName()",
        "description": "When adding new attributes to instances of a class, equality for that class needs to be defined.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/DefineEqualsWhenAddingAttributes.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate fewer_than_two_public_methods(Class cls, int methods) {\n  (methods = 0 or methods = 1) and\n  methods = count(Function f | f = cls.getAMethod() and not f = cls.getInitMethod())\n}\n\npredicate does_not_define_special_method(Class cls) {\n  not exists(Function f | f = cls.getAMethod() and f.isSpecialMethod())\n}\n\npredicate no_inheritance(Class c) {\n  not exists(ClassValue cls, ClassValue other |\n    cls.getScope() = c and\n    other != ClassValue::object()\n  |\n    other.getABaseType() = cls or\n    cls.getABaseType() = other\n  ) and\n  not exists(Expr base | base = c.getABase() |\n    not base instanceof Name or base.(Name).getId() != \"object\"\n  )\n}\n\npredicate is_decorated(Class c) { exists(c.getADecorator()) }\n\npredicate is_stateful(Class c) {\n  exists(Function method, ExprContext ctx |\n    method.getScope() = c and\n    (ctx instanceof Store or ctx instanceof AugStore)\n  |\n    exists(Subscript s | s.getScope() = method and s.getCtx() = ctx)\n    or\n    exists(Attribute a | a.getScope() = method and a.getCtx() = ctx)\n  )\n  or\n  exists(Function method, Call call, Attribute a, string name |\n    method.getScope() = c and\n    call.getScope() = method and\n    call.getFunc() = a and\n    a.getName() = name\n  |\n    name in [\"pop\", \"remove\", \"discard\", \"extend\", \"append\"]\n  )\n}\n\npredicate useless_class(Class c, int methods) {\n  c.isTopLevel() and\n  c.isPublic() and\n  no_inheritance(c) and\n  fewer_than_two_public_methods(c, methods) and\n  does_not_define_special_method(c) and\n  not c.isProbableMixin() and\n  not is_decorated(c) and\n  not is_stateful(c)\n}\n\nfrom Class c, int methods, string msg\nwhere\n  useless_class(c, methods) and\n  (\n    methods = 1 and\n    msg =\n      \"Class \" + c.getName() +\n        \" defines only one public method, which should be replaced by a function.\"\n    or\n    methods = 0 and\n    msg =\n      \"Class \" + c.getName() +\n        \" defines no public methods and could be replaced with a namedtuple or dictionary.\"\n  )\nselect c, msg",
        "description": "Class only defines one public method (apart from `__init__` or `__new__`) and should be replaced by a function",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/UselessClass.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ClassValue c\nwhere not c.isBuiltin() and not c.isContextManager() and exists(c.declaredAttribute(\"__del__\"))\nselect c,\n  \"Class \" + c.getName() +\n    \" implements __del__ (presumably to release some resource). Consider making it a context manager.\"",
        "description": "Making a class a context manager allows instances to be used in a 'with' statement. This improves resource handling and code readability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/ShouldBeContextManager.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nClassObject left_base(ClassObject type, ClassObject base) {\n  exists(int i | i > 0 and type.getBaseType(i) = base and result = type.getBaseType(i - 1))\n}\n\npredicate invalid_mro(ClassObject t, ClassObject left, ClassObject right) {\n  t.isNewStyle() and\n  left = left_base(t, right) and\n  left = right.getAnImproperSuperType()\n}\n\nfrom ClassObject t, ClassObject left, ClassObject right\nwhere invalid_mro(t, left, right)\nselect t,\n  \"Construction of class \" + t.getName() +\n    \" can fail due to invalid method resolution order(MRO) for bases $@ and $@.\", left,\n  left.getName(), right, right.getName()",
        "description": "Class definition will raise a type error at runtime due to inconsistent method resolution order(MRO)",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/InconsistentMRO.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate does_nothing(PyFunctionObject f) {\n  not exists(Stmt s | s.getScope() = f.getFunction() |\n    not s instanceof Pass and not s.(ExprStmt).getValue() = f.getFunction().getDocString()\n  )\n}\n\npredicate calls_super(FunctionObject f) {\n  exists(Call sup, Call meth, Attribute attr, GlobalVariable v |\n    meth.getScope() = f.getFunction() and\n    meth.getFunc() = attr and\n    attr.getObject() = sup and\n    attr.getName() = f.getName() and\n    sup.getFunc() = v.getAnAccess() and\n    v.getId() = \"super\"\n  )\n}\n\npredicate allowed(string name) {\n  /*\n   * The standard library specifically recommends this :(\n   * See https://docs.python.org/3/library/socketserver.html#asynchronous-mixins\n   */\n\n  name = \"process_request\"\n}\n\nfrom\n  ClassObject c, ClassObject b1, ClassObject b2, string name, int i1, int i2, Object o1, Object o2\nwhere\n  c.getBaseType(i1) = b1 and\n  c.getBaseType(i2) = b2 and\n  i1 < i2 and\n  o1 != o2 and\n  o1 = b1.lookupAttribute(name) and\n  o2 = b2.lookupAttribute(name) and\n  not name.matches(\"\\\\_\\\\_%\\\\_\\\\_\") and\n  not calls_super(o1) and\n  not does_nothing(o2) and\n  not allowed(name) and\n  not o1.overrides(o2) and\n  not o2.overrides(o1) and\n  not c.declaresAttribute(name)\nselect c, \"Base classes have conflicting values for attribute '\" + name + \"': $@ and $@.\", o1,\n  o1.toString(), o2, o2.toString()",
        "description": "When a class subclasses multiple base classes and more than one base class defines the same attribute, attribute overriding may result in unexpected behavior by instances of this class.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/ConflictingAttributesInBaseClasses.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Expressions.CallArgs\n\nfrom Call call, ClassValue cls, string name, FunctionValue init\nwhere\n  illegally_named_parameter(call, cls, name) and\n  init = get_function_or_initializer(cls)\nselect call, \"Keyword argument '\" + name + \"' is not a supported parameter name of $@.\", init,\n  init.getQualifiedName()",
        "description": "Using a named argument whose name does not correspond to a parameter of the __init__ method of the class being instantiated, will result in a TypeError at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/WrongNameForArgumentInClassInstantiation.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport ClassAttributes\n\npredicate undefined_class_attribute(SelfAttributeRead a, CheckClass c, int line, string name) {\n  name = a.getName() and\n  not c.sometimesDefines(name) and\n  c.interestingUndefined(a) and\n  line = a.getLocation().getStartLine() and\n  not attribute_assigned_in_method(c.getAMethodCalledFromInit(), name)\n}\n\npredicate report_undefined_class_attribute(Attribute a, ClassObject c, string name) {\n  exists(int line |\n    undefined_class_attribute(a, c, line, name) and\n    line = min(int x | undefined_class_attribute(_, c, x, name))\n  )\n}\n\nfrom Attribute a, ClassObject c, string name\nwhere report_undefined_class_attribute(a, c, name)\nselect a, \"Attribute '\" + name + \"' is not defined in either the class body or in any method.\"",
        "description": "Accessing an attribute of `self` that is not initialized anywhere in the class in the `__init__` method may cause an AttributeError at runtime",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/UndefinedClassAttribute.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate uses_of_super_in_old_style_class(Call s) {\n  exists(Function f, ClassObject c |\n    s.getScope() = f and\n    f.getScope() = c.getPyClass() and\n    not c.failedInference() and\n    not c.isNewStyle() and\n    s.getFunc().(Name).getId() = \"super\"\n  )\n}\n\nfrom Call c\nwhere uses_of_super_in_old_style_class(c)\nselect c, \"'super()' will not work in old-style classes.\"",
        "description": "Using super() to access inherited methods is not supported by old-style classes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/SuperInOldStyleClass.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate mutates_descriptor(ClassObject cls, SelfAttributeStore s) {\n  cls.isDescriptorType() and\n  exists(PyFunctionObject f, PyFunctionObject get_set |\n    exists(string name | cls.lookupAttribute(name) = get_set |\n      name = \"__get__\" or name = \"__set__\" or name = \"__delete__\"\n    ) and\n    cls.lookupAttribute(_) = f and\n    get_set.getACallee*() = f and\n    not f.getName() = \"__init__\" and\n    s.getScope() = f.getFunction()\n  )\n}\n\nfrom ClassObject cls, SelfAttributeStore s\nwhere mutates_descriptor(cls, s)\nselect s,\n  \"Mutation of descriptor $@ object may lead to action-at-a-distance effects or race conditions for properties.\",\n  cls, cls.getName()",
        "description": "Descriptor objects can be shared across many instances. Mutating them can cause strange side effects or race conditions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/MutatingDescriptor.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Expressions.CallArgs\n\nfrom Call call, ClassValue cls, string too, string should, int limit, FunctionValue init\nwhere\n  (\n    too_many_args(call, cls, limit) and\n    too = \"too many arguments\" and\n    should = \"no more than \"\n    or\n    too_few_args(call, cls, limit) and\n    too = \"too few arguments\" and\n    should = \"no fewer than \"\n  ) and\n  init = get_function_or_initializer(cls)\nselect call, \"Call to $@ with \" + too + \"; should be \" + should + limit.toString() + \".\", init,\n  init.getQualifiedName()",
        "description": "Using too many or too few arguments in a call to the `__init__` method of a class will result in a TypeError at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/WrongNumberArgumentsInClassInstantiation.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport ClassAttributes\n\npredicate guarded_by_other_attribute(SelfAttributeRead a, CheckClass c) {\n  c.sometimesDefines(a.getName()) and\n  exists(SelfAttributeRead guard, If i |\n    i.contains(a) and\n    c.assignedInInit(guard.getName())\n  |\n    i.getTest() = guard\n    or\n    i.getTest().contains(guard)\n  )\n}\n\npredicate maybe_undefined_class_attribute(SelfAttributeRead a, CheckClass c) {\n  c.sometimesDefines(a.getName()) and\n  not c.alwaysDefines(a.getName()) and\n  c.interestingUndefined(a) and\n  not guarded_by_other_attribute(a, c)\n}\n\nfrom Attribute a, ClassObject c, SelfAttributeStore sa\nwhere\n  maybe_undefined_class_attribute(a, c) and\n  sa.getClass() = c.getPyClass() and\n  sa.getName() = a.getName()\nselect a,\n  \"Attribute '\" + a.getName() +\n    \"' is not defined in the class body nor in the __init__() method, but it is defined $@.\", sa,\n  \"here\"",
        "description": "Accessing an attribute of `self` that is not initialized in the `__init__` method may cause an AttributeError at runtime",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/MaybeUndefinedClassAttribute.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nclass InitCallStmt extends ExprStmt {\n  InitCallStmt() {\n    exists(Call call, Attribute attr | call = this.getValue() and attr = call.getFunc() |\n      attr.getName() = \"__init__\"\n    )\n  }\n}\n\npredicate overwrites_which(Function subinit, AssignStmt write_attr, string which) {\n  write_attr.getScope() = subinit and\n  self_write_stmt(write_attr, _) and\n  exists(Stmt top | top.contains(write_attr) or top = write_attr |\n    (\n      exists(int i, int j, InitCallStmt call | call.getScope() = subinit |\n        i > j and top = subinit.getStmt(i) and call = subinit.getStmt(j) and which = \"superclass\"\n      )\n      or\n      exists(int i, int j, InitCallStmt call | call.getScope() = subinit |\n        i < j and top = subinit.getStmt(i) and call = subinit.getStmt(j) and which = \"subclass\"\n      )\n    )\n  )\n}\n\npredicate self_write_stmt(Stmt s, string attr) {\n  exists(Attribute a, Name self |\n    self = a.getObject() and\n    s.contains(a) and\n    self.getId() = \"self\" and\n    a.getCtx() instanceof Store and\n    a.getName() = attr\n  )\n}\n\npredicate both_assign_attribute(Stmt s1, Stmt s2, Function f1, Function f2) {\n  exists(string name |\n    s1.getScope() = f1 and\n    s2.getScope() = f2 and\n    self_write_stmt(s1, name) and\n    self_write_stmt(s2, name)\n  )\n}\n\npredicate attribute_overwritten(\n  AssignStmt overwrites, AssignStmt overwritten, string name, string classtype, string classname\n) {\n  exists(\n    FunctionObject superinit, FunctionObject subinit, ClassObject superclass, ClassObject subclass,\n    AssignStmt subattr, AssignStmt superattr\n  |\n    (\n      classtype = \"superclass\" and\n      classname = superclass.getName() and\n      overwrites = subattr and\n      overwritten = superattr\n      or\n      classtype = \"subclass\" and\n      classname = subclass.getName() and\n      overwrites = superattr and\n      overwritten = subattr\n    ) and\n    /* OK if overwritten in subclass and is a class attribute */\n    (not exists(superclass.declaredAttribute(name)) or classtype = \"subclass\") and\n    superclass.declaredAttribute(\"__init__\") = superinit and\n    subclass.declaredAttribute(\"__init__\") = subinit and\n    superclass = subclass.getASuperType() and\n    overwrites_which(subinit.getFunction(), subattr, classtype) and\n    both_assign_attribute(subattr, superattr, subinit.getFunction(), superinit.getFunction()) and\n    self_write_stmt(superattr, name)\n  )\n}\n\nfrom string classtype, AssignStmt overwrites, AssignStmt overwritten, string name, string classname\nwhere attribute_overwritten(overwrites, overwritten, name, classtype, classname)\nselect overwrites,\n  \"Assignment overwrites attribute \" + name + \", which was previously defined in \" + classtype +\n    \" $@.\", overwritten, classname",
        "description": "Assignment to self attribute overwrites attribute previously defined in subclass or superclass `__init__` method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/OverwritingAttributeInSuperClass.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ClassObject c\nwhere not c.isNewStyle() and c.declaresAttribute(\"__slots__\") and not c.failedInference()\nselect c,\n  \"Using '__slots__' in an old style class just creates a class attribute called '__slots__'.\"",
        "description": "Overriding the class dictionary by declaring `__slots__` is not supported by old-style classes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/SlotsInOldStyleClass.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom PropertyObject prop, ClassObject cls\nwhere cls.declaredAttribute(_) = prop and not cls.failedInference() and not cls.isNewStyle()\nselect prop,\n  \"Property \" + prop.getName() + \" will not work properly, as class \" + cls.getName() +\n    \" is an old-style class.\"",
        "description": "Using property descriptors in old-style classes does not work from Python 2.1 onward.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/PropertyInOldStyleClass.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport MethodCallOrder\n\nfrom Class base, Function shouldCall, FunctionOption possibleIssue, string msg\nwhere\n  exists(FunctionOption possiblyMissingSuper |\n    missingCallToSuperclassMethodRestricted(base, shouldCall, \"__init__\") and\n    possiblyMissingSuper = getPossibleMissingSuperOption(base, shouldCall, \"__init__\") and\n    (\n      possibleIssue.asSome() = possiblyMissingSuper.asSome() and\n      msg =\n        \"This class does not call $@ during initialization. ($@ may be missing a call to super().__init__)\"\n      or\n      possiblyMissingSuper.isNone() and\n      (\n        possibleIssue.asSome() = base.getInitMethod() and\n        msg =\n          \"This class does not call $@ during initialization. ($@ may be missing a call to a base class __init__)\"\n        or\n        not exists(base.getInitMethod()) and\n        possibleIssue.isNone() and\n        msg =\n          \"This class does not call $@ during initialization. (The class lacks an __init__ method to ensure every base class __init__ is called.)\"\n      )\n    )\n  )\nselect base, msg, shouldCall, shouldCall.getQualifiedName(), possibleIssue,\n  possibleIssue.getQualifiedName()",
        "description": "An omitted call to a superclass `__init__` method may lead to objects of this class not being fully initialized.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/CallsToInitDel/MissingCallToInit.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport MethodCallOrder\n\npredicate multipleCallsToSuperclassDel(\n  Function meth, Function calledMulti, DataFlow::MethodCallNode call1,\n  DataFlow::MethodCallNode call2\n) {\n  multipleCallsToSuperclassMethod(meth, calledMulti, call1, call2, \"__del__\")\n}\n\nfrom\n  Function meth, Function calledMulti, DataFlow::MethodCallNode call1,\n  DataFlow::MethodCallNode call2, Function target1, Function target2, string msg\nwhere\n  multipleCallsToSuperclassDel(meth, calledMulti, call1, call2) and\n  // Only alert for the lowest method in the hierarchy that both calls will call.\n  not exists(Function subMulti |\n    multipleCallsToSuperclassDel(meth, subMulti, _, _) and\n    calledMulti.getScope() = getADirectSuperclass+(subMulti.getScope())\n  ) and\n  target1 = getDirectSuperCallTargetFromCall(meth.getScope(), meth, call1, _) and\n  target2 = getDirectSuperCallTargetFromCall(meth.getScope(), meth, call2, _) and\n  (\n    target1 != target2 and\n    msg =\n      \"This finalization method calls $@ multiple times, via $@ and $@, resolving to $@ and $@ respectively.\"\n    or\n    target1 = target2 and\n    // The targets themselves are called multiple times (either is calledMulti, or something earlier in the MRO)\n    // Mentioning them again would be redundant.\n    msg = \"This finalization method calls $@ multiple times, via $@ and $@.\"\n  )\nselect meth, msg, calledMulti, calledMulti.getQualifiedName(), call1, \"this call\", call2,\n  \"this call\", target1, target1.getQualifiedName(), target2, target2.getQualifiedName()",
        "description": "A duplicated call to a superclass `__del__` method may lead to class instances not be cleaned up properly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/CallsToInitDel/SuperclassDelCalledMultipleTimes.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport MethodCallOrder\n\npredicate multipleCallsToSuperclassInit(\n  Function meth, Function calledMulti, DataFlow::MethodCallNode call1,\n  DataFlow::MethodCallNode call2\n) {\n  multipleCallsToSuperclassMethod(meth, calledMulti, call1, call2, \"__init__\")\n}\n\nfrom\n  Function meth, Function calledMulti, DataFlow::MethodCallNode call1,\n  DataFlow::MethodCallNode call2, Function target1, Function target2, string msg\nwhere\n  multipleCallsToSuperclassInit(meth, calledMulti, call1, call2) and\n  // Only alert for the lowest method in the hierarchy that both calls will call.\n  not exists(Function subMulti |\n    multipleCallsToSuperclassInit(meth, subMulti, _, _) and\n    calledMulti.getScope() = getADirectSuperclass+(subMulti.getScope())\n  ) and\n  target1 = getDirectSuperCallTargetFromCall(meth.getScope(), meth, call1, _) and\n  target2 = getDirectSuperCallTargetFromCall(meth.getScope(), meth, call2, _) and\n  (\n    target1 != target2 and\n    msg =\n      \"This initialization method calls $@ multiple times, via $@ and $@, resolving to $@ and $@ respectively.\"\n    or\n    target1 = target2 and\n    // The targets themselves are called multiple times (either is calledMulti, or something earlier in the MRO)\n    // Mentioning them again would be redundant.\n    msg = \"This initialization method calls $@ multiple times, via $@ and $@.\"\n  )\nselect meth, msg, calledMulti, calledMulti.getQualifiedName(), call1, \"this call\", call2,\n  \"this call\", target1, target1.getQualifiedName(), target2, target2.getQualifiedName()",
        "description": "A duplicated call to a superclass `__init__` method may lead to objects of this class not being properly initialized.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/CallsToInitDel/SuperclassInitCalledMultipleTimes.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport MethodCallOrder\n\nFunction getDelMethod(Class c) {\n  result = c.getAMethod() and\n  result.getName() = \"__del__\"\n}\n\nfrom Class base, Function shouldCall, FunctionOption possibleIssue, string msg\nwhere\n  not exists(Function newMethod | newMethod = base.getAMethod() and newMethod.getName() = \"__new__\") and\n  exists(FunctionOption possiblyMissingSuper |\n    missingCallToSuperclassMethodRestricted(base, shouldCall, \"__del__\") and\n    possiblyMissingSuper = getPossibleMissingSuperOption(base, shouldCall, \"__del__\") and\n    (\n      not possiblyMissingSuper.isNone() and\n      possibleIssue = possiblyMissingSuper and\n      msg =\n        \"This class does not call $@ during finalization. ($@ may be missing a call to super().__del__)\"\n      or\n      possiblyMissingSuper.isNone() and\n      (\n        possibleIssue.asSome() = getDelMethod(base) and\n        msg =\n          \"This class does not call $@ during finalization. ($@ may be missing a call to a base class __del__)\"\n        or\n        not exists(getDelMethod(base)) and\n        possibleIssue.isNone() and\n        msg =\n          \"This class does not call $@ during finalization. (The class lacks an __del__ method to ensure every base class __del__ is called.)\"\n      )\n    )\n  )\nselect base, msg, shouldCall, shouldCall.getQualifiedName(), possibleIssue,\n  possibleIssue.getQualifiedName()",
        "description": "An omitted call to a superclass `__del__` method may lead to class instances not being cleaned up properly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/CallsToInitDel/MissingCallToDel.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.internal.DataFlowDispatch\nimport Classes.Equality\n\npredicate missingEquality(Class cls, Function defined, string missing) {\n  defined = cls.getMethod(\"__ne__\") and\n  not exists(cls.getMethod(\"__eq__\")) and\n  missing = \"__eq__\"\n  or\n  // In python 3, __ne__ automatically delegates to __eq__ if its not defined in the hierarchy\n  // However if it is defined in a superclass (and isn't a delegation method) then it will use the superclass method (which may be incorrect)\n  defined = cls.getMethod(\"__eq__\") and\n  not exists(cls.getMethod(\"__ne__\")) and\n  exists(Function neMeth |\n    neMeth = getADirectSuperclass+(cls).getMethod(\"__ne__\") and\n    not neMeth instanceof DelegatingEqualityMethod\n  ) and\n  missing = \"__ne__\"\n}\n\nfrom Class cls, Function defined, string missing\nwhere missingEquality(cls, defined, missing)\nselect cls, \"This class implements $@, but does not implement \" + missing + \".\", defined,\n  defined.getName()",
        "description": "Class definitions of equality and inequality operators may be inconsistent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/Comparisons/EqualsOrNotEquals.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.internal.DataFlowDispatch\nimport semmle.python.ApiGraphs\n\npredicate totalOrdering(Class cls) {\n  API::moduleImport(\"functools\")\n      .getMember(\"total_ordering\")\n      .asSource()\n      .flowsTo(DataFlow::exprNode(cls.getADecorator()))\n}\n\npredicate definesStrictOrdering(Class cls, Function meth) {\n  meth = cls.getMethod(\"__lt__\")\n  or\n  not exists(cls.getMethod(\"__lt__\")) and\n  meth = cls.getMethod(\"__gt__\")\n}\n\npredicate definesNonStrictOrdering(Class cls, Function meth) {\n  meth = cls.getMethod(\"__le__\")\n  or\n  not exists(cls.getMethod(\"__le__\")) and\n  meth = cls.getMethod(\"__ge__\")\n}\n\npredicate missingComparison(Class cls, Function defined, string missing) {\n  definesStrictOrdering(cls, defined) and\n  not definesNonStrictOrdering(getADirectSuperclass*(cls), _) and\n  missing = \"__le__ or __ge__\"\n  or\n  definesNonStrictOrdering(cls, defined) and\n  not definesStrictOrdering(getADirectSuperclass*(cls), _) and\n  missing = \"__lt__ or __gt__\"\n}\n\nfrom Class cls, Function defined, string missing\nwhere\n  not totalOrdering(cls) and\n  missingComparison(cls, defined, missing)\nselect cls, \"This class implements $@, but does not implement \" + missing + \".\", defined,\n  defined.getName()",
        "description": "Class defines ordering comparison methods, but does not define both strict and nonstrict ordering methods, to ensure all four comparison operators behave as expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/Comparisons/IncompleteOrdering.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate missingEquality(Class cls, Function defined) {\n  defined = cls.getMethod(\"__hash__\") and\n  not exists(cls.getMethod(\"__eq__\"))\n  // In python 3, the case of defined eq without hash automatically makes the class unhashable (even if a superclass defined hash)\n  // So this is not an issue.\n}\n\nfrom Class cls, Function defined\nwhere missingEquality(cls, defined)\nselect cls, \"This class implements $@, but does not implement __eq__.\", defined, defined.getName()",
        "description": "Defining a hash operation without defining equality may be a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/Comparisons/EqualsOrHash.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.internal.DataFlowDispatch\n\npredicate isSettableProperty(Function prop) {\n  isProperty(prop) and\n  exists(Function setter |\n    setter.getScope() = prop.getScope() and\n    setter.getName() = prop.getName() and\n    isSetter(setter)\n  )\n}\n\npredicate isSetter(Function f) {\n  exists(DataFlow::AttrRead attr |\n    f.getADecorator() = attr.asExpr() and\n    attr.getAttributeName() = \"setter\"\n  )\n}\n\npredicate isProperty(Function prop) {\n  prop.getADecorator() = API::builtin(\"property\").asSource().asExpr()\n}\n\npredicate shadowedBySuperclass(\n  Class cls, Class superclass, DataFlow::AttrWrite write, Function shadowed\n) {\n  getADirectSuperclass+(cls) = superclass and\n  shadowed = cls.getAMethod() and\n  exists(Function init |\n    init = superclass.getInitMethod() and\n    DataFlow::parameterNode(init.getArg(0)).(DataFlow::LocalSourceNode).flowsTo(write.getObject()) and\n    write.getAttributeName() = shadowed.getName()\n  ) and\n  // Allow cases in which the super class defines the method as well.\n  // We assume that the original method must have been defined for a reason.\n  not exists(Function superShadowed |\n    superShadowed = superclass.getAMethod() and\n    superShadowed.getName() = shadowed.getName()\n  ) and\n  // Allow properties if they have setters, as the write in the superclass will call the setter.\n  not isSettableProperty(shadowed) and\n  not isSetter(shadowed)\n}\n\nfrom Class cls, Class superclass, DataFlow::AttrWrite write, Function shadowed, string extra\nwhere\n  shadowedBySuperclass(cls, superclass, write, shadowed) and\n  (\n    if isProperty(shadowed)\n    then\n      // it's not a setter, so it's a read-only property\n      extra = \" (read-only property may cause an error if written to in the superclass)\"\n    else extra = \"\"\n  )\nselect shadowed, \"This method is shadowed by $@ in superclass $@.\" + extra, write,\n  \"attribute \" + write.getAttributeName(), superclass, superclass.getName()",
        "description": "Defining an attribute in a superclass method with a name that matches a subclass method, hides the method in the subclass.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/SubclassShadowing/SubclassShadowing.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.internal.DataFlowDispatch\n\npredicate initSelfCallOverridden(\n  Function init, DataFlow::Node self, DataFlow::MethodCallNode call, Function target,\n  Function override\n) {\n  init.isInitMethod() and\n  call.getScope() = init and\n  exists(Class superclass, Class subclass, DataFlow::ParameterNode selfArg |\n    superclass = init.getScope() and\n    subclass = override.getScope() and\n    subclass = getADirectSubclass+(superclass) and\n    selfArg.getParameter() = init.getArg(0) and\n    DataFlow::localFlow(selfArg, self) and\n    call.calls(self, override.getName()) and\n    target = superclass.getAMethod() and\n    target.getName() = override.getName()\n  )\n}\n\npredicate readsFromSelf(Function method) {\n  exists(DataFlow::ParameterNode self, DataFlow::Node sink |\n    self.getParameter() = method.getArg(0) and\n    DataFlow::localFlow(self, sink)\n  |\n    sink instanceof DataFlow::ArgumentNode\n    or\n    sink = any(DataFlow::AttrRead a).getObject()\n  )\n}\n\nfrom\n  Function init, DataFlow::Node self, DataFlow::MethodCallNode call, Function target,\n  Function override\nwhere\n  initSelfCallOverridden(init, self, call, target, override) and\n  readsFromSelf(override) and\n  not isClassmethod(override) and\n  not isStaticmethod(override) and\n  not target.getName().matches(\"\\\\_%\")\nselect call, \"This call to $@ in an initialization method is overridden by $@.\", target,\n  target.getQualifiedName(), override, override.getQualifiedName()",
        "description": "Calling a method from `__init__` that is overridden by a subclass may result in a partially initialized instance being observed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Classes/InitCallsSubclass/InitCallsSubclassMethod.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport FileNotAlwaysClosedQuery\nimport codeql.util.Option\n\nfrom FileOpen fo, string msg, LocatableOption<Location, DataFlow::Node>::Option exec\nwhere\n  fileNotClosed(fo) and\n  msg = \"File is opened but is not closed.\" and\n  exec.isNone()\n  or\n  fileMayNotBeClosedOnException(fo, exec.asSome()) and\n  msg = \"File may not be closed if $@ raises an exception.\"\nselect fo, msg, exec, \"this operation\"",
        "description": "Opening a file without ensuring that it is always closed may lead to data loss or resource leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Resources/FileNotAlwaysClosed.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nselect projectRoot(), count(PointsToBasedCallGraph::ResolvableCallRelevantTarget call)",
        "description": "The number of (relevant) calls that could be resolved to a callee that is relevant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/PointsToResolvableCallsRelevantTarget.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nfrom CallNode call, Target target\nwhere\n  target.isRelevant() and\n  call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target\nselect call, \"$@ to $@\", call, \"Call\", target, target.toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/TTCallGraph.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nfrom string tag, int c\nwhere\n  tag = \"SHARED\" and\n  c =\n    count(CallNode call, Target target |\n      target.isRelevant() and\n      call.(PointsToBasedCallGraph::ResolvableCall).getTarget() = target and\n      call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target\n    )\n  or\n  tag = \"NEW\" and\n  c =\n    count(CallNode call, Target target |\n      target.isRelevant() and\n      not call.(PointsToBasedCallGraph::ResolvableCall).getTarget() = target and\n      call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target\n    )\n  or\n  tag = \"MISSING\" and\n  c =\n    count(CallNode call, Target target |\n      target.isRelevant() and\n      call.(PointsToBasedCallGraph::ResolvableCall).getTarget() = target and\n      not call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target\n    )\nselect tag, c",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/TTCallGraphOverview.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nfrom CallNode call, Target target\nwhere\n  target.isRelevant() and\n  call.(PointsToBasedCallGraph::ResolvableCall).getTarget() = target and\n  call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target\nselect call, \"SHARED: $@ to $@\", call, \"Call\", target, target.toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/TTCallGraphShared.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nselect projectRoot(), count(PointsToBasedCallGraph::ResolvableCall call)",
        "description": "The number of (relevant) calls that can be resolved to a callee.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/PointsToResolvableCalls.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nfrom CallNode call, Target target\nwhere\n  target.isRelevant() and\n  call.(PointsToBasedCallGraph::ResolvableCall).getTarget() = target and\n  not call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target\nselect call, \"MISSING: $@ to $@\", call, \"Call\", target, target.toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/TTCallGraphMissing.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.FlowSummary\nimport meta.MetaMetrics\n\nfrom DataFlow::Node useSite, SummarizedCallable target, string kind\nwhere\n  (\n    useSite = target.getACall() and kind = \"Call\"\n    or\n    useSite = target.getACallback() and kind = \"Callback\"\n  ) and\n  not useSite.getLocation().getFile() instanceof IgnoredFile\nselect useSite, kind + \" to \" + target",
        "description": "A call site for which we have a summarized callable",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/SummarizedCallableCallSites.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nselect projectRoot(),\n  100.0 * count(PointsToBasedCallGraph::ResolvableCall call) / count(RelevantCall call).(float)",
        "description": "The percentage of (relevant) calls that can be resolved to a callee.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/PointsToResolvableCallRatio.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\nimport meta.MetaMetrics\n\nfrom DataFlowCall call, DataFlowCallable target\nwhere\n  target = viableCallable(call) and\n  not call.getLocation().getFile() instanceof IgnoredFile and\n  not target.getScope().getLocation().getFile() instanceof IgnoredFile\nselect call, \"Call to $@\", target.getScope(), target.toString()",
        "description": "An edge in the call graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/CallGraph.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nselect projectRoot(), count(RelevantCall call)",
        "description": "The number of (relevant) calls in the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/ResolvableCallCandidates.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nfrom CallNode call, Target target\nwhere\n  target.isRelevant() and\n  not call.(PointsToBasedCallGraph::ResolvableCall).getTarget() = target and\n  call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target and\n  1 < count(call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget())\nselect call, \"NEW: $@ to $@\", call, \"Call\", target, target.toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/TTCallGraphNewAmbiguous.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallGraphQuality\n\nfrom CallNode call, Target target\nwhere\n  target.isRelevant() and\n  not call.(PointsToBasedCallGraph::ResolvableCall).getTarget() = target and\n  call.(TypeTrackingBasedCallGraph::ResolvableCall).getTarget() = target\nselect call, \"NEW: $@ to $@\", call, \"Call\", target, target.toString()",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/analysis-quality/TTCallGraphNew.ql",
        "language": "python"
    },
    {
        "query": "private import python\nprivate import semmle.python.dataflow.new.DataFlow\nprivate import semmle.python.dataflow.new.RemoteFlowSources\nprivate import meta.MetaMetrics\n\nfrom RemoteFlowSource source\nwhere not source.getLocation().getFile() instanceof IgnoredFile\nselect source, \"RemoteFlowSource: \" + source.getSourceType()",
        "description": "Sources of remote user input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/alerts/RemoteFlowSources.ql",
        "language": "python"
    },
    {
        "query": "private import python\nprivate import semmle.python.dataflow.new.DataFlow\nprivate import semmle.python.Concepts\nprivate import meta.MetaMetrics\n\nfrom Http::Server::RequestHandler requestHandler, string title\nwhere\n  not requestHandler.getLocation().getFile() instanceof IgnoredFile and\n  if requestHandler.isMethod()\n  then\n    title = \"Method \" + requestHandler.getScope().(Class).getName() + \".\" + requestHandler.getName()\n  else title = requestHandler.toString()\nselect requestHandler, \"RequestHandler: \" + title",
        "description": "HTTP Server Request Handlers",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/alerts/RequestHandlers.ql",
        "language": "python"
    },
    {
        "query": "private import python\nprivate import semmle.python.dataflow.new.DataFlow\nprivate import Sinks\n\nfrom string kind\nselect taintSink(kind), kind + \" sink\"",
        "description": "Sinks from TaintTracking queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/alerts/TaintSinks.ql",
        "language": "python"
    },
    {
        "query": "private import python\nprivate import semmle.python.dataflow.new.DataFlow\nprivate import semmle.python.dataflow.new.TaintTracking\nprivate import semmle.python.dataflow.new.RemoteFlowSources\nprivate import meta.MetaMetrics\nprivate import semmle.python.dataflow.new.internal.PrintNode\n\nmodule RemoteFlowSourceReachConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) {\n    node instanceof RemoteFlowSource and\n    not node.getLocation().getFile() instanceof IgnoredFile\n  }\n\n  predicate isSink(DataFlow::Node node) {\n    not node.getLocation().getFile() instanceof IgnoredFile\n    // We could try to reduce the number of sinks in this configuration, by only\n    // allowing something that is on one end of a localFlowStep, readStep or storeStep,\n    // however, it's a brittle solution that requires us to remember to update this file\n    // if/when adding something new to the data-flow library.\n    //\n    // From testing on a few projects, trying to reduce the number of nodes, we only\n    // gain a reduction in the range of 40%, and while that's nice, it doesn't seem\n    // worth it to me for a meta query.\n  }\n}\n\nmodule RemoteFlowSourceReachFlow = TaintTracking::Global<RemoteFlowSourceReachConfig>;\n\nfrom DataFlow::Node reachable\nwhere RemoteFlowSourceReachFlow::flow(_, reachable)\nselect reachable, prettyNode(reachable)",
        "description": "Nodes that can be reached with taint tracking from sources of remote user input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/alerts/RemoteFlowSourcesReach.ql",
        "language": "python"
    },
    {
        "query": "private import python\nprivate import semmle.python.dataflow.new.DataFlow\nprivate import Sinks\n\nfrom string kind\nwhere not kind in [\"CleartextLogging\", \"LogInjection\"]\nselect taintSink(kind), kind + \" sink\"",
        "description": "Interesting sinks from TaintTracking queries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/alerts/InterestingTaintSinks.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nprivate import semmle.python.ApiGraphs\nimport semmle.python.frameworks.internal.SubclassFinder::NotExposed\nprivate import semmle.python.frameworks.Flask\nprivate import semmle.python.frameworks.FastApi\nprivate import semmle.python.frameworks.Django\nprivate import semmle.python.frameworks.Tornado\nprivate import semmle.python.frameworks.Stdlib\nprivate import semmle.python.frameworks.Requests\nprivate import semmle.python.frameworks.Starlette\nprivate import semmle.python.frameworks.ClickhouseDriver\nprivate import semmle.python.frameworks.Aiohttp\nprivate import semmle.python.frameworks.Fabric\nprivate import semmle.python.frameworks.Httpx\nprivate import semmle.python.frameworks.Invoke\nprivate import semmle.python.frameworks.MarkupSafe\nprivate import semmle.python.frameworks.Multidict\nprivate import semmle.python.frameworks.Pycurl\nprivate import semmle.python.frameworks.RestFramework\nprivate import semmle.python.frameworks.SqlAlchemy\nprivate import semmle.python.frameworks.Tornado\nprivate import semmle.python.frameworks.Urllib3\nprivate import semmle.python.frameworks.Pydantic\nprivate import semmle.python.frameworks.Peewee\nprivate import semmle.python.frameworks.Aioch\nprivate import semmle.python.frameworks.Lxml\nimport semmle.python.frameworks.data.internal.ApiGraphModelsExtensions as Extensions\n\nclass FlaskViewClasses extends FindSubclassesSpec {\n  FlaskViewClasses() { this = \"flask.View~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Flask::Views::View::subclassRef() }\n}\n\nclass FlaskMethodViewClasses extends FindSubclassesSpec {\n  FlaskMethodViewClasses() { this = \"flask.MethodView~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Flask::Views::MethodView::subclassRef() }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof FlaskViewClasses }\n\n  override string getFullyQualifiedName() { result = \"flask.views.MethodView\" }\n}\n\nclass FastApiRouter extends FindSubclassesSpec {\n  FastApiRouter() { this = \"fastapi.APIRouter~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = FastApi::ApiRouter::cls() }\n}\n\nclass DjangoForms extends FindSubclassesSpec {\n  DjangoForms() { this = \"django.forms.BaseForm~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = any(Django::Forms::Form::ModeledSubclass subclass)\n  }\n}\n\nclass DjangoView extends FindSubclassesSpec {\n  DjangoView() { this = \"Django.Views.View~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = any(Django::Views::View::ModeledSubclass subclass)\n  }\n}\n\nclass DjangoField extends FindSubclassesSpec {\n  DjangoField() { this = \"Django.Forms.Field~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = any(Django::Forms::Field::ModeledSubclass subclass)\n  }\n}\n\nclass DjangoModel extends FindSubclassesSpec {\n  DjangoModel() { this = \"Django.db.models.Model~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DB::Models::Model::subclassRef()\n  }\n}\n\nclass TornadoRequestHandler extends FindSubclassesSpec {\n  TornadoRequestHandler() { this = \"tornado.web.RequestHandler~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = Tornado::TornadoModule::Web::RequestHandler::subclassRef()\n  }\n}\n\nclass WSGIServer extends FindSubclassesSpec {\n  WSGIServer() { this = \"wsgiref.simple_server.WSGIServer~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = StdlibPrivate::WsgirefSimpleServer::subclassRef()\n  }\n}\n\nclass StdlibBaseHttpRequestHandler extends FindSubclassesSpec {\n  StdlibBaseHttpRequestHandler() { this = \"http.server.BaseHTTPRequestHandler~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = StdlibPrivate::BaseHttpRequestHandler::subclassRef()\n  }\n}\n\nclass StdlibCgiFieldStorage extends FindSubclassesSpec {\n  StdlibCgiFieldStorage() { this = \"cgi.FieldStorage~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = StdlibPrivate::Cgi::FieldStorage::subclassRef()\n  }\n}\n\nclass DjangoHttpResponse extends FindSubclassesSpec {\n  DjangoHttpResponse() { this = \"django.http.response.HttpResponse~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponse::classRef()\n  }\n}\n\nclass DjangoHttpResponseRedirect extends FindSubclassesSpec {\n  DjangoHttpResponseRedirect() { this = \"django.http.response.HttpResponseRedirect~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseRedirect::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseRedirect\" }\n}\n\nclass DjangoHttpResponsePermanentRedirect extends FindSubclassesSpec {\n  DjangoHttpResponsePermanentRedirect() {\n    this = \"django.http.response.HttpResponsePermanentRedirect~Subclass\"\n  }\n\n  override API::Node getAlreadyModeledClass() {\n    result =\n      PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponsePermanentRedirect::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() {\n    result = \"django.http.response.HttpResponsePermanentRedirect\"\n  }\n}\n\nclass DjangoHttpResponseNotModified extends FindSubclassesSpec {\n  DjangoHttpResponseNotModified() { this = \"django.http.response.HttpResponseNotModified~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseNotModified::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() {\n    result = \"django.http.response.HttpResponseNotModified\"\n  }\n}\n\nclass DjangoHttpResponseBadRequest extends FindSubclassesSpec {\n  DjangoHttpResponseBadRequest() { this = \"django.http.response.HttpResponseBadRequest~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseBadRequest::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseBadRequest\" }\n}\n\nclass DjangoHttpResponseNotFound extends FindSubclassesSpec {\n  DjangoHttpResponseNotFound() { this = \"django.http.response.HttpResponseNotFound~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseNotFound::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseNotFound\" }\n}\n\nclass DjangoHttpResponseForbidden extends FindSubclassesSpec {\n  DjangoHttpResponseForbidden() { this = \"django.http.response.HttpResponseForbidden~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseForbidden::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseForbidden\" }\n}\n\nclass DjangoHttpResponseNotAllowed extends FindSubclassesSpec {\n  DjangoHttpResponseNotAllowed() { this = \"django.http.response.HttpResponseNotAllowed~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseNotAllowed::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseNotAllowed\" }\n}\n\nclass DjangoHttpResponseGone extends FindSubclassesSpec {\n  DjangoHttpResponseGone() { this = \"django.http.response.HttpResponseGone~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseGone::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.HttpResponseGone\" }\n}\n\nclass DjangoHttpResponseServerError extends FindSubclassesSpec {\n  DjangoHttpResponseServerError() { this = \"django.http.response.HttpResponseServerError~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::HttpResponseServerError::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() {\n    result = \"django.http.response.HttpResponseServerError\"\n  }\n}\n\nclass DjangoHttpResponseJsonResponse extends FindSubclassesSpec {\n  DjangoHttpResponseJsonResponse() { this = \"django.http.response.JsonResponse~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::JsonResponse::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.JsonResponse\" }\n}\n\nclass DjangoHttpResponseStreamingResponse extends FindSubclassesSpec {\n  DjangoHttpResponseStreamingResponse() {\n    this = \"django.http.response.StreamingHttpResponse~Subclass\"\n  }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::StreamingHttpResponse::classRef()\n  }\n}\n\nclass DjangoHttpResponseFileResponse extends FindSubclassesSpec {\n  DjangoHttpResponseFileResponse() { this = \"django.http.response.FileResponse~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Response::FileResponse::classRef()\n  }\n\n  override FindSubclassesSpec getSuperClass() {\n    result instanceof DjangoHttpResponseStreamingResponse\n  }\n\n  override string getFullyQualifiedName() { result = \"django.http.response.FileResponse\" }\n}\n\nclass FlaskResponse extends FindSubclassesSpec {\n  FlaskResponse() { this = \"flask.Response~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Flask::Response::classRef() }\n}\n\nclass RequestsResponse extends FindSubclassesSpec {\n  RequestsResponse() { this = \"requests.models.Response~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Requests::Response::classRef() }\n}\n\nclass HttpClientHttpResponse extends FindSubclassesSpec {\n  HttpClientHttpResponse() { this = \"http.client.HTTPResponse~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::HttpResponse::classRef() }\n}\n\nclass StarletteWebsocket extends FindSubclassesSpec {\n  StarletteWebsocket() { this = \"starlette.websockets.WebSocket~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Starlette::WebSocket::classRef() }\n}\n\nclass StarletteUrl extends FindSubclassesSpec {\n  StarletteUrl() { this = \"starlette.requests.URL~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Starlette::Url::classRef() }\n}\n\nclass ClickhouseClient extends FindSubclassesSpec {\n  ClickhouseClient() { this = \"clickhouse_driver.client.Client~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = ClickhouseDriver::Client::subclassRef() }\n}\n\nclass AiohttpSession extends FindSubclassesSpec {\n  AiohttpSession() { this = \"aiohttp.ClientSession~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = AiohttpClientModel::ClientSession::classRef()\n  }\n}\n\nclass FabricConnection extends FindSubclassesSpec {\n  FabricConnection() { this = \"fabric.connection.Connection~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = FabricV2::Fabric::Connection::ConnectionClass::classRef()\n  }\n}\n\nclass DjangoRawSql extends FindSubclassesSpec {\n  DjangoRawSql() { this = \"django.db.models.expressions.RawSQL~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DB::Models::Expressions::RawSql::classRef()\n  }\n}\n\nclass DjangoHttpRequest extends FindSubclassesSpec {\n  DjangoHttpRequest() { this = \"django.http.request.HttpRequest~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DjangoHttp::Request::HttpRequest::classRef()\n  }\n}\n\nclass FlaskClass extends FindSubclassesSpec {\n  FlaskClass() { this = \"flask.Flask~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Flask::FlaskApp::classRef() }\n}\n\nclass FlaskBlueprint extends FindSubclassesSpec {\n  FlaskBlueprint() { this = \"flask.Blueprint~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Flask::Blueprint::classRef() }\n}\n\nclass HttpxClient extends FindSubclassesSpec {\n  HttpxClient() { this = \"httpx.Client~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = HttpxModel::Client::classRef() }\n}\n\nclass InvokeContext extends FindSubclassesSpec {\n  InvokeContext() { this = \"invoke.context.Context~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = Invoke::InvokeModule::Context::ContextClass::classRef()\n  }\n}\n\nclass MarkupSafe extends FindSubclassesSpec {\n  MarkupSafe() { this = \"markupsafe.Markup~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = MarkupSafeModel::Markup::classRef() }\n}\n\nclass Multidict extends FindSubclassesSpec {\n  Multidict() { this = \"multidict.MultiDictProxy~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Multidict::MultiDictProxy::classRef() }\n}\n\nclass PyCurl extends FindSubclassesSpec {\n  PyCurl() { this = \"pycurl.Curl~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Pycurl::Curl::classRef() }\n}\n\nclass RestFrameworkRequest extends FindSubclassesSpec {\n  RestFrameworkRequest() { this = \"rest_framework.request.Request~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = RestFramework::Request::classRef() }\n}\n\nclass RestFrameworkResponse extends FindSubclassesSpec {\n  RestFrameworkResponse() { this = \"rest_framework.response.Response~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = RestFramework::Response::classRef() }\n\n  override FindSubclassesSpec getSuperClass() { result instanceof DjangoHttpResponse }\n\n  override string getFullyQualifiedName() { result = \"rest_framework.response.Response\" }\n}\n\nclass SqlAlchemyEngine extends FindSubclassesSpec {\n  SqlAlchemyEngine() { this = \"sqlalchemy.engine.Engine~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = SqlAlchemy::Engine::classRef() }\n}\n\nclass SqlAlchemyConnection extends FindSubclassesSpec {\n  SqlAlchemyConnection() { this = \"sqlalchemy.engine.Connection~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = SqlAlchemy::Connection::classRef() }\n}\n\nclass SqlAlchemySession extends FindSubclassesSpec {\n  SqlAlchemySession() { this = \"sqlalchemy.orm.Session~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = SqlAlchemy::Session::classRef() }\n}\n\nclass UrlLibParseSplitResult extends FindSubclassesSpec {\n  UrlLibParseSplitResult() { this = \"urllib.parse.SplitResult~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Stdlib::SplitResult::classRef() }\n}\n\nclass StdlibHttpConnection extends FindSubclassesSpec {\n  StdlibHttpConnection() { this = \"http.client.HTTPConnection~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::HttpConnection::classRef() }\n}\n\nclass StringIO extends FindSubclassesSpec {\n  StringIO() { this = \"io.StringIO~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::StringIO::classRef() }\n}\n\nclass TornadoApplication extends FindSubclassesSpec {\n  TornadoApplication() { this = \"tornado.web.Application~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = Tornado::TornadoModule::Web::Application::classRef()\n  }\n}\n\nclass TornadoRequest extends FindSubclassesSpec {\n  TornadoRequest() { this = \"tornado.httputil.HttpServerRequest~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = Tornado::TornadoModule::HttpUtil::HttpServerRequest::classRef()\n  }\n}\n\nclass Urllib3PoolManager extends FindSubclassesSpec {\n  Urllib3PoolManager() { this = \"urllib3.PoolManager~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Urllib3::PoolManager::classRef() }\n}\n\nclass StdlibLogger extends FindSubclassesSpec {\n  StdlibLogger() { this = \"logging.Logger~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Stdlib::Logger::subclassRef() }\n}\n\nclass PydanticBaseModel extends FindSubclassesSpec {\n  PydanticBaseModel() { this = \"pydantic.BaseModel~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Pydantic::BaseModel::subclassRef() }\n}\n\nclass PeeweeDatabase extends FindSubclassesSpec {\n  PeeweeDatabase() { this = \"peewee.Database~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Peewee::Database::subclassRef() }\n}\n\nclass AiochClient extends FindSubclassesSpec {\n  AiochClient() { this = \"aioch.Client~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = Aioch::Client::subclassRef() }\n}\n\nclass AiohttpView extends FindSubclassesSpec {\n  AiohttpView() { this = \"aiohttp.web.View~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = AiohttpWebModel::View::subclassRef() }\n}\n\nclass DjangoFileField extends FindSubclassesSpec {\n  DjangoFileField() { this = \"django.db.models.FileField~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() {\n    result = PrivateDjango::DjangoImpl::DB::Models::FileField::subclassRef()\n  }\n}\n\nclass RestFrameworkApiException extends FindSubclassesSpec {\n  RestFrameworkApiException() { this = \"rest_framework.exceptions.APIException~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = RestFramework::ApiException::classRef() }\n}\n\nclass ElementTree extends FindSubclassesSpec {\n  ElementTree() { this = \"xml.etree.ElementTree~Subclass\" }\n\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::elementTreeClassRef() }\n}\n\nclass LxmlETreeAlias extends FindSubclassesSpec {\n  LxmlETreeAlias() { this = \"lxml.etree~Alias\" }\n\n  override API::Node getAlreadyModeledClass() { result = Lxml::etreeRef() }\n}\n\nclass PickleAlias extends FindSubclassesSpec {\n  PickleAlias() { this = \"pickle~Alias\" }\n\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::pickle() }\n}\n\nclass PickleLoadAlias extends FindSubclassesSpec {\n  PickleLoadAlias() { this = \"pickle.load~Alias\" }\n\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::pickle_load() }\n}\n\nclass PickleLoadsAlias extends FindSubclassesSpec {\n  PickleLoadsAlias() { this = \"pickle.loads~Alias\" }\n\n  override API::Node getAlreadyModeledClass() { result = StdlibPrivate::pickle_loads() }\n}\n\nbindingset[fullyQualified]\npredicate fullyQualifiedToYamlFormat(string fullyQualified, string type2, string path) {\n  exists(int firstDot | firstDot = fullyQualified.indexOf(\".\", 0, 0) |\n    type2 = fullyQualified.prefix(firstDot) and\n    path =\n      (\"Member[\" + fullyQualified.suffix(firstDot + 1).replaceAll(\".\", \"].Member[\") + \"]\")\n          .replaceAll(\".Member[__init__].\", \"\")\n          .replaceAll(\"Member[__init__].\", \"\")\n  )\n}\n\nfrom FindSubclassesSpec spec, string newModelFullyQualified, string type2, string path, Module mod\nwhere\n  newModel(spec, newModelFullyQualified, _, mod, _) and\n  not exists(FindSubclassesSpec subclass | subclass.getSuperClass() = spec |\n    // Since a class C which is a subclass for flask.MethodView is always a subclass of\n    // flask.View, and we chose to care about this distinction, in a naive approach we\n    // would always record rows for _both_ specs... that's just wasteful, so instead we\n    // only record the row for the more specific spec -- this is captured by the\n    // .getSuperClass() method on a spec, which can links specs together in this way.\n    // However, if the definition actually depends on some logic, like below, we should\n    // still record both rows\n    // ```\n    // if <cond>:\n    //     class C(flask.View): ...\n    // else:\n    //     class C(flask.MethodView): ...\n    // ```\n    newModel(subclass, newModelFullyQualified, _, mod, _)\n    or\n    // When defining specs for both foo.Foo and bar.Bar, and you encounter the class\n    // definition for Bar as `class Bar(foo.Foo): ...` inside `__init__.py` of the `bar`\n    // PyPI package, we would normally record this new class as being an unmodeled\n    // subclass of foo.Foo (since the class definition is not found when using\n    // API::moduleImport(\"bar\").getMember(\"Bar\")). However, we don't actually want to\n    // treat this as foo.Foo, since it's actually bar.Bar -- so we use the fully\n    // qualified name ot ignore cases such as this!\n    newModelFullyQualified = subclass.getFullyQualifiedName()\n  ) and\n  fullyQualifiedToYamlFormat(newModelFullyQualified, type2, path) and\n  not Extensions::typeModel(spec, type2, path) and\n  (\n    not newModelFullyQualified.regexpMatch(\"(?i).*tests?_?.*\")\n    or\n    type2 = \"find_subclass_test\"\n  )\nselect spec.(string), type2, path",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/ClassHierarchy/Find.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom string msg, int cnt, int sort\nwhere\n  sort = 0 and\n  msg = \"Lines of code in DB\" and\n  cnt = sum(Module m | | m.getMetrics().getNumberOfLinesOfCode())\n  or\n  sort = 1 and\n  msg = \"Lines of code in repo\" and\n  cnt =\n    sum(Module m | exists(m.getFile().getRelativePath()) | m.getMetrics().getNumberOfLinesOfCode())\n  or\n  sort = 2 and\n  msg = \"Files\" and\n  cnt = count(File f)\n  or\n  sort = 10 and msg = \"----------\" and cnt = 0\n  or\n  sort = 11 and\n  msg = \"Modules\" and\n  cnt = count(Module m)\n  or\n  sort = 12 and\n  msg = \"Classes\" and\n  cnt = count(Class c)\n  or\n  sort = 13 and\n  msg = \"Functions\" and\n  cnt = count(Function f)\n  or\n  sort = 14 and\n  msg = \"async functions\" and\n  cnt = count(Function f | f.isAsync())\n  or\n  sort = 15 and\n  msg = \"*args params\" and\n  cnt = count(Function f | f.hasVarArg())\n  or\n  sort = 16 and\n  msg = \"**kwargs params\" and\n  cnt = count(Function f | f.hasKwArg())\n  or\n  sort = 20 and msg = \"----------\" and cnt = 0\n  or\n  sort = 21 and\n  msg = \"call\" and\n  cnt = count(Call c)\n  or\n  sort = 22 and\n  msg = \"for loop\" and\n  cnt = count(For f)\n  or\n  sort = 23 and\n  msg = \"comprehension\" and\n  cnt = count(Comp c)\n  or\n  sort = 24 and\n  msg = \"attribute\" and\n  cnt = count(Attribute a)\n  or\n  sort = 25 and\n  msg = \"assignment\" and\n  cnt = count(Assign a)\n  or\n  sort = 26 and\n  msg = \"await\" and\n  cnt = count(Await a)\n  or\n  sort = 27 and\n  msg = \"yield\" and\n  cnt = count(Yield y)\n  or\n  sort = 28 and\n  msg = \"with\" and\n  cnt = count(With w)\n  or\n  sort = 29 and\n  msg = \"raise\" and\n  cnt = count(Raise r)\n  or\n  sort = 30 and\n  msg = \"return\" and\n  cnt = count(Return r)\n  or\n  sort = 31 and\n  msg = \"match\" and\n  cnt = count(MatchStmt m)\n  or\n  sort = 32 and\n  msg = \"from ... import ...\" and\n  cnt = count(Import i | i.isFromImport())\n  or\n  sort = 33 and\n  msg = \"import ...\" and\n  cnt = count(Import i | not i.isFromImport())\n  or\n  sort = 34 and\n  msg = \"import *\" and\n  cnt = count(ImportStar i)\nselect sort, msg, cnt order by sort",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/debug/DebugStats.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.internal.DataFlowPublic\nimport semmle.python.dataflow.new.internal.DataFlowPrivate\n\npredicate interestingClass(Class cls) {\n  cls.getName() = \"YourClassName\"\n  // and cls.getLocation().getFile().getAbsolutePath().matches(\"%/folder/file.py\")\n}\n\nquery predicate superClasses(Class cls, Class super_) {\n  interestingClass(cls) and\n  super_ = getADirectSuperclass+(cls)\n}\n\nquery predicate subClasses(Class cls, Class super_) {\n  interestingClass(cls) and\n  super_ = getADirectSubclass+(cls)\n}\n\nfrom Class cls\nwhere interestingClass(cls)\nselect cls",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/meta/debug/SimpleClassDebug.ql",
        "language": "python"
    },
    {
        "query": "import modeling.ModelEditor\n\nfrom Endpoint endpoint\nselect endpoint, endpoint.getNamespace(), endpoint.getClass(), endpoint.getFunctionName(),\n  endpoint.getParameters(), endpoint.getSupportedStatus(), endpoint.getFileName(),\n  endpoint.getSupportedType(), endpoint.getKind()",
        "description": "A list of endpoints accessible (methods and attributes) for consumers of the library. Excludes test and generated code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/utils/modeleditor/FrameworkModeEndpoints.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate is_simple_import(Import imp) { not exists(Attribute a | imp.contains(a)) }\n\npredicate double_import(Import original, Import duplicate, Module m) {\n  original != duplicate and\n  is_simple_import(original) and\n  is_simple_import(duplicate) and\n  /* Imports import the same thing */\n  exists(ImportExpr e1, ImportExpr e2 |\n    e1.getName() = m.getName() and\n    e2.getName() = m.getName() and\n    e1 = original.getAName().getValue() and\n    e2 = duplicate.getAName().getValue()\n  ) and\n  original.getAName().getAsname().(Name).getId() = duplicate.getAName().getAsname().(Name).getId() and\n  exists(Module enclosing |\n    original.getScope() = enclosing and\n    duplicate.getEnclosingModule() = enclosing and\n    (\n      /* Duplicate is not at top level scope */\n      duplicate.getScope() != enclosing\n      or\n      /* Original dominates duplicate */\n      original.getAnEntryNode().dominates(duplicate.getAnEntryNode())\n    )\n  )\n}\n\nfrom Import original, Import duplicate, Module m\nwhere double_import(original, duplicate, m)\nselect duplicate,\n  \"This import of module \" + m.getName() + \" is redundant, as it was previously imported $@.\",\n  original, \"on line \" + original.getLocation().getStartLine().toString()",
        "description": "Importing a module a second time has no effect and impairs readability",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/MultipleImports.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.filters.Tests\n\nfrom ImportMember im, ModuleValue m, AttrNode store_attr, string name\nwhere\n  m.importedAs(im.getModule().(ImportExpr).getImportedModuleName()) and\n  im.getName() = name and\n  /* Modification must be in a function, so it can occur during lifetime of the import value */\n  store_attr.getScope() instanceof Function and\n  /* variable resulting from import must have a long lifetime */\n  not im.getScope() instanceof Function and\n  store_attr.isStore() and\n  store_attr.getObject(name).pointsTo(m) and\n  /* Import not in same module as modification. */\n  not im.getEnclosingModule() = store_attr.getScope().getEnclosingModule() and\n  /* Modification is not in a test */\n  not store_attr.getScope().getScope*() instanceof TestScope\nselect im,\n  \"Importing the value of '\" + name +\n    \"' from $@ means that any change made to $@ will be not be observed locally.\", m,\n  \"module \" + m.getName(), store_attr, m.getName() + \".\" + store_attr.getName()",
        "description": "Importing the value of a mutable attribute directly means that changes in global state will not be observed locally.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/FromImportOfMutableAttribute.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Variables.Definition\nimport semmle.python.ApiGraphs\n\nprivate predicate is_pytest_fixture(Import imp, Variable name) {\n  exists(Alias a, API::Node pytest_fixture, API::Node decorator |\n    pytest_fixture = API::moduleImport(\"pytest\").getMember(\"fixture\") and\n    // The additional `.getReturn()` is to account for the difference between\n    // ```\n    // @pytest.fixture\n    // def foo():\n    //    ...\n    // ```\n    // and\n    // ```\n    // @pytest.fixture(some, args, here)\n    // def foo():\n    //    ...\n    // ```\n    decorator in [pytest_fixture, pytest_fixture.getReturn()] and\n    a = imp.getAName() and\n    a.getAsname().(Name).getVariable() = name and\n    a.getValue() = decorator.getReturn().getAValueReachableFromSource().asExpr()\n  )\n}\n\npredicate global_name_used(Module m, string name) {\n  exists(Name u, GlobalVariable v |\n    u.uses(v) and\n    v.getId() = name and\n    u.getEnclosingModule() = m\n  )\n  or\n  // A use of an undefined class local variable, will use the global variable\n  exists(Name u, LocalVariable v |\n    u.uses(v) and\n    v.getId() = name and\n    u.getEnclosingModule() = m and\n    not v.getScope().getEnclosingScope*() instanceof Function\n  )\n}\n\npredicate all_not_understood(Module m) {\n  exists(GlobalVariable a | a.getId() = \"__all__\" and a.getScope() = m |\n    // `__all__` is not defined as a simple list\n    not m.declaredInAll(_)\n    or\n    // `__all__` is modified\n    exists(Call c | c.getFunc().(Attribute).getObject() = a.getALoad())\n  )\n}\n\npredicate imported_module_used_in_doctest(Import imp) {\n  exists(string modname, string docstring |\n    imp.getAName().getAsname().(Name).getId() = modname and\n    // Look for doctests containing the patterns:\n    // >>> \u2026name\u2026\n    // ... \u2026name\u2026\n    docstring = doctest_in_scope(imp.getScope()) and\n    docstring.regexpMatch(\"[\\\\s\\\\S]*(>>>|\\\\.\\\\.\\\\.).*\" + modname + \"[\\\\s\\\\S]*\")\n  )\n}\n\npragma[noinline]\nprivate string doctest_in_scope(Scope scope) {\n  exists(StringLiteral doc |\n    doc.getEnclosingModule() = scope and\n    doc.isDocString() and\n    result = doc.getText() and\n    result.regexpMatch(\"[\\\\s\\\\S]*(>>>|\\\\.\\\\.\\\\.)[\\\\s\\\\S]*\")\n  )\n}\n\npragma[noinline]\nprivate string typehint_annotation_in_module(Module module_scope) {\n  exists(StringLiteral annotation |\n    annotation = any(Arguments a).getAnAnnotation().getASubExpression*()\n    or\n    annotation = any(AnnAssign a).getAnnotation().getASubExpression*()\n    or\n    annotation = any(FunctionExpr f).getReturns().getASubExpression*()\n  |\n    annotation.pointsTo(Value::forString(result)) and\n    annotation.getEnclosingModule() = module_scope\n  )\n}\n\npragma[noinline]\nprivate string typehint_comment_in_file(File file) {\n  exists(Comment typehint |\n    file = typehint.getLocation().getFile() and\n    result = typehint.getText() and\n    result.matches(\"# type:%\")\n  )\n}\n\npredicate imported_alias_used_in_typehint(Import imp, Variable name) {\n  imp.getAName().getAsname().(Name).getVariable() = name and\n  exists(File file, Module module_scope |\n    module_scope = imp.getEnclosingModule() and\n    file = module_scope.getFile()\n  |\n    // Look for type hints containing the patterns:\n    // # type: \u2026name\u2026\n    typehint_comment_in_file(file).regexpMatch(\"# type:.*\" + name.getId() + \".*\")\n    or\n    // Type hint is inside a string annotation, as needed for forward references\n    typehint_annotation_in_module(module_scope).regexpMatch(\".*\\\\b\" + name.getId() + \"\\\\b.*\")\n  )\n}\n\npredicate unused_import(Import imp, Variable name) {\n  imp.getAName().getAsname().(Name).getVariable() = name and\n  not imp.getAnImportedModuleName() = \"__future__\" and\n  not imp.getEnclosingModule().declaredInAll(name.getId()) and\n  imp.getScope() = imp.getEnclosingModule() and\n  not global_name_used(imp.getScope(), name.getId()) and\n  // Imports in `__init__.py` are used to force module loading\n  not imp.getEnclosingModule().isPackageInit() and\n  // Name may be imported for use in epytext documentation\n  not exists(Comment cmt | cmt.getText().matches(\"%L{\" + name.getId() + \"}%\") |\n    cmt.getLocation().getFile() = imp.getLocation().getFile()\n  ) and\n  not name_acceptable_for_unused_variable(name) and\n  // Assume that opaque `__all__` includes imported module\n  not all_not_understood(imp.getEnclosingModule()) and\n  not imported_module_used_in_doctest(imp) and\n  not imported_alias_used_in_typehint(imp, name) and\n  not is_pytest_fixture(imp, name) and\n  // Only consider import statements that actually point-to something (possibly an unknown module).\n  // If this is not the case, it's likely that the import statement never gets executed.\n  imp.getAName().getValue().pointsTo(_)\n}\n\nfrom Stmt s, Variable name\nwhere unused_import(s, name)\nselect s, \"Import of '\" + name.getId() + \"' is not used.\"",
        "description": "Import is not required as it is not used",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/UnusedImport.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Cyclic\n\nfrom ModuleValue m1, ModuleValue m2, Stmt imp\nwhere\n  imp.getEnclosingModule() = m1.getScope() and\n  stmt_imports(imp) = m2 and\n  circular_import(m1, m2) and\n  m1 != m2 and\n  // this query finds all cyclic imports that are *not* flagged by ModuleLevelCyclicImport\n  not failing_import_due_to_cycle(m2, m1, _, _, _, _) and\n  not exists(If i | i.isNameEqMain() and i.contains(imp))\nselect imp, \"Import of module $@ begins an import cycle.\", m2, m2.getName()",
        "description": "Module forms part of an import cycle, thereby indirectly importing itself.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/CyclicImport.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate shadowsImport(Variable l) {\n  exists(Import i, Name shadow |\n    shadow = i.getAName().getAsname() and\n    shadow.getId() = l.getId() and\n    i.getScope() = l.getScope().getScope*()\n  )\n}\n\nfrom Variable l, Name defn\nwhere shadowsImport(l) and defn.defines(l) and exists(For for | defn = for.getTarget())\nselect defn, \"Loop variable '\" + l.getId() + \"' shadows an import.\"",
        "description": "A loop variable shadows an import.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/ImportShadowedByLoopVar.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate modules_imports_itself(ImportingStmt i, ModuleValue m) {\n  i.getEnclosingModule() = m.getScope() and\n  m =\n    max(string s, ModuleValue m_ |\n      s = i.getAnImportedModuleName() and\n      m_.importedAs(s)\n    |\n      m_ order by s.length()\n    )\n}\n\nfrom ImportingStmt i, ModuleValue m\nwhere modules_imports_itself(i, m)\nselect i, \"The module '\" + m.getName() + \"' imports itself.\"",
        "description": "A module imports itself",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/ModuleImportsItself.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate multiple_import(Import imp) { count(imp.getAName()) > 1 and not imp.isFromImport() }\n\nfrom Import i\nwhere multiple_import(i)\nselect i, \"Multiple imports on one line.\"",
        "description": "Defining multiple imports on one line makes code more difficult to read; PEP8 states that imports should usually be on separate lines.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/Imports.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Cyclic\n\n// This is a potentially crashing bug if\n// 1. the imports in the whole cycle are lexically outside a def (and so executed at import time)\n// 2. there is a use ('M.foo' or 'from M import foo') of the imported module that is lexically outside a def\n// 3. 'foo' is defined in M after the import in M which completes the cycle.\n// then if we import the 'used' module, we will reach the cyclic import, start importing the 'using'\n// module, hit the 'use', and then crash due to the imported symbol not having been defined yet\nfrom ModuleValue m1, Stmt imp, ModuleValue m2, string attr, Expr use, ControlFlowNode defn\nwhere failing_import_due_to_cycle(m1, m2, imp, defn, use, attr)\nselect use,\n  \"'\" + attr + \"' may not be defined if module $@ is imported before module $@, as the $@ of \" +\n    attr + \" occurs after the cyclic $@ of \" + m2.getName() + \".\",\n  // Arguments for the placeholders in the above message:\n  m1, m1.getName(), m2, m2.getName(), defn, \"definition\", imp, \"import\"",
        "description": "Module uses member of cyclically imported module, which can lead to failure at import time.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/ModuleLevelCyclicImport.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ImportStar i\nselect i, \"Using 'from ... import *' pollutes the namespace.\"",
        "description": "Using import * prevents some analysis",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/ImportStarUsed.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate import_and_import_from(Import i1, Import i2, Module m) {\n  i1.getEnclosingModule() = i2.getEnclosingModule() and\n  exists(ImportExpr e1, ImportExpr e2, ImportMember im |\n    e1 = i1.getAName().getValue() and im = i2.getAName().getValue() and e2 = im.getModule()\n  |\n    e1.getName() = m.getName() and e2.getName() = m.getName()\n  )\n}\n\nfrom Stmt i1, Stmt i2, Module m\nwhere import_and_import_from(i1, i2, m)\nselect i1, \"Module '\" + m.getName() + \"' is imported with both 'import' and 'import from'.\"",
        "description": "A module is imported with the \"import\" and \"import from\" statements",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/ImportandImportFrom.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate import_star(ImportStar imp, ModuleValue exporter) {\n  exporter.importedAs(imp.getImportedModuleName())\n}\n\npredicate all_defined(ModuleValue exporter) {\n  exporter.isBuiltin()\n  or\n  exporter.getScope().(ImportTimeScope).definesName(\"__all__\")\n  or\n  exporter.getScope().getInitModule().(ImportTimeScope).definesName(\"__all__\")\n}\n\nfrom ImportStar imp, ModuleValue exporter\nwhere import_star(imp, exporter) and not all_defined(exporter) and not exporter.isAbsent()\nselect imp,\n  \"Import pollutes the enclosing namespace, as the imported module $@ does not define '__all__'.\",\n  exporter, exporter.getName()",
        "description": "Importing a module using 'import *' may unintentionally pollute the global namespace if the module does not define `__all__`",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/UnintentionalImport.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom SyntaxError error\nwhere not error instanceof EncodingError\nselect error, error.getMessage() + \" (in Python \" + major_version() + \").\"",
        "description": "Syntax errors cause failures at runtime and prevent analysis of the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/SyntaxError.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate deprecated_module(string name, string instead, int major, int minor) {\n  name = \"posixfile\" and instead = \"fcntl\" and major = 1 and minor = 5\n  or\n  name = \"gopherlib\" and instead = \"no replacement\" and major = 2 and minor = 5\n  or\n  name = \"rgbimgmodule\" and instead = \"no replacement\" and major = 2 and minor = 5\n  or\n  name = \"pre\" and instead = \"re\" and major = 1 and minor = 5\n  or\n  name = \"whrandom\" and instead = \"random\" and major = 2 and minor = 1\n  or\n  name = \"rfc822\" and instead = \"email\" and major = 2 and minor = 3\n  or\n  name = \"mimetools\" and instead = \"email\" and major = 2 and minor = 3\n  or\n  name = \"MimeWriter\" and instead = \"email\" and major = 2 and minor = 3\n  or\n  name = \"mimify\" and instead = \"email\" and major = 2 and minor = 3\n  or\n  name = \"rotor\" and instead = \"no replacement\" and major = 2 and minor = 4\n  or\n  name = \"statcache\" and instead = \"no replacement\" and major = 2 and minor = 2\n  or\n  name = \"mpz\" and instead = \"a third party\" and major = 2 and minor = 2\n  or\n  name = \"xreadlines\" and instead = \"no replacement\" and major = 2 and minor = 3\n  or\n  name = \"multifile\" and instead = \"email\" and major = 2 and minor = 5\n  or\n  name = \"sets\" and instead = \"builtins\" and major = 2 and minor = 6\n  or\n  name = \"buildtools\" and instead = \"no replacement\" and major = 2 and minor = 3\n  or\n  name = \"cfmfile\" and instead = \"no replacement\" and major = 2 and minor = 4\n  or\n  name = \"macfs\" and instead = \"no replacement\" and major = 2 and minor = 3\n  or\n  name = \"md5\" and instead = \"hashlib\" and major = 2 and minor = 5\n  or\n  name = \"sha\" and instead = \"hashlib\" and major = 2 and minor = 5\n}\n\nstring deprecation_message(string mod) {\n  exists(int major, int minor | deprecated_module(mod, _, major, minor) |\n    result =\n      \"The \" + mod + \" module was deprecated in version \" + major.toString() + \".\" +\n        minor.toString() + \".\"\n  )\n}\n\nstring replacement_message(string mod) {\n  exists(string instead | deprecated_module(mod, instead, _, _) |\n    result = \" Use \" + instead + \" module instead.\" and not instead = \"no replacement\"\n    or\n    result = \"\" and instead = \"no replacement\"\n  )\n}\n\nfrom ImportExpr imp, string name, string instead\nwhere\n  name = imp.getName() and\n  deprecated_module(name, instead, _, _) and\n  not exists(Try try, ExceptStmt except | except = try.getAHandler() |\n    except.getType().pointsTo(ClassValue::importError()) and\n    except.containsInScope(imp)\n  )\nselect imp, deprecation_message(name) + replacement_message(name)",
        "description": "Import of a deprecated module",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/DeprecatedModule.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom EncodingError error\nselect error, error.getMessage()",
        "description": "Encoding errors cause failures at runtime and prevent analysis of the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Imports/EncodingError.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\n\npredicate doesnt_reraise(ExceptStmt ex) { ex.getAFlowNode().getBasicBlock().reachesExit() }\n\npredicate catches_base_exception(ExceptStmt ex) {\n  ex.getType() = API::builtin(\"BaseException\").getAValueReachableFromSource().asExpr()\n  or\n  not exists(ex.getType())\n}\n\nfrom ExceptStmt ex\nwhere\n  catches_base_exception(ex) and\n  doesnt_reraise(ex)\nselect ex, \"Except block directly handles BaseException.\"",
        "description": "Handling 'BaseException' means that system exits and keyboard interrupts may be mis-handled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/CatchingBaseException.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\n\npredicate empty_except(ExceptStmt ex) {\n  not exists(Stmt s | s = ex.getAStmt() and not s instanceof Pass)\n}\n\npredicate no_else(ExceptStmt ex) { not exists(ex.getTry().getOrelse()) }\n\npredicate no_comment(ExceptStmt ex) {\n  not exists(Comment c |\n    c.getLocation().getFile() = ex.getLocation().getFile() and\n    c.getLocation().getStartLine() >= ex.getLocation().getStartLine() and\n    c.getLocation().getEndLine() <= ex.getBody().getLastItem().getLocation().getEndLine()\n  )\n}\n\npredicate non_local_control_flow(ExceptStmt ex) {\n  ex.getType() = API::builtin(\"StopIteration\").getAValueReachableFromSource().asExpr()\n}\n\npredicate try_has_normal_exit(Try try) {\n  exists(ControlFlowNode pred, ControlFlowNode succ |\n    /* Exists a non-exception predecessor, successor pair */\n    pred.getASuccessor() = succ and\n    not pred.getAnExceptionalSuccessor() = succ\n  |\n    /* Successor is either a normal flow node or a fall-through exit */\n    not exists(Scope s | s.getReturnNode() = succ) and\n    /* Predecessor is in try body and successor is not */\n    pred.getNode().getParentNode*() = try.getAStmt() and\n    not succ.getNode().getParentNode*() = try.getAStmt()\n  )\n}\n\npredicate attribute_access(Stmt s) {\n  s.(ExprStmt).getValue() instanceof Attribute\n  or\n  exists(string name | s.(ExprStmt).getValue().(Call).getFunc().(Name).getId() = name |\n    name = \"getattr\" or name = \"setattr\" or name = \"delattr\"\n  )\n  or\n  s.(Delete).getATarget() instanceof Attribute\n}\n\npredicate subscript(Stmt s) {\n  s.(ExprStmt).getValue() instanceof Subscript\n  or\n  s.(Delete).getATarget() instanceof Subscript\n}\n\npredicate encode_decode(Call ex, Expr type) {\n  exists(string name | ex.getFunc().(Attribute).getName() = name |\n    name = \"encode\" and\n    type = API::builtin(\"UnicodeEncodeError\").getAValueReachableFromSource().asExpr()\n    or\n    name = \"decode\" and\n    type = API::builtin(\"UnicodeDecodeError\").getAValueReachableFromSource().asExpr()\n  )\n}\n\npredicate small_handler(ExceptStmt ex, Stmt s, Expr type) {\n  not exists(ex.getTry().getStmt(1)) and\n  s = ex.getTry().getStmt(0) and\n  ex.getType() = type\n}\n\npredicate focussed_handler(ExceptStmt ex) {\n  exists(Stmt s, Expr type | small_handler(ex, s, type) |\n    subscript(s) and\n    type = API::builtin(\"IndexError\").getASubclass*().getAValueReachableFromSource().asExpr()\n    or\n    attribute_access(s) and\n    type = API::builtin(\"AttributeError\").getAValueReachableFromSource().asExpr()\n    or\n    s.(ExprStmt).getValue() instanceof Name and\n    type = API::builtin(\"NameError\").getAValueReachableFromSource().asExpr()\n    or\n    encode_decode(s.(ExprStmt).getValue(), type)\n  )\n}\n\nTry try_return() { not exists(result.getStmt(1)) and result.getStmt(0) instanceof Return }\n\nfrom ExceptStmt ex\nwhere\n  empty_except(ex) and\n  no_else(ex) and\n  no_comment(ex) and\n  not non_local_control_flow(ex) and\n  not ex.getTry() = try_return() and\n  try_has_normal_exit(ex.getTry()) and\n  not focussed_handler(ex)\nselect ex, \"'except' clause does nothing but pass and there is no explanatory comment.\"",
        "description": "Except doesn't do anything and has no comment",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/EmptyExcept.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\n\nfrom Raise r, DataFlow::LocalSourceNode origin\nwhere\n  exists(DataFlow::Node exception | exception.asExpr() = r.getException() |\n    origin.flowsTo(exception)\n  ) and\n  origin.asExpr() instanceof Tuple and\n  major_version() = 2\nselect r,\n  \"Raising a $@ will result in the first element (recursively) being raised and all other elements being discarded.\",\n  origin, \"tuple\"",
        "description": "Raising a tuple will result in all but the first element being discarded",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/RaisingTuple.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\n\npredicate raiseNotImplemented(Raise raise, Expr notImpl) {\n  exists(API::Node n | n = API::builtin(\"NotImplemented\") |\n    notImpl = n.getACall().asExpr()\n    or\n    n.asSource().flowsTo(DataFlow::exprNode(notImpl))\n  ) and\n  notImpl = raise.getException()\n}\n\nfrom Expr notimpl\nwhere raiseNotImplemented(_, notimpl)\nselect notimpl, \"NotImplemented is not an Exception. Did you mean NotImplementedError?\"",
        "description": "Using `NotImplemented` as an exception will result in a type error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/NotImplementedIsNotAnException.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.internal.DataFlowDispatch\nimport semmle.python.ApiGraphs\nimport semmle.python.frameworks.data.internal.ApiGraphModels\n\npredicate builtinException(string name) {\n  typeModel(\"builtins.BaseException~Subclass\", \"builtins.\" + name, \"\")\n}\n\npredicate builtinExceptionSubclass(string base, string sub) {\n  typeModel(\"builtins.\" + base + \"~Subclass\", \"builtins.\" + sub, \"\")\n}\n\nnewtype TExceptType =\n  TClass(Class c) or\n  TBuiltin(string name) { builtinException(name) }\n\nclass ExceptType extends TExceptType {\n  Class asClass() { this = TClass(result) }\n\n  string asBuiltinName() { this = TBuiltin(result) }\n\n  predicate isBuiltin() { this = TBuiltin(_) }\n\n  string getName() {\n    result = this.asClass().getName()\n    or\n    result = this.asBuiltinName()\n  }\n\n  string toString() { result = this.getName() }\n\n  DataFlow::Node getAUse() {\n    result = classTracker(this.asClass())\n    or\n    API::builtin(this.asBuiltinName()).asSource().flowsTo(result)\n  }\n\n  ExceptType getADirectSuperclass() {\n    result.asClass() = getADirectSuperclass(this.asClass())\n    or\n    result.isBuiltin() and\n    result.getAUse().asExpr() = this.asClass().getABase()\n    or\n    builtinExceptionSubclass(result.asBuiltinName(), this.asBuiltinName()) and\n    this != result\n  }\n\n  /**\n   * Holds if this element is at the specified location.\n   * The location spans column `startColumn` of line `startLine` to\n   * column `endColumn` of line `endLine` in file `filepath`.\n   * For more information, see\n   * [Providing locations in CodeQL queries](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).\n   */\n  predicate hasLocationInfo(\n    string filePath, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    this.asClass()\n        .getLocation()\n        .hasLocationInfo(filePath, startLine, startColumn, endLine, endColumn)\n    or\n    this.isBuiltin() and\n    filePath = \"\" and\n    startLine = 0 and\n    startColumn = 0 and\n    endLine = 0 and\n    endColumn = 0\n  }\n}\n\npredicate incorrectExceptOrder(ExceptStmt ex1, ExceptType cls1, ExceptStmt ex2, ExceptType cls2) {\n  exists(int i, int j, Try t |\n    ex1 = t.getHandler(i) and\n    ex2 = t.getHandler(j) and\n    i < j and\n    cls1 = exceptClass(ex1) and\n    cls2 = exceptClass(ex2) and\n    cls1 = cls2.getADirectSuperclass*()\n  )\n}\n\nExceptType exceptClass(ExceptStmt ex) { ex.getType() = result.getAUse().asExpr() }\n\nfrom ExceptStmt ex1, ExceptType cls1, ExceptStmt ex2, ExceptType cls2, string msg\nwhere\n  incorrectExceptOrder(ex1, cls1, ex2, cls2) and\n  if cls1 = cls2\n  then msg = \"This except block handling $@ is unreachable; as $@ also handles $@.\"\n  else\n    msg =\n      \"This except block handling $@ is unreachable; as $@ for the more general $@ always subsumes it.\"\nselect ex2, msg, cls2, cls2.getName(), ex1, \"this except block\", cls1, cls1.getName()",
        "description": "Handling general exceptions before specific exceptions means that the specific handlers are never executed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/IncorrectExceptOrder.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ExceptFlowNode ex, Value t, ClassValue c, ControlFlowNode origin, string what\nwhere\n  ex.handledException(t, c, origin) and\n  (\n    exists(ClassValue x | x = t |\n      not x.isLegalExceptionType() and\n      not x.failedInference(_) and\n      what = \"class '\" + x.getName() + \"'\"\n    )\n    or\n    not t instanceof ClassValue and\n    what = \"instance of '\" + c.getName() + \"'\"\n  )\nselect ex.getNode(),\n  \"Non-exception $@ in exception handler which will never match raised exception.\", origin, what",
        "description": "An exception handler specifying a non-exception type will never handle any exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/IllegalExceptionHandlerType.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Raising\nimport Exceptions.NotImplemented\n\nfrom Raise r, ClassValue t\nwhere\n  type_or_typeof(r, t, _) and\n  not t.isLegalExceptionType() and\n  not t.failedInference(_) and\n  not use_of_not_implemented_in_raise(r, _)\nselect r,\n  \"Illegal class '\" + t.getName() + \"' raised; will result in a TypeError being raised instead.\"",
        "description": "Raising a non-exception object or type will result in a TypeError being raised instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/IllegalRaise.ql",
        "language": "python"
    },
    {
        "query": "import python\nprivate import semmle.python.ApiGraphs\n\nAPI::Node iter() { result = API::builtin(\"iter\") }\n\nAPI::Node next() { result = API::builtin(\"next\") }\n\nAPI::Node stopIteration() { result = API::builtin(\"StopIteration\") }\n\npredicate call_to_iter(CallNode call, EssaVariable sequence) {\n  call = iter().getACall().asCfgNode() and\n  call.getArg(0) = sequence.getAUse()\n}\n\npredicate call_to_next(CallNode call, ControlFlowNode iter) {\n  call = next().getACall().asCfgNode() and\n  call.getArg(0) = iter\n}\n\npredicate call_to_next_has_default(CallNode call) {\n  exists(call.getArg(1)) or exists(call.getArgByName(\"default\"))\n}\n\npredicate guarded_not_empty_sequence(EssaVariable sequence) {\n  sequence.getDefinition() instanceof EssaEdgeRefinement\n}\n\npredicate iter_not_exhausted(EssaVariable iterator) {\n  exists(EssaVariable sequence |\n    call_to_iter(iterator.getDefinition().(AssignmentDefinition).getValue(), sequence) and\n    guarded_not_empty_sequence(sequence)\n  )\n}\n\npredicate stop_iteration_handled(CallNode call) {\n  exists(Try t |\n    t.containsInScope(call.getNode()) and\n    t.getAHandler().getType() = stopIteration().getAValueReachableFromSource().asExpr()\n  )\n}\n\nfrom CallNode call\nwhere\n  call_to_next(call, _) and\n  not call_to_next_has_default(call) and\n  not exists(EssaVariable iterator |\n    call_to_next(call, iterator.getAUse()) and\n    iter_not_exhausted(iterator)\n  ) and\n  call.getNode().getScope().(Function).isGenerator() and\n  not exists(Comp comp | comp.contains(call.getNode())) and\n  not stop_iteration_handled(call) and\n  // PEP 479 removes this concern from 3.7 onwards\n  // see: https://peps.python.org/pep-0479/\n  //\n  // However, we do not know the minor version of the analyzed code (only of the extractor),\n  // so we only alert on Python 2.\n  major_version() = 2\nselect call, \"Call to 'next()' in a generator.\"",
        "description": "Calling next() in a generator may cause unintended early termination of an iteration.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Exceptions/UnguardedNextInGenerator.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate callToAssertOnComparison(Call call, string assertName, Cmpop op) {\n  call.getFunc().(Attribute).getName() = assertName and\n  (assertName = \"assertTrue\" or assertName = \"assertFalse\") and\n  exists(Compare cmp |\n    cmp = call.getArg(0) and\n    /* Exclude complex comparisons like: a < b < c */\n    not exists(cmp.getOp(1)) and\n    op = cmp.getOp(0)\n  )\n}\n\nclass CallToAssertOnComparison extends Call {\n  CallToAssertOnComparison() { callToAssertOnComparison(this, _, _) }\n\n  Cmpop getOperator() { callToAssertOnComparison(this, _, result) }\n\n  string getMethodName() { callToAssertOnComparison(this, result, _) }\n\n  string getBetterName() {\n    exists(Cmpop op |\n      callToAssertOnComparison(this, \"assertTrue\", op) and\n      (\n        op instanceof Eq and result = \"assertEqual\"\n        or\n        op instanceof NotEq and result = \"assertNotEqual\"\n        or\n        op instanceof Lt and result = \"assertLess\"\n        or\n        op instanceof LtE and result = \"assertLessEqual\"\n        or\n        op instanceof Gt and result = \"assertGreater\"\n        or\n        op instanceof GtE and result = \"assertGreaterEqual\"\n        or\n        op instanceof In and result = \"assertIn\"\n        or\n        op instanceof NotIn and result = \"assertNotIn\"\n        or\n        op instanceof Is and result = \"assertIs\"\n        or\n        op instanceof IsNot and result = \"assertIsNot\"\n      )\n      or\n      callToAssertOnComparison(this, \"assertFalse\", op) and\n      (\n        op instanceof NotEq and result = \"assertEqual\"\n        or\n        op instanceof Eq and result = \"assertNotEqual\"\n        or\n        op instanceof GtE and result = \"assertLess\"\n        or\n        op instanceof Gt and result = \"assertLessEqual\"\n        or\n        op instanceof LtE and result = \"assertGreater\"\n        or\n        op instanceof Lt and result = \"assertGreaterEqual\"\n        or\n        op instanceof NotIn and result = \"assertIn\"\n        or\n        op instanceof In and result = \"assertNotIn\"\n        or\n        op instanceof IsNot and result = \"assertIs\"\n        or\n        op instanceof Is and result = \"assertIsNot\"\n      )\n    )\n  }\n}\n\nfrom CallToAssertOnComparison call\nwhere\n  /* Exclude cases where an explicit message is provided*/\n  not exists(call.getArg(1))\nselect call,\n  call.getMethodName() + \"(a \" + call.getOperator().getSymbol() + \" b) \" +\n    \"cannot provide an informative message. Using \" + call.getBetterName() +\n    \"(a, b) instead will give more informative messages.\"",
        "description": "Using 'assertTrue' or 'assertFalse' rather than a more specific assertion can give uninformative failure messages.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Testing/ImpreciseAssert.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nDataFlow::ExprNode squareOp() {\n  exists(BinaryExpr e | e = result.asExpr() |\n    e.getOp() instanceof Pow and e.getRight().(IntegerLiteral).getN() = \"2\"\n  )\n}\n\nDataFlow::ExprNode squareMul() {\n  exists(BinaryExpr e | e = result.asExpr() |\n    e.getOp() instanceof Mult and e.getRight().(Name).getId() = e.getLeft().(Name).getId()\n  )\n}\n\nDataFlow::ExprNode square() { result in [squareOp(), squareMul()] }\n\nfrom DataFlow::CallCfgNode c, BinaryExpr s, DataFlow::ExprNode left, DataFlow::ExprNode right\nwhere\n  c = API::moduleImport(\"math\").getMember(\"sqrt\").getACall() and\n  c.getArg(0).asExpr() = s and\n  s.getOp() instanceof Add and\n  left.asExpr() = s.getLeft() and\n  right.asExpr() = s.getRight() and\n  left.getALocalSource() = square() and\n  right.getALocalSource() = square()\nselect c, \"Pythagorean calculation with sub-optimal numerics.\"",
        "description": "Calculating the length of the hypotenuse using the standard formula may lead to overflow.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Numerics/Pythagorean.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate typing_import(ImportingStmt is) {\n  exists(Module m |\n    is.getScope() = m and\n    exists(TypeHintComment tc | tc.getLocation().getFile() = m.getFile())\n  )\n}\n\npredicate unique_yield(Stmt s) {\n  exists(Yield y | s.contains(y)) and\n  exists(Function f |\n    f = s.getScope() and\n    strictcount(Yield y | f.containsInScope(y)) = 1\n  )\n}\n\npredicate suppression_in_scope(Stmt s) {\n  exists(With w |\n    w.getContextExpr().(Call).getFunc().pointsTo(Value::named(\"contextlib.suppress\")) and\n    w.getScope() = s.getScope()\n  )\n}\n\npredicate marks_an_impossible_else_branch(Stmt s) {\n  exists(If i | i.getOrelse().getItem(0) = s |\n    s.(Assert).getTest() instanceof False\n    or\n    s instanceof Raise\n  )\n}\n\npredicate reportable_unreachable(Stmt s) {\n  s.isUnreachable() and\n  not typing_import(s) and\n  not suppression_in_scope(s) and\n  not exists(Stmt other | other.isUnreachable() |\n    other.contains(s)\n    or\n    exists(StmtList l, int i, int j | l.getItem(i) = other and l.getItem(j) = s and i < j)\n  ) and\n  not unique_yield(s) and\n  not marks_an_impossible_else_branch(s)\n}\n\nfrom Stmt s\nwhere reportable_unreachable(s)\nselect s, \"This statement is unreachable.\"",
        "description": "Code is unreachable",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/UnreachableCode.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Assert a, string b, string non\nwhere\n  a.getTest() instanceof Tuple and\n  (\n    if exists(a.getTest().(Tuple).getAnElt())\n    then (\n      b = \"True\" and non = \"non-\"\n    ) else (\n      b = \"False\" and non = \"\"\n    )\n  )\nselect a, \"Assertion of \" + non + \"empty tuple is always \" + b + \".\"",
        "description": "Using an assert statement to test a tuple provides no validity checking.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/AssertOnTuple.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Expr e, Location l, string kind, string what\nwhere\n  e.isParenthesized() and\n  not e instanceof Tuple and\n  (\n    exists(If i | i.getTest() = e) and kind = \"if\" and what = \"condition\"\n    or\n    exists(While w | w.getTest() = e) and kind = \"while\" and what = \"condition\"\n    or\n    exists(Return r | r.getValue() = e) and kind = \"return\" and what = \"value\"\n    or\n    exists(Assert a | a.getTest() = e and not exists(a.getMsg())) and\n    kind = \"assert\" and\n    what = \"test\"\n  ) and\n  // These require parentheses\n  (not e instanceof Yield and not e instanceof YieldFrom and not e instanceof GeneratorExp) and\n  l = e.getLocation() and\n  l.getStartLine() = l.getEndLine()\nselect e, \"Parenthesized \" + what + \" in '\" + kind + \"' statement.\"",
        "description": "Putting parentheses around a condition in an 'if' or 'while' statement is unnecessary and harder to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/C_StyleParentheses.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate assignment(AssignStmt a, Expr left, Expr right) {\n  a.getATarget() = left and a.getValue() = right\n}\n\npredicate corresponding(Expr left, Expr right) {\n  assignment(_, left, right)\n  or\n  exists(Attribute la, Attribute ra |\n    corresponding(la, ra) and\n    left = la.getObject() and\n    right = ra.getObject()\n  )\n}\n\npredicate same_value(Expr left, Expr right) {\n  same_name(left, right)\n  or\n  same_attribute(left, right)\n}\n\npredicate maybe_defined_in_outer_scope(Name n) {\n  exists(SsaVariable v | v.getAUse().getNode() = n | v.maybeUndefined())\n}\n\n\npredicate isBuiltin(string name) { exists(Value v | v = Value::named(name) and v.isBuiltin()) }\n\npredicate same_name(Name n1, Name n2) {\n  corresponding(n1, n2) and\n  n1.getVariable() = n2.getVariable() and\n  not isBuiltin(n1.getId()) and\n  not maybe_defined_in_outer_scope(n2)\n}\n\nClassValue value_type(Attribute a) { a.getObject().pointsTo().getClass() = result }\n\npredicate is_property_access(Attribute a) {\n  value_type(a).lookup(a.getName()) instanceof PropertyValue\n}\n\npredicate same_attribute(Attribute a1, Attribute a2) {\n  corresponding(a1, a2) and\n  a1.getName() = a2.getName() and\n  same_value(a1.getObject(), a2.getObject()) and\n  exists(value_type(a1)) and\n  not is_property_access(a1)\n}\n\npragma[nomagic]\nComment pyflakes_comment() { result.getText().toLowerCase().matches(\"%pyflakes%\") }\n\nint pyflakes_commented_line(File file) {\n  pyflakes_comment().getLocation().hasLocationInfo(file.getAbsolutePath(), result, _, _, _)\n}\n\npredicate pyflakes_commented(AssignStmt assignment) {\n  exists(Location loc |\n    assignment.getLocation() = loc and\n    loc.getStartLine() = pyflakes_commented_line(loc.getFile())\n  )\n}\n\npredicate side_effecting_lhs(Attribute lhs) {\n  exists(ClassValue cls, ClassValue decl |\n    lhs.getObject().pointsTo().getClass() = cls and\n    decl = cls.getASuperType() and\n    not decl.isBuiltin()\n  |\n    decl.declaresAttribute(\"__setattr__\")\n  )\n}\n\nfrom AssignStmt a, Expr left, Expr right\nwhere\n  assignment(a, left, right) and\n  same_value(left, right) and\n  // some people use self-assignment to shut Pyflakes up, such as `ok = ok # Pyflakes`\n  not pyflakes_commented(a) and\n  not side_effecting_lhs(left)\nselect a, \"This assignment assigns a variable to itself.\"",
        "description": "Assigning a variable to itself is useless and very likely indicates an error in the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/RedundantAssignment.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate originIsLocals(ControlFlowNode n) { n.pointsTo(_, _, Value::named(\"locals\").getACall()) }\n\npredicate modification_of_locals(ControlFlowNode f) {\n  originIsLocals(f.(SubscriptNode).getObject()) and\n  (f.isStore() or f.isDelete())\n  or\n  exists(string mname, AttrNode attr |\n    attr = f.(CallNode).getFunction() and\n    originIsLocals(attr.getObject(mname))\n  |\n    mname in [\"pop\", \"popitem\", \"update\", \"clear\"]\n  )\n}\n\nfrom AstNode a, ControlFlowNode f\nwhere\n  modification_of_locals(f) and\n  a = f.getNode() and\n  // in module level scope `locals() == globals()`\n  // see https://docs.python.org/3/library/functions.html#locals\n  // FP report in https://github.com/github/codeql/issues/6674\n  not a.getScope() instanceof ModuleScope\nselect a, \"Modification of the locals() dictionary will have no effect on the local variables.\"",
        "description": "Modifications of the dictionary returned by locals() are not propagated to the local variables of a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/ModificationOfLocals.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Stmt loop, StmtList body, StmtList clause, string kind\nwhere\n  (\n    exists(For f | f = loop | clause = f.getOrelse() and body = f.getBody() and kind = \"for\")\n    or\n    exists(While w | w = loop | clause = w.getOrelse() and body = w.getBody() and kind = \"while\")\n  ) and\n  not exists(Break b | body.contains(b))\nselect loop,\n  \"This '\" + kind + \"' statement has a redundant 'else' as no 'break' is present in the body.\"",
        "description": "An 'else' clause in a 'for' or 'while' statement that does not contain a 'break' is redundant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/UnnecessaryElseClause.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nprivate int len(ExprList el) { result = count(el.getAnItem()) }\n\npredicate mismatched(Assign a, int lcount, int rcount, Location loc, string sequenceType) {\n  exists(ExprList l, ExprList r |\n    (\n      a.getATarget().(Tuple).getElts() = l or\n      a.getATarget().(List).getElts() = l\n    ) and\n    (\n      a.getValue().(Tuple).getElts() = r and sequenceType = \"tuple\"\n      or\n      a.getValue().(List).getElts() = r and sequenceType = \"list\"\n    ) and\n    loc = a.getValue().getLocation() and\n    lcount = len(l) and\n    rcount = len(r) and\n    lcount != rcount and\n    not exists(Starred s | l.getAnItem() = s or r.getAnItem() = s)\n  )\n}\n\npredicate mismatched_tuple_rhs(Assign a, int lcount, int rcount, Location loc) {\n  exists(ExprList l, TupleValue r, AstNode origin |\n    (\n      a.getATarget().(Tuple).getElts() = l or\n      a.getATarget().(List).getElts() = l\n    ) and\n    a.getValue().pointsTo(r, origin) and\n    loc = origin.getLocation() and\n    lcount = len(l) and\n    rcount = r.length() and\n    lcount != rcount and\n    not l.getAnItem() instanceof Starred\n  )\n}\n\nfrom Assign a, int lcount, int rcount, Location loc, string sequenceType\nwhere\n  mismatched(a, lcount, rcount, loc, sequenceType)\n  or\n  mismatched_tuple_rhs(a, lcount, rcount, loc) and\n  sequenceType = \"tuple\"\nselect a,\n  \"Left hand side of assignment contains \" + lcount +\n    \" variables, but right hand side is a $@ of length \" + rcount + \".\", loc, sequenceType",
        "description": "Assigning multiple variables without ensuring that you define a value for each variable causes an exception at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/MismatchInMultipleAssignment.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.filters.Tests\n\npredicate has_string_type(Value v) {\n  v.getClass() = ClassValue::str()\n  or\n  v.getClass() = ClassValue::unicode() and major_version() = 2\n}\n\nfrom\n  For loop, ControlFlowNode iter, Value str, Value seq, ControlFlowNode seq_origin,\n  ControlFlowNode str_origin\nwhere\n  loop.getIter().getAFlowNode() = iter and\n  iter.pointsTo(str, str_origin) and\n  iter.pointsTo(seq, seq_origin) and\n  has_string_type(str) and\n  seq.getClass().isIterable() and\n  not has_string_type(seq) and\n  // suppress occurrences from tests\n  not seq_origin.getScope().getScope*() instanceof TestScope and\n  not str_origin.getScope().getScope*() instanceof TestScope\nselect loop,\n  \"Iteration over $@, of class \" + seq.getClass().getName() + \", may also iterate over $@.\",\n  seq_origin, \"sequence\", str_origin, \"string\"",
        "description": "Iteration over either a string or a sequence in the same loop can cause errors that are hard to find.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/IterableStringOrSequence.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Call call, ClassValue ex\nwhere\n  call.getFunc().pointsTo(ex) and\n  ex.getASuperType() = ClassValue::exception() and\n  exists(ExprStmt s | s.getValue() = call)\nselect call, \"Instantiating an exception, but not raising it, has no effect.\"",
        "description": "An exception object is created, but is not used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/UnusedExceptionObject.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate calls_close(Call c) { exists(Attribute a | c.getFunc() = a and a.getName() = \"close\") }\n\npredicate only_stmt_in_finally(Try t, Call c) {\n  exists(ExprStmt s |\n    t.getAFinalstmt() = s and s.getValue() = c and strictcount(t.getAFinalstmt()) = 1\n  )\n}\n\npredicate points_to_context_manager(ControlFlowNode f, ClassValue cls) {\n  forex(Value v | f.pointsTo(v) | v.getClass() = cls) and\n  cls.isContextManager()\n}\n\nfrom Call close, Try t, ClassValue cls\nwhere\n  only_stmt_in_finally(t, close) and\n  calls_close(close) and\n  exists(ControlFlowNode f | f = close.getFunc().getAFlowNode().(AttrNode).getObject() |\n    points_to_context_manager(f, cls)\n  )\nselect close,\n  \"Instance of context-manager class $@ is closed in a finally block. Consider using 'with' statement.\",\n  cls, cls.getName()",
        "description": "Using a 'try-finally' block to ensure only that a resource is closed makes code more difficult to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/ShouldUseWithStatement.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom AstNode node, string kind\nwhere\n  not node.getScope() instanceof Function and\n  (\n    node instanceof Return and kind = \"return\"\n    or\n    node instanceof Yield and kind = \"yield\"\n    or\n    node instanceof YieldFrom and kind = \"yield from\"\n  )\nselect node, \"'\" + kind + \"' is used outside a function.\"",
        "description": "Using 'return' or 'yield' outside a function causes a 'SyntaxError' at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/ReturnOrYieldOutsideFunction.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.filters.Tests\n\nfrom Assert a, string value\nwhere\n  /* Exclude asserts inside test cases */\n  not a.getScope().getScope*() instanceof TestScope and\n  exists(Expr test | test = a.getTest() |\n    value = test.(IntegerLiteral).getN()\n    or\n    value = \"\\\"\" + test.(StringLiteral).getS() + \"\\\"\"\n    or\n    value = test.(NameConstant).toString()\n  ) and\n  /* Exclude asserts appearing at the end of a chain of `elif`s */\n  not exists(If i | i.getElif().getAnOrelse() = a)\nselect a, \"Assert of literal constant \" + value + \".\"",
        "description": "An assert statement testing a literal constant value may exhibit different behavior when optimizations are enabled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/AssertLiteralConstant.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate loop_variable_ssa(For f, Variable v, SsaVariable s) {\n  f.getTarget().getAFlowNode() = s.getDefinition() and v = s.getVariable()\n}\n\npredicate variableUsedInNestedLoops(For inner, For outer, Variable v, Name n) {\n  /* Ignore cases where there is no use of the variable or the only use is in the inner loop. */\n  outer.contains(n) and\n  not inner.contains(n) and\n  /* Only treat loops in body as inner loops. Loops in the else clause are ignored. */\n  outer.getBody().contains(inner) and\n  exists(SsaVariable s |\n    loop_variable_ssa(inner, v, s.getAnUltimateDefinition()) and\n    loop_variable_ssa(outer, v, _) and\n    s.getAUse().getNode() = n\n  )\n}\n\nfrom For inner, For outer, Variable v, Name n\nwhere variableUsedInNestedLoops(inner, outer, v, n)\nselect inner, \"Nested for statement $@ loop variable '\" + v.getId() + \"' of enclosing $@.\", n,\n  \"uses\", outer, \"for statement\"",
        "description": "Redefining a variable in an inner loop and then using the variable in an outer loop causes unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/NestedLoopsSameVariableWithReuse.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate needs_docstring(Scope s) {\n  s.isPublic() and\n  (\n    not s instanceof Function\n    or\n    function_needs_docstring(s)\n  )\n}\n\npredicate function_needs_docstring(Function f) {\n  not exists(FunctionValue fo, FunctionValue base | fo.overrides(base) and fo.getScope() = f |\n    not function_needs_docstring(base.getScope())\n  ) and\n  f.getName() != \"lambda\" and\n  (f.getMetrics().getNumberOfLinesOfCode() - count(f.getADecorator())) > 2 and\n  not exists(PythonPropertyObject p |\n    p.getGetter().getFunction() = f or\n    p.getSetter().getFunction() = f\n  )\n}\n\nstring scope_type(Scope s) {\n  result = \"Module\" and s instanceof Module and not s.(Module).isPackage()\n  or\n  result = \"Class\" and s instanceof Class\n  or\n  result = \"Function\" and s instanceof Function\n}\n\nfrom Scope s\nwhere needs_docstring(s) and not exists(s.getDocString())\nselect s, scope_type(s) + \" \" + s.getName() + \" does not have a docstring.\"",
        "description": "Omitting documentation strings from public classes, functions or methods makes it more difficult for other developers to maintain the code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/DocStrings.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom CallNode call, string name\nwhere call.getFunction().pointsTo(Value::siteQuitter(name))\nselect call,\n  \"The '\" + name +\n    \"' site.Quitter object may not exist if the 'site' module is not loaded or is modified.\"",
        "description": "exit() or quit() may fail if the interpreter is run with the -S option.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/UseOfExit.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate main_eq_name(If i) {\n  exists(Name n, StringLiteral m, Compare c |\n    i.getTest() = c and\n    c.getLeft() = n and\n    c.getAComparator() = m and\n    n.getId() = \"__name__\" and\n    m.getText() = \"__main__\"\n  )\n}\n\npredicate is_print_stmt(Stmt s) {\n  s instanceof Print\n  or\n  exists(ExprStmt e, Call c, Name n |\n    e = s and c = e.getValue() and n = c.getFunc() and n.getId() = \"print\"\n  )\n}\n\nfrom Stmt p\nwhere\n  is_print_stmt(p) and\n  // TODO: Need to discuss how we would like to handle ModuleObject.getKind in the glorious future\n  exists(ModuleValue m | m.getScope() = p.getScope() and m.isUsedAsModule()) and\n  not exists(If i | main_eq_name(i) and i.getASubStatement().getASubStatement*() = p)\nselect p, \"Print statement may execute during import.\"",
        "description": "Using a print statement at module scope (except when guarded by `if __name__ == '__main__'`) will cause surprising output when the module is imported.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/TopLevelPrint.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate isInsideLoop(AstNode node) {\n  node.getParentNode() instanceof While\n  or\n  node.getParentNode() instanceof For\n  or\n  exists(AstNode prev | isInsideLoop(prev) | node = prev.getAChildNode())\n}\n\nfrom Delete del, Expr e, Function f\nwhere\n  f.getLastStatement() = del and\n  e = del.getATarget() and\n  f.containsInScope(e) and\n  not e instanceof Subscript and\n  not e instanceof Attribute and\n  not isInsideLoop(del) and\n  // False positive: calling `sys.exc_info` within a function results in a\n  //       reference cycle, and an explicit call to `del` helps break this cycle.\n  not exists(FunctionValue ex |\n    ex = Value::named(\"sys.exc_info\") and\n    ex.getACall().getScope() = f\n  )\nselect del, \"Unnecessary deletion of local variable $@ in function $@.\", e, e.toString(), f,\n  f.getName()",
        "description": "Using a 'delete' statement to delete a local variable is unnecessary, because the variable is deleted automatically when the function exits.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/UnnecessaryDelete.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate understood_attribute(Attribute attr, ClassValue cls, ClassValue attr_cls) {\n  exists(string name | attr.getName() = name |\n    attr.getObject().pointsTo().getClass() = cls and\n    cls.attr(name).getClass() = attr_cls\n  )\n}\n\npredicate side_effecting_attribute(Attribute attr) {\n  exists(ClassValue attr_cls |\n    understood_attribute(attr, _, attr_cls) and\n    side_effecting_descriptor_type(attr_cls)\n  )\n}\n\npredicate maybe_side_effecting_attribute(Attribute attr) {\n  not understood_attribute(attr, _, _) and not attr.pointsTo(_)\n  or\n  side_effecting_attribute(attr)\n}\n\npredicate side_effecting_descriptor_type(ClassValue descriptor) {\n  descriptor.isDescriptorType() and\n  // Technically all descriptor gets have side effects,\n  // but some are indicative of a missing call and\n  // we want to treat them as having no effect.\n  not descriptor = ClassValue::functionType() and\n  not descriptor = ClassValue::staticmethod() and\n  not descriptor = ClassValue::classmethod()\n}\n\npredicate side_effecting_binary(Expr b) {\n  exists(Expr sub, ClassValue cls, string method_name |\n    binary_operator_special_method(b, sub, cls, method_name)\n    or\n    comparison_special_method(b, sub, cls, method_name)\n  |\n    method_name = special_method() and\n    cls.hasAttribute(method_name) and\n    not exists(ClassValue declaring |\n      declaring.declaresAttribute(method_name) and\n      declaring = cls.getASuperType() and\n      declaring.isBuiltin() and\n      not declaring = ClassValue::object()\n    )\n  )\n}\n\npragma[nomagic]\nprivate predicate binary_operator_special_method(\n  BinaryExpr b, Expr sub, ClassValue cls, string method_name\n) {\n  method_name = special_method() and\n  sub = b.getLeft() and\n  method_name = b.getOp().getSpecialMethodName() and\n  sub.pointsTo().getClass() = cls\n}\n\npragma[nomagic]\nprivate predicate comparison_special_method(Compare b, Expr sub, ClassValue cls, string method_name) {\n  exists(Cmpop op |\n    b.compares(sub, op, _) and\n    method_name = op.getSpecialMethodName()\n  ) and\n  sub.pointsTo().getClass() = cls\n}\n\nprivate string special_method() {\n  result = any(Cmpop c).getSpecialMethodName()\n  or\n  result = any(BinaryExpr b).getOp().getSpecialMethodName()\n}\n\npredicate is_notebook(File f) {\n  exists(Comment c | c.getLocation().getFile() = f |\n    c.getText().regexpMatch(\"#\\\\s*<nbformat>.+</nbformat>\\\\s*\")\n  )\n}\n\npredicate in_notebook(Expr e) { is_notebook(e.getScope().(Module).getFile()) }\n\nFunctionValue assertRaises() {\n  result = Value::named(\"unittest.TestCase\").(ClassValue).lookup(\"assertRaises\")\n}\n\npredicate in_raises_test(Expr e) {\n  exists(With w |\n    w.contains(e) and\n    w.getContextExpr() = assertRaises().getACall().getNode()\n  )\n}\n\npredicate python2_print(Expr e) {\n  e.(BinaryExpr).getLeft().(Name).getId() = \"print\" and\n  e.(BinaryExpr).getOp() instanceof RShift\n  or\n  python2_print(e.(Tuple).getElt(0))\n}\n\npredicate no_effect(Expr e) {\n  // strings can be used as comments\n  not e instanceof StringLiteral and\n  not e.hasSideEffects() and\n  forall(Expr sub | sub = e.getASubExpression*() |\n    not side_effecting_binary(sub) and\n    not maybe_side_effecting_attribute(sub)\n  ) and\n  not in_notebook(e) and\n  not in_raises_test(e) and\n  not python2_print(e)\n}\n\nfrom ExprStmt stmt\nwhere no_effect(stmt.getValue())\nselect stmt, \"This statement has no effect.\"",
        "description": "A statement has no effect",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/StatementNoEffect.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Stmt s, string kind\nwhere\n  s instanceof Return and kind = \"return\" and exists(Try t | t.getFinalbody().contains(s))\n  or\n  s instanceof Break and\n  kind = \"break\" and\n  exists(Try t | t.getFinalbody().contains(s) |\n    not exists(For loop | loop.contains(s) and t.getFinalbody().contains(loop)) and\n    not exists(While loop | loop.contains(s) and t.getFinalbody().contains(loop))\n  )\nselect s, \"'\" + kind + \"' in a finally block will swallow any exceptions raised.\"",
        "description": "Using a Break or Return statement in a finally block causes the Try-finally block to exit, discarding the exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/BreakOrReturnInFinally.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate is_condition(Expr cond) {\n  exists(If i | i.getTest() = cond) or\n  exists(IfExp ie | ie.getTest() = cond)\n}\n\npredicate effective_constant(Name cond) {\n  exists(GlobalVariable var | var = cond.getVariable() and not exists(NameNode f | f.defines(var)) |\n    var.getId() = \"True\" or var.getId() = \"False\" or var.getId() = \"NotImplemented\"\n  )\n}\n\npredicate test_makes_code_unreachable(Expr cond) {\n  exists(If i | i.getTest() = cond | i.getStmt(0).isUnreachable() or i.getOrelse(0).isUnreachable())\n  or\n  exists(While w | w.getTest() = cond and w.getStmt(0).isUnreachable())\n}\n\nfrom Expr cond\nwhere\n  is_condition(cond) and\n  (cond.isConstant() or effective_constant(cond)) and\n  /* Ignore cases where test makes code unreachable, as that is handled in different query */\n  not test_makes_code_unreachable(cond)\nselect cond, \"Testing a constant will always give the same result.\"",
        "description": "The conditional is always true or always false",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/ConstantInConditional.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom For loop, ControlFlowNode iter, Value v, ClassValue t, ControlFlowNode origin\nwhere\n  loop.getIter().getAFlowNode() = iter and\n  iter.pointsTo(_, v, origin) and\n  v.getClass() = t and\n  not t.isIterable() and\n  not t.failedInference(_) and\n  not v = Value::named(\"None\") and\n  not t.isDescriptorType()\nselect loop, \"This for-loop may attempt to iterate over a $@ of class $@.\", origin,\n  \"non-iterable instance\", t, t.getName()",
        "description": "Using a non-iterable as the object in a 'for' loop causes a TypeError.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/NonIteratorInForLoop.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate string_concat_in_loop(BinaryExpr b) {\n  b.getOp() instanceof Add and\n  exists(SsaVariable d, SsaVariable u, BinaryExprNode add |\n    add.getNode() = b and d = u.getAnUltimateDefinition()\n  |\n    d.getDefinition().(DefinitionNode).getValue() = add and\n    u.getAUse() = add.getAnOperand() and\n    add.getAnOperand().pointsTo().getClass() = ClassValue::str()\n  )\n}\n\nfrom BinaryExpr b, Stmt s\nwhere string_concat_in_loop(b) and s.getASubExpression() = b\nselect s, \"String concatenation in a loop is quadratic in the number of iterations.\"",
        "description": "Concatenating strings in loops has quadratic performance.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/StringConcatenationInLoop.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate func_with_side_effects(Expr e) {\n  exists(string name | name = e.(Attribute).getName() or name = e.(Name).getId() |\n    name in [\n        \"print\", \"write\", \"append\", \"pop\", \"remove\", \"discard\", \"delete\", \"close\", \"open\", \"exit\"\n      ]\n  )\n}\n\npredicate call_with_side_effect(Call e) {\n  e.getAFlowNode() = Value::named(\"subprocess.call\").getACall()\n  or\n  e.getAFlowNode() = Value::named(\"subprocess.check_call\").getACall()\n  or\n  e.getAFlowNode() = Value::named(\"subprocess.check_output\").getACall()\n}\n\npredicate probable_side_effect(Expr e) {\n  // Only consider explicit yields, not artificial ones in comprehensions\n  e instanceof Yield and not exists(Comp c | c.contains(e))\n  or\n  e instanceof YieldFrom\n  or\n  e instanceof Call and func_with_side_effects(e.(Call).getFunc())\n  or\n  e instanceof Call and call_with_side_effect(e)\n}\n\nfrom Assert a, Expr e\nwhere probable_side_effect(e) and a.contains(e)\nselect a, \"This 'assert' statement contains an $@ which may have side effects.\", e, \"expression\"",
        "description": "Side-effects in assert statements result in differences between normal and optimized behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/SideEffectInAssert.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate is_doc_string(ExprStmt s) {\n  s.getValue() instanceof Unicode or s.getValue() instanceof Bytes\n}\n\npredicate has_doc_string(StmtList stmts) {\n  stmts.getParent() instanceof Scope and\n  is_doc_string(stmts.getItem(0))\n}\n\nfrom Pass p, StmtList list\nwhere\n  list.getAnItem() = p and\n  (\n    strictcount(list.getAnItem()) = 2 and not has_doc_string(list)\n    or\n    strictcount(list.getAnItem()) > 2\n  )\nselect p, \"Unnecessary 'pass' statement.\"",
        "description": "Unnecessary 'pass' statement",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/UnnecessaryPass.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nstring message() {\n  result = \"The 'exec' statement is used.\" and major_version() = 2\n  or\n  result = \"The 'exec' function is used.\" and major_version() = 3\n}\n\npredicate exec_function_call(Call c) {\n  exists(GlobalVariable exec | exec = c.getFunc().(Name).getVariable() and exec.getId() = \"exec\")\n}\n\nfrom AstNode exec\nwhere exec_function_call(exec) or exec instanceof Exec\nselect exec, message()",
        "description": "The 'exec' statement or function is used which could cause arbitrary code to be executed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/ExecUsed.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate loop_variable(For f, Variable v) { f.getTarget().defines(v) }\n\npredicate variableUsedInNestedLoops(For inner, For outer, Variable v) {\n  /* Only treat loops in body as inner loops. Loops in the else clause are ignored. */\n  outer.getBody().contains(inner) and\n  loop_variable(inner, v) and\n  loop_variable(outer, v) and\n  /* Ignore cases where there is no use of the variable or the only use is in the inner loop */\n  exists(Name n | n.uses(v) and outer.contains(n) and not inner.contains(n))\n}\n\nfrom For inner, For outer, Variable v\nwhere variableUsedInNestedLoops(inner, outer, v)\nselect inner, \"Nested for statement uses loop variable '\" + v.getId() + \"' of enclosing $@.\", outer,\n  \"for statement\"",
        "description": "Nested loops in which the target variable is the same for each loop make the behavior of the loops difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Statements/NestedLoopsSameVariable.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Definition\n\npredicate unused_parameter(FunctionValue f, LocalVariable v) {\n  v.isParameter() and\n  v.getScope() = f.getScope() and\n  not name_acceptable_for_unused_variable(v) and\n  not exists(NameNode u | u.uses(v)) and\n  not exists(Name inner, LocalVariable iv |\n    inner.uses(iv) and iv.getId() = v.getId() and inner.getScope().getScope() = v.getScope()\n  )\n}\n\npredicate is_abstract(FunctionValue func) {\n  func.getScope().getADecorator().(Name).getId().matches(\"%abstract%\")\n}\n\nfrom PythonFunctionValue f, LocalVariable v\nwhere\n  v.getId() != \"self\" and\n  unused_parameter(f, v) and\n  not f.isOverridingMethod() and\n  not f.isOverriddenMethod() and\n  not is_abstract(f)\nselect f, \"The parameter '\" + v.getId() + \"' is never used.\"",
        "description": "Parameter is defined but not used",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/UnusedParameter.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Definition\n\npredicate multiply_defined(AstNode asgn1, AstNode asgn2, Variable v) {\n  /*\n   * Must be redefined on all possible paths in the CFG corresponding to the original source.\n   * For example, splitting may create a path where `def` is unconditionally redefined, even though\n   * it is not in the original source.\n   */\n\n  forex(Definition def, Definition redef |\n    def.getVariable() = v and\n    def = asgn1.getAFlowNode() and\n    redef = asgn2.getAFlowNode()\n  |\n    def.isUnused() and\n    def.getARedef() = redef and\n    def.isRelevant()\n  )\n}\n\npredicate simple_literal(Expr e) {\n  e.(Num).getN() = \"0\"\n  or\n  e instanceof NameConstant\n  or\n  e instanceof List and not exists(e.(List).getAnElt())\n  or\n  e instanceof Tuple and not exists(e.(Tuple).getAnElt())\n  or\n  e instanceof Dict and not exists(e.(Dict).getAKey())\n  or\n  e.(StringLiteral).getText() = \"\"\n}\n\npredicate uninteresting_definition(AstNode asgn1) {\n  exists(AssignStmt a | a.getATarget() = asgn1 | simple_literal(a.getValue()))\n}\n\nfrom AstNode asgn1, AstNode asgn2, Variable v\nwhere\n  multiply_defined(asgn1, asgn2, v) and\n  forall(Name el | el = asgn1.getParentNode().(Tuple).getAnElt() | multiply_defined(el, _, _)) and\n  not uninteresting_definition(asgn1)\nselect asgn1,\n  \"This assignment to '\" + v.getId() + \"' is unnecessary as it is $@ before this value is used.\",\n  asgn2, \"redefined\"",
        "description": "Assignment to a variable occurs multiple times without any intermediate use of that variable",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/MultiplyDefined.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Undefined\nimport semmle.python.pointsto.PointsTo\n\npredicate uninitialized_local(NameNode use) {\n  exists(FastLocalVariable local | use.uses(local) or use.deletes(local) |\n    not local.escapes() and not local = any(Nonlocal nl).getAVariable()\n  ) and\n  (\n    any(Uninitialized uninit).taints(use) and\n    PointsToInternal::reachableBlock(use.getBasicBlock(), _)\n    or\n    not exists(EssaVariable var | var.getASourceUse() = use)\n  )\n}\n\npredicate explicitly_guarded(NameNode u) {\n  exists(Try t |\n    t.getBody().contains(u.getNode()) and\n    t.getAHandler().getType().pointsTo(ClassValue::nameError())\n  )\n}\n\nfrom NameNode u\nwhere uninitialized_local(u) and not explicitly_guarded(u)\nselect u.getNode(), \"Local variable '\" + u.getId() + \"' may be used before it is initialized.\"",
        "description": "Using a local variable before it is initialized causes an UnboundLocalError.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/UninitializedLocal.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Variables.MonkeyPatched\nimport Loop\nimport semmle.python.pointsto.PointsTo\n\npredicate guarded_against_name_error(Name u) {\n  exists(Try t | t.getBody().getAnItem().contains(u) |\n    t.getAHandler().getType().(Name).getId() = \"NameError\"\n  )\n  or\n  exists(ConditionBlock guard, BasicBlock controlled, Call globals |\n    guard.getLastNode().getNode().contains(globals) or\n    guard.getLastNode().getNode() = globals\n  |\n    globals.getFunc().(Name).getId() = \"globals\" and\n    guard.controls(controlled, _) and\n    controlled.contains(u.getAFlowNode())\n  )\n}\n\npredicate contains_unknown_import_star(Module m) {\n  exists(ImportStar imp | imp.getScope() = m |\n    exists(ModuleValue imported | imported.importedAs(imp.getImportedModuleName()) |\n      not imported.hasCompleteExportInfo()\n    )\n  )\n}\n\npredicate undefined_use_in_function(Name u) {\n  exists(Function f |\n    u.getScope().getScope*() = f and\n    // Either function is a method or inner function or it is live at the end of the module scope\n    (\n      not f.getScope() = u.getEnclosingModule() or\n      u.getEnclosingModule().(ImportTimeScope).definesName(f.getName())\n    ) and\n    // There is a use, but not a definition of this global variable in the function or enclosing scope\n    exists(GlobalVariable v | u.uses(v) |\n      not exists(Assign a, Scope defnScope |\n        a.getATarget() = v.getAnAccess() and a.getScope() = defnScope\n      |\n        defnScope = f\n        or\n        // Exclude modules as that case is handled more precisely below.\n        defnScope = f.getScope().getScope*() and not defnScope instanceof Module\n      )\n    )\n  ) and\n  not u.getEnclosingModule().(ImportTimeScope).definesName(u.getId()) and\n  not exists(ModuleValue m | m.getScope() = u.getEnclosingModule() | m.hasAttribute(u.getId())) and\n  not globallyDefinedName(u.getId()) and\n  not exists(SsaVariable var | var.getAUse().getNode() = u and not var.maybeUndefined()) and\n  not guarded_against_name_error(u) and\n  not (u.getEnclosingModule().isPackageInit() and u.getId() = \"__path__\")\n}\n\npredicate undefined_use_in_class_or_module(Name u) {\n  exists(GlobalVariable v | u.uses(v)) and\n  not u.getScope().getScope*() instanceof Function and\n  exists(SsaVariable var | var.getAUse().getNode() = u | var.maybeUndefined()) and\n  not guarded_against_name_error(u) and\n  not exists(ModuleValue m | m.getScope() = u.getEnclosingModule() | m.hasAttribute(u.getId())) and\n  not (u.getEnclosingModule().isPackageInit() and u.getId() = \"__path__\") and\n  not globallyDefinedName(u.getId())\n}\n\npredicate use_of_exec(Module m) {\n  exists(Exec exec | exec.getScope() = m)\n  or\n  exists(CallNode call, FunctionValue exec | exec.getACall() = call and call.getScope() = m |\n    exec = Value::named(\"exec\") or\n    exec = Value::named(\"execfile\")\n  )\n}\n\npredicate undefined_use(Name u) {\n  (\n    undefined_use_in_class_or_module(u)\n    or\n    undefined_use_in_function(u)\n  ) and\n  not monkey_patched_builtin(u.getId()) and\n  not contains_unknown_import_star(u.getEnclosingModule()) and\n  not use_of_exec(u.getEnclosingModule()) and\n  not exists(u.getVariable().getAStore()) and\n  not u.pointsTo(_) and\n  not probably_defined_in_loop(u)\n}\n\nprivate predicate first_use_in_a_block(Name use) {\n  exists(GlobalVariable v, BasicBlock b, int i |\n    i = min(int j | b.getNode(j).getNode() = v.getALoad()) and b.getNode(i) = use.getAFlowNode()\n  )\n}\n\npredicate first_undefined_use(Name use) {\n  undefined_use(use) and\n  exists(GlobalVariable v | v.getALoad() = use |\n    first_use_in_a_block(use) and\n    not exists(ControlFlowNode other |\n      other.getNode() = v.getALoad() and\n      other.getBasicBlock().strictlyDominates(use.getAFlowNode().getBasicBlock())\n    )\n  )\n}\n\nfrom Name u\nwhere first_undefined_use(u)\nselect u, \"This use of global variable '\" + u.getId() + \"' may be undefined.\"",
        "description": "Using a global variable before it is initialized causes an exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/UndefinedGlobal.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Definition\n\npredicate complex_all(Module m) {\n  exists(Assign a, GlobalVariable all |\n    a.defines(all) and a.getScope() = m and all.getId() = \"__all__\"\n  |\n    not a.getValue() instanceof List\n    or\n    exists(Expr e | e = a.getValue().(List).getAnElt() | not e instanceof StringLiteral)\n  )\n  or\n  exists(Call c, GlobalVariable all |\n    c.getFunc().(Attribute).getObject() = all.getALoad() and\n    c.getScope() = m and\n    all.getId() = \"__all__\"\n  )\n}\n\npredicate used_in_forward_declaration(Name used, Module mod) {\n  exists(StringLiteral s, Annotation annotation |\n    s.getS() = used.getId() and\n    s.getEnclosingModule() = mod and\n    annotation.getASubExpression*() = s\n  )\n}\n\npredicate unused_global(Name unused, GlobalVariable v) {\n  not exists(ImportingStmt is | is.contains(unused)) and\n  forex(DefinitionNode defn | defn.getNode() = unused |\n    not defn.getValue().getNode() instanceof FunctionExpr and\n    not defn.getValue().getNode() instanceof ClassExpr and\n    not exists(Name u |\n      // A use of the variable\n      u.uses(v)\n    |\n      // That is reachable from this definition, directly\n      defn.strictlyReaches(u.getAFlowNode())\n      or\n      // indirectly\n      defn.getBasicBlock().reachesExit() and u.getScope() != unused.getScope()\n    ) and\n    not unused.getEnclosingModule().getAnExport() = v.getId() and\n    not exists(unused.getParentNode().(ClassDef).getDefinedClass().getADecorator()) and\n    not exists(unused.getParentNode().(FunctionDef).getDefinedFunction().getADecorator()) and\n    unused.defines(v) and\n    not name_acceptable_for_unused_variable(v) and\n    not complex_all(unused.getEnclosingModule())\n  ) and\n  not used_in_forward_declaration(unused, unused.getEnclosingModule())\n}\n\nfrom Name unused, GlobalVariable v\nwhere\n  unused_global(unused, v) and\n  // If unused is part of a tuple, count it as unused if all elements of that tuple are unused.\n  forall(Name el | el = unused.getParentNode().(Tuple).getAnElt() | unused_global(el, _))\nselect unused, \"The global variable '\" + v.getId() + \"' is not used.\"",
        "description": "Global variable is defined but not used",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/UnusedModuleVariable.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate declaredInAll(Module m, StringLiteral name) {\n  exists(Assign a, GlobalVariable all |\n    a.defines(all) and\n    a.getScope() = m and\n    all.getId() = \"__all__\" and\n    a.getValue().(List).getAnElt() = name\n  )\n}\n\npredicate mutates_globals(ModuleValue m) {\n  exists(CallNode globals |\n    globals = Value::named(\"globals\").(FunctionValue).getACall() and\n    globals.getScope() = m.getScope()\n  |\n    exists(AttrNode attr | attr.getObject() = globals)\n    or\n    exists(SubscriptNode sub | sub.getObject() = globals and sub.isStore())\n  )\n  or\n  // Enum (added in 3.4) has method `_convert_` that alters globals\n  // This was called `_convert` until 3.8, but that name will be removed in 3.9\n  exists(ClassValue enum_class |\n    enum_class.getASuperType() = Value::named(\"enum.Enum\") and\n    (\n      // In Python < 3.8, Enum._convert can be found with points-to\n      exists(Value enum_convert |\n        enum_convert = enum_class.attr(\"_convert\") and\n        exists(CallNode call | call.getScope() = m.getScope() |\n          enum_convert.getACall() = call or\n          call.getFunction().pointsTo(enum_convert)\n        )\n      )\n      or\n      // In Python 3.8, Enum._convert_ is implemented using a metaclass, and our points-to\n      // analysis doesn't handle that well enough. So we need a special case for this\n      not exists(enum_class.attr(\"_convert\")) and\n      exists(CallNode call | call.getScope() = m.getScope() |\n        call.getFunction().(AttrNode).getObject([\"_convert\", \"_convert_\"]).pointsTo() = enum_class\n      )\n    )\n  )\n}\n\npredicate is_exported_submodule_name(ModuleValue m, string exported_name) {\n  m.getScope().getShortName() = \"__init__\" and\n  exists(m.getScope().getPackage().getSubModule(exported_name))\n}\n\npredicate contains_unknown_import_star(ModuleValue m) {\n  exists(ImportStarNode imp | imp.getEnclosingModule() = m.getScope() |\n    imp.getModule().pointsTo().isAbsent()\n    or\n    not exists(imp.getModule().pointsTo())\n  )\n}\n\nfrom ModuleValue m, StringLiteral name, string exported_name\nwhere\n  declaredInAll(m.getScope(), name) and\n  exported_name = name.getText() and\n  not m.hasAttribute(exported_name) and\n  not is_exported_submodule_name(m, exported_name) and\n  not contains_unknown_import_star(m) and\n  not mutates_globals(m)\nselect name, \"The name '\" + exported_name + \"' is exported by __all__ but is not defined.\"",
        "description": "Including an undefined attribute in `__all__` causes an exception when the module is imported using '*'",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/UndefinedExport.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Shadowing\nimport semmle.python.types.Builtins\n\npredicate allow_list(string name) {\n  name in [\n      /* These are rarely used and thus unlikely to be confusing */\n      \"iter\", \"next\", \"input\", \"file\", \"apply\", \"slice\", \"buffer\", \"coerce\", \"intern\", \"exit\",\n      \"quit\", \"license\",\n      /* These are short and/or hard to avoid */\n      \"dir\", \"id\", \"max\", \"min\", \"sum\", \"cmp\", \"chr\", \"ord\", \"bytes\", \"_\",\n    ]\n}\n\npredicate shadows(Name d, string name, Function scope, int line) {\n  exists(LocalVariable l |\n    d.defines(l) and\n    l.getId() = name and\n    exists(Builtin::builtin(l.getId()))\n  ) and\n  d.getScope() = scope and\n  d.getLocation().getStartLine() = line and\n  not allow_list(name) and\n  not optimizing_parameter(d)\n}\n\npredicate first_shadowing_definition(Name d, string name) {\n  exists(int first, Scope scope |\n    shadows(d, name, scope, first) and\n    first = min(int line | shadows(_, name, scope, line))\n  )\n}\n\nfrom Name d, string name\nwhere first_shadowing_definition(d, name)\nselect d, \"Local variable \" + name + \" shadows a builtin variable.\"",
        "description": "Defining a local variable with the same name as a built-in object makes the built-in object unusable within the current scope and makes the code more difficult to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/ShadowBuiltin.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Global g\nwhere g.getScope() instanceof Module\nselect g, \"Declaring '\" + g.getAName() + \"' as global at module-level is redundant.\"",
        "description": "Use of the 'global' statement at module level",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/GlobalAtModuleLevel.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Definition\n\nfrom ListComprehensionDeclaration l, Name use, Name defn\nwhere\n  use = l.getALeakedVariableUse() and\n  defn = l.getDefinition() and\n  l.getAFlowNode().strictlyReaches(use.getAFlowNode()) and\n  /* Make sure we aren't in a loop, as the variable may be redefined */\n  not use.getAFlowNode().strictlyReaches(l.getAFlowNode()) and\n  not l.contains(use) and\n  not use.deletes(_) and\n  not exists(SsaVariable v |\n    v.getAUse() = use.getAFlowNode() and\n    not v.getDefinition().strictlyDominates(l.getAFlowNode())\n  )\nselect use,\n  use.getId() + \" may have a different value in Python 3, as the $@ will not be in scope.\", defn,\n  \"list comprehension variable\"",
        "description": "Using the iteration variable of a list comprehension in the enclosing scope will result in different behavior between Python 2 and 3 and is confusing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/LeakingListComprehension.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Variables.MonkeyPatched\n\npredicate initialized_as_local(PlaceHolder use) {\n  exists(SsaVariable l, Function f | f = use.getScope() and l.getAUse() = use.getAFlowNode() |\n    l.getVariable() instanceof LocalVariable and\n    not l.maybeUndefined()\n  )\n}\n\nClass enclosing_class(PlaceHolder use) { result.getAMethod() = use.getScope() }\n\npredicate template_attribute(PlaceHolder use) {\n  exists(ImportTimeScope cls | cls = enclosing_class(use) | cls.definesName(use.getId()))\n}\n\npredicate not_a_global(PlaceHolder use) {\n  not exists(PythonModuleObject mo |\n    mo.hasAttribute(use.getId()) and mo.getModule() = use.getEnclosingModule()\n  ) and\n  not globallyDefinedName(use.getId()) and\n  not monkey_patched_builtin(use.getId()) and\n  not globallyDefinedName(use.getId())\n}\n\nfrom PlaceHolder p\nwhere\n  not initialized_as_local(p) and\n  not template_attribute(p) and\n  not_a_global(p)\nselect p, \"This use of place-holder variable '\" + p.getId() + \"' may be undefined.\"",
        "description": "Using a variable before it is initialized causes an exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/UndefinedPlaceHolder.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Global g\nwhere not g.getScope() instanceof Module\nselect g, \"Updating global variables except at module initialization is discouraged.\"",
        "description": "Use of the 'global' statement may indicate poor modularity.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/Global.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Shadowing\nimport semmle.python.types.Builtins\n\npredicate shadows(Name d, GlobalVariable g, Function scope, int line) {\n  g.getScope() = scope.getScope() and\n  d.getScope() = scope and\n  exists(LocalVariable l |\n    d.defines(l) and\n    l.getId() = g.getId()\n  ) and\n  not exists(Import il, Import ig, Name gd | il.contains(d) and gd.defines(g) and ig.contains(gd)) and\n  not exists(Assign a | a.getATarget() = d and a.getValue() = g.getAnAccess()) and\n  not exists(Builtin::builtin(g.getId())) and\n  d.getLocation().getStartLine() = line and\n  exists(Name defn | defn.defines(g) | not exists(If i | i.isNameEqMain() | i.contains(defn))) and\n  not optimizing_parameter(d)\n}\n\nAttrNode pytest_fixture_attr() {\n  exists(ModuleValue pytest | result.getObject(\"fixture\").pointsTo(pytest))\n}\n\nValue pytest_fixture() {\n  exists(CallNode call |\n    call.getFunction() = pytest_fixture_attr()\n    or\n    call.getFunction().(CallNode).getFunction() = pytest_fixture_attr()\n  |\n    call.pointsTo(result)\n  )\n}\n\npredicate assigned_pytest_fixture(GlobalVariable v) {\n  exists(NameNode def |\n    def.defines(v) and def.(DefinitionNode).getValue().pointsTo(pytest_fixture())\n  )\n}\n\npredicate first_shadowing_definition(Name d, GlobalVariable g) {\n  exists(int first, Scope scope |\n    shadows(d, g, scope, first) and\n    first = min(int line | shadows(_, g, scope, line))\n  )\n}\n\nfrom Name d, GlobalVariable g, Name def\nwhere\n  first_shadowing_definition(d, g) and\n  not exists(Name n | n.deletes(g)) and\n  def.defines(g) and\n  not assigned_pytest_fixture(g) and\n  not g.getId() = \"_\"\nselect d, \"Local variable '\" + g.getId() + \"' shadows a $@.\", def, \"global variable\"",
        "description": "Defining a local variable with the same name as a global variable makes the global variable unusable within the current scope and makes the code more difficult to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/ShadowGlobal.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Definition\n\npredicate is_increment(Stmt s) {\n  /* x += n */\n  s.(AugAssign).getValue() instanceof IntegerLiteral\n  or\n  /* x = x + n */\n  exists(Name t, BinaryExpr add |\n    t = s.(AssignStmt).getTarget(0) and\n    add = s.(AssignStmt).getValue() and\n    add.getLeft().(Name).getVariable() = t.getVariable() and\n    add.getRight() instanceof IntegerLiteral\n  )\n}\n\npredicate counting_loop(For f) { is_increment(f.getAStmt()) }\n\npredicate empty_loop(For f) { not exists(f.getStmt(1)) and f.getStmt(0) instanceof Pass }\n\npredicate one_item_only(For f) {\n  not exists(Continue c | f.contains(c)) and\n  exists(Stmt s | s = f.getBody().getLastItem() |\n    s instanceof Return\n    or\n    s instanceof Break\n  )\n}\n\npredicate points_to_call_to_range(ControlFlowNode f) {\n  /* (x)range is a function in Py2 and a class in Py3, so we must treat it as a plain object */\n  exists(Value range |\n    range = Value::named(\"range\") or\n    range = Value::named(\"xrange\")\n  |\n    f = range.getACall()\n  )\n  or\n  /* In case points-to fails due to 'from six.moves import range' or similar. */\n  exists(string range | f.getNode().(Call).getFunc().(Name).getId() = range |\n    range = \"range\" or range = \"xrange\"\n  )\n  or\n  /* Handle list(range(...)) and list(list(range(...))) */\n  f.(CallNode).pointsTo().getClass() = ClassValue::list() and\n  points_to_call_to_range(f.(CallNode).getArg(0))\n}\n\npredicate use_of_non_constant(Name n) {\n  exists(Variable var |\n    n.uses(var) and\n    /* use is local */\n    not n.getScope() instanceof Module and\n    /* variable is not global */\n    not var.getScope() instanceof Module\n  |\n    /* Defined more than once (dynamically) */\n    strictcount(Name def | def.defines(var)) > 1\n    or\n    exists(For f, Name def | f.contains(def) and def.defines(var))\n    or\n    exists(While w, Name def | w.contains(def) and def.defines(var))\n  )\n}\n\npredicate implicit_repeat(For f) {\n  not exists(f.getStmt(1)) and\n  exists(ImmutableLiteral imm | f.getStmt(0).contains(imm)) and\n  not exists(Name n | f.getBody().contains(n) and use_of_non_constant(n))\n}\n\nControlFlowNode get_comp_iterable(For f) {\n  exists(Comp c | c.getFunction().getStmt(0) = f | c.getAFlowNode().getAPredecessor() = result)\n}\n\nfrom For f, Variable v, string msg\nwhere\n  f.getTarget() = v.getAnAccess() and\n  not f.getAStmt().contains(v.getAnAccess()) and\n  not points_to_call_to_range(f.getIter().getAFlowNode()) and\n  not points_to_call_to_range(get_comp_iterable(f)) and\n  not name_acceptable_for_unused_variable(v) and\n  not f.getScope().getName() = \"genexpr\" and\n  not empty_loop(f) and\n  not one_item_only(f) and\n  not counting_loop(f) and\n  not implicit_repeat(f) and\n  if exists(Name del | del.deletes(v) and f.getAStmt().contains(del))\n  then msg = \"' is deleted, but not used, in the loop body.\"\n  else msg = \"' is not used in the loop body.\"\nselect f, \"For loop variable '\" + v.getId() + msg",
        "description": "A loop iteration variable is unused, which suggests an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/SuspiciousUnusedLoopIterationVariable.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Definition\n\npredicate unused_local(Name unused, LocalVariable v) {\n  forex(Definition def | def.getNode() = unused |\n    def.getVariable() = v and\n    def.isUnused() and\n    not exists(def.getARedef()) and\n    not exists(annotation_without_assignment(v)) and\n    def.isRelevant() and\n    not v = any(Nonlocal n).getAVariable() and\n    not exists(def.getNode().getParentNode().(FunctionDef).getDefinedFunction().getADecorator()) and\n    not exists(def.getNode().getParentNode().(ClassDef).getDefinedClass().getADecorator())\n  )\n}\n\nprivate AnnAssign annotation_without_assignment(LocalVariable v) {\n  result.getTarget() = v.getAStore() and\n  not exists(result.getValue())\n}\n\nfrom Name unused, LocalVariable v\nwhere\n  unused_local(unused, v) and\n  // If unused is part of a tuple, count it as unused if all elements of that tuple are unused.\n  forall(Name el | el = unused.getParentNode().(Tuple).getAnElt() | unused_local(el, _))\nselect unused, \"Variable \" + v.getId() + \" is not used.\"",
        "description": "Local variable is defined but not used",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/UnusedLocalVariable.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport LoopVariableCaptureQuery\nimport EscapingCaptureFlow::PathGraph\n\nfrom\n  CallableExpr capturing, AstNode loop, Variable var, string descr,\n  EscapingCaptureFlow::PathNode source, EscapingCaptureFlow::PathNode sink\nwhere\n  escapingCapture(capturing, loop, var, source, sink) and\n  if capturing instanceof Lambda then descr = \"lambda\" else descr = \"function\"\nselect capturing, source, sink,\n  \"This \" + descr + \" captures the loop variable $@, and may escape the loop by being stored at $@.\",\n  loop, var.getId(), sink, \"this location\"",
        "description": "Capturing a loop variable is not the same as capturing its value, and can lead to unexpected behavior or bugs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Variables/LoopVariableCapture/LoopVariableCapture.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nclass DelCall extends Call {\n  DelCall() { this.getFunc().(Attribute).getName() = \"__del__\" }\n\n  predicate isSuperCall() {\n    exists(Function f | f = this.getScope() and f.getName() = \"__del__\" |\n      // We pass in `self` as the first argument...\n      f.getArg(0).asName().getVariable() = this.getArg(0).(Name).getVariable()\n      or\n      // ... or the call is of the form `super(Type, self).__del__()`, or the equivalent\n      // Python 3: `super().__del__()`.\n      exists(Call superCall | superCall = this.getFunc().(Attribute).getObject() |\n        superCall.getFunc().(Name).getId() = \"super\"\n      )\n    )\n  }\n}\n\nfrom DelCall del\nwhere not del.isSuperCall()\nselect del, \"The __del__ special method is called explicitly.\"",
        "description": "The `__del__` special method is called by the virtual machine when an object is being finalized. It should not be called explicitly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/ExplicitCallToDel.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.strings\n\npredicate string_format(BinaryExpr operation, StringLiteral str, Value args, AstNode origin) {\n  operation.getOp() instanceof Mod and\n  exists(Context ctx |\n    operation.getLeft().pointsTo(ctx, _, str) and\n    operation.getRight().pointsTo(ctx, args, origin)\n  )\n}\n\nint sequence_length(Value args) {\n  /* Guess length of sequence */\n  exists(Tuple seq | seq.pointsTo(args, _) |\n    result = strictcount(seq.getAnElt()) and\n    not seq.getAnElt() instanceof Starred\n  )\n  or\n  exists(ImmutableLiteral i | i.getLiteralValue() = args | result = 1)\n}\n\nfrom\n  BinaryExpr operation, StringLiteral fmt, Value args, int slen, int alen, AstNode origin,\n  string provided\nwhere\n  string_format(operation, fmt, args, origin) and\n  slen = sequence_length(args) and\n  alen = format_items(fmt) and\n  slen != alen and\n  (if slen = 1 then provided = \" is provided.\" else provided = \" are provided.\")\nselect operation,\n  \"Wrong number of $@ for string format. Format $@ takes \" + alen.toString() + \", but \" +\n    slen.toString() + provided, origin, \"arguments\", fmt, fmt.getText()",
        "description": "A string formatting operation, such as '\"%s: %s, %s\" % (a,b)', where the number of conversion specifiers in the format string differs from the number of values to be formatted will raise a TypeError.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/WrongNumberArgumentsForFormat.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Compare c\nwhere c.getOp(0) instanceof Eq and c.getAComparator() instanceof None\nselect c, \"Testing for None should use the 'is' operator.\"",
        "description": "Testing whether an object is 'None' using the == operator is inefficient and potentially incorrect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/EqualsNone.ql",
        "language": "python"
    },
    {
        "query": "import python\nprivate import semmle.python.types.Builtins\n\nfrom CallNode call, ControlFlowNode func\nwhere major_version() = 2 and call.getFunction() = func and func.pointsTo(Value::named(\"apply\"))\nselect call, \"Call to the obsolete builtin function 'apply'.\"",
        "description": "The builtin function 'apply' is obsolete and should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/UseofApply.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.strings\n\nfrom Expr e, int start\nwhere start = illegal_conversion_specifier(e)\nselect e, \"Invalid conversion specifier at index \" + start + \" of \" + repr(e) + \".\"",
        "description": "An unsupported format character in a format string",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/UnsupportedFormatCharacter.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Expressions.CallArgs\n\nfrom Call call, FunctionObject func, string name\nwhere\n  illegally_named_parameter_objectapi(call, func, name) and\n  not func.isAbstract() and\n  not exists(FunctionObject overridden |\n    func.overrides(overridden) and overridden.getFunction().getAnArg().(Name).getId() = name\n  )\nselect call, \"Keyword argument '\" + name + \"' is not a supported parameter name of $@.\", func,\n  func.descriptiveString()",
        "description": "Using a named argument whose name does not correspond to a parameter of the called function or method, will result in a TypeError at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/WrongNameForArgumentInCall.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.pointsto.PointsTo\n\npredicate rhs_in_expr(ControlFlowNode rhs, Compare cmp) {\n  exists(Cmpop op, int i | cmp.getOp(i) = op and cmp.getComparator(i) = rhs.getNode() |\n    op instanceof In or op instanceof NotIn\n  )\n}\n\nfrom ControlFlowNode non_seq, Compare cmp, Value v, ClassValue cls, ControlFlowNode origin\nwhere\n  rhs_in_expr(non_seq, cmp) and\n  non_seq.pointsTo(_, v, origin) and\n  v.getClass() = cls and\n  not Types::failedInference(cls, _) and\n  not cls.hasAttribute(\"__contains__\") and\n  not cls.hasAttribute(\"__iter__\") and\n  not cls.hasAttribute(\"__getitem__\") and\n  not cls = ClassValue::nonetype() and\n  not cls = Value::named(\"types.MappingProxyType\")\nselect cmp, \"This test may raise an Exception as the $@ may be of non-container class $@.\", origin,\n  \"target\", cls, cls.getName()",
        "description": "A membership test, such as 'item in sequence', with a non-container on the right hand side will raise a 'TypeError'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/ContainsNonContainer.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport CallArgs\n\nfrom Call call, FunctionValue func, string too, string should, int limit\nwhere\n  (\n    too_many_args(call, func, limit) and too = \"too many arguments\" and should = \"no more than \"\n    or\n    too_few_args(call, func, limit) and too = \"too few arguments\" and should = \"no fewer than \"\n  ) and\n  not isAbstract(func) and\n  not exists(FunctionValue overridden |\n    func.overrides(overridden) and correct_args_if_called_as_method(call, overridden)\n  ) and\n  /* The semantics of `__new__` can be a bit subtle, so we simply exclude `__new__` methods */\n  not func.getName() = \"__new__\"\nselect call, \"Call to $@ with \" + too + \"; should be \" + should + limit.toString() + \".\", func,\n  func.descriptiveString()",
        "description": "Using too many or too few arguments in a call to a function will result in a TypeError at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/WrongNumberArgumentsInCall.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.strings\n\nfrom Expr e, ClassValue t\nwhere\n  exists(BinaryExpr b |\n    b.getOp() instanceof Mod and\n    format_string(b.getLeft()) and\n    e = b.getRight() and\n    mapping_format(b.getLeft()) and\n    e.pointsTo().getClass() = t and\n    not t.isMapping()\n  )\nselect e, \"Right hand side of a % operator must be a mapping, not class $@.\", t, t.getName()",
        "description": "The formatted object must be a mapping when the format includes a named specifier; otherwise a TypeError will be raised.\"",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/ExpectedMappingForFormatString.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode call\nwhere\n  major_version() = 2 and\n  call = API::builtin(\"input\").getACall() and\n  call != API::builtin(\"raw_input\").getACall()\nselect call, \"The unsafe built-in function 'input' is used in Python 2.\"",
        "description": "The built-in function 'input' is used which, in Python 2, can allow arbitrary code to be run.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/UseofInput.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.ApiGraphs\n\nfrom DataFlow::CallCfgNode call_to_super, string name\nwhere\n  call_to_super = API::builtin(\"super\").getACall() and\n  name = call_to_super.getScope().getScope().(Class).getName() and\n  exists(DataFlow::Node arg |\n    arg = call_to_super.getArg(0) and\n    arg.getALocalSource().asExpr().(Name).getId() != name\n  )\nselect call_to_super.getNode(), \"First argument to super() should be \" + name + \".\"",
        "description": "Calling super with something other than the enclosing class may cause incorrect object initialization.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/CallToSuperWrongClass.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport IsComparisons\n\nfrom Compare comp, Cmpop op, ClassValue c\nwhere\n  invalid_portable_is_comparison(comp, op, c) and\n  exists(Expr sub | sub = comp.getASubExpression() |\n    cpython_interned_constant(sub) and\n    not universally_interned_constant(sub)\n  )\nselect comp,\n  \"The result of this comparison with '\" + op.getSymbol() +\n    \"' may differ between implementations of Python.\"",
        "description": "Comparison using 'is' when equivalence is not the same as identity and may not be portable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/NonPortableComparisonUsingIs.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Compare comparison, Expr left, Expr right\nwhere\n  comparison.compares(left, _, right) and\n  left.isConstant() and\n  right.isConstant() and\n  not exists(Assert a | a.getTest() = comparison)\nselect comparison, \"Comparison of constants; use 'True' or 'False' instead.\"",
        "description": "Comparison of constants is always constant, but is harder to read than a simple constant.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/CompareConstants.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate comparison_using_is(Compare comp, ControlFlowNode left, Cmpop op, ControlFlowNode right) {\n  exists(CompareNode fcomp | fcomp = comp.getAFlowNode() |\n    fcomp.operands(left, op, right) and\n    (op instanceof Is or op instanceof IsNot)\n  )\n}\n\nprivate predicate cpython_interned_value(Expr e) {\n  exists(string text | text = e.(StringLiteral).getText() |\n    text.length() = 0\n    or\n    text.length() = 1 and text.regexpMatch(\"[U+0000-U+00ff]\")\n  )\n  or\n  exists(int i | i = e.(IntegerLiteral).getN().toInt() | -5 <= i and i <= 256)\n  or\n  exists(Tuple t | t = e and not exists(t.getAnElt()))\n}\n\npredicate uninterned_literal(Expr e) {\n  (\n    e instanceof StringLiteral\n    or\n    e instanceof IntegerLiteral\n    or\n    e instanceof FloatLiteral\n    or\n    e instanceof Dict\n    or\n    e instanceof List\n    or\n    e instanceof Tuple\n  ) and\n  not cpython_interned_value(e)\n}\n\nfrom Compare comp, Cmpop op, string alt\nwhere\n  exists(ControlFlowNode left, ControlFlowNode right |\n    comparison_using_is(comp, left, op, right) and\n    (\n      op instanceof Is and alt = \"==\"\n      or\n      op instanceof IsNot and alt = \"!=\"\n    )\n  |\n    uninterned_literal(left.getNode())\n    or\n    uninterned_literal(right.getNode())\n  )\nselect comp,\n  \"Values compared using '\" + op.getSymbol() +\n    \"' when equivalence is not the same as identity. Use '\" + alt + \"' instead.\"",
        "description": "Comparison using `is` when equivalence is not the same as identity",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/IncorrectComparisonUsingIs.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Exceptions.NotImplemented\n\nfrom Call c, Value v, ClassValue t, Expr f, AstNode origin\nwhere\n  f = c.getFunc() and\n  f.pointsTo(v, origin) and\n  t = v.getClass() and\n  not t.isCallable() and\n  not t.failedInference(_) and\n  not t.hasAttribute(\"__get__\") and\n  not v = Value::named(\"None\") and\n  not use_of_not_implemented_in_raise(_, f)\nselect c, \"Call to a $@ of $@.\", origin, \"non-callable\", t, t.toString()",
        "description": "A call to an object which is not a callable will raise a TypeError at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/NonCallableCalled.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom BinaryExpr div, ControlFlowNode left, ControlFlowNode right\nwhere\n  // Only relevant for Python 2, as all later versions implement true division\n  major_version() = 2 and\n  exists(BinaryExprNode bin, Value lval, Value rval |\n    bin = div.getAFlowNode() and\n    bin.getNode().getOp() instanceof Div and\n    bin.getLeft().pointsTo(lval, left) and\n    lval.getClass() = ClassValue::int_() and\n    bin.getRight().pointsTo(rval, right) and\n    rval.getClass() = ClassValue::int_() and\n    // Ignore instances where integer division leaves no remainder\n    not lval.(NumericValue).getIntValue() % rval.(NumericValue).getIntValue() = 0 and\n    not bin.getNode().getEnclosingModule().hasFromFuture(\"division\") and\n    // Filter out results wrapped in `int(...)`\n    not exists(CallNode c |\n      c = ClassValue::int_().getACall() and\n      c.getAnArg() = bin\n    )\n  )\nselect div, \"Result of division may be truncated as its $@ and $@ arguments may both be integers.\",\n  left, \"left\", right, \"right\"",
        "description": "The arguments to a division statement may be integers, which may cause the result to be truncated in Python 2.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/TruncatedDivision.ql",
        "language": "python"
    },
    {
        "query": "import python\n\n\npredicate numpy_array_type(ClassValue na) {\n  exists(ModuleValue np | np.getName() = \"numpy\" or np.getName() = \"numpy.core\" |\n    na.getASuperType() = np.attr(\"ndarray\")\n  )\n}\n\npredicate has_custom_getitem(Value v) {\n  v.getClass().lookup(\"__getitem__\") instanceof PythonFunctionValue\n  or\n  numpy_array_type(v.getClass())\n}\n\npredicate explicitly_hashed(ControlFlowNode f) {\n  exists(CallNode c, GlobalVariable hash |\n    c.getArg(0) = f and c.getFunction().(NameNode).uses(hash) and hash.getId() = \"hash\"\n  )\n}\n\npredicate unhashable_subscript(ControlFlowNode f, ClassValue c, ControlFlowNode origin) {\n  is_unhashable(f, c, origin) and\n  exists(SubscriptNode sub | sub.getIndex() = f |\n    exists(Value custom_getitem |\n      sub.getObject().pointsTo(custom_getitem) and\n      not has_custom_getitem(custom_getitem)\n    )\n  )\n}\n\npredicate is_unhashable(ControlFlowNode f, ClassValue cls, ControlFlowNode origin) {\n  exists(Value v | f.pointsTo(v, origin) and v.getClass() = cls |\n    not cls.hasAttribute(\"__hash__\") and not cls.failedInference(_) and cls.isNewStyle()\n    or\n    cls.lookup(\"__hash__\") = Value::named(\"None\")\n  )\n}\n\npredicate typeerror_is_caught(ControlFlowNode f) {\n  exists(Try try |\n    try.getBody().contains(f.getNode()) and\n    try.getAHandler().getType().pointsTo(ClassValue::typeError())\n  )\n}\n\nfrom ControlFlowNode f, ClassValue c, ControlFlowNode origin\nwhere\n  not typeerror_is_caught(f) and\n  (\n    explicitly_hashed(f) and is_unhashable(f, c, origin)\n    or\n    unhashable_subscript(f, c, origin)\n  )\nselect f.getNode(), \"This $@ of $@ is unhashable.\", origin, \"instance\", c, c.getQualifiedName()",
        "description": "Hashing an object which is not hashable will result in a TypeError at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/HashedButNoHash.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.strings\n\npredicate dict_key(Dict d, Expr k, string s) {\n  k = d.getAKey() and\n  (\n    s = k.(Num).getN()\n    or\n    // We use \ufffd to mark unrepresentable characters\n    // so two instances of \ufffd may represent different strings in the source code\n    not \"\ufffd\" = s.charAt(_) and\n    exists(StringLiteral c | c = k |\n      s = \"u\\\"\" + c.getText() + \"\\\"\" and c.isUnicode()\n      or\n      s = \"b\\\"\" + c.getText() + \"\\\"\" and not c.isUnicode()\n    )\n  )\n}\n\nfrom Dict d, Expr k1, Expr k2\nwhere\n  exists(string s | dict_key(d, k1, s) and dict_key(d, k2, s) and k1 != k2) and\n  (\n    exists(BasicBlock b, int i1, int i2 |\n      k1.getAFlowNode() = b.getNode(i1) and\n      k2.getAFlowNode() = b.getNode(i2) and\n      i1 < i2\n    )\n    or\n    k1.getAFlowNode().getBasicBlock().strictlyDominates(k2.getAFlowNode().getBasicBlock())\n  )\nselect k1, \"Dictionary key \" + repr(k1) + \" is subsequently $@.\", k2, \"overwritten\"",
        "description": "Duplicate key in dict literal. All but the last will be lost.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/DuplicateKeyInDictionaryLiteral.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate simple_wrapper(Lambda l, Expr wrapped) {\n  exists(Function f, Call c | f = l.getInnerScope() and c = l.getExpression() |\n    wrapped = c.getFunc() and\n    count(f.getAnArg()) = count(c.getAnArg()) and\n    forall(int arg | exists(f.getArg(arg)) | f.getArgName(arg) = c.getArg(arg).(Name).getId()) and\n    /* Either no **kwargs or they must match */\n    (\n      not exists(f.getKwarg()) and not exists(c.getKwargs())\n      or\n      f.getKwarg().(Name).getId() = c.getKwargs().(Name).getId()\n    ) and\n    /* Either no *args or they must match */\n    (\n      not exists(f.getVararg()) and not exists(c.getStarargs())\n      or\n      f.getVararg().(Name).getId() = c.getStarargs().(Name).getId()\n    ) and\n    /* No named parameters in call */\n    not exists(c.getAKeyword())\n  ) and\n  // f is not necessarily a drop-in replacement for the lambda if there are default argument values\n  not exists(l.getArgs().getADefault())\n}\n\npredicate unnecessary_lambda(Lambda l, Expr e) {\n  simple_wrapper(l, e) and\n  (\n    /* plain class */\n    exists(ClassValue c | e.pointsTo(c))\n    or\n    /* plain function */\n    exists(FunctionValue f | e.pointsTo(f))\n    or\n    /* bound-method of enclosing instance */\n    exists(ClassValue cls, Attribute a | cls.getScope() = l.getScope().getScope() and a = e |\n      a.getObject().(Name).getId() = \"self\" and\n      cls.hasAttribute(a.getName())\n    )\n  )\n}\n\nfrom Lambda l, Expr e\nwhere unnecessary_lambda(l, e)\nselect l,\n  \"This 'lambda' is just a simple wrapper around a callable object. Use that object directly.\"",
        "description": "A lambda is used that calls through to a function without modifying any parameters",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/UnnecessaryLambda.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Expressions.RedundantComparison\n\nfrom RedundantComparison comparison\nwhere not comparison.isConstant() and not comparison.maybeMissingSelf()\nselect comparison, \"Comparison of identical values; use cmath.isnan() if testing for not-a-number.\"",
        "description": "Comparison of identical values, the intent of which is unclear.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/CompareIdenticalValues.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate string_const(Expr s) {\n  s instanceof StringLiteral\n  or\n  string_const(s.(BinaryExpr).getLeft()) and string_const(s.(BinaryExpr).getRight())\n}\n\nfrom StringLiteral s\nwhere\n  // Implicitly concatenated string is in a list and that list contains at least one other string.\n  exists(List l, Expr other |\n    not s = other and\n    l.getAnElt() = s and\n    l.getAnElt() = other and\n    string_const(other)\n  ) and\n  exists(s.getAnImplicitlyConcatenatedPart()) and\n  not s.isParenthesized()\nselect s, \"Implicit string concatenation. Maybe missing a comma?\"",
        "description": "Omitting a comma between strings causes implicit concatenation which is confusing in a list.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/UnintentionalImplicitStringConcatenation.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Expressions.RedundantComparison\n\nfrom RedundantComparison comparison\nwhere comparison.maybeMissingSelf()\nselect comparison, \"Comparison of identical values; may be missing 'self'.\"",
        "description": "Comparison of identical values, the intent of which is unclear.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/CompareIdenticalValuesMissingSelf.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.Comparisons\n\n\nprivate predicate is_complex(Expr comp) {\n  exists(comp.(Compare).getOp(1))\n  or\n  is_complex(comp.(UnaryExpr).getOperand())\n}\n\nprivate predicate useless_test(Comparison comp, ComparisonControlBlock controls, boolean isTrue) {\n  controls.impliesThat(comp.getBasicBlock(), comp, isTrue) and\n  /* Exclude complex comparisons of form `a < x < y`, as we do not (yet) have perfect flow control for those */\n  not is_complex(controls.getTest().getNode())\n}\n\nprivate predicate useless_test_ast(AstNode comp, AstNode previous, boolean isTrue) {\n  forex(Comparison compnode, ConditionBlock block |\n    compnode.getNode() = comp and\n    block.getLastNode().getNode() = previous\n  |\n    useless_test(compnode, block, isTrue)\n  )\n}\n\nfrom Expr test, Expr other, boolean isTrue\nwhere\n  useless_test_ast(test, other, isTrue) and not useless_test_ast(test.getAChildNode+(), other, _)\nselect test, \"Test is always \" + isTrue + \", because of $@.\", other, \"this condition\"",
        "description": "The result of a comparison is implied by a previous comparison.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Comparisons/UselessComparisonTest.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.regex\n\npredicate unmatchable_dollar(RegExp r, int start) {\n  not r.getAMode() = \"MULTILINE\" and\n  not r.getAMode() = \"VERBOSE\" and\n  r.specialCharacter(start, start + 1, \"$\") and\n  not r.lastItem(start, start + 1)\n}\n\nfrom RegExp r, int offset\nwhere unmatchable_dollar(r, offset)\nselect r,\n  \"This regular expression includes an unmatchable dollar at offset \" + offset.toString() + \".\"",
        "description": "Regular expressions containing a dollar '$' in the middle cannot be matched, whatever the input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Regex/UnmatchableDollar.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.regex\n\npredicate duplicate_char_in_class(RegExp r, string char) {\n  exists(int i, int j, int x, int y, int start, int end |\n    i != x and\n    j != y and\n    start < i and\n    j < end and\n    start < x and\n    y < end and\n    r.character(i, j) and\n    char = r.getText().substring(i, j) and\n    r.character(x, y) and\n    char = r.getText().substring(x, y) and\n    r.charSet(start, end)\n  ) and\n  /* Exclude \ufffd as we use it for any unencodable character */\n  char != \"\ufffd\" and\n  //Ignore whitespace in verbose mode\n  not (\n    r.getAMode() = \"VERBOSE\" and\n    char in [\" \", \"\\t\", \"\\r\", \"\\n\"]\n  )\n}\n\nfrom RegExp r, string char\nwhere duplicate_char_in_class(r, char)\nselect r,\n  \"This regular expression includes duplicate character '\" + char + \"' in a set of characters.\"",
        "description": "Duplicate characters in a class have no effect and may indicate an error in the regular expression.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Regex/DuplicateCharacterInSet.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.regex\n\nfrom RegExp r, string missing, string part\nwhere r.getText().regexpMatch(\".*\\\\(P<\\\\w+>.*\") and missing = \"?\" and part = \"named group\"\nselect r, \"Regular expression is missing '\" + missing + \"' in \" + part + \".\"",
        "description": "Incomplete special groups are parsed as normal groups and are unlikely to match the intended strings.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Regex/MissingPartSpecialGroup.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.regex\n\npredicate unmatchable_caret(RegExp r, int start) {\n  not r.getAMode() = \"MULTILINE\" and\n  not r.getAMode() = \"VERBOSE\" and\n  r.specialCharacter(start, start + 1, \"^\") and\n  not r.firstItem(start, start + 1)\n}\n\nfrom RegExp r, int offset\nwhere unmatchable_caret(r, offset)\nselect r,\n  \"This regular expression includes an unmatchable caret at offset \" + offset.toString() + \".\"",
        "description": "Regular expressions containing a caret '^' in the middle cannot be matched, whatever the input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Regex/UnmatchableCaret.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.regex\n\nfrom RegExp r, int offset\nwhere\n  r.escapingChar(offset) and\n  r.getChar(offset + 1) = \"b\" and\n  exists(int start, int end | start < offset and end > offset | r.charSet(start, end))\nselect r, \"Backspace escape in regular expression at offset \" + offset + \".\"",
        "description": "Using '\\b' to escape the backspace character in a regular expression is confusing since it could be mistaken for a word boundary assertion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Regex/BackspaceEscape.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport AdvancedFormatting\n\nfrom AdvancedFormattingCall call, AdvancedFormatString fmt, string name, string fmt_repr\nwhere\n  call.getAFormat() = fmt and\n  name = call.getAKeyword().getArg() and\n  forall(AdvancedFormatString format | format = call.getAFormat() |\n    not format.getFieldName(_, _) = name\n  ) and\n  not exists(call.getKwargs()) and\n  (\n    strictcount(call.getAFormat()) = 1 and fmt_repr = \"format \\\"\" + fmt.getText() + \"\\\"\"\n    or\n    strictcount(call.getAFormat()) != 1 and fmt_repr = \"any format used.\"\n  )\nselect call,\n  \"Surplus named argument for string format. An argument named '\" + name +\n    \"' is provided, but it is not required by $@.\", fmt, fmt_repr",
        "description": "Including surplus keyword arguments in a formatting call makes code more difficult to read and may indicate an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Formatting/UnusedNamedArgumentIn3101Format.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport AdvancedFormatting\n\nfrom AdvancedFormattingCall call, AdvancedFormatString fmt, string name\nwhere\n  call.getAFormat() = fmt and\n  not name = call.getAKeyword().getArg() and\n  fmt.getFieldName(_, _) = name and\n  not exists(call.getKwargs())\nselect call,\n  \"Missing named argument for string format. Format $@ requires '\" + name + \"', but it is omitted.\",\n  fmt, \"\\\"\" + fmt.getText() + \"\\\"\"",
        "description": "A string formatting operation, such as '\"{name}\".format(key=b)', where the names of format items in the format string differs from the names of the values to be formatted will raise a KeyError.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Formatting/WrongNameInArgumentsFor3101Format.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport AdvancedFormatting\n\nfrom AdvancedFormattingCall call, AdvancedFormatString fmt\nwhere call.getAFormat() = fmt and fmt.isImplicitlyNumbered() and fmt.isExplicitlyNumbered()\nselect fmt, \"Formatting string mixes implicitly and explicitly numbered fields.\"",
        "description": "Using implicit and explicit numbering in string formatting operations, such as '\"{}: {1}\".format(a,b)', will raise a ValueError.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Formatting/MixedExplicitImplicitIn3101Format.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport AdvancedFormatting\n\nint field_count(AdvancedFormatString fmt) { result = max(fmt.getFieldNumber(_, _)) + 1 }\n\nfrom AdvancedFormattingCall call, AdvancedFormatString fmt, int arg_count, int max_field\nwhere\n  arg_count = call.providedArgCount() and\n  max_field = field_count(fmt) and\n  call.getAFormat() = fmt and\n  not exists(call.getStarargs()) and\n  forall(AdvancedFormatString other | other = call.getAFormat() | field_count(other) < arg_count)\nselect call,\n  \"Too many arguments for string format. Format $@ requires only \" + max_field + \", but \" +\n    arg_count.toString() + \" are provided.\", fmt, \"\\\"\" + fmt.getText() + \"\\\"\"",
        "description": "Including surplus arguments in a formatting call makes code more difficult to read and may indicate an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Formatting/UnusedArgumentIn3101Format.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport AdvancedFormatting\n\nfrom\n  AdvancedFormattingCall call, AdvancedFormatString fmt, int arg_count, int max_field,\n  string provided\nwhere\n  arg_count = call.providedArgCount() and\n  max_field = max(fmt.getFieldNumber(_, _)) and\n  call.getAFormat() = fmt and\n  not exists(call.getStarargs()) and\n  arg_count <= max_field and\n  (if arg_count = 1 then provided = \" is provided.\" else provided = \" are provided.\")\nselect call,\n  \"Too few arguments for string format. Format $@ requires at least \" + (max_field + 1) + \", but \" +\n    arg_count.toString() + provided, fmt, \"\\\"\" + fmt.getText() + \"\\\"\"",
        "description": "A string formatting operation, such as '\"{0}: {1}, {2}\".format(a,b)', where the number of values to be formatted is too few for the format string will raise an IndexError.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Expressions/Formatting/WrongNumberArgumentsFor3101Format.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom File file\nwhere exists(file.getRelativePath())\nselect file, \"\"",
        "description": "Lists all Python files in the source code directory that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Diagnostics/ExtractedFiles.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nint getWarningSeverity() { result = 1 }\n\n// The spec\n// https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541338\n// defines error and warning as:\n//\n// \"error\": A serious problem was found. The condition encountered by the tool resulted\n// in the analysis being halted or caused the results to be incorrect or incomplete.\n//\n// \"warning\": A problem that is not considered serious was found. The condition\n// encountered by the tool is such that it is uncertain whether a problem occurred, or\n// is such that the analysis might be incomplete but the results that were generated are\n// probably valid.\n//\n// So SyntaxErrors are reported at the warning level, since analysis might be incomplete\n// but the results that were generated are probably valid.\nfrom SyntaxError error, File file\nwhere\n  file = error.getFile() and\n  exists(file.getRelativePath())\nselect error, \"Extraction failed in \" + file + \" with error \" + error.getMessage(),\n  getWarningSeverity()",
        "description": "List all extraction warnings for Python files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Diagnostics/ExtractionWarnings.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport MethodArgNames\n\nfrom Function f, string message\nwhere\n  firstArgShouldReferToClsAndDoesnt(f) and\n  (\n    if exists(f.getArgName(0))\n    then\n      message =\n        \"Class methods or methods of a type deriving from type should have 'cls', rather than '\" +\n          f.getArgName(0) + \"', as their first parameter.\"\n    else\n      message =\n        \"Class methods or methods of a type deriving from type should have 'cls' as their first parameter.\"\n  )\nselect f, message",
        "description": "By the PEP8 style guide, the first parameter of a class method should be named `cls`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/NonCls.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom ClassValue iterable, FunctionValue iter, ClassValue iterator\nwhere\n  iter = iterable.lookup(\"__iter__\") and\n  iterator = iter.getAnInferredReturnType() and\n  not iterator.isIterator()\nselect iterator,\n  \"Class \" + iterator.getName() +\n    \" is returned as an iterator (by $@) but does not fully implement the iterator interface.\",\n  iter, iter.getName()",
        "description": "The `__iter__` method returns a non-iterator which, if used in a 'for' loop, would raise a 'TypeError'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/IterReturnsNonIterator.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom FunctionValue method\nwhere\n  exists(ClassValue c |\n    c.declaredAttribute(\"__del__\") = method and\n    method.getScope().getMetrics().getCyclomaticComplexity() > 3\n  )\nselect method, \"Overly complex '__del__' method.\"",
        "description": "`__del__` methods may be called at arbitrary times, perhaps never called at all, and should be simple.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/OverlyComplexDelMethod.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport MethodArgNames\n\nfrom Function f, string message\nwhere\n  firstArgShouldBeNamedSelfAndIsnt(f) and\n  (\n    if exists(f.getArgName(0))\n    then\n      message =\n        \"Normal methods should have 'self', rather than '\" + f.getArgName(0) +\n          \"', as their first parameter.\"\n    else\n      message =\n        \"Normal methods should have at least one parameter (the first of which should be 'self').\"\n  )\nselect f, message",
        "description": "By the PEP8 style guide, the first parameter of a normal method should be named `self`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/NonSelf.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\nimport semmle.python.dataflow.new.internal.DataFlowDispatch\n\nprivate predicate attributeMethod(string name) {\n  name = [\"__getattribute__\", \"__getattr__\", \"__delattr__\"] // __setattr__ excluded as it makes sense to raise different kinds of errors based on the `value` parameter\n}\n\nprivate predicate indexingMethod(string name) {\n  name = [\"__getitem__\", \"__delitem__\"] // __setitem__ excluded as it makes sense to raise different kinds of errors based on the `value` parameter\n}\n\nprivate predicate arithmeticMethod(string name) {\n  name =\n    [\n      \"__add__\", \"__sub__\", \"__and__\", \"__or__\", \"__xor__\", \"__lshift__\", \"__rshift__\", \"__pow__\",\n      \"__mul__\", \"__div__\", \"__divmod__\", \"__truediv__\", \"__floordiv__\", \"__matmul__\", \"__radd__\",\n      \"__rsub__\", \"__rand__\", \"__ror__\", \"__rxor__\", \"__rlshift__\", \"__rrshift__\", \"__rpow__\",\n      \"__rmul__\", \"__rdiv__\", \"__rdivmod__\", \"__rtruediv__\", \"__rfloordiv__\", \"__rmatmul__\",\n      \"__iadd__\", \"__isub__\", \"__iand__\", \"__ior__\", \"__ixor__\", \"__ilshift__\", \"__irshift__\",\n      \"__ipow__\", \"__imul__\", \"__idiv__\", \"__idivmod__\", \"__itruediv__\", \"__ifloordiv__\",\n      \"__imatmul__\", \"__pos__\", \"__neg__\", \"__abs__\", \"__invert__\",\n    ]\n}\n\nprivate predicate orderingMethod(string name) {\n  name =\n    [\n      \"__lt__\",\n      \"__le__\",\n      \"__gt__\",\n      \"__ge__\",\n    ]\n}\n\nprivate predicate castMethod(string name) {\n  name =\n    [\n      \"__int__\",\n      \"__float__\",\n      \"__index__\",\n      \"__trunc__\",\n      \"__complex__\"\n    ] // __bool__ excluded as it makes sense to allow it to always raise\n}\n\npredicate correctRaise(string name, Expr exec) {\n  execIsOfType(exec, \"TypeError\") and\n  (\n    indexingMethod(name) or\n    attributeMethod(name) or\n    // Allow add methods to raise a TypeError, as they can be used for sequence concatenation as well as arithmetic\n    name = [\"__add__\", \"__iadd__\", \"__radd__\"]\n  )\n  or\n  exists(string execName |\n    preferredRaise(name, execName, _) and\n    execIsOfType(exec, execName)\n  )\n}\n\npredicate preferredRaise(string name, string execName, string message) {\n  attributeMethod(name) and\n  execName = \"AttributeError\" and\n  message = \"should raise an AttributeError instead.\"\n  or\n  indexingMethod(name) and\n  execName = \"LookupError\" and\n  message = \"should raise a LookupError (KeyError or IndexError) instead.\"\n  or\n  orderingMethod(name) and\n  execName = \"TypeError\" and\n  message = \"should raise a TypeError or return NotImplemented instead.\"\n  or\n  arithmeticMethod(name) and\n  execName = \"ArithmeticError\" and\n  message = \"should raise an ArithmeticError or return NotImplemented instead.\"\n  or\n  name = \"__bool__\" and\n  execName = \"TypeError\" and\n  message = \"should raise a TypeError instead.\"\n}\n\npredicate execIsOfType(Expr exec, string execName) {\n  // Might make sense to have execName be an IPA type here. Or part of a more general API modeling builtin/stdlib subclass relations.\n  exists(string subclass |\n    execName = \"TypeError\" and\n    subclass = \"TypeError\"\n    or\n    execName = \"LookupError\" and\n    subclass = [\"LookupError\", \"KeyError\", \"IndexError\"]\n    or\n    execName = \"ArithmeticError\" and\n    subclass = [\"ArithmeticError\", \"FloatingPointError\", \"OverflowError\", \"ZeroDivisionError\"]\n    or\n    execName = \"AttributeError\" and\n    subclass = \"AttributeError\"\n  |\n    exec = API::builtin(subclass).getACall().asExpr()\n    or\n    exec = API::builtin(subclass).getASubclass().getACall().asExpr()\n  )\n}\n\npredicate noNeedToAlwaysRaise(Function meth, string message, boolean allowNotImplemented) {\n  meth.getName() = \"__hash__\" and\n  message = \"use __hash__ = None instead.\" and\n  allowNotImplemented = false\n  or\n  castMethod(meth.getName()) and\n  message = \"this method does not need to be implemented.\" and\n  allowNotImplemented = true and\n  // Allow an always raising cast method if it's overriding other behavior\n  not exists(Function overridden |\n    overridden.getName() = meth.getName() and\n    overridden.getScope() = getADirectSuperclass+(meth.getScope()) and\n    not alwaysRaises(overridden, _)\n  )\n}\n\npredicate isAbstract(Function func) { func.getADecorator().(Name).getId().matches(\"%abstract%\") }\n\npredicate alwaysRaises(Function f, Expr exec) {\n  directlyRaises(f, exec) and\n  strictcount(Expr e | directlyRaises(f, e)) = 1 and\n  not exists(f.getANormalExit())\n}\n\npredicate directlyRaises(Function f, Expr exec) {\n  exists(Raise r |\n    r.getScope() = f and\n    exec = r.getException() and\n    exec instanceof Call\n  )\n}\n\npredicate isNotImplementedError(Expr exec) {\n  exec = API::builtin(\"NotImplementedError\").getACall().asExpr()\n}\n\nstring getExecName(Expr exec) { result = exec.(Call).getFunc().(Name).getId() }\n\nfrom Function f, Expr exec, string message\nwhere\n  f.isSpecialMethod() and\n  not isAbstract(f) and\n  directlyRaises(f, exec) and\n  (\n    exists(boolean allowNotImplemented, string subMessage |\n      alwaysRaises(f, exec) and\n      noNeedToAlwaysRaise(f, subMessage, allowNotImplemented) and\n      (allowNotImplemented = true implies not isNotImplementedError(exec)) and // don't alert if it's a NotImplementedError and that's ok\n      message = \"This method always raises $@ - \" + subMessage\n    )\n    or\n    not isNotImplementedError(exec) and\n    not correctRaise(f.getName(), exec) and\n    exists(string subMessage | preferredRaise(f.getName(), _, subMessage) |\n      if alwaysRaises(f, exec)\n      then message = \"This method always raises $@ - \" + subMessage\n      else message = \"This method raises $@ - \" + subMessage\n    )\n  )\nselect f, message, exec, getExecName(exec)",
        "description": "Raising a non-standard exception in a special method alters the expected interface of that method.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/IncorrectRaiseInSpecialMethod.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Expressions.CallArgs\n\nfrom Call call, FunctionValue func, FunctionValue overriding, string problem\nwhere\n  not func.getName() = \"__init__\" and\n  overriding.overrides(func) and\n  call = overriding.getAMethodCall().getNode() and\n  correct_args_if_called_as_method(call, overriding) and\n  (\n    arg_count(call) + 1 < func.minParameters() and problem = \"too few arguments\"\n    or\n    arg_count(call) >= func.maxParameters() and problem = \"too many arguments\"\n    or\n    exists(string name |\n      call.getAKeyword().getArg() = name and\n      overriding.getScope().getAnArg().(Name).getId() = name and\n      not func.getScope().getAnArg().(Name).getId() = name and\n      problem = \"an argument named '\" + name + \"'\"\n    )\n  )\nselect func,\n  \"Overridden method signature does not match $@, where it is passed \" + problem +\n    \". Overriding method $@ matches the call.\", call, \"call\", overriding,\n  overriding.descriptiveString()",
        "description": "Method has a signature that differs from both the signature of its overriding methods and the arguments with which it is called, and if it were called, would be likely to cause an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/IncorrectlySpecifiedOverriddenMethod.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Expressions.CallArgs\n\nfrom Call call, FunctionValue func, FunctionValue overridden, string problem\nwhere\n  func.overrides(overridden) and\n  (\n    wrong_args(call, func, _, problem) and\n    correct_args_if_called_as_method(call, overridden)\n    or\n    exists(string name |\n      illegally_named_parameter(call, func, name) and\n      problem = \"an argument named '\" + name + \"'\" and\n      overridden.getScope().getAnArg().(Name).getId() = name\n    )\n  )\nselect func,\n  \"Overriding method signature does not match $@, where it is passed \" + problem +\n    \". Overridden method $@ is correctly specified.\", call, \"here\", overridden,\n  overridden.descriptiveString()",
        "description": "Method has a different signature from the overridden method and, if it were called, would be likely to cause an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/IncorrectlyOverriddenMethod.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport Testing.Mox\n\npredicate is_used(Call c) {\n  exists(Expr outer | outer != c and outer.containsInScope(c) |\n    outer instanceof Call or outer instanceof Attribute or outer instanceof Subscript\n  )\n  or\n  exists(Stmt s |\n    c = s.getASubExpression() and\n    not s instanceof ExprStmt and\n    /* Ignore if a single return, as def f(): return g() is quite common. Covers implicit return in a lambda. */\n    not (s instanceof Return and strictcount(Return r | r.getScope() = s.getScope()) = 1)\n  )\n}\n\nfrom Call c, FunctionValue func\nwhere\n  /* Call result is used, but callee is a procedure */\n  is_used(c) and\n  c.getFunc().pointsTo(func) and\n  func.getScope().isProcedure() and\n  /* All callees are procedures */\n  forall(FunctionValue callee | c.getFunc().pointsTo(callee) | callee.getScope().isProcedure()) and\n  /* Mox return objects have an `AndReturn` method */\n  not useOfMoxInModule(c.getEnclosingModule())\nselect c, \"The result of $@ is used even though it is always None.\", func, func.getQualifiedName()",
        "description": "The return value of a procedure (a function that does not return a value) is used. This is confusing to the reader as the value (None) has no meaning.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/UseImplicitNoneReturnValue.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate explicitly_returns_non_none(Function func) {\n  exists(Return return |\n    return.getScope() = func and\n    exists(Expr val | val = return.getValue() | not val instanceof None)\n  )\n}\n\npredicate has_implicit_return(Function func) {\n  exists(ControlFlowNode fallthru |\n    fallthru = func.getFallthroughNode() and not fallthru.unlikelyReachable()\n  )\n  or\n  exists(Return return | return.getScope() = func and not exists(return.getValue()))\n}\n\nfrom Function func\nwhere explicitly_returns_non_none(func) and has_implicit_return(func)\nselect func,\n  \"Mixing implicit and explicit returns may indicate an error, as implicit returns always return None.\"",
        "description": "Mixing implicit and explicit returns indicates a likely error as implicit returns always return `None`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/ConsistentReturns.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Return r, Expr rv\nwhere\n  exists(Function init | init.isInitMethod() and r.getScope() = init) and\n  r.getValue() = rv and\n  not rv.pointsTo(Value::none_()) and\n  not exists(FunctionValue f | f.getACall() = rv.getAFlowNode() | f.neverReturns()) and\n  // to avoid double reporting, don't trigger if returning result from other __init__ function\n  not exists(Attribute meth | meth = rv.(Call).getFunc() | meth.getName() = \"__init__\")\nselect r, \"Explicit return in __init__ method.\"",
        "description": "Explicitly returning a value from an `__init__` method will raise a TypeError.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/ExplicitReturnInInit.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\n\npredicate returns_tuple_of_size(Function func, int size, Tuple tuple) {\n  exists(Return return, DataFlow::Node value |\n    value.asExpr() = return.getValue() and\n    return.getScope() = func and\n    any(DataFlow::LocalSourceNode n | n.asExpr() = tuple).flowsTo(value)\n  |\n    size = count(int n | exists(tuple.getElt(n)))\n  )\n}\n\nfrom Function func, int s1, int s2, AstNode t1, AstNode t2\nwhere\n  returns_tuple_of_size(func, s1, t1) and\n  returns_tuple_of_size(func, s2, t2) and\n  s1 < s2 and\n  // Don't report on functions that have a return type annotation\n  not exists(func.getDefinition().(FunctionExpr).getReturns())\nselect func, func.getQualifiedName() + \" returns $@ and $@.\", t1, \"tuple of size \" + s1, t2,\n  \"tuple of size \" + s2",
        "description": "A function that potentially returns tuples of different lengths may indicate a problem.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/ReturnConsistentTupleSizes.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.functions.ModificationOfParameterWithDefault\nimport ModificationOfParameterWithDefault::Flow::PathGraph\n\nfrom\n  ModificationOfParameterWithDefault::Flow::PathNode source,\n  ModificationOfParameterWithDefault::Flow::PathNode sink\nwhere ModificationOfParameterWithDefault::Flow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This expression mutates a $@.\", source.getNode(),\n  \"default value\"",
        "description": "Modifying the default value of a parameter can lead to unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/ModificationOfParameterWithDefault.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Function f\nwhere\n  f.isInitMethod() and\n  (exists(Yield y | y.getScope() = f) or exists(YieldFrom y | y.getScope() = f))\nselect f, \"__init__ method is a generator.\"",
        "description": "`__init__` method is a generator.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/InitIsGenerator.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.DataFlow\nimport semmle.python.dataflow.new.internal.DataFlowDispatch\nimport codeql.util.Option\n\npredicate overrides(Function base, Function sub) {\n  base.getName() = sub.getName() and\n  base.getScope() = getADirectSuperclass+(sub.getScope())\n}\n\nbindingset[num, str]\nstring plural(int num, string str) {\n  num = 1 and result = \"1 \" + str\n  or\n  num != 1 and result = num.toString() + \" \" + str + \"s\"\n}\n\nstring describeMin(Function func) {\n  exists(string descr | descr = plural(func.getMinPositionalArguments(), \"positional argument\") |\n    if func.getMinPositionalArguments() = func.getMaxPositionalArguments()\n    then result = descr\n    else result = \"at least \" + descr\n  )\n}\n\nstring describeMax(Function func) {\n  if func.hasVarArg()\n  then result = \"arbitrarily many positional arguments\"\n  else\n    exists(string descr | descr = plural(func.getMaxPositionalArguments(), \"positional argument\") |\n      if func.getMinPositionalArguments() = func.getMaxPositionalArguments()\n      then result = descr\n      else result = \"at most \" + descr\n    )\n}\n\nstring describeMinShort(Function func) {\n  exists(string descr | descr = func.getMinPositionalArguments().toString() |\n    if func.getMinPositionalArguments() = func.getMaxPositionalArguments()\n    then result = descr\n    else result = \"at least \" + descr\n  )\n}\n\nstring describeMaxShort(Function func) {\n  if func.hasVarArg()\n  then result = \"arbitrarily many\"\n  else\n    exists(string descr | descr = func.getMaxPositionalArguments().toString() |\n      if func.getMinPositionalArguments() = func.getMaxPositionalArguments()\n      then result = descr\n      else result = \"at most \" + descr\n    )\n}\n\nstring describeMaxBound(Function func) {\n  if func.hasVarArg()\n  then result = \"arbitrarily many\"\n  else result = func.getMaxPositionalArguments().toString()\n}\n\npredicate strongSignatureMismatch(Function base, Function sub, string msg) {\n  overrides(base, sub) and\n  (\n    sub.getMinPositionalArguments() > base.getMaxPositionalArguments() and\n    msg =\n      \"requires \" + describeMin(sub) + \", whereas overridden $@ requires \" + describeMaxShort(base) +\n        \".\"\n    or\n    sub.getMaxPositionalArguments() < base.getMinPositionalArguments() and\n    msg =\n      \"requires \" + describeMax(sub) + \", whereas overridden $@ requires \" + describeMinShort(base) +\n        \".\"\n  )\n}\n\npredicate weakSignatureMismatch(Function base, Function sub, string msg) {\n  overrides(base, sub) and\n  (\n    sub.getMinPositionalArguments() > base.getMinPositionalArguments() and\n    msg =\n      \"requires \" + describeMin(sub) + \", whereas overridden $@ may be called with \" +\n        base.getMinPositionalArguments().toString() + \".\"\n    or\n    sub.getMaxPositionalArguments() < base.getMaxPositionalArguments() and\n    msg =\n      \"requires \" + describeMax(sub) + \", whereas overridden $@ may be called with \" +\n        describeMaxBound(base) + \".\"\n    or\n    sub.getMinPositionalArguments() <= base.getMinPositionalArguments() and\n    sub.getMaxPositionalArguments() >= base.getMaxPositionalArguments() and\n    exists(string arg |\n      // TODO: positional-only args not considered\n      // e.g. `def foo(x, y, /, z):` has x,y as positional only args, should not be considered as possible kw args\n      // However, this likely does not create FPs, as we require a 'witness' call to generate an alert.\n      arg = base.getAnArg().getName() and\n      not arg = sub.getAnArg().getName() and\n      not exists(sub.getKwarg()) and\n      msg = \"does not accept keyword argument `\" + arg + \"`, which overridden $@ does.\"\n    )\n    or\n    exists(base.getKwarg()) and\n    not exists(sub.getKwarg()) and\n    msg = \"does not accept arbitrary keyword arguments, which overridden $@ does.\"\n  )\n}\n\npredicate ignore(Function f) {\n  isClassmethod(f)\n  or\n  exists(\n    Function g // other functions with the same name, e.g. @property getters/setters.\n  |\n    g.getScope() = f.getScope() and\n    g.getName() = f.getName() and\n    g != f\n  )\n}\n\nFunction resolveCall(Call call) {\n  exists(DataFlowCall dfc | call = dfc.getNode().(CallNode).getNode() |\n    result = viableCallable(dfc).(DataFlowFunction).getScope()\n  )\n}\n\npredicate callViableForEitherOverride(Function base, Function sub, Call call) {\n  overrides(base, sub) and\n  base = resolveCall(call) and\n  sub = resolveCall(call)\n}\n\npredicate matchingStatic(Function base, Function sub) {\n  overrides(base, sub) and\n  (\n    isStaticmethod(base) and\n    isStaticmethod(sub)\n    or\n    not isStaticmethod(base) and\n    not isStaticmethod(sub)\n  )\n}\n\nint extraSelfArg(Function func) { if isStaticmethod(func) then result = 0 else result = 1 }\n\npredicate callMatchesSignature(Function func, Call call) {\n  func = resolveCall(call) and\n  (\n    // Each parameter of the function is accounted for in the call\n    forall(Parameter param, int i | param = func.getArg(i) |\n      // self arg\n      i = 0 and not isStaticmethod(func)\n      or\n      // positional arg\n      i - extraSelfArg(func) < call.getPositionalArgumentCount()\n      or\n      // has default\n      exists(param.getDefault())\n      or\n      // keyword arg\n      call.getANamedArgumentName() = param.getName()\n    )\n    or\n    // arbitrary varargs or kwargs\n    exists(call.getStarArg())\n    or\n    exists(call.getKwargs())\n  ) and\n  // No excess parameters\n  call.getPositionalArgumentCount() + extraSelfArg(func) <= func.getMaxPositionalArguments() and\n  (\n    exists(func.getKwarg())\n    or\n    forall(string name | name = call.getANamedArgumentName() | exists(func.getArgByName(name)))\n  )\n}\n\npragma[nomagic]\nprivate File getFunctionFile(Function f) { result = f.getLocation().getFile() }\n\nCall getASignatureMismatchWitness(Function base, Function sub) {\n  callViableForEitherOverride(base, sub, result) and\n  callMatchesSignature(base, result) and\n  not callMatchesSignature(sub, result)\n}\n\npragma[inline]\nstring preferredFile(File callFile, Function base, Function sub) {\n  if callFile = getFunctionFile(base)\n  then result = \" A\"\n  else\n    if callFile = getFunctionFile(sub)\n    then result = \" B\"\n    else result = callFile.getAbsolutePath()\n}\n\nCall chooseASignatureMismatchWitness(Function base, Function sub) {\n  exists(getASignatureMismatchWitness(base, sub)) and\n  result =\n    min(Call c |\n      c = getASignatureMismatchWitness(base, sub)\n    |\n      c\n      order by\n        preferredFile(c.getLocation().getFile(), base, sub), c.getLocation().getStartLine(),\n        c.getLocation().getStartColumn()\n    )\n}\n\nmodule CallOption = LocatableOption<Location, Call>;\n\nfrom Function base, Function sub, string msg, string extraMsg, CallOption::Option call\nwhere\n  not sub.isSpecialMethod() and\n  sub.getName() != \"__init__\" and\n  not ignore(sub) and\n  not ignore(base) and\n  matchingStatic(base, sub) and\n  (\n    // If we have a witness, alert for a 'weak' mismatch, but prefer the message for a 'strong' mismatch if that holds.\n    call.asSome() = chooseASignatureMismatchWitness(base, sub) and\n    extraMsg =\n      \" $@ correctly calls the base method, but does not match the signature of the overriding method.\" and\n    (\n      strongSignatureMismatch(base, sub, msg)\n      or\n      not strongSignatureMismatch(base, sub, _) and\n      weakSignatureMismatch(base, sub, msg)\n    )\n    or\n    // With no witness, only alert for 'strong' mismatches.\n    not exists(getASignatureMismatchWitness(base, sub)) and\n    call.isNone() and\n    strongSignatureMismatch(base, sub, msg) and\n    extraMsg = \"\"\n  )\nselect sub, \"This method \" + msg + extraMsg, base, base.getQualifiedName(), call, \"This call\"",
        "description": "Overriding a method without ensuring that both methods accept the same number and type of parameters has the potential to cause an error when there is a mismatch.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/SignatureOverriddenMethod.ql",
        "language": "python"
    },
    {
        "query": "import python\n\npredicate slice_method_name(string name) {\n  name = \"__getslice__\" or name = \"__setslice__\" or name = \"__delslice__\"\n}\n\nfrom PythonFunctionValue f, string meth\nwhere\n  f.getScope().isMethod() and\n  not f.isOverridingMethod() and\n  slice_method_name(meth) and\n  f.getName() = meth\nselect f, meth + \" method has been deprecated since Python 2.0.\"",
        "description": "Defining special methods for slicing has been deprecated since Python 2.0.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/DeprecatedSliceMethod.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.ApiGraphs\n\nFunction iterMethod(Class c) { result = c.getAMethod() and result.getName() = \"__iter__\" }\n\nFunction nextMethod(Class c) { result = c.getAMethod() and result.getName() = \"__next__\" }\n\npredicate isSelfVar(Function f, Name var) { var.getVariable() = f.getArg(0).(Name).getVariable() }\n\npredicate isGoodReturn(Function f, Expr e) {\n  isSelfVar(f, e)\n  or\n  exists(DataFlow::CallCfgNode call, DataFlow::AttrRead read, DataFlow::Node selfNode |\n    e = call.asExpr()\n  |\n    call = API::builtin(\"iter\").getACall() and\n    call.getArg(0) = read and\n    read.accesses(selfNode, \"__next__\") and\n    isSelfVar(f, selfNode.asExpr()) and\n    call.getArg(1).asExpr() instanceof None\n  )\n}\n\npredicate returnsNonSelf(Function f) {\n  exists(f.getFallthroughNode())\n  or\n  exists(Return r | r.getScope() = f and not isGoodReturn(f, r.getValue()))\n}\n\npredicate iterWrapperMethods(Function iter, Function next) {\n  exists(string field |\n    exists(Return r, DataFlow::Node self, DataFlow::AttrRead read |\n      r.getScope() = iter and\n      r.getValue() = [iterCall(read).asExpr(), read.asExpr()] and\n      read.accesses(self, field) and\n      isSelfVar(iter, self.asExpr())\n    ) and\n    exists(Return r, DataFlow::Node self, DataFlow::AttrRead read |\n      r.getScope() = next and\n      r.getValue() = nextCall(read).asExpr() and\n      read.accesses(self, field) and\n      isSelfVar(next, self.asExpr())\n    )\n  )\n}\n\nprivate DataFlow::CallCfgNode iterCall(DataFlow::Node arg) {\n  result.(DataFlow::MethodCallNode).calls(arg, \"__iter__\")\n  or\n  result = API::builtin(\"iter\").getACall() and\n  arg = result.getArg(0) and\n  not exists(result.getArg(1))\n}\n\nprivate DataFlow::CallCfgNode nextCall(DataFlow::Node arg) {\n  result.(DataFlow::MethodCallNode).calls(arg, \"__next__\")\n  or\n  result = API::builtin(\"next\").getACall() and\n  arg = result.getArg(0)\n}\n\nfrom Class c, Function iter, Function next\nwhere\n  next = nextMethod(c) and\n  iter = iterMethod(c) and\n  returnsNonSelf(iter) and\n  not iterWrapperMethods(iter, next)\nselect iter, \"Iter method of iterator $@ does not return `\" + iter.getArg(0).getName() + \"`.\", c,\n  c.getName()",
        "description": "Iterator does not return self from `__iter__` method, violating the iterator protocol.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/IterReturnsNonSelf.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.objects.Callables\n\npredicate meaningful_return_value(Expr val) {\n  val instanceof Name\n  or\n  val instanceof BooleanLiteral\n  or\n  exists(FunctionValue callee |\n    val = callee.getACall().getNode() and returns_meaningful_value(callee)\n  )\n  or\n  not exists(FunctionValue callee | val = callee.getACall().getNode()) and not val instanceof Name\n}\n\npredicate used_value(Expr val) {\n  exists(LocalVariable var, Expr other |\n    var.getAnAccess() = val and other = var.getAnAccess() and not other = val\n  )\n}\n\npredicate returns_meaningful_value(FunctionValue f) {\n  not exists(f.getScope().getFallthroughNode()) and\n  (\n    exists(Return ret, Expr val | ret.getScope() = f.getScope() and val = ret.getValue() |\n      meaningful_return_value(val) and\n      not used_value(val)\n    )\n    or\n    /*\n     * Is f a builtin function that returns something other than None?\n     * Ignore __import__ as it is often called purely for side effects\n     */\n\n    f.isBuiltin() and\n    f.getAnInferredReturnType() != ClassValue::nonetype() and\n    not f.getName() = \"__import__\"\n  )\n}\n\npredicate wrapped_in_try_except(ExprStmt call) {\n  exists(Try t |\n    exists(t.getAHandler()) and\n    strictcount(Call c | t.getBody().contains(c)) = 1 and\n    call = t.getAStmt()\n  )\n}\n\nfrom ExprStmt call, FunctionValue callee, float percentage_used, int total\nwhere\n  call.getValue() = callee.getACall().getNode() and\n  returns_meaningful_value(callee) and\n  not wrapped_in_try_except(call) and\n  exists(int unused |\n    unused = count(ExprStmt e | e.getValue().getAFlowNode() = callee.getACall()) and\n    total = count(callee.getACall())\n  |\n    percentage_used = (100.0 * (total - unused) / total).floor()\n  ) and\n  /* Report an alert if we see at least 5 calls and the return value is used in at least 3/4 of those calls. */\n  percentage_used >= 75 and\n  total >= 5\nselect call,\n  \"Call discards return value of function $@. The result is used in \" + percentage_used.toString() +\n    \"% of calls.\", callee, callee.getName()",
        "description": "Ignoring return values may result in discarding errors or loss of information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/ReturnValueIgnored.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.dataflow.new.internal.DataFlowDispatch as DD\n\npredicate is_unary_op(string name) {\n  name in [\n      \"__del__\", \"__repr__\", \"__neg__\", \"__pos__\", \"__abs__\", \"__invert__\", \"__complex__\",\n      \"__int__\", \"__float__\", \"__long__\", \"__oct__\", \"__hex__\", \"__str__\", \"__index__\", \"__enter__\",\n      \"__hash__\", \"__bool__\", \"__nonzero__\", \"__unicode__\", \"__len__\", \"__iter__\", \"__reversed__\",\n      \"__aenter__\", \"__aiter__\", \"__anext__\", \"__await__\", \"__ceil__\", \"__floor__\", \"__trunc__\",\n      \"__length_hint__\", \"__dir__\", \"__bytes__\"\n    ]\n}\n\npredicate is_binary_op(string name) {\n  name in [\n      \"__lt__\", \"__le__\", \"__delattr__\", \"__delete__\", \"__instancecheck__\", \"__subclasscheck__\",\n      \"__getitem__\", \"__delitem__\", \"__contains__\", \"__add__\", \"__sub__\", \"__mul__\", \"__eq__\",\n      \"__floordiv__\", \"__div__\", \"__truediv__\", \"__mod__\", \"__divmod__\", \"__lshift__\", \"__rshift__\",\n      \"__and__\", \"__xor__\", \"__or__\", \"__ne__\", \"__radd__\", \"__rsub__\", \"__rmul__\", \"__rfloordiv__\",\n      \"__rdiv__\", \"__rtruediv__\", \"__rmod__\", \"__rdivmod__\", \"__rpow__\", \"__rlshift__\", \"__gt__\",\n      \"__rrshift__\", \"__rand__\", \"__rxor__\", \"__ror__\", \"__iadd__\", \"__isub__\", \"__imul__\",\n      \"__ifloordiv__\", \"__idiv__\", \"__itruediv__\", \"__ge__\", \"__imod__\", \"__ipow__\", \"__ilshift__\",\n      \"__irshift__\", \"__iand__\", \"__ixor__\", \"__ior__\", \"__coerce__\", \"__cmp__\", \"__rcmp__\",\n      \"__getattr__\", \"__getattribute__\", \"__buffer__\", \"__release_buffer__\", \"__matmul__\",\n      \"__rmatmul__\", \"__imatmul__\", \"__missing__\", \"__class_getitem__\", \"__mro_entries__\",\n      \"__format__\"\n    ]\n}\n\npredicate is_ternary_op(string name) {\n  name in [\"__setattr__\", \"__set__\", \"__setitem__\", \"__getslice__\", \"__delslice__\", \"__set_name__\"]\n}\n\npredicate is_quad_op(string name) { name in [\"__setslice__\", \"__exit__\", \"__aexit__\"] }\n\nint argument_count(string name) {\n  is_unary_op(name) and result = 1\n  or\n  is_binary_op(name) and result = 2\n  or\n  is_ternary_op(name) and result = 3\n  or\n  is_quad_op(name) and result = 4\n}\n\nint staticmethod_correction(Function func) {\n  if DD::isStaticmethod(func) then result = 1 else result = 0\n}\n\npredicate incorrect_special_method_defn(\n  Function func, string message, boolean show_counts, string name, boolean is_unused_default\n) {\n  exists(int required, int correction |\n    required = argument_count(name) - correction and correction = staticmethod_correction(func)\n  |\n    /* actual_non_default <= actual */\n    if required > func.getMaxPositionalArguments()\n    then message = \"Too few parameters\" and show_counts = true and is_unused_default = false\n    else\n      if required < func.getMinPositionalArguments()\n      then message = \"Too many parameters\" and show_counts = true and is_unused_default = false\n      else (\n        func.getMinPositionalArguments() < required and\n        not func.hasVarArg() and\n        message =\n          (required - func.getMinPositionalArguments()) + \" default values(s) will never be used\" and\n        show_counts = false and\n        is_unused_default = true\n      )\n  )\n}\n\npredicate incorrect_pow(\n  Function func, string message, boolean show_counts, boolean is_unused_default\n) {\n  exists(int correction | correction = staticmethod_correction(func) |\n    func.getMaxPositionalArguments() < 2 - correction and\n    message = \"Too few parameters\" and\n    show_counts = true and\n    is_unused_default = false\n    or\n    func.getMinPositionalArguments() > 3 - correction and\n    message = \"Too many parameters\" and\n    show_counts = true and\n    is_unused_default = false\n    or\n    func.getMinPositionalArguments() < 2 - correction and\n    message = (2 - func.getMinPositionalArguments()) + \" default value(s) will never be used\" and\n    show_counts = false and\n    is_unused_default = true\n    or\n    func.getMinPositionalArguments() = 3 - correction and\n    message = \"Third parameter to __pow__ should have a default value\" and\n    show_counts = false and\n    is_unused_default = false\n  )\n}\n\npredicate incorrect_round(\n  Function func, string message, boolean show_counts, boolean is_unused_default\n) {\n  exists(int correction | correction = staticmethod_correction(func) |\n    func.getMaxPositionalArguments() < 1 - correction and\n    message = \"Too few parameters\" and\n    show_counts = true and\n    is_unused_default = false\n    or\n    func.getMinPositionalArguments() > 2 - correction and\n    message = \"Too many parameters\" and\n    show_counts = true and\n    is_unused_default = false\n    or\n    func.getMinPositionalArguments() = 2 - correction and\n    message = \"Second parameter to __round__ should have a default value\" and\n    show_counts = false and\n    is_unused_default = false\n  )\n}\n\npredicate incorrect_get(\n  Function func, string message, boolean show_counts, boolean is_unused_default\n) {\n  exists(int correction | correction = staticmethod_correction(func) |\n    func.getMaxPositionalArguments() < 3 - correction and\n    message = \"Too few parameters\" and\n    show_counts = true and\n    is_unused_default = false\n    or\n    func.getMinPositionalArguments() > 3 - correction and\n    message = \"Too many parameters\" and\n    show_counts = true and\n    is_unused_default = false\n    or\n    func.getMinPositionalArguments() < 2 - correction and\n    not func.hasVarArg() and\n    message = (2 - func.getMinPositionalArguments()) + \" default value(s) will never be used\" and\n    show_counts = false and\n    is_unused_default = true\n  )\n}\n\nstring should_have_parameters(string name) {\n  if name in [\"__pow__\", \"__get__\"]\n  then result = \"2 or 3\"\n  else result = argument_count(name).toString()\n}\n\nstring has_parameters(Function f) {\n  exists(int i | i = f.getMinPositionalArguments() |\n    i = 0 and result = \"no parameters\"\n    or\n    i = 1 and result = \"1 parameter\"\n    or\n    i > 1 and result = i.toString() + \" parameters\"\n  )\n}\n\npredicate isLikelyPlaceholderFunction(Function f) {\n  // Body has only a single statement.\n  f.getBody().getItem(0) = f.getBody().getLastItem() and\n  (\n    // Body is a string literal. This is a common pattern for Zope interfaces.\n    f.getBody().getLastItem().(ExprStmt).getValue() instanceof StringLiteral\n    or\n    // Body just raises an exception.\n    f.getBody().getLastItem() instanceof Raise\n    or\n    // Body is a pass statement.\n    f.getBody().getLastItem() instanceof Pass\n  )\n}\n\nfrom\n  Function f, string message, string sizes, boolean show_counts, string name, Class owner,\n  boolean show_unused_defaults\nwhere\n  owner.getAMethod() = f and\n  f.getName() = name and\n  (\n    incorrect_special_method_defn(f, message, show_counts, name, show_unused_defaults)\n    or\n    incorrect_pow(f, message, show_counts, show_unused_defaults) and name = \"__pow__\"\n    or\n    incorrect_get(f, message, show_counts, show_unused_defaults) and name = \"__get__\"\n    or\n    incorrect_round(f, message, show_counts, show_unused_defaults) and\n    name = \"__round__\"\n  ) and\n  not isLikelyPlaceholderFunction(f) and\n  show_unused_defaults = false and\n  (\n    show_counts = false and sizes = \"\"\n    or\n    show_counts = true and\n    sizes = \", which has \" + has_parameters(f) + \", but should have \" + should_have_parameters(name)\n  )\nselect f, message + \" for special method \" + name + sizes + \", in class $@.\", owner, owner.getName()",
        "description": "Special method has incorrect signature",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Functions/SignatureSpecialMethods.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom BasicBlock d\nwhere none()\nselect d, \"Duplicate code: \" + \"-1\" + \" lines are duplicated at \" + \"<file>\" + \":\" + \"-1\"",
        "description": "This block of code is duplicated elsewhere. If possible, the shared code should be refactored so there is only one occurrence left. It may not always be possible to address these issues; other duplicate code checks (such as duplicate function, duplicate class) give subsets of the results with higher confidence.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/external/DuplicateBlock.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, Module other, string message\nwhere none()\nselect m, message, other, other.getName()",
        "description": "There is another module that shares a lot of the code with this module. Notice that names of variables and types may have been changed. Merge the two modules to improve maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/external/MostlySimilarFile.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Function m, Function other, string message\nwhere none()\nselect m, message, other, other.getName()",
        "description": "There is another function that is very similar this one. Extract the common code to a common function to improve sharing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/external/SimilarFunction.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Module m, Module other, string message\nwhere none()\nselect m, message, other, other.getName()",
        "description": "There is another file that shares a lot of the code with this file. Merge the two files to improve maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/external/MostlyDuplicateFile.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Class c, Class other, string message\nwhere none()\nselect c, message, other, other.getName()",
        "description": "More than 80% of the methods in this class are duplicated in another class. Create a common supertype to improve code sharing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/external/MostlyDuplicateClass.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nfrom Function m, Function other, string message\nwhere none()\nselect m, message, other, other.getName()",
        "description": "There is another identical implementation of this function. Extract the code to a common file or superclass to improve sharing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/external/DuplicateFunction.ql",
        "language": "python"
    },
    {
        "query": "import python\n\nselect sum(Module m | | m.getMetrics().getNumberOfLinesOfCode())",
        "description": "The total number of lines of Python code across all files, including external libraries and auto-generated files. This is a useful metric of the size of a database. This query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Summary/LinesOfCode.ql",
        "language": "python"
    },
    {
        "query": "import python\nimport semmle.python.filters.GeneratedCode\n\nselect sum(Module m |\n    exists(m.getFile().getRelativePath()) and\n    not m.getFile() instanceof GeneratedFile\n  |\n    m.getMetrics().getNumberOfLinesOfCode()\n  )",
        "description": "The total number of lines of Python code from the source code directory, excluding auto-generated files. This query counts the lines of code, excluding whitespace or comments. Note: If external libraries are included in the codebase either in a checked-in virtual environment or as vendored code, that will currently be counted as user written code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/python/ql/src/Summary/LinesOfUserCode.ql",
        "language": "python"
    },
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import codeql.swift.elements.Locatable as L\nprivate import codeql.swift.elements.Comments as C\n\nclass AstNode extends L::Locatable {\n  predicate hasLocationInfo(string path, int startLine, int startColumn, int endLine, int endColumn) {\n    this.getLocation().hasLocationInfo(path, startLine, startColumn, endLine, endColumn)\n  }\n}\n\nclass SingleLineComment extends AstNode instanceof C::Comment {\n  private string text;\n\n  SingleLineComment() {\n    this instanceof C::SingleLineComment and\n    text = super.getText().regexpCapture(\"//([^\\\\r\\\\n]*)[\\\\r\\\\n]?\", 1)\n    or\n    this instanceof C::MultiLineComment and\n    // suppression comments must be single-line\n    text = super.getText().regexpCapture(\"/\\\\*([^\\\\r\\\\n]*)\\\\*/\", 1)\n  }\n\n  override predicate hasLocationInfo(\n    string path, int startLine, int startColumn, int endLine, int endColumn\n  ) {\n    this.(C::SingleLineComment).getLocation().hasLocationInfo(path, startLine, startColumn, _, _) and\n    endLine = startLine and\n    endColumn = startColumn + text.length() + 1\n    or\n    this.(C::MultiLineComment)\n        .getLocation()\n        .hasLocationInfo(path, startLine, startColumn, endLine, endColumn + 1)\n  }\n\n  string getText() { result = text }\n}\n\nimport AS::Make<AstNode, SingleLineComment>",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/AlertSuppression.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.UnsafeUnpackQuery\nimport UnsafeUnpackFlow::PathGraph\n\nfrom UnsafeUnpackFlow::PathNode sourceNode, UnsafeUnpackFlow::PathNode sinkNode\nwhere UnsafeUnpackFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"Unsafe unpacking from a malicious zip retrieved from a remote location.\"",
        "description": "Unpacking user controlled zips without validating whether the destination file path is within the destination directory can cause files outside the destination directory to be overwritten.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/experimental/Security/CWE-022/UnsafeUnpack.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.UnsafeJsEvalQuery\nimport UnsafeJsEvalFlow::PathGraph\n\nfrom\n  UnsafeJsEvalFlow::PathNode sourceNode, UnsafeJsEvalFlow::PathNode sinkNode, UnsafeJsEvalSink sink\nwhere\n  UnsafeJsEvalFlow::flowPath(sourceNode, sinkNode) and\n  sink = sinkNode.getNode()\nselect sink, sourceNode, sinkNode, \"Evaluation of uncontrolled JavaScript from a remote source.\"",
        "description": "Evaluating JavaScript code containing a substring from a remote source may lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-094/UnsafeJsEval.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.WeakSensitiveDataHashingQuery\nimport WeakSensitiveDataHashingFlow::PathGraph\n\nfrom\n  WeakSensitiveDataHashingFlow::PathNode source, WeakSensitiveDataHashingFlow::PathNode sink,\n  string algorithm, SensitiveExpr expr\nwhere\n  WeakSensitiveDataHashingFlow::flowPath(source, sink) and\n  algorithm = sink.getNode().(WeakSensitiveDataHashingSink).getAlgorithm() and\n  expr = source.getNode().asExpr()\nselect sink.getNode(), source, sink,\n  \"Insecure hashing algorithm (\" + algorithm + \") depends on $@.\", source.getNode(),\n  \"sensitive data (\" + expr.getSensitiveType() + \" \" + expr.getLabel() + \")\"",
        "description": "Using broken or weak cryptographic hashing algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-328/WeakSensitiveDataHashing.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.WeakPasswordHashingQuery\nimport WeakPasswordHashingFlow::PathGraph\n\nfrom\n  WeakPasswordHashingFlow::PathNode source, WeakPasswordHashingFlow::PathNode sink, string algorithm\nwhere\n  WeakPasswordHashingFlow::flowPath(source, sink) and\n  algorithm = sink.getNode().(WeakPasswordHashingSink).getAlgorithm()\nselect sink.getNode(), source, sink,\n  \"Insecure hashing algorithm (\" + algorithm + \") depends on $@.\", source.getNode(),\n  \"password (\" + source.getNode().asExpr() + \")\"",
        "description": "Using inappropriate cryptographic hashing algorithms with passwords can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-328/WeakPasswordHashing.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.HardcodedEncryptionKeyQuery\nimport HardcodedKeyFlow::PathGraph\n\nfrom HardcodedKeyFlow::PathNode sourceNode, HardcodedKeyFlow::PathNode sinkNode\nwhere HardcodedKeyFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"The key '\" + sinkNode.getNode().toString() +\n    \"' has been initialized with hard-coded values from $@.\", sourceNode,\n  sourceNode.getNode().toString()",
        "description": "Using hardcoded keys for encryption is not secure, because potential attackers can easily guess them.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-321/HardcodedEncryptionKey.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.PredicateInjectionQuery\nimport PredicateInjectionFlow::PathGraph\n\nfrom PredicateInjectionFlow::PathNode source, PredicateInjectionFlow::PathNode sink\nwhere PredicateInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This predicate depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an NSPredicate from user-controlled sources may lead to attackers changing the predicate's intended logic.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-943/PredicateInjection.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.ECBEncryptionQuery\nimport EcbEncryptionFlow::PathGraph\n\nfrom EcbEncryptionFlow::PathNode sourceNode, EcbEncryptionFlow::PathNode sinkNode\nwhere EcbEncryptionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"The initialization of the cipher '\" + sinkNode.getNode().toString() +\n    \"' uses the insecure ECB block mode from $@.\", sourceNode, sourceNode.getNode().toString()",
        "description": "Using the ECB encryption mode makes code vulnerable to replay attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-327/ECBEncryption.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.InsufficientHashIterationsQuery\nimport InsufficientHashIterationsFlow::PathGraph\n\nfrom\n  InsufficientHashIterationsFlow::PathNode sourceNode,\n  InsufficientHashIterationsFlow::PathNode sinkNode\nwhere InsufficientHashIterationsFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"The value '\" + sourceNode.getNode().toString() +\n    \"' is an insufficient number of iterations for secure password hashing.\"",
        "description": "Using hash functions with fewer than 120,000 iterations is insufficient to protect passwords because a cracking attack will require a low level of computational effort.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-916/InsufficientHashIterations.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.CleartextStorageDatabaseQuery\nimport CleartextStorageDatabaseFlow::PathGraph\n\nDataFlow::Node cleanupNode(DataFlow::Node n) {\n  result = n.(DataFlow::PostUpdateNode).getPreUpdateNode()\n  or\n  not n instanceof DataFlow::PostUpdateNode and\n  result = n\n}\n\nfrom\n  CleartextStorageDatabaseFlow::PathNode sourceNode,\n  CleartextStorageDatabaseFlow::PathNode sinkNode, DataFlow::Node cleanSink\nwhere\n  CleartextStorageDatabaseFlow::flowPath(sourceNode, sinkNode) and\n  cleanSink = cleanupNode(sinkNode.getNode())\nselect cleanSink, sourceNode, sinkNode,\n  \"This operation stores '\" + cleanSink.toString() +\n    \"' in a database. It may contain unencrypted sensitive data from $@.\", sourceNode,\n  sourceNode.getNode().toString()",
        "description": "Storing sensitive information in a non-encrypted database can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-311/CleartextStorageDatabase.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.CleartextTransmissionQuery\nimport CleartextTransmissionFlow::PathGraph\n\nfrom CleartextTransmissionFlow::PathNode sourceNode, CleartextTransmissionFlow::PathNode sinkNode\nwhere CleartextTransmissionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"This operation transmits '\" + sinkNode.getNode().toString() +\n    \"', which may contain unencrypted sensitive data from $@.\", sourceNode,\n  sourceNode.getNode().toString()",
        "description": "Transmitting sensitive information across a network in cleartext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-311/CleartextTransmission.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.InsecureTLSQuery\nimport InsecureTlsFlow::PathGraph\n\nfrom InsecureTlsFlow::PathNode sourceNode, InsecureTlsFlow::PathNode sinkNode\nwhere InsecureTlsFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode, \"This TLS configuration is insecure.\"",
        "description": "TLS v1.0 and v1.1 versions are known to be vulnerable. TLS v1.2 or v1.3 should be used instead.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-757/InsecureTLS.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.ConstantSaltQuery\nimport ConstantSaltFlow::PathGraph\n\nfrom\n  ConstantSaltFlow::PathNode sourcePathNode, ConstantSaltFlow::PathNode sinkPathNode,\n  DataFlow::Node sourceNode\nwhere\n  ConstantSaltFlow::flowPath(sourcePathNode, sinkPathNode) and sourceNode = sourcePathNode.getNode()\nselect sinkPathNode.getNode(), sourcePathNode, sinkPathNode,\n  \"The value $@ is used as a constant, which is insecure for hashing passwords.\", sourceNode,\n  sourceNode.toString()",
        "description": "Using constant salts for password hashing is not secure because potential attackers can precompute the hash value via dictionary attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-760/ConstantSalt.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.StaticInitializationVectorQuery\nimport StaticInitializationVectorFlow::PathGraph\n\nfrom\n  StaticInitializationVectorFlow::PathNode sourceNode,\n  StaticInitializationVectorFlow::PathNode sinkNode\nwhere StaticInitializationVectorFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"The static value '\" + sourceNode.getNode().toString() +\n    \"' is used as an initialization vector for encryption.\"",
        "description": "Using a static initialization vector (IV) for encryption is not secure. To maximize encryption and prevent dictionary attacks, IVs should be unique and unpredictable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-1204/StaticInitializationVector.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.SqlInjectionQuery\nimport SqlInjectionFlow::PathGraph\n\nfrom SqlInjectionFlow::PathNode sourceNode, SqlInjectionFlow::PathNode sinkNode\nwhere SqlInjectionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode, \"This query depends on a $@.\",\n  sourceNode.getNode(), \"user-provided value\"",
        "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-089/SqlInjection.ql",
        "language": "swift"
    },
    {
        "query": "private import swift\nprivate import codeql.swift.dataflow.DataFlow\nprivate import codeql.swift.regex.Regex\nprivate import codeql.swift.regex.RegexTreeView::RegexTreeView as TreeImpl\nprivate import codeql.swift.security.regex.HostnameRegex as HostnameRegex\nprivate import codeql.regex.MissingRegExpAnchor as MissingRegExpAnchor\n\nprivate module Impl implements\n  MissingRegExpAnchor::MissingRegExpAnchorSig<TreeImpl, HostnameRegex::Impl>\n{\n  predicate isUsedAsReplace(RegexPatternSource pattern) {\n    exists(RegexEval eval |\n      eval.getARegex() = pattern.asExpr() and\n      eval.isUsedAsReplace()\n    )\n  }\n\n  string getEndAnchorText() { result = \"$\" }\n}\n\nimport MissingRegExpAnchor::Make<TreeImpl, HostnameRegex::Impl, Impl>\n\nfrom DataFlow::Node node, string msg\nwhere\n  isUnanchoredHostnameRegExp(node, msg)\n  or\n  isSemiAnchoredHostnameRegExp(node, msg)\n  or\n  hasMisleadingAnchorPrecedence(node, msg)\n  or\n  isLineAnchoredHostnameRegExp(node, msg)\nselect node, msg",
        "description": "Regular expressions without anchors can be vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-020/MissingRegexAnchor.ql",
        "language": "swift"
    },
    {
        "query": "private import codeql.swift.security.regex.HostnameRegex as HostnameRegex\n\nquery predicate problems = HostnameRegex::incompleteHostnameRegExp/4;",
        "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname may match more hostnames than expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-020/IncompleteHostnameRegex.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.ConstantPasswordQuery\nimport ConstantPasswordFlow::PathGraph\n\nfrom ConstantPasswordFlow::PathNode sourceNode, ConstantPasswordFlow::PathNode sinkNode\nwhere ConstantPasswordFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"The value '\" + sourceNode.getNode().toString() + \"' is used as a constant password.\"",
        "description": "Using constant passwords is not secure, because potential attackers can easily recover them from the source code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-259/ConstantPassword.ql",
        "language": "swift"
    },
    {
        "query": "import codeql.swift.regex.Regex\nprivate import codeql.swift.regex.RegexTreeView::RegexTreeView as TreeView\nimport codeql.regex.nfa.BadTagFilterQuery::Make<TreeView>\n\nfrom HtmlMatchingRegExp regexp, string msg\nwhere\n  // there might be multiple messages, we arbitrarily pick the shortest one\n  msg = min(string m | isBadRegexpFilter(regexp, m) | m order by m.length(), m)\nselect regexp, msg",
        "description": "Matching HTML tags using regular expressions is hard to do right, and can lead to security issues.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-116/BadTagFilter.ql",
        "language": "swift"
    },
    {
        "query": "import codeql.swift.regex.Regex\nprivate import codeql.swift.regex.RegexTreeView::RegexTreeView as TreeView\nimport codeql.regex.nfa.ExponentialBackTracking::Make<TreeView>\n\nfrom TreeView::RegExpTerm t, string pump, State s, string prefixMsg\nwhere hasReDoSResult(t, pump, s, prefixMsg)\nselect t,\n  \"This part of the regular expression may cause exponential backtracking on strings \" + prefixMsg +\n    \"containing many repetitions of '\" + pump + \"'.\"",
        "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-1333/ReDoS.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.CleartextStoragePreferencesQuery\nimport CleartextStoragePreferencesFlow::PathGraph\n\nDataFlow::Node cleanupNode(DataFlow::Node n) {\n  result = n.(DataFlow::PostUpdateNode).getPreUpdateNode()\n  or\n  not n instanceof DataFlow::PostUpdateNode and\n  result = n\n}\n\nfrom\n  CleartextStoragePreferencesFlow::PathNode sourceNode,\n  CleartextStoragePreferencesFlow::PathNode sinkNode, DataFlow::Node cleanSink\nwhere\n  CleartextStoragePreferencesFlow::flowPath(sourceNode, sinkNode) and\n  cleanSink = cleanupNode(sinkNode.getNode())\nselect cleanSink, sourceNode, sinkNode,\n  \"This operation stores '\" + cleanSink.toString() + \"' in \" +\n    sinkNode.getNode().(CleartextStoragePreferencesSink).getStoreName() +\n    \". It may contain unencrypted sensitive data from $@.\", sourceNode,\n  sourceNode.getNode().toString()",
        "description": "Storing sensitive information in a non-encrypted store can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-312/CleartextStoragePreferences.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.CleartextLoggingQuery\nimport CleartextLoggingFlow::PathGraph\n\nfrom CleartextLoggingFlow::PathNode source, CleartextLoggingFlow::PathNode sink\nwhere CleartextLoggingFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This operation writes '\" + sink.toString() +\n    \"' to a log file. It may contain unencrypted sensitive data from $@.\", source,\n  source.getNode().toString()",
        "description": "Logging sensitive information in plaintext can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-312/CleartextLogging.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.UncontrolledFormatStringQuery\nimport TaintedFormatFlow::PathGraph\n\nfrom TaintedFormatFlow::PathNode sourceNode, TaintedFormatFlow::PathNode sinkNode\nwhere TaintedFormatFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode, \"This format string depends on $@.\",\n  sourceNode.getNode(), \"this user-provided value\"",
        "description": "Using external input in format strings can lead to exceptions or information leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-134/UncontrolledFormatString.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.StringLengthConflationQuery\nimport StringLengthConflationFlow::PathGraph\n\nfrom\n  StringLengthConflationFlow::PathNode source, StringLengthConflationFlow::PathNode sink,\n  StringType sourceType, StringType sinkType, string message\nwhere\n  StringLengthConflationFlow::flowPath(source, sink) and\n  StringLengthConflationConfig::isSource(source.getNode(), sourceType) and\n  sinkType = sink.getNode().(StringLengthConflationSink).getCorrectStringType() and\n  message =\n    \"This \" + sourceType + \" length is used in \" + sinkType.getSingular() +\n      \", but it may not be equivalent.\"\nselect sink.getNode(), source, sink, message",
        "description": "Using a length value from an `NSString` in a `String`, or a count from a `String` in an `NSString`, may cause unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-135/StringLengthConflation.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.regex.RegexInjectionQuery\nimport RegexInjectionFlow::PathGraph\n\nfrom RegexInjectionFlow::PathNode sourceNode, RegexInjectionFlow::PathNode sinkNode\nwhere RegexInjectionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode,\n  \"This regular expression is constructed from a $@.\", sourceNode.getNode(), \"user-provided value\"",
        "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to provide a regex that could require exponential time on certain inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-730/RegexInjection.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.PathInjectionQuery\nimport PathInjectionFlow::PathGraph\n\nfrom PathInjectionFlow::PathNode source, PathInjectionFlow::PathNode sink\nwhere PathInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-022/PathInjection.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.XXEQuery\nimport XxeFlow::PathGraph\n\nfrom XxeFlow::PathNode source, XxeFlow::PathNode sink\nwhere XxeFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against external entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-611/XXE.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.CommandInjectionQuery\nimport CommandInjectionFlow::PathGraph\n\nfrom CommandInjectionFlow::PathNode sourceNode, CommandInjectionFlow::PathNode sinkNode\nwhere CommandInjectionFlow::flowPath(sourceNode, sinkNode)\nselect sinkNode.getNode(), sourceNode, sinkNode, \"This command depends on a $@.\",\n  sourceNode.getNode(), \"user-provided value\"",
        "description": "Building a system command from user-controlled sources may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-078/CommandInjection.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.UnsafeWebViewFetchQuery\nimport UnsafeWebViewFetchFlow::PathGraph\n\nfrom\n  UnsafeWebViewFetchFlow::PathNode sourceNode, UnsafeWebViewFetchFlow::PathNode sinkNode,\n  UnsafeWebViewFetchSink sink, string message\nwhere\n  UnsafeWebViewFetchFlow::flowPath(sourceNode, sinkNode) and\n  sink = sinkNode.getNode() and\n  (\n    // no base URL\n    not exists(sink.getBaseUrl()) and\n    message = \"Tainted data is used in a WebView fetch.\"\n    or\n    // base URL is nil\n    sink.getBaseUrl() instanceof NilLiteralExpr and\n    message = \"Tainted data is used in a WebView fetch without restricting the base URL.\"\n    or\n    // base URL is also tainted\n    UnsafeWebViewFetchFlow::flowToExpr(sink.getBaseUrl()) and\n    message = \"Tainted data is used in a WebView fetch with a tainted base URL.\"\n  )\nselect sink, sourceNode, sinkNode, message",
        "description": "Fetching data in a WebView without restricting the base URL may allow an attacker to access sensitive local data, or enable cross-site scripting attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Security/CWE-079/UnsafeWebViewFetch.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.printast.PrintAst\nimport codeql.IDEContextual\nimport codeql.swift.generated.ParentChild\n\nexternal string selectedSourceFile();\n\nclass PrintAstConfigurationOverride extends PrintAstConfiguration {\n  /**\n   * Holds if the location matches the selected file in the VS Code extension and\n   * the element is `e`.\n   */\n  override predicate shouldPrint(Locatable e) {\n    super.shouldPrint(e) and\n    (\n      e.getFile() = getFileBySourceArchiveName(selectedSourceFile())\n      or\n      exists(Locatable parent | this.shouldPrint(parent) and parent = getImmediateParent(e))\n    )\n  }\n}",
        "description": "Outputs a representation of a file's Abstract Syntax Tree. This query is used by the VS Code extension.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/ide-contextual-queries/printAst.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.FlowSources\nimport codeql.swift.security.SensitiveExprs\nimport codeql.swift.regex.Regex\n\npredicate statistic(string what, string value) {\n  what = \"Files\" and value = count(File f).toString()\n  or\n  what = \"Lines of code\" and value = sum(File f | | f.getNumberOfLinesOfCode()).toString()\n  or\n  what = \"Compiler errors\" and value = count(CompilerError d).toString()\n  or\n  what = \"Compiler warnings\" and value = count(CompilerWarning d).toString()\n  or\n  what = \"Expressions\" and value = count(Expr e | not e.getFile() instanceof UnknownFile).toString()\n  or\n  what = \"Local flow sources\" and value = count(LocalFlowSource s).toString()\n  or\n  what = \"Remote flow sources\" and value = count(RemoteFlowSource s).toString()\n  or\n  what = \"Sensitive expressions\" and value = count(SensitiveExpr e).toString()\n  or\n  what = \"Regular expression evals\" and value = count(RegexEval e).toString()\n  or\n  what = \"Regular expressions evaluated\" and\n  value = count(RegexEval e | | e.getARegex()).toString()\n}\n\nfrom string what, string value\nwhere statistic(what, value)\nselect what, value",
        "description": "A table of summary statistics about a database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Summary/SummaryStats.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.FlowSources\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.dataflow.TaintTracking\n\nmodule TaintReachConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node instanceof FlowSource }\n\n  predicate isSink(DataFlow::Node node) { any() }\n}\n\nmodule TaintReachFlow = TaintTracking::Global<TaintReachConfig>;\n\nint taintedNodesCount() { result = count(DataFlow::Node n | TaintReachFlow::flowTo(n)) }\n\nfloat taintReach() { result = (taintedNodesCount() * 1000000.0) / count(DataFlow::Node n) }\n\npredicate statistic(string what, string value) {\n  what = \"Dataflow nodes (total)\" and value = count(DataFlow::Node n).toString()\n  or\n  what = \"Dataflow nodes (tainted)\" and value = taintedNodesCount().toString()\n  or\n  what = \"Taint reach (per million nodes)\" and value = taintReach().toString()\n}\n\nfrom string what, string value\nwhere statistic(what, value)\nselect what, value",
        "description": "Calculates 'taint reach', a measure of how much of a database is reached from flow sources, via taint flow. This can be expensive to compute on large databases.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Summary/TaintReach.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.security.SensitiveExprs\n\nfrom SensitiveExpr e\nselect e, \"Sensitive expression: \" + e.getSensitiveType()",
        "description": "List all sensitive expressions found in the database. Sensitive expressions are expressions that have been identified as potentially containing data that should not be leaked to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Summary/SensitiveExprs.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.regex.Regex\n\nfrom RegexEval e, string message, Expr regex\nwhere\n  message = \"Regular expression evaluation with source $@.\" and regex = e.getARegex()\n  or\n  message = \"Regular expression evaluation with no identified source.\" and\n  not exists(e.getARegex()) and\n  regex = e\nselect e, message, regex, regex.toString()",
        "description": "List all regular expression evaluations found in the database.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Summary/RegexEvals.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.DataFlow\nimport codeql.swift.security.PathInjectionQuery\nimport codeql.swift.security.UnsafeWebViewFetchQuery\nimport codeql.swift.security.SqlInjectionQuery\nimport codeql.swift.security.UnsafeJsEvalQuery\nimport codeql.swift.security.UncontrolledFormatStringQuery\nimport codeql.swift.security.StringLengthConflationQuery\nimport codeql.swift.security.ConstantPasswordQuery\nimport codeql.swift.security.CleartextStorageDatabaseQuery\nimport codeql.swift.security.CleartextTransmissionQuery\nimport codeql.swift.security.CleartextLoggingQuery\nimport codeql.swift.security.CleartextStoragePreferencesQuery\nimport codeql.swift.security.HardcodedEncryptionKeyQuery\nimport codeql.swift.security.ECBEncryptionQuery\nimport codeql.swift.security.WeakSensitiveDataHashingQuery as WeakSensitiveDataHashingQuery\nimport codeql.swift.security.WeakPasswordHashingQuery as WeakPasswordHashingQuery\nimport codeql.swift.security.XXEQuery\nimport codeql.swift.security.InsecureTLSQuery\nimport codeql.swift.security.ConstantSaltQuery\nimport codeql.swift.security.InsufficientHashIterationsQuery\nimport codeql.swift.security.PredicateInjectionQuery\nimport codeql.swift.security.StaticInitializationVectorQuery\n\nstring queryForSink(DataFlow::Node sink) {\n  PathInjectionConfig::isSink(sink) and result = \"swift/path-injection\"\n  or\n  UnsafeWebViewFetchConfig::isSink(sink) and result = \"swift/unsafe-webview-fetch\"\n  or\n  SqlInjectionConfig::isSink(sink) and result = \"swift/sql-injection\"\n  or\n  UnsafeJsEvalConfig::isSink(sink) and result = \"swift/unsafe-js-eval\"\n  or\n  TaintedFormatConfig::isSink(sink) and result = \"swift/uncontrolled-format-string\"\n  or\n  StringLengthConflationConfig::isSink(sink) and result = \"swift/string-length-conflation\"\n  or\n  ConstantPasswordConfig::isSink(sink) and result = \"swift/constant-password\"\n  or\n  CleartextStorageDatabaseConfig::isSink(sink) and result = \"swift/cleartext-storage-database\"\n  or\n  CleartextTransmissionConfig::isSink(sink) and result = \"swift/cleartext-transmission\"\n  or\n  CleartextLoggingConfig::isSink(sink) and result = \"swift/cleartext-logging\"\n  or\n  CleartextStoragePreferencesConfig::isSink(sink) and result = \"swift/cleartext-storage-preferences\"\n  or\n  HardcodedKeyConfig::isSink(sink) and result = \"swift/hardcoded-key\"\n  or\n  EcbEncryptionConfig::isSink(sink) and result = \"swift/ecb-encryption\"\n  or\n  WeakSensitiveDataHashingQuery::WeakSensitiveDataHashingConfig::isSink(sink) and\n  result = \"swift/weak-sensitive-data-hashing\"\n  or\n  WeakPasswordHashingQuery::WeakPasswordHashingConfig::isSink(sink) and\n  result = \"swift/weak-password-hashing\"\n  or\n  XxeConfig::isSink(sink) and result = \"swift/xxe\"\n  or\n  InsecureTlsConfig::isSink(sink) and result = \"swift/insecure-tls\"\n  or\n  ConstantSaltConfig::isSink(sink) and result = \"swift/constant-salt\"\n  or\n  InsufficientHashIterationsConfig::isSink(sink) and result = \"swift/insufficient-hash-iterations\"\n  or\n  PredicateInjectionConfig::isSink(sink) and result = \"swift/predicate-injection\"\n  or\n  StaticInitializationVectorConfig::isSink(sink) and result = \"swift/static-initialization-vector\"\n}\n\nfrom DataFlow::Node n\nselect n, \"Sink for \" + queryForSink(n)",
        "description": "List all query sinks found in the database. Query sinks are potential results depending on what data flows to them and other context.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Summary/QuerySinks.ql",
        "language": "swift"
    },
    {
        "query": "import swift\nimport codeql.swift.dataflow.FlowSources\n\nstring sourceClass(FlowSource s) {\n  s instanceof LocalFlowSource and result = \"Local flow source\"\n  or\n  s instanceof RemoteFlowSource and result = \"Remote flow source\"\n}\n\nfrom FlowSource s\nselect s, sourceClass(s) + \": \" + s.getSourceType()",
        "description": "List all flow sources found in the database. Flow sources indicate data that originates from an untrusted source, such as as untrusted remote data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/queries/Summary/FlowSources.ql",
        "language": "swift"
    },
    {
        "query": "import swift\n\nfrom File f\nwhere exists(f.getRelativePath())\nselect f, \"File successfully extracted.\"",
        "description": "Lists all files in the source code directory that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/diagnostics/ExtractedFiles.ql",
        "language": "swift"
    },
    {
        "query": "import swift\n\nselect sum(File f | | f.getNumberOfLinesOfCode())",
        "description": "Count all lines in source code in which something was extracted. Entities spanning multiple lines like multi-line strings or comments only contribute one line to this count.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/diagnostics/SuccessfullyExtractedLines.ql",
        "language": "swift"
    },
    {
        "query": "import swift\n\nfrom CompilerError error\nselect error, \"Compiler error in \" + error.getFile() + \" with error message \" + error.getText()",
        "description": "List all compiler errors for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/diagnostics/internal/ExtractionErrors.ql",
        "language": "swift"
    },
    {
        "query": "import swift\n\nselect count(AstNode n | n.getAPrimaryQlClass().matches(\"Unresolved%\") | n)",
        "description": "Count all unresolved AST nodes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/diagnostics/internal/UnresolvedAstNodes.ql",
        "language": "swift"
    },
    {
        "query": "import swift\n\nselect count(AstNode n)",
        "description": "Count all AST nodes.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/swift/ql/src/diagnostics/internal/AstNodes.ql",
        "language": "swift"
    },
    {
        "query": "private import codeql.util.suppression.AlertSuppression as AS\nprivate import javascript as JS\n\nclass AstNode extends JS::Locatable {\n  AstNode() { not this.(JS::HTML::TextNode).getText().regexpMatch(\"\\\\s*\") }\n\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.getLocation().hasLocationInfo(filepath, startline, startcolumn, endline, endcolumn)\n  }\n}\n\nclass SingleLineComment extends AstNode {\n  private string text;\n\n  SingleLineComment() {\n    (\n      text = this.(JS::Comment).getText() or\n      text = this.(JS::HTML::CommentNode).getText()\n    ) and\n    // suppression comments must be single-line\n    not text.matches(\"%\\n%\")\n  }\n\n  string getText() { result = text }\n}\n\nimport AS::Make<AstNode, SingleLineComment>",
        "description": "Generates information about alert suppressions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AlertSuppression.ql",
        "language": "javascript"
    },
    {
        "query": "import definitions\n\nfrom Locatable e, AstNode def, string kind\nwhere def = definitionOf(e, kind)\nselect e, def, kind",
        "description": "Generates use-definition pairs that provide the data for jump-to-definition in the code viewer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/definitions.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.filters.ClassifyFiles\n\nfrom File f, string category\nwhere classify(f, category)\nselect f, category",
        "description": "This query produces a list of all files in a snapshot that are classified as generated code, test code, externs declarations, library code or template code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/filters/ClassifyFiles.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, int n\nwhere n = f.getNumberOfLines()\nselect f, n order by n desc",
        "description": "The number of lines in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FLines.ql",
        "language": "javascript"
    },
    {
        "query": "import ES20xxFeatures\n\nfrom File f\nselect f, count(AstNode nd | nd.getFile() = f and isES20xxFeature(nd, _, _)) as n order by n desc",
        "description": "Measures the number of uses of language features introduced in ECMAScript 2015 or later in files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FUseOfES6.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, int n\nwhere n = strictsum(TopLevel tl | tl = f.getATopLevel() | tl.getNumberOfLines())\nselect f, 100.0 * (f.getNumberOfLinesOfComments().(float) / n.(float)) as ratio order by ratio desc",
        "description": "The percentage of lines in a file that contain comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FCommentRatio.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Function func, int complexity\nwhere complexity = func.getCyclomaticComplexity()\nselect func, complexity order by complexity desc",
        "description": "The cyclomatic complexity of a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FunCyclomaticComplexity.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f\nselect f, f.getNumberOfLinesOfComments() as n order by n desc",
        "description": "Files with few lines of comment might not have sufficient documentation to make them understandable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FLinesOfComment.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, int n\nwhere none()\nselect f, n order by n desc",
        "description": "The number of lines in a file (including code, comment and whitespace lines) occurring in a block of lines that is duplicated at least once somewhere else.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FLinesOfDuplicatedCode.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, int n\nwhere n = count(Function fun | fun.getTopLevel().getFile() = f)\nselect f, n order by n desc",
        "description": "The number of functions in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FFunctions.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, int n\nwhere n = f.getNumberOfLinesOfCode()\nselect f, n order by n desc",
        "description": "Measures the number of lines of code in each file, ignoring lines that contain only comments or whitespace.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FLinesOfCode.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Function f\nselect f, f.getNumberOfLinesOfCode() as n order by n desc",
        "description": "The number of lines of code in a function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FunLinesOfCode.ql",
        "language": "javascript"
    },
    {
        "query": "import semmle.javascript.frameworks.Testing\n\nfrom File f, int n\nwhere n = strictcount(Test test | test.getFile() = f)\nselect f, n order by n desc",
        "description": "The number of tests defined in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FNumberOfTests.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, float n\nwhere\n  n =\n    avg(Function fun, int toAvg |\n      fun.getTopLevel().getFile() = f and toAvg = fun.getCyclomaticComplexity()\n    |\n      toAvg\n    )\nselect f, n",
        "description": "The average cyclomatic complexity of the functions in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FCyclomaticComplexity.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, int n\nwhere none()\nselect f, n order by n desc",
        "description": "The number of lines in a file (including code, comment and whitespace lines) occurring in a block of lines that is similar to a block of lines seen somewhere else.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FLinesOfSimilarCode.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f, int n\nwhere n = count(Stmt s | s.getTopLevel().getFile() = f)\nselect f, n order by n desc",
        "description": "The number of statements in a file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/FNumberOfStatements.ql",
        "language": "javascript"
    },
    {
        "query": "import ExternalDependencies\n\nfrom File f, Dependency dep, string entity, int n\nwhere externalDependencies(f, dep, entity, n)\nselect entity, n order by n desc",
        "description": "Count the number of dependencies a JavaScript source file has on NPM packages or framework libraries.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/Dependencies/ExternalDependencies.ql",
        "language": "javascript"
    },
    {
        "query": "import ExternalDependencies\n\nfrom File f, string entity\nwhere externalDependencies(f, _, entity, _)\nselect entity, f",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Metrics/Dependencies/ExternalDependenciesSourceLinks.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CommentedOut\n\npredicate isFlowAnnotation(SlashStarComment c) {\n  c.getText().regexpMatch(\"^(?s)\\\\s*(: |::|flow-include ).*\")\n}\n\nfrom CommentedOutCode c\nwhere not isFlowAnnotation(c)\nselect c, \"This comment appears to contain commented-out code.\"",
        "description": "Comments that contain commented-out code should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Comments/CommentedOutCode.ql",
        "language": "javascript"
    },
    {
        "query": "import CommentedOut\n\nfrom File f\nselect f, sum(CommentedOutCode comment | comment.getFile() = f | comment.getNumCodeLines())",
        "description": "Measures the number of commented-out lines of code in each file.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Comments/FCommentedOutCode.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Comment c\nwhere c.getText().regexpMatch(\"(?s).*FIXME.*|.*TODO.*|.*(?<!=)\\\\s*XXX.*\")\nselect c, \"TODO comments should be addressed.\"",
        "description": "A comment that contains 'TODO' or similar keywords may indicate code that is incomplete or broken, or it may highlight an ambiguity in the software's specification.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Comments/TodoComments.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CodeInjectionQuery\nimport CodeInjectionFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom CodeInjectionFlow::PathNode source, CodeInjectionFlow::PathNode sink\nwhere CodeInjectionFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, sink.getNode().(Sink).getMessagePrefix() + \" depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Interpreting unsanitized user input as code allows a malicious user arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-094/CodeInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ConditionalBypassQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport ConditionalBypassFlow::PathGraph\n\nfrom\n  ConditionalBypassFlow::PathNode source, ConditionalBypassFlow::PathNode sink,\n  SensitiveAction action\nwhere\n  isTaintedGuardNodeForSensitiveAction(sink, source, action) and\n  not isEarlyAbortGuardNode(sink, action) and\n  source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, \"This condition guards a sensitive $@, but a $@ controls it.\",\n  action, \"action\", source.getNode(), \"user-provided value\"",
        "description": "Conditions that the user controls are not suited for making security-related decisions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-807/ConditionalBypass.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.SqlInjectionQuery as Sql\nimport semmle.javascript.security.dataflow.NosqlInjectionQuery as Nosql\nimport semmle.javascript.heuristics.AdditionalSources\n\nmodule Merged =\n  DataFlow::MergePathGraph<Sql::SqlInjectionFlow::PathNode, Nosql::NosqlInjectionFlow::PathNode,\n    Sql::SqlInjectionFlow::PathGraph, Nosql::NosqlInjectionFlow::PathGraph>;\n\nimport DataFlow::DeduplicatePathGraph<Merged::PathNode, Merged::PathGraph>\n\nfrom PathNode source, PathNode sink, string type\nwhere\n  Sql::SqlInjectionFlow::flowPath(source.getAnOriginalPathNode().asPathNode1(),\n    sink.getAnOriginalPathNode().asPathNode1()) and\n  type = \"string\"\n  or\n  Nosql::NosqlInjectionFlow::flowPath(source.getAnOriginalPathNode().asPathNode2(),\n    sink.getAnOriginalPathNode().asPathNode2()) and\n  type = \"object\"\nselect sink.getNode(), source, sink, \"This query \" + type + \" depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-089/SqlInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ExternalAPIUsedWithUntrustedDataQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport ExternalAPIUsedWithUntrustedDataFlow::PathGraph\n\nfrom\n  ExternalAPIUsedWithUntrustedDataFlow::PathNode source,\n  ExternalAPIUsedWithUntrustedDataFlow::PathNode sink\nwhere\n  ExternalAPIUsedWithUntrustedDataFlow::flowPath(source, sink) and\n  source.getNode() instanceof HeuristicSource\nselect sink, source, sink,\n  \"Call to \" + sink.getNode().(Sink).getApiName() + \" with untrusted data from $@.\", source,\n  source.toString()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-020/UntrustedDataToExternalAPI.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.RemotePropertyInjectionQuery\nimport RemotePropertyInjectionFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom RemotePropertyInjectionFlow::PathNode source, RemotePropertyInjectionFlow::PathNode sink\nwhere\n  RemotePropertyInjectionFlow::flowPath(source, sink) and\n  source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, sink.getNode().(Sink).getMessage() + \" depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Allowing writes to arbitrary properties of an object may lead to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-400/RemotePropertyInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ResourceExhaustionQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport ResourceExhaustionFlow::PathGraph\n\nfrom ResourceExhaustionFlow::PathNode source, ResourceExhaustionFlow::PathNode sink\nwhere ResourceExhaustionFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink, source, sink, sink.getNode().(Sink).getProblemDescription() + \" from a $@.\", source,\n  \"user-provided value\"",
        "description": "Allocating objects or timers with user-controlled sizes or durations can cause resource exhaustion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-770/ResourceExhaustion.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.LogInjectionQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode source, LogInjectionFlow::PathNode sink\nwhere LogInjectionFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, \"Log entry depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-117/LogInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CorsMisconfigurationForCredentialsQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport CorsMisconfigurationFlow::PathGraph\n\nfrom CorsMisconfigurationFlow::PathNode source, CorsMisconfigurationFlow::PathNode sink\nwhere\n  CorsMisconfigurationFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, \"$@ leak vulnerability due to a $@.\",\n  sink.getNode().(Sink).getCredentialsHeader(), \"Credential\", source.getNode(),\n  \"misconfigured CORS header value\"",
        "description": "Misconfiguration of CORS HTTP headers allows for leaks of secret credentials.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-346/CorsMisconfigurationForCredentials.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.PrototypePollutingAssignmentQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport PrototypePollutingAssignmentFlow::PathGraph\n\nfrom\n  PrototypePollutingAssignmentFlow::PathNode source, PrototypePollutingAssignmentFlow::PathNode sink\nwhere\n  PrototypePollutingAssignmentFlow::flowPath(source, sink) and\n  not isIgnoredLibraryFlow(source.getNode(), sink.getNode()) and\n  source.getNode() instanceof HeuristicSource\nselect sink, source, sink,\n  \"This assignment may alter Object.prototype if a malicious '__proto__' string is injected from $@.\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "Modifying an object obtained via a user-controlled property name may lead to accidental mutation of the built-in Object prototype, and possibly escalate to remote code execution or cross-site scripting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-915/PrototypePollutingAssignment.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.XmlBombQuery\nimport XmlBombFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom XmlBombFlow::PathNode source, XmlBombFlow::PathNode sink\nwhere XmlBombFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against uncontrolled entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user input as an XML document with arbitrary internal entity expansion is vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-776/XmlBomb.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.TaintedFormatStringQuery\nimport TaintedFormatStringFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom TaintedFormatStringFlow::PathNode source, TaintedFormatStringFlow::PathNode sink\nwhere\n  TaintedFormatStringFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, \"Format string depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using external input in format strings can lead to garbled output.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-134/TaintedFormatString.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnsafeDeserializationQuery\nimport UnsafeDeserializationFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom UnsafeDeserializationFlow::PathNode source, UnsafeDeserializationFlow::PathNode sink\nwhere\n  UnsafeDeserializationFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, \"Unsafe deserialization depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-502/UnsafeDeserialization.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.RegExpInjectionQuery\nimport RegExpInjectionFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom RegExpInjectionFlow::PathNode source, RegExpInjectionFlow::PathNode sink\nwhere RegExpInjectionFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, \"This regular expression is constructed from a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-730/RegExpInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.XxeQuery\nimport XxeFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom XxeFlow::PathNode source, XxeFlow::PathNode sink\nwhere XxeFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against external entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-611/Xxe.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CommandInjectionQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport CommandInjectionFlow::PathGraph\n\nfrom\n  CommandInjectionFlow::PathNode source, CommandInjectionFlow::PathNode sink,\n  DataFlow::Node highlight, Source sourceNode\nwhere\n  CommandInjectionFlow::flowPath(source, sink) and\n  (\n    if isSinkWithHighlight(sink.getNode(), _)\n    then isSinkWithHighlight(sink.getNode(), highlight)\n    else highlight = sink.getNode()\n  ) and\n  sourceNode = source.getNode() and\n  source.getNode() instanceof HeuristicSource\nselect highlight, source, sink, \"This command line depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-078/CommandInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.XpathInjectionQuery\nimport XpathInjectionFlow::PathGraph\nimport semmle.javascript.heuristics.AdditionalSources\n\nfrom XpathInjectionFlow::PathNode source, XpathInjectionFlow::PathNode sink\nwhere XpathInjectionFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink, \"XPath expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-643/XpathInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.DomBasedXssQuery\nimport semmle.javascript.heuristics.AdditionalSources\nimport DomBasedXssFlow::PathGraph\n\nfrom DomBasedXssFlow::PathNode source, DomBasedXssFlow::PathNode sink\nwhere DomBasedXssFlow::flowPath(source, sink) and source.getNode() instanceof HeuristicSource\nselect sink.getNode(), source, sink,\n  sink.getNode().(Sink).getVulnerabilityKind() + \" vulnerability due to $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/heuristics/ql/src/Security/CWE-079/Xss.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DataFlow::NewNode newSet, DataFlow::Node ignoredArg\nwhere\n  newSet = DataFlow::globalVarRef(\"Set\").getAnInstantiation() and\n  (\n    ignoredArg = newSet.getArgument(any(int n | n > 0))\n    or\n    ignoredArg = newSet.getASpreadArgument()\n  )\nselect ignoredArg, \"All but the first argument to the Set constructor are ignored.\"",
        "description": "The `Set` constructor ignores all but the first argument, so passing multiple arguments may indicate a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/StandardLibrary/MultipleArgumentsToSetConstructor.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport SSRF\nimport SsrfFlow::PathGraph\n\nfrom SsrfFlow::PathNode source, SsrfFlow::PathNode sink, DataFlow::Node request\nwhere\n  SsrfFlow::flowPath(source, sink) and request = sink.getNode().(RequestForgery::Sink).getARequest()\nselect sink, source, sink, \"The URL of this request depends on a user-provided value.\"",
        "description": "Sending network requests with user-controlled data as part of the URL allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-918/SSRF.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport DecompressionBombs\n\nmodule DecompressionBombConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof DecompressionBomb::Sink }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DecompressionBomb::AdditionalTaintStep addstep |\n      addstep.isAdditionalTaintStep(node1, node2)\n    )\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule DecompressionBombFlow = TaintTracking::Global<DecompressionBombConfig>;\n\nimport DecompressionBombFlow::PathGraph\n\nfrom DecompressionBombFlow::PathNode source, DecompressionBombFlow::PathNode sink\nwhere DecompressionBombFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This Decompression depends on a $@.\", source.getNode(),\n  \"potentially untrusted source\"",
        "description": "User-controlled data that flows into decompression library APIs without checking the compression rate is dangerous",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-522-DecompressionBombs/DecompressionBombs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nDataFlow::InvokeNode nodeInvocation() {\n  result instanceof ClientRequest\n  or\n  result instanceof Http::ServerDefinition\n}\n\nDataFlow::ObjectLiteralNode nodeOptions() { result.flowsTo(nodeInvocation().getAnArgument()) }\n\nfrom DataFlow::PropWrite disable\nwhere\n  exists(DataFlow::SourceNode env |\n    env = NodeJSLib::process().getAPropertyRead(\"env\") and\n    disable = env.getAPropertyWrite(\"NODE_OPTIONS\") and\n    disable.getRhs().getStringValue().matches(\"%--insecure-http-parser%\")\n  )\n  or\n  (\n    disable = nodeOptions().getAPropertyWrite(\"insecureHTTPParser\")\n    or\n    // the same thing, but with API-nodes if they happen to be available\n    exists(API::Node nodeInvk | nodeInvk.getAnInvocation() = nodeInvocation() |\n      disable.getRhs() = nodeInvk.getAParameter().getMember(\"insecureHTTPParser\").asSink()\n    )\n  ) and\n  disable.getRhs().(AnalyzedNode).getTheBooleanValue() = true\nselect disable, \"Allowing invalid HTTP headers is strongly discouraged.\"",
        "description": "Using an insecure http parser can lead to http smuggling attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-444/InsecureHttpParser.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nmodule EnvValueAndKeyInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink = keyOfEnv() or\n    sink = valueOfEnv()\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    exists(DataFlow::InvokeNode ikn |\n      ikn = DataFlow::globalVarRef(\"Object\").getAMemberInvocation(\"keys\")\n    |\n      node1 = ikn.getArgument(0) and\n      (\n        node2 = ikn.getAChainedMethodCall([\"filter\", \"map\"]) or\n        node2 = ikn or\n        node2 = ikn.getAChainedMethodCall(\"forEach\").getABoundCallbackParameter(0, 0)\n      )\n    )\n  }\n}\n\nmodule EnvValueAndKeyInjectionFlow = TaintTracking::Global<EnvValueAndKeyInjectionConfig>;\n\nDataFlow::Node keyOfEnv() {\n  result =\n    NodeJSLib::process().getAPropertyRead(\"env\").getAPropertyWrite().getPropertyNameExpr().flow()\n}\n\nDataFlow::Node valueOfEnv() {\n  result = API::moduleImport(\"process\").getMember(\"env\").getAMember().asSink()\n}\n\nprivate predicate readToProcessEnv(DataFlow::Node envKey, DataFlow::Node envValue) {\n  exists(DataFlow::PropWrite env |\n    env = NodeJSLib::process().getAPropertyRead(\"env\").getAPropertyWrite()\n  |\n    envKey = env.getPropertyNameExpr().flow() and\n    envValue = env.getRhs()\n  )\n}\n\nimport EnvValueAndKeyInjectionFlow::PathGraph\n\nfrom\n  EnvValueAndKeyInjectionFlow::PathNode source, EnvValueAndKeyInjectionFlow::PathNode envKey,\n  EnvValueAndKeyInjectionFlow::PathNode envValue\nwhere\n  EnvValueAndKeyInjectionFlow::flowPath(source, envKey) and\n  envKey.getNode() = keyOfEnv() and\n  EnvValueAndKeyInjectionFlow::flowPath(source, envValue) and\n  envValue.getNode() = valueOfEnv() and\n  readToProcessEnv(envKey.getNode(), envValue.getNode())\nselect envKey.getNode(), source, envKey, \"arbitrary environment variable assignment from this $@.\",\n  source.getNode(), \"user controllable source\"",
        "description": "creating arbitrary environment variables from user controlled data is not secure",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-099/EnvValueAndKeyInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nmodule EnvValueInjectionConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink = API::moduleImport(\"process\").getMember(\"env\").getAMember().asSink()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule EnvValueInjectionFlow = TaintTracking::Global<EnvValueInjectionConfig>;\n\nimport EnvValueInjectionFlow::PathGraph\n\nfrom EnvValueInjectionFlow::PathNode source, EnvValueInjectionFlow::PathNode sink\nwhere EnvValueInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"this environment variable assignment is $@.\",\n  source.getNode(), \"user controllable\"",
        "description": "assigning important environment variables from user controlled data is not secure",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-099/EnvValueInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nabstract class Barrier extends DataFlow::Node { }\n\nclass NonFirstStringConcatLeaf extends Barrier {\n  NonFirstStringConcatLeaf() {\n    exists(StringOps::ConcatenationRoot root |\n      this = root.getALeaf() and\n      not this = root.getFirstLeaf()\n    )\n    or\n    exists(DataFlow::CallNode join |\n      join = DataFlow::moduleMember(\"path\", \"join\").getACall() and\n      this = join.getArgument([1 .. join.getNumArgument() - 1])\n    )\n  }\n}\n\nclass DynamicImport extends DataFlow::ExprNode {\n  DynamicImport() { this = any(DynamicImportExpr e).getSource().flow() }\n}\n\nclass WorkerThreads extends DataFlow::Node {\n  WorkerThreads() {\n    this = API::moduleImport(\"node:worker_threads\").getMember(\"Worker\").getParameter(0).asSink()\n  }\n}\n\nnewtype TFlowState =\n  TTaint() or\n  TUrlConstructor()\n\nmodule CodeInjectionConfig implements DataFlow::StateConfigSig {\n  class FlowState extends TFlowState {\n    string toString() {\n      this = TTaint() and result = \"taint\"\n      or\n      this = TUrlConstructor() and result = \"url-constructor\"\n    }\n  }\n\n  predicate isSource(DataFlow::Node source, FlowState state) {\n    source instanceof ActiveThreatModelSource and state = TTaint()\n  }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof DynamicImport }\n\n  predicate isSink(DataFlow::Node sink, FlowState state) {\n    sink instanceof WorkerThreads and state = TUrlConstructor()\n  }\n\n  predicate isBarrier(DataFlow::Node node) { node instanceof Barrier }\n\n  predicate isAdditionalFlowStep(\n    DataFlow::Node node1, FlowState state1, DataFlow::Node node2, FlowState state2\n  ) {\n    exists(DataFlow::NewNode newUrl | node2 = newUrl |\n      newUrl = DataFlow::globalVarRef(\"URL\").getAnInstantiation() and\n      node1 = newUrl.getArgument(0)\n    ) and\n    state1 = TTaint() and\n    state2 = TUrlConstructor()\n  }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule CodeInjectionFlow = TaintTracking::GlobalWithState<CodeInjectionConfig>;\n\nimport CodeInjectionFlow::PathGraph\n\nfrom CodeInjectionFlow::PathNode source, CodeInjectionFlow::PathNode sink\nwhere CodeInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This command line depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Interpreting unsanitized user input as code allows a malicious user arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-094-dataURL/CodeInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport DataFlow\n\nclass PredictableResultSource extends DataFlow::Node {\n  PredictableResultSource() {\n    exists(API::Node uuidCallRet |\n      uuidCallRet = API::moduleImport(\"uuid\").getMember([\"v1\", \"v3\", \"v5\"]).getReturn()\n    |\n      this = uuidCallRet.asSource()\n    )\n  }\n}\n\nclass TokenAssignmentValueSink extends DataFlow::Node {\n  TokenAssignmentValueSink() {\n    exists(string name | name.toLowerCase().matches([\"%token\", \"%code\"]) |\n      exists(PropWrite pw | this = pw.getRhs() | pw.getPropertyName().toLowerCase() = name)\n      or\n      exists(AssignExpr ae | this = ae.getRhs().flow() |\n        ae.getLhs().(VariableAccess).getVariable().getName().toLowerCase() = name\n      )\n    )\n  }\n}\n\nmodule TokenBuiltFromUuidConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof PredictableResultSource }\n\n  predicate isSink(DataFlow::Node sink) { sink instanceof TokenAssignmentValueSink }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule TokenBuiltFromUuidFlow = TaintTracking::Global<TokenBuiltFromUuidConfig>;\n\nimport TokenBuiltFromUuidFlow::PathGraph\n\nfrom TokenBuiltFromUuidFlow::PathNode source, TokenBuiltFromUuidFlow::PathNode sink\nwhere TokenBuiltFromUuidFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Token built from $@.\", source.getNode(), \"predictable value\"",
        "description": "Tokens used for sensitive tasks, such as, password recovery, and email confirmation, should not use predictable values.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-340/TokenBuiltFromUUID.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport JWT\n\nmodule UnverifiedDecodeConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink = unverifiedDecode() }\n\n  predicate observeDiffInformedIncrementalMode() { any() }\n}\n\nmodule UnverifiedDecodeFlow = TaintTracking::Global<UnverifiedDecodeConfig>;\n\nmodule VerifiedDecodeConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) { source instanceof ActiveThreatModelSource }\n\n  predicate isSink(DataFlow::Node sink) { sink = verifiedDecode() }\n}\n\nmodule VerifiedDecodeFlow = TaintTracking::Global<VerifiedDecodeConfig>;\n\nimport UnverifiedDecodeFlow::PathGraph\n\nfrom UnverifiedDecodeFlow::PathNode source, UnverifiedDecodeFlow::PathNode sink\nwhere\n  UnverifiedDecodeFlow::flowPath(source, sink) and\n  not VerifiedDecodeFlow::flow(source.getNode(), _)\nselect source.getNode(), source, sink, \"Decoding JWT $@.\", sink.getNode(),\n  \"without signature verification\"",
        "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-347/decodeJwtWithoutVerification.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport JWT\n\nmodule DecodeWithoutVerificationConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node source) {\n    source = [unverifiedDecode(), verifiedDecode()].getALocalSource()\n  }\n\n  predicate isSink(DataFlow::Node sink) {\n    sink = unverifiedDecode()\n    or\n    sink = verifiedDecode()\n  }\n\n  predicate observeDiffInformedIncrementalMode() {\n    // TODO(diff-informed): Manually verify if config can be diff-informed.\n    // ql/src/experimental/Security/CWE-347/decodeJwtWithoutVerificationLocalSource.ql:32: Flow call outside 'select' clause\n    // ql/src/experimental/Security/CWE-347/decodeJwtWithoutVerificationLocalSource.ql:42: Flow call outside 'select' clause\n    none()\n  }\n}\n\nmodule DecodeWithoutVerificationFlow = TaintTracking::Global<DecodeWithoutVerificationConfig>;\n\npredicate isSafe(DataFlow::Node source) {\n  DecodeWithoutVerificationFlow::flow(source, verifiedDecode())\n}\n\npredicate isVulnerable(DataFlow::Node source, DataFlow::Node sink) {\n  not isSafe(source) and // i.e., source does not flow to a verify call\n  DecodeWithoutVerificationFlow::flow(source, sink) and // but it does flow to something else\n  sink = unverifiedDecode() // and that something else is a call to decode.\n}\n\nimport DecodeWithoutVerificationFlow::PathGraph\n\nfrom DecodeWithoutVerificationFlow::PathNode source, DecodeWithoutVerificationFlow::PathNode sink\nwhere\n  DecodeWithoutVerificationFlow::flowPath(source, sink) and\n  isVulnerable(source.getNode(), sink.getNode())\nselect source.getNode(), source, sink, \"Decoding JWT $@.\", sink.getNode(),\n  \"without signature verification\"",
        "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/experimental/Security/CWE-347/decodeJwtWithoutVerificationLocalSource.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate exportsAssign(Assignment assign, Variable exportsVar, DataFlow::Node nd) {\n  exists(NodeModule m |\n    exportsVar = m.getScope().getVariable(\"exports\") and\n    assign.getLhs() = exportsVar.getAnAccess() and\n    nd = assign.getRhs().flow()\n  )\n  or\n  exportsAssign(assign, exportsVar, nd.getASuccessor())\n}\n\npredicate moduleExportsAssign(DataFlow::PropWrite pw, DataFlow::Node nd) {\n  pw.getBase().asExpr() instanceof ModuleAccess and\n  pw.getPropertyName() = \"exports\" and\n  nd = pw.getRhs()\n  or\n  moduleExportsAssign(pw, nd.getASuccessor())\n}\n\nfrom Assignment assgn, Variable exportsVar, DataFlow::Node exportsVal\nwhere\n  exportsAssign(assgn, exportsVar, exportsVal) and\n  not exists(exportsVal.getAPredecessor()) and\n  // this is OK if `exportsVal` flows into `module.exports`\n  not moduleExportsAssign(_, exportsVal) and\n  // export assignments do work in closure modules\n  not assgn.getTopLevel() instanceof Closure::ClosureModule\nselect assgn, \"Assigning to 'exports' does not export anything.\"",
        "description": "Assigning to the special 'exports' variable only overwrites its value and does not export anything. Such an assignment is hence most likely unintentional.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/NodeJS/InvalidExport.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate declaresDependency(NpmPackage pkg, string name, JsonValue dep) {\n  dep = pkg.getPackageJson().getDependencies().getPropValue(name)\n}\n\nExpr getAPathExpr(NpmPackage pkg) {\n  exists(Import imprt |\n    result = imprt.getImportedPathExpr() and\n    pkg.getAModule() = imprt.getEnclosingModule()\n  )\n  or\n  exists(ReExportDeclaration decl |\n    result = decl.getImportedPath() and\n    pkg.getAModule() = decl.getEnclosingModule()\n  )\n}\n\nDOM::AttributeDefinition getAUrlAttribute(NpmPackage pkg) {\n  result.getFile() = pkg.getAFile() and\n  DOM::isUrlValuedAttribute(result)\n}\n\nstring getPackageScriptNameWithDependency(NpmPackage pkg, string dependency) {\n  exists(JsonObject scriptsObject, string scriptName, string script |\n    declaresDependency(pkg, dependency, _) and\n    scriptsObject = pkg.getPackageJson().getPropValue(\"scripts\") and\n    script = scriptsObject.getPropStringValue(scriptName) and\n    script.regexpMatch(\".*\\\\b\\\\Q\" + dependency + \"\\\\E\\\\b.*\") and\n    result = scriptName\n  )\n}\n\npredicate usesDependency(NpmPackage pkg, string name) {\n  declaresDependency(pkg, name, _) and\n  (\n    // there is a path expression (e.g., in a `require` or `import`) that\n    // references `pkg`\n    exists(Expr path | path = getAPathExpr(pkg) |\n      path.getStringValue().(FilePath).getPackagePrefix() = name\n    )\n    or\n    // there is an HTML URL attribute that may reference `pkg`\n    exists(DOM::AttributeDefinition attr | attr = getAUrlAttribute(pkg) |\n      // check whether the URL contains `node_modules/name`\n      attr.getStringValue().regexpMatch(\".*\\\\bnode_modules/\\\\Q\" + name + \"\\\\E(/.*)?\")\n    )\n    or\n    // there is a reference in a package.json white-listed script\n    exists(string packageScriptName |\n      packageScriptName = getPackageScriptNameWithDependency(pkg, name)\n    |\n      packageScriptName = \"preinstall\" or\n      packageScriptName = \"install\" or\n      packageScriptName = \"postinstall\"\n    )\n  )\n}\n\npredicate implicitRequire(NpmPackage pkg, string name) {\n  // look for Express `set('view engine', ...)` calls\n  exists(MethodCallExpr setViewEngine, string engine |\n    Express::appCreation().flowsToExpr(setViewEngine.getReceiver()) and\n    setViewEngine.getMethodName() = \"set\" and\n    setViewEngine.getArgument(0).getStringValue() = \"view engine\" and\n    setViewEngine.getArgument(1).getStringValue() = engine and\n    setViewEngine.getTopLevel() = pkg.getAModule()\n  |\n    // chop off leading dot, if any\n    if engine.matches(\".%\") then name = engine.suffix(1) else name = engine\n  )\n}\n\nfrom NpmPackage pkg, string name, JsonValue dep\nwhere\n  exists(pkg.getAModule()) and\n  declaresDependency(pkg, name, dep) and\n  not usesDependency(pkg, name) and\n  not implicitRequire(pkg, name)\nselect dep, \"Unused dependency '\" + name + \"'.\"",
        "description": "If unnecessary package dependencies are included in package.json, the package will become harder to install.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/NodeJS/UnusedDependency.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate hasUntrackedExports(NodeModule m) {\n  // look for assignments of the form `module.exports[p] = ...`, where we cannot\n  // determine the name of the exported property being assigned\n  exists(DataFlow::PropWrite pwn |\n    pwn.getBase().analyze().getAValue() = m.getAModuleExportsValue() and\n    not exists(pwn.getPropertyName())\n  )\n  or\n  // look for assignments of the form `module.exports = exp` where `exp` is indefinite\n  exists(AbstractModuleObject am, AnalyzedPropertyWrite apw, DataFlow::AnalyzedNode exp |\n    am.getModule() = m and\n    apw.writes(am, \"exports\", exp) and\n    exp.getAValue().isIndefinite(_)\n  )\n  or\n  // look for function calls of the form `f(module.exports)`\n  exists(InvokeExpr invk | invk.getAnArgument().analyze().getAValue() = m.getAModuleExportsValue())\n}\n\npredicate propDefinedOnRequire(NodeModule m, string prop) {\n  exists(DataFlow::ModuleImportNode imp |\n    imp.asExpr().(Require).getImportedModule() = m and\n    exists(imp.getAPropertyWrite(prop))\n  )\n}\n\npredicate propAccessOn(PropAccess pacc, NodeModule m) {\n  exists(DataFlow::ModuleImportNode imp |\n    imp.asExpr().(Require).getImportedModule() = m and\n    imp.flowsToExpr(pacc.getBase())\n  )\n}\n\nfrom NodeModule m, PropAccess pacc, string prop\nwhere\n  propAccessOn(pacc, m) and\n  count(NodeModule mm | propAccessOn(pacc, mm)) = 1 and\n  prop = pacc.getPropertyName() and\n  // m doesn't export 'prop'\n  not prop = m.getAnExportedSymbol() and\n  // 'prop' isn't otherwise defined on m\n  not propDefinedOnRequire(m, prop) and\n  // m doesn't use complicated exports\n  not hasUntrackedExports(m)\nselect pacc, \"Module $@ does not export symbol \" + prop + \".\", m, m.getName()",
        "description": "Importing a symbol from a module that does not export it most likely indicates a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/NodeJS/DubiousImport.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nstring ppDiff(Container c1, Container c2) {\n  relatedAncestors(c1, c2) and\n  if c1.getBaseName() = c2.getBaseName()\n  then result = ppDiff(c1.getParentContainer(), c2.getParentContainer()) + \"/\" + c1.getBaseName()\n  else\n    if\n      not exists(c1.getParentContainer()) or\n      sourceLocationPrefix(c1.getParentContainer().getAbsolutePath())\n    then result = \"/\" + c1.getBaseName()\n    else result = \".../\" + c1.getBaseName()\n}\n\npredicate relatedAncestors(Container c1, Container c2) {\n  exists(NodeModule m, NodeModule n | relatedModules(m, n) | c1 = m.getFile() and c2 = n.getFile())\n  or\n  relatedAncestors(c1.(Folder).getAChildContainer(), c2.(Folder).getAChildContainer())\n}\n\nstring pp(NodeModule m, NodeModule other) {\n  relatedModules(m, other) and\n  if m.getName() = other.getName() and m != other\n  then result = ppDiff(m.getFile(), other.getFile())\n  else result = m.getName()\n}\n\npredicate relatedModules(NodeModule m, NodeModule n) {\n  n = m.getAnImportedModule() or m = n.getAnImportedModule()\n}\n\nfrom NodeModule m, Require r, NodeModule imported, string msg, AstNode linktarget, string linktext\nwhere\n  r = m.getAnImport() and\n  imported = r.getImportedModule() and\n  if imported = m\n  then\n    // set linktarget and linktext to dummy values in this case\n    msg = \"directly imports itself\" and linktarget = m and linktext = \"\"\n  else\n    // find an import in `imported` that (directly or indirectly) imports `m`\n    exists(Require r2, Module imported2 |\n      r2 = imported.getAnImport() and imported2 = r2.getImportedModule()\n    |\n      imported2.getAnImportedModule*() = m and\n      msg = \"imports module \" + pp(imported, m) + \", which in turn $@ it\" and\n      linktarget = r2 and\n      // check whether it is a direct or indirect import\n      (\n        if imported2 = m\n        then linktext = \"imports\"\n        else (\n          // only report indirect imports if there is no direct import\n          linktext = \"indirectly imports\" and not imported.getAnImportedModule() = m\n        )\n      )\n    )\nselect r, \"Module \" + pp(m, imported) + \" \" + msg + \".\", linktarget, linktext",
        "description": "If a module indirectly imports itself, some modules involved in the import cycle may end up with partially loaded dependencies. This is error-prone and should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/NodeJS/CyclicImport.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nPackageJson getClosestPackageJson(Folder f) {\n  result = f.(NpmPackage).getPackageJson()\n  or\n  not f instanceof NpmPackage and result = getClosestPackageJson(f.getParentContainer())\n}\n\nfrom Require r, string path, string mod\nwhere\n  path = r.getImportedPathString() and\n  // the imported module is the initial segment of the path, up to\n  // `/` or the end of the string, whichever comes first; we exclude\n  // local paths starting with `.` or `/`, since they might refer to files\n  // downloaded or generated during the build\n  mod = path.regexpCapture(\"([^./][^/]*)(/.*|$)\", 1) and\n  // exclude WebPack/Require.js loaders\n  not mod.matches(\"%!%\") and\n  // import cannot be resolved statically\n  not exists(r.getImportedModule()) and\n  // no enclosing NPM package declares a dependency on `mod`\n  forex(NpmPackage pkg, PackageJson pkgJson |\n    pkg.getAModule() = r.getTopLevel() and pkgJson = pkg.getPackageJson().getEnclosingPackage*()\n  |\n    not pkgJson.declaresDependency(mod, _) and\n    not pkgJson.getPeerDependencies().getADependency(mod, _) and\n    // exclude packages depending on `fbjs`, which automatically pulls in many otherwise\n    // undeclared dependencies\n    not pkgJson.declaresDependency(\"fbjs\", _)\n  )\nselect r, \"Module \" + mod + \" cannot be resolved, and is not declared as a dependency in $@.\",\n  getClosestPackageJson(r.getFile().getParentContainer()), \"package.json\"",
        "description": "An import that cannot be resolved to a module will cause an exception at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/NodeJS/UnresolvableImport.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate definedInModule(GlobalVariable v, NodeModule m) {\n  exists(LValue def |\n    def.getTopLevel() = m and\n    def.(Expr).accessesGlobal(v.getName())\n  )\n}\n\nfrom NodeModule m, GlobalVariable f, InvokeExpr invk, DataFlow::Node export, GlobalVarAccess acc\nwhere\n  export = m.getAnExportedValue(f.getName()) and\n  acc = f.getAnAccess() and\n  invk.getCallee() = acc and\n  invk.getTopLevel() = m and\n  // don't flag if the variable is defined in the same module\n  not definedInModule(f, m) and\n  // don't flag if there is a linter directive declaring the variable\n  not exists(Linting::GlobalDeclaration glob | glob.declaresGlobalForAccess(acc)) and\n  // don't flag if there is an externs declaration for the variable\n  not exists(ExternalGlobalDecl egd | egd.getName() = f.getName()) and\n  // don't flag if the invocation could refer to a property introduced by `with`\n  not exists(WithStmt with | with.mayAffect(invk.getCallee()))\nselect invk, \"'\" + f.getName() + \"' references an undeclared global variable, \" + \"not $@.\", export,\n  \"the variable of the same name that is exported\"",
        "description": "Referencing an undeclared global variable in a module that exports a definition of the same name is confusing and may indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/NodeJS/MissingExports.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\npredicate isRepeatedDependency(AngularJS::InjectableFunction f, string name, DataFlow::Node node) {\n  exists(int i, int j |\n    i < j and\n    exists(f.getDependencyDeclaration(i, name)) and\n    node = f.getDependencyDeclaration(j, name)\n  )\n}\n\nfrom AngularJS::InjectableFunction f, DataFlow::Node node, string name\nwhere\n  isRepeatedDependency(f, name, node) and\n  not count(f.asFunction().getParameterByName(name)) > 1 // avoid duplicating reports from js/duplicate-parameter-name\nselect f.asFunction().getFunction().(FirstLineOf), \"This function has a duplicate dependency $@.\",\n  node, name",
        "description": "Repeated dependency names are redundant for AngularJS dependency injection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/DuplicateDependency.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DataFlow::MethodCallNode mce, AngularJS::BuiltinServiceReference service\nwhere\n  service.getName() = \"$sceProvider\" and\n  mce = service.getAMethodCall(\"enabled\") and\n  mce.getArgument(0).mayHaveBooleanValue(false)\nselect mce, \"Disabling SCE is strongly discouraged.\"",
        "description": "Disabling strict contextual escaping (SCE) can cause security vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/DisablingSce.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate isABuiltinEventName(string name) {\n  // $rootScope.Scope\n  name = \"$destroy\"\n  or\n  // $location\n  name = [\"$locationChangeStart\", \"$locationChangeSuccess\"]\n  or\n  // ngView\n  name = \"$viewContentLoaded\"\n  or\n  // angular-ui/ui-router\n  name =\n    [\n      \"$stateChangeStart\", \"$stateNotFound\", \"$stateChangeSuccess\", \"$stateChangeError\",\n      \"$viewContentLoading \", \"$viewContentLoaded \"\n    ]\n  or\n  // $route\n  name = [\"$routeChangeStart\", \"$routeChangeSuccess\", \"$routeChangeError\", \"$routeUpdate\"]\n  or\n  // ngInclude\n  name = [\"$includeContentRequested\", \"$includeContentLoaded\", \"$includeContentError\"]\n}\n\npredicate isAUserDefinedEventName(string name) {\n  exists(string methodName, DataFlow::MethodCallNode mcn |\n    methodName = \"$emit\" or methodName = \"$broadcast\"\n  |\n    mcn.getArgument(0).mayHaveStringValue(name) and\n    (\n      // dataflow based scope resolution\n      mcn = any(AngularJS::ScopeServiceReference scope).getAMethodCall(methodName)\n      or\n      // heuristic scope resolution: assume parameters like `$scope` or `$rootScope` are AngularJS scope objects\n      exists(DataFlow::ParameterNode param |\n        param.getName() = any(AngularJS::ScopeServiceReference scope).getName() and\n        param.getAMethodCall() = mcn and\n        mcn.getMethodName() = methodName\n      )\n      or\n      // a call in an AngularJS expression\n      exists(AngularJS::NgCallExpr call |\n        call.getCallee().(AngularJS::NgVarExpr).getName() = methodName and\n        call.getArgument(0).(AngularJS::NgString).getStringValue() = name\n      )\n    )\n  )\n}\n\nfrom AngularJS::ScopeServiceReference scope, DataFlow::MethodCallNode mce, string eventName\nwhere\n  mce = scope.getAMethodCall(\"$on\") and\n  mce.getArgument(0).mayHaveStringValue(eventName) and\n  not (\n    isAUserDefinedEventName(eventName) or\n    isABuiltinEventName(eventName) or\n    // external, namespaced\n    eventName.regexpMatch(\".*[.:].*\") or\n    // from other event system (DOM: onClick et al)\n    eventName.regexpMatch(\"on[A-Z][a-zA-Z]+\") // camelCased with 'on'-prefix\n  )\nselect mce.getArgument(1),\n  \"This event listener is dead, the event '\" + eventName + \"' is not emitted anywhere.\"",
        "description": "An AngularJS event listener that listens for a non-existent event has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/DeadAngularJSEventListener.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom AngularJS::InjectableFunction f1, AngularJS::InjectableFunction f2\nwhere\n  f1.asFunction().getNumParameter() > 0 and\n  not exists(f1.getAnExplicitDependencyInjection()) and\n  // ... but only if explicit dependencies are used somewhere else in the same file\n  f1 != f2 and\n  exists(f2.getAnExplicitDependencyInjection()) and\n  f1.getFile() = f2.getFile()\nselect f1,\n  \"This function has no explicit dependency injections, but $@ has an explicit dependency injection.\",\n  f2, \"this function\"",
        "description": "Functions without explicit dependency injections will not work when their parameter names are minified.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/MissingExplicitInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom AngularJS::InjectableFunction f, DataFlow::ParameterNode p, string msg\nwhere\n  p = f.asFunction().getAParameter() and\n  (\n    not p = f.getDependencyParameter(_) and\n    msg = \"This parameter has no injected dependency.\"\n    or\n    exists(string n | p = f.getDependencyParameter(n) |\n      p.getName() != n and\n      exists(f.getDependencyParameter(p.getName())) and\n      msg =\n        \"This parameter is named '\" + p.getName() + \"', \" + \"but actually refers to dependency '\" +\n          n + \"'.\"\n    )\n  )\nselect p, msg",
        "description": "If the injected dependencies of a function go out of sync with its parameters, the function will become difficult to understand and maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/DependencyMismatch.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom AngularJS::ServiceReference compile, DataFlow::ParameterNode elem, DataFlow::CallNode c\nwhere\n  compile.getName() = \"$compile\" and\n  elem =\n    any(AngularJS::CustomDirective d)\n        .getALinkFunction()\n        .(AngularJS::LinkFunction)\n        .getElementParameter() and\n  c = compile.getACall() and\n  elem.flowsTo(c.getArgument(0)) and\n  // don't flag $compile calls that specify a `maxPriority`\n  c.getNumArgument() < 3\nselect c, \"This call to $compile may cause double compilation of '\" + elem + \"'.\"",
        "description": "Recompiling an already compiled part of the DOM can lead to unexpected behavior of directives, performance problems, and memory leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/DoubleCompilation.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport Declarations.UnusedParameter\nimport semmle.javascript.RestrictedLocations\n\npredicate isUnusedParameter(DataFlow::FunctionNode f, string msg, Parameter parameter) {\n  exists(Variable pv |\n    isUnused(f.getFunction(), parameter, pv, _) and\n    not isAnAccidentallyUnusedParameter(parameter) and // avoid double alerts\n    msg = \"Unused dependency \" + pv.getName() + \".\"\n  )\n}\n\npredicate isMissingParameter(AngularJS::InjectableFunction f, string msg, AstNode location) {\n  exists(int paramCount, int injectionCount |\n    DataFlow::valueNode(location) = f and\n    paramCount = f.asFunction().getNumParameter() and\n    injectionCount = count(f.getADependencyDeclaration(_)) and\n    paramCount < injectionCount and\n    exists(string parametersString, string dependenciesAreString |\n      (if paramCount = 1 then parametersString = \"parameter\" else parametersString = \"parameters\") and\n      (\n        if injectionCount = 1\n        then dependenciesAreString = \"dependency is\"\n        else dependenciesAreString = \"dependencies are\"\n      ) and\n      msg =\n        \"This function has \" + paramCount + \" \" + parametersString + \", but \" + injectionCount + \" \"\n          + dependenciesAreString + \" injected into it.\"\n    )\n  )\n}\n\nfrom AngularJS::InjectableFunction f, string message, AstNode location\nwhere\n  isUnusedParameter(f.asFunction(), message, location) or isMissingParameter(f, message, location)\nselect location.(FirstLineOf), message",
        "description": "Unused dependencies are confusing, and should be removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/UnusedAngularDependency.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport AngularJS\n\npredicate isServiceDirectiveOrFilterFunction(InjectableFunctionServiceRequest request) {\n  exists(InjectableFunction f | f = request.getAnInjectedFunction() |\n    exists(ServiceRecipeDefinition def | def.getAFactoryFunction() = f) or\n    exists(FactoryRecipeDefinition def | def.getAFactoryFunction() = f) or\n    exists(DirectiveDefinition def | def.getAFactoryFunction() = f) or\n    exists(FilterDefinition def | def.getAFactoryFunction() = f)\n  )\n}\n\npredicate isControllerFunction(InjectableFunctionServiceRequest request) {\n  exists(InjectableFunction f | f = request.getAnInjectedFunction() |\n    exists(ControllerDefinition def | def.getAFactoryFunction() = f)\n  )\n}\n\npredicate isRunMethod(InjectableFunctionServiceRequest request) {\n  exists(InjectableFunction f | f = request.getAnInjectedFunction() |\n    exists(RunMethodDefinition def | def.getRunMethod() = f)\n  )\n}\n\npredicate isConfigMethod(InjectableFunctionServiceRequest request) {\n  exists(InjectableFunction f | f = request.getAnInjectedFunction() |\n    exists(ConfigMethodDefinition def | def.getConfigMethod() = f)\n  )\n}\n\npredicate isWildcardKind(string kind) {\n  kind = \"type\" or // builtins of kind \"type\" are usable everywhere\n  kind = \"decorator\" // a decorator is always allowed, its decoratee might not be\n}\n\npredicate isCompatibleRequestedService(InjectableFunctionServiceRequest request, string kind) {\n  isWildcardKind(kind) and exists(request)\n  or\n  (\n    isServiceDirectiveOrFilterFunction(request) or\n    isRunMethod(request) or\n    isControllerFunction(request)\n  ) and\n  kind = [\"value\", \"service\", \"factory\", \"constant\", \"provider-value\"]\n  or\n  isControllerFunction(request) and\n  kind = \"controller-only\"\n  or\n  isConfigMethod(request) and\n  (\n    kind = \"constant\" or\n    kind = \"provider\"\n  )\n}\n\nstring getServiceKind(InjectableFunctionServiceRequest request, string serviceName) {\n  exists(ServiceReference id | id = request.getAServiceDefinition(serviceName) |\n    id = getBuiltinServiceOfKind(result)\n    or\n    exists(CustomServiceDefinition custom |\n      id = custom.getServiceReference() and\n      (\n        custom instanceof ValueRecipeDefinition and result = \"value\"\n        or\n        custom instanceof ServiceRecipeDefinition and result = \"service\"\n        or\n        custom instanceof FactoryRecipeDefinition and result = \"factory\"\n        or\n        custom instanceof DecoratorRecipeDefinition and result = \"decorator\"\n        or\n        custom instanceof ConstantRecipeDefinition and result = \"constant\"\n        or\n        (\n          custom instanceof ProviderRecipeDefinition and\n          if serviceName.matches(\"%Provider\")\n          then result = \"provider\"\n          else result = \"provider-value\"\n        )\n      )\n    )\n  )\n}\n\nfrom\n  InjectableFunctionServiceRequest request, string name, string componentDescriptionString,\n  string compatibleWithString, string kind\nwhere\n  name = request.getAServiceName() and\n  name != \"$provide\" and\n  name != \"$injector\" and // special case: these services are always allowed\n  kind = getServiceKind(request, name) and\n  exists(request.getAServiceDefinition(name)) and // ignore unknown/undefined services\n  not isCompatibleRequestedService(request, kind) and\n  compatibleWithString =\n    concat(string compatibleKind |\n      isCompatibleRequestedService(request, compatibleKind) and\n      not isWildcardKind(compatibleKind)\n    |\n      \"'\" + compatibleKind + \"'\", \", \" order by compatibleKind\n    ).regexpReplaceAll(\",(?=[^,]+$)\", \" or\") and\n  (\n    isServiceDirectiveOrFilterFunction(request) and\n    componentDescriptionString = \"Components such as services, directives, filters, and animations\"\n    or\n    isControllerFunction(request) and\n    componentDescriptionString = \"Controllers\"\n    or\n    isRunMethod(request) and\n    componentDescriptionString = \"Run methods\"\n    or\n    isConfigMethod(request) and\n    componentDescriptionString = \"Config methods\"\n  )\nselect request,\n  \"'\" + name + \"' is a dependency of kind '\" + kind + \"', and cannot be injected here. \" +\n    componentDescriptionString + \" can only be injected with dependencies of kind \" +\n    compatibleWithString + \".\"",
        "description": "Dependency-injecting a service of the wrong kind causes an error at runtime.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/IncompatibleService.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom HTML::Attribute attr, string name\nwhere\n  name = attr.getName() and\n  // only flag URL-valued attributes...\n  (name = \"href\" or name = \"src\" or name = \"srcset\") and\n  // ...where the value contains some interpolated expressions\n  attr.getValue().matches(\"%{{%}}\") and\n  // check that there is at least one use of an AngularJS attribute directive nearby\n  // (`{{...}}` is used by other templating frameworks as well)\n  any(AngularJS::DirectiveInstance d).getATarget().getElement().getRoot() = attr.getRoot()\nselect attr, \"Use 'ng-\" + name + \"' instead of '\" + name + \"'.\"",
        "description": "Using AngularJS markup in an HTML attribute that references a URL (such as 'href' or 'src') may cause the browser to send a request with an invalid URL.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/UseNgSrc.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom AngularJS::InjectableFunction f, DataFlow::Node explicitInjection\nwhere\n  count(f.getAnExplicitDependencyInjection()) > 1 and\n  explicitInjection = f.getAnExplicitDependencyInjection()\nselect f.asFunction().getFunction().(FirstLineOf),\n  \"This function has $@ defined in multiple places.\", explicitInjection, \"dependency injections\"",
        "description": "Specifying dependency injections of an AngularJS component multiple times overrides earlier specifications.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/RepeatedInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate isResourceUrlWhitelist(\n  DataFlow::MethodCallNode setupCall, DataFlow::ArrayCreationNode list\n) {\n  exists(AngularJS::ServiceReference service |\n    service.getName() = \"$sceDelegateProvider\" and\n    setupCall = service.getAMethodCall(\"resourceUrlWhitelist\") and\n    list.flowsTo(setupCall.getArgument(0))\n  )\n}\n\nclass ResourceUrlWhitelistEntry extends Expr {\n  DataFlow::MethodCallNode setupCall;\n  string pattern;\n\n  ResourceUrlWhitelistEntry() {\n    exists(DataFlow::ArrayCreationNode whitelist |\n      isResourceUrlWhitelist(setupCall, whitelist) and\n      this = whitelist.getAnElement().asExpr() and\n      this.mayHaveStringValue(pattern)\n    )\n  }\n\n  /**\n   * Gets the method call that sets up this whitelist.\n   */\n  DataFlow::MethodCallNode getSetupCall() { result = setupCall }\n\n  /**\n   * Holds if this expression is insecure to use in an URL pattern whitelist due\n   * to the reason given by `explanation`.\n   */\n  predicate isInsecure(string explanation) {\n    exists(string componentName, string component |\n      exists(int componentNumber |\n        componentName = \"scheme\" and componentNumber = 1\n        or\n        componentName = \"domain\" and componentNumber = 2\n        or\n        componentName = \"TLD\" and componentNumber = 4\n      |\n        component = pattern.regexpCapture(\"(.*?)://(.*?(\\\\.(.*?))?)(:\\\\d+)?(/.*)?\", componentNumber)\n      ) and\n      explanation = \"the \" + componentName + \" '\" + component + \"' is insecurely specified\"\n    |\n      componentName = \"scheme\" and component.matches(\"%*%\")\n      or\n      componentName = \"domain\" and component.matches(\"%**%\")\n      or\n      componentName = \"TLD\" and component = \"*\"\n    )\n  }\n}\n\nfrom ResourceUrlWhitelistEntry entry, DataFlow::MethodCallNode setupCall, string explanation\nwhere\n  entry.isInsecure(explanation) and\n  setupCall = entry.getSetupCall()\nselect setupCall, \"$@ is not a secure whitelist entry, because \" + explanation + \".\", entry,\n  entry.toString()",
        "description": "URL whitelists that are too permissive can cause security vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/AngularJS/InsecureUrlWhitelist.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpNegativeLookahead neg, RegExpGroup grp, RegExpBackRef back\nwhere\n  grp.getParent+() = neg and\n  grp = back.getGroup() and\n  not back.getParent+() = neg and\n  neg.isPartOfRegExpLiteral()\nselect back,\n  \"This back reference always matches the empty string, since it refers to $@, which is contained in a $@.\",\n  grp, \"this capture group\", neg, \"negative lookahead assertion\"",
        "description": "If a back reference refers to a capture group inside a preceding negative lookahead assertion, then the back reference always matches the empty string, which probably indicates a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/BackrefIntoNegativeLookahead.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpDollar dollar, RegExpTerm t\nwhere\n  dollar.isPartOfRegExpLiteral() and\n  t = dollar.getSuccessor+() and\n  not t.isNullable() and\n  // conservative handling of multi-line regular expressions\n  not dollar.getLiteral().isMultiline()\nselect dollar, \"This assertion can never match.\"",
        "description": "If a dollar assertion '$' appears in a regular expression before another term that cannot match the empty string, then this assertion can never match, so the entire regular expression cannot match any string.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/UnmatchableDollar.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpCharacterClass recc\nwhere\n  not exists(recc.getAChild()) and\n  not recc.isInverted() and\n  recc.isPartOfRegExpLiteral()\nselect recc, \"Empty character class.\"",
        "description": "Empty character classes are not normally useful and may indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/EmptyCharacterClass.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpBackRef rebr\nwhere\n  rebr.getLocation().getStartColumn() < rebr.getGroup().getLocation().getEndColumn() and\n  not rebr.isInBackwardMatchingContext() and\n  rebr.isPartOfRegExpLiteral()\nselect rebr, \"This back reference precedes its capture group.\"",
        "description": "If a back reference precedes the capture group it refers to, it matches the empty string, which is probably not what was expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/BackrefBeforeGroup.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpParseError repe\nselect repe, \"Malformed regular expression: \" + repe + \".\"",
        "description": "Regular expressions that do not adhere to the ECMAScript standard may be interpreted differently across platforms and should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/MalformedRegExp.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpBackRef rebr, string ref\nwhere\n  rebr.isPartOfRegExpLiteral() and\n  not exists(rebr.getGroup()) and\n  (\n    ref = rebr.getNumber().toString()\n    or\n    ref = \"named '\" + rebr.getName() + \"'\"\n  )\nselect rebr, \"There is no capture group \" + ref + \" in this regular expression.\"",
        "description": "Regular expression escape sequences of the form '\\n', where 'n' is a positive number greater than the number of capture groups in the regular expression, are not allowed by the ECMAScript standard.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/UnboundBackref.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nRegExpTerm getEffectiveRootAux(RegExpTerm actualRoot) {\n  actualRoot.isRootTerm() and\n  result = actualRoot\n  or\n  result = getEffectiveRootAux(actualRoot).(RegExpAlt).getAChild()\n  or\n  result = getEffectiveRootAux(actualRoot).(RegExpGroup).getAChild()\n}\n\nRegExpTerm getEffectiveRoot(RegExpTerm actualRoot) {\n  result = getEffectiveRootAux(actualRoot) and\n  not result instanceof RegExpAlt and\n  not result instanceof RegExpGroup\n}\n\npredicate isPossiblyAnchoredOnBothEnds(RegExpSequence term) {\n  term.getAChild*() instanceof RegExpCaret and\n  term.getAChild*() instanceof RegExpDollar and\n  term.getNumChild() >= 2\n}\n\npredicate isUniversalRegExp(RegExpTerm term) {\n  exists(RegExpTerm child | child = term.(RegExpStar).getAChild() |\n    child instanceof RegExpDot\n    or\n    child.(RegExpCharacterClass).isUniversalClass()\n  )\n  or\n  term.(RegExpSequence).getNumChild() = 0\n}\n\nabstract class RegExpQuery extends DataFlow::CallNode {\n  abstract RegExpTerm getRegExp();\n}\n\nclass RegExpTestCall extends DataFlow::MethodCallNode, RegExpQuery {\n  DataFlow::RegExpCreationNode regexp;\n\n  RegExpTestCall() { this = regexp.getAReference().getAMethodCall(\"test\") }\n\n  override RegExpTerm getRegExp() { result = regexp.getRoot() }\n}\n\nclass RegExpSearchCall extends DataFlow::MethodCallNode, RegExpQuery {\n  DataFlow::RegExpCreationNode regexp;\n\n  RegExpSearchCall() {\n    this.getMethodName() = \"search\" and\n    regexp.getAReference().flowsTo(this.getArgument(0))\n  }\n\n  override RegExpTerm getRegExp() { result = regexp.getRoot() }\n}\n\npredicate isAssertion(RegExpTerm t) {\n  t instanceof RegExpSubPattern or\n  t instanceof RegExpWordBoundary or\n  t instanceof RegExpNonWordBoundary\n}\n\nfrom RegExpTerm term, RegExpQuery call, string message\nwhere\n  term.isNullable() and\n  not isAssertion(term.getAChild*()) and\n  not isUniversalRegExp(term) and\n  term = getEffectiveRoot(call.getRegExp()) and\n  (\n    call instanceof RegExpTestCall and\n    not isPossiblyAnchoredOnBothEnds(term) and\n    message =\n      \"This regular expression always matches when used in a test $@, as it can match an empty substring.\"\n    or\n    call instanceof RegExpSearchCall and\n    not term.getAChild*() instanceof RegExpDollar and\n    message =\n      \"This regular expression always matches at index 0 when used $@, as it matches the empty substring.\"\n  )\nselect term, message, call, \"here\"",
        "description": "Regular expression tests that always find a match indicate dead code or a logic error",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/RegExpAlwaysMatches.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpCaret caret, RegExpTerm t\nwhere\n  caret.isPartOfRegExpLiteral() and\n  t = caret.getPredecessor+() and\n  not t.isNullable() and\n  // conservative handling of multi-line regular expressions\n  not caret.getLiteral().isMultiline()\nselect caret, \"This assertion can never match.\"",
        "description": "If a caret assertion '^' appears in a regular expression after another term that cannot match the empty string, then this assertion can never match, so the entire regular expression cannot match any string.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/UnmatchableCaret.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate constantInCharacterClass(RegExpCharacterClass recc, int i, RegExpConstant cc, string val) {\n  cc =\n    rank[i](RegExpConstant cc2, int j |\n      cc2 = recc.getChild(j) and cc2.isCharacter() and cc2.getValue() = val\n    |\n      cc2 order by j\n    )\n}\n\nfrom RegExpCharacterClass recc, RegExpConstant first, RegExpConstant repeat, int rnk, string val\nwhere\n  constantInCharacterClass(recc, 1, first, val) and\n  constantInCharacterClass(recc, rnk, repeat, val) and\n  rnk > 1 and\n  recc.isPartOfRegExpLiteral()\nselect first, \"Character '\" + first + \"' is $@.\", repeat, \"repeated in the same character class\"",
        "description": "If a character class in a regular expression contains the same character twice, this may indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/DuplicateCharacterInCharacterClass.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom RegExpCharEscape rece\nwhere\n  rece.toString() = \"\\\\b\" and\n  rece.isPartOfRegExpLiteral()\nselect rece, \"Backspace escape in regular expression.\"",
        "description": "Using '\\b' to escape the backspace character in a regular expression is confusing since it could be mistaken for a word boundary assertion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/BackspaceEscape.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate matchesString(Expr e, string s) {\n  exists(RegExpLiteral rl |\n    rl.flow().(DataFlow::SourceNode).flowsToExpr(e) and\n    not rl.isIgnoreCase() and\n    regExpMatchesString(rl.getRoot(), s)\n  )\n  or\n  s = e.getStringValue()\n}\n\nlanguage[monotonicAggregates]\npredicate regExpMatchesString(RegExpTerm t, string s) {\n  t.isPartOfRegExpLiteral() and\n  (\n    // constants match themselves\n    s = t.(RegExpConstant).getValue()\n    or\n    // assertions match the empty string\n    (\n      t instanceof RegExpCaret or\n      t instanceof RegExpDollar or\n      t instanceof RegExpWordBoundary or\n      t instanceof RegExpNonWordBoundary or\n      t instanceof RegExpLookahead or\n      t instanceof RegExpLookbehind\n    ) and\n    s = \"\"\n    or\n    // groups match their content\n    regExpMatchesString(t.(RegExpGroup).getAChild(), s)\n    or\n    // single-character classes match that character\n    exists(RegExpCharacterClass recc | recc = t and not recc.isInverted() |\n      recc.getNumChild() = 1 and\n      regExpMatchesString(recc.getChild(0), s)\n    )\n    or\n    // sequences match the concatenation of their elements\n    exists(RegExpSequence seq | seq = t |\n      s =\n        concat(int i, RegExpTerm child |\n          child = seq.getChild(i)\n        |\n          any(string subs | regExpMatchesString(child, subs)) order by i\n        )\n    )\n  )\n}\n\nfrom MethodCallExpr repl, string s, string friendly\nwhere\n  repl.getMethodName() = [\"replace\", \"replaceAll\"] and\n  matchesString(repl.getArgument(0), s) and\n  repl.getArgument(1).getStringValue() = s and\n  (if s = \"\" then friendly = \"the empty string\" else friendly = \"'\" + s + \"'\")\nselect repl.getArgument(0), \"This replaces \" + friendly + \" with itself.\"",
        "description": "Replacing a substring with itself has no effect and may indicate a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/RegExp/IdentityReplacement.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.filters.ClassifyFiles\n\nclass PipeCall extends DataFlow::MethodCallNode {\n  PipeCall() {\n    this.getMethodName() = \"pipe\" and\n    this.getNumArgument() = [1, 2] and\n    not this.getArgument([0, 1]).asExpr() instanceof Function and\n    not this.getArgument(0).asExpr() instanceof ObjectExpr and\n    not this.getArgument(0).getALocalSource() = getNonNodeJsStreamType()\n  }\n\n  /** Gets the source stream (receiver of the pipe call). */\n  DataFlow::Node getSourceStream() { result = this.getReceiver() }\n\n  /** Gets the destination stream (argument of the pipe call). */\n  DataFlow::Node getDestinationStream() { result = this.getArgument(0) }\n}\n\nprivate DataFlow::Node getNonNodeJsStreamType() {\n  result = getNonStreamApi().getAValueReachableFromSource()\n}\n\nprivate API::Node getNonStreamApi() {\n  exists(string moduleName |\n    moduleName\n        .regexpMatch([\n            \"rxjs(|/.*)\", \"@strapi(|/.*)\", \"highland(|/.*)\", \"execa(|/.*)\", \"arktype(|/.*)\",\n            \"@ngrx(|/.*)\", \"@datorama(|/.*)\", \"@angular(|/.*)\", \"react.*\", \"@langchain(|/.*)\",\n          ]) and\n    result = API::moduleImport(moduleName)\n  )\n  or\n  result = getNonStreamApi().getAMember()\n  or\n  result = getNonStreamApi().getAParameter().getAParameter()\n  or\n  result = getNonStreamApi().getReturn()\n  or\n  result = getNonStreamApi().getPromised()\n}\n\nprivate string getEventHandlerMethodName() { result = [\"on\", \"once\", \"addListener\"] }\n\nprivate string getChainableStreamMethodName() {\n  result =\n    [\n      \"setEncoding\", \"pause\", \"resume\", \"unpipe\", \"destroy\", \"cork\", \"uncork\", \"setDefaultEncoding\",\n      \"off\", \"removeListener\", getEventHandlerMethodName()\n    ]\n}\n\nprivate string getNonchainableStreamMethodName() {\n  result = [\"read\", \"write\", \"end\", \"pipe\", \"unshift\", \"push\", \"isPaused\", \"wrap\", \"emit\"]\n}\n\nprivate string getStreamPropertyName() {\n  result =\n    [\n      \"readable\", \"writable\", \"destroyed\", \"closed\", \"readableHighWaterMark\", \"readableLength\",\n      \"readableObjectMode\", \"readableEncoding\", \"readableFlowing\", \"readableEnded\", \"flowing\",\n      \"writableHighWaterMark\", \"writableLength\", \"writableObjectMode\", \"writableFinished\",\n      \"writableCorked\", \"writableEnded\", \"defaultEncoding\", \"allowHalfOpen\", \"objectMode\",\n      \"errored\", \"pending\", \"autoDestroy\", \"encoding\", \"path\", \"fd\", \"bytesRead\", \"bytesWritten\",\n      \"_readableState\", \"_writableState\"\n    ]\n}\n\nprivate string getStreamMethodName() {\n  result = [getChainableStreamMethodName(), getNonchainableStreamMethodName()]\n}\n\nclass ErrorHandlerRegistration extends DataFlow::MethodCallNode {\n  ErrorHandlerRegistration() {\n    this.getMethodName() = getEventHandlerMethodName() and\n    this.getArgument(0).getStringValue() = \"error\"\n  }\n}\n\nprivate predicate streamFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n  exists(PipeCall pipe |\n    node1 = pipe.getDestinationStream() and\n    node2 = pipe\n  )\n  or\n  exists(DataFlow::MethodCallNode chainable |\n    chainable.getMethodName() = getChainableStreamMethodName() and\n    node1 = chainable.getReceiver() and\n    node2 = chainable\n  )\n}\n\nprivate DataFlow::SourceNode destinationStreamRef(DataFlow::TypeTracker t, PipeCall pipe) {\n  t.start() and\n  (result = pipe or result = pipe.getDestinationStream().getALocalSource())\n  or\n  exists(DataFlow::SourceNode prev |\n    prev = destinationStreamRef(t.continue(), pipe) and\n    streamFlowStep(prev, result)\n  )\n  or\n  exists(DataFlow::TypeTracker t2 | result = destinationStreamRef(t2, pipe).track(t2, t))\n}\n\nprivate DataFlow::SourceNode destinationStreamRef(PipeCall pipe) {\n  result = destinationStreamRef(DataFlow::TypeTracker::end(), pipe)\n}\n\nprivate predicate isPipeFollowedByNonStreamMethod(PipeCall pipeCall) {\n  exists(DataFlow::MethodCallNode call |\n    call = destinationStreamRef(pipeCall).getAMethodCall() and\n    not call.getMethodName() = getStreamMethodName()\n  )\n}\n\nprivate predicate isPipeFollowedByNonStreamProperty(PipeCall pipeCall) {\n  exists(DataFlow::PropRef propRef |\n    propRef = destinationStreamRef(pipeCall).getAPropertyRead() and\n    not propRef.getPropertyName() = [getStreamPropertyName(), getStreamMethodName()]\n  )\n}\n\nprivate predicate isPipeFollowedByNonStreamAccess(PipeCall pipeCall) {\n  isPipeFollowedByNonStreamMethod(pipeCall) or\n  isPipeFollowedByNonStreamProperty(pipeCall)\n}\n\nprivate DataFlow::SourceNode sourceStreamRef(DataFlow::TypeBackTracker t, PipeCall pipeCall) {\n  t.start() and\n  result = pipeCall.getSourceStream().getALocalSource()\n  or\n  exists(DataFlow::SourceNode prev |\n    prev = sourceStreamRef(t.continue(), pipeCall) and\n    streamFlowStep(result.getALocalUse(), prev)\n  )\n  or\n  exists(DataFlow::TypeBackTracker t2 | result = sourceStreamRef(t2, pipeCall).backtrack(t2, t))\n}\n\nprivate DataFlow::SourceNode sourceStreamRef(PipeCall pipeCall) {\n  result = sourceStreamRef(DataFlow::TypeBackTracker::end(), pipeCall)\n}\n\nprivate predicate hasErrorHandlerRegistered(PipeCall pipeCall) {\n  exists(DataFlow::Node stream |\n    stream = sourceStreamRef(pipeCall).getALocalUse() and\n    (\n      stream.(DataFlow::SourceNode).getAMethodCall(_) instanceof ErrorHandlerRegistration\n      or\n      exists(DataFlow::SourceNode base, string propName |\n        stream = base.getAPropertyRead(propName) and\n        base.getAPropertyRead(propName).getAMethodCall(_) instanceof ErrorHandlerRegistration\n      )\n      or\n      exists(DataFlow::PropWrite propWrite, DataFlow::SourceNode instance |\n        propWrite.getRhs().getALocalSource() = stream and\n        instance = propWrite.getBase().getALocalSource() and\n        instance.getAPropertyRead(propWrite.getPropertyName()).getAMethodCall(_) instanceof\n          ErrorHandlerRegistration\n      )\n    )\n  )\n  or\n  hasPlumber(pipeCall)\n}\n\nprivate predicate hasPlumber(PipeCall pipeCall) {\n  pipeCall.getDestinationStream().getALocalSource() = API::moduleImport(\"gulp-plumber\").getACall()\n  or\n  sourceStreamRef+(pipeCall) = API::moduleImport(\"gulp-plumber\").getACall()\n}\n\nprivate predicate hasNonNodeJsStreamSource(PipeCall pipeCall) {\n  sourceStreamRef(pipeCall) = getNonNodeJsStreamType() or\n  destinationStreamRef(pipeCall) = getNonNodeJsStreamType()\n}\n\nprivate predicate hasNonStreamSourceLikeUsage(PipeCall pipeCall) {\n  exists(DataFlow::MethodCallNode call, string name |\n    call.getReceiver().getALocalSource() = sourceStreamRef(pipeCall) and\n    name = call.getMethodName() and\n    not name = getStreamMethodName()\n  )\n  or\n  exists(DataFlow::PropRef propRef, string propName |\n    propRef.getBase().getALocalSource() = sourceStreamRef(pipeCall) and\n    propName = propRef.getPropertyName() and\n    not propName = [getStreamPropertyName(), getStreamMethodName()]\n  )\n}\n\nprivate predicate hasErrorHandlerDownstream(PipeCall pipeCall) {\n  exists(DataFlow::SourceNode stream |\n    stream = destinationStreamRef(pipeCall) and\n    (\n      exists(ErrorHandlerRegistration handler | handler.getReceiver().getALocalSource() = stream)\n      or\n      exists(DataFlow::SourceNode base, string propName |\n        stream = base.getAPropertyRead(propName) and\n        base.getAPropertyRead(propName).getAMethodCall(_) instanceof ErrorHandlerRegistration\n      )\n    )\n  )\n}\n\nfrom PipeCall pipeCall\nwhere\n  not hasErrorHandlerRegistered(pipeCall) and\n  hasErrorHandlerDownstream(pipeCall) and\n  not isPipeFollowedByNonStreamAccess(pipeCall) and\n  not hasNonStreamSourceLikeUsage(pipeCall) and\n  not hasNonNodeJsStreamSource(pipeCall) and\n  not isTestFile(pipeCall.getFile())\nselect pipeCall,\n  \"Stream pipe without error handling on the source stream. Errors won't propagate downstream and may be silently dropped.\"",
        "description": "Calling `pipe()` on a stream without error handling will drop errors coming from the input stream",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Quality/UnhandledErrorInStreamPipeline.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.PostMessageStarQuery\nimport PostMessageStarFlow::PathGraph\n\nfrom PostMessageStarFlow::PathNode source, PostMessageStarFlow::PathNode sink\nwhere PostMessageStarFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"$@ is sent to another window without origin restriction.\",\n  source.getNode(), \"Sensitive data\"",
        "description": "When sending sensitive information to another window using `postMessage`, the origin of the target window should be restricted to avoid unintentional information leaks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-201/PostMessageStar.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.FunctionalityFromUntrustedSource\n\nfrom AddsUntrustedUrl s\n// do not alert on explicitly untrusted domains\n// another query can alert on these, js/functionality-from-untrusted-domain\nwhere not isUrlWithUntrustedDomain(s.getUrl())\nselect s, s.getProblem()",
        "description": "Including functionality from an untrusted source may allow an attacker to control the functionality and execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-830/FunctionalityFromUntrustedSource.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.FunctionalityFromUntrustedSource\n\nfrom AddsUntrustedUrl s\nwhere isUrlWithUntrustedDomain(s.getUrl())\nselect s, \"Content loaded from untrusted domain with no integrity check.\"",
        "description": "Using a resource from an untrusted or compromised domain makes your code vulnerable to receiving malicious code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-830/FunctionalityFromUntrustedDomain.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnsafeCodeConstruction::UnsafeCodeConstruction\nimport UnsafeCodeConstructionFlow::PathGraph\n\nfrom\n  UnsafeCodeConstructionFlow::PathNode source, UnsafeCodeConstructionFlow::PathNode sink,\n  Sink sinkNode\nwhere UnsafeCodeConstructionFlow::flowPath(source, sink) and sinkNode = sink.getNode()\nselect sink.getNode(), source, sink,\n  \"This \" + sinkNode.getSinkType() + \" which depends on $@ is later $@.\", source.getNode(),\n  \"library input\", sinkNode.getCodeSink(), \"interpreted as code\"",
        "description": "Using externally controlled strings to construct code may allow a malicious user to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-094/UnsafeCodeConstruction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CodeInjectionQuery\nimport CodeInjectionFlow::PathGraph\n\nfrom CodeInjectionFlow::PathNode source, CodeInjectionFlow::PathNode sink\nwhere CodeInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, sink.getNode().(Sink).getMessagePrefix() + \" depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Interpreting unsanitized user input as code allows a malicious user arbitrary code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-094/CodeInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnsafeDynamicMethodAccessQuery\nimport UnsafeDynamicMethodAccessFlow::PathGraph\n\nfrom UnsafeDynamicMethodAccessFlow::PathNode source, UnsafeDynamicMethodAccessFlow::PathNode sink\nwhere UnsafeDynamicMethodAccessFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"This method is invoked using a $@, which may allow remote code execution.\", source.getNode(),\n  \"user-controlled value\"",
        "description": "Invoking user-controlled methods on certain objects can lead to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-094/UnsafeDynamicMethodAccess.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ImproperCodeSanitizationQuery\nprivate import semmle.javascript.heuristics.HeuristicSinks\nprivate import semmle.javascript.security.dataflow.CodeInjectionCustomizations\nimport ImproperCodeSanitizationFlow::PathGraph\n\nprivate DataFlow::Node remoteFlow(DataFlow::TypeTracker t) {\n  t.start() and\n  result instanceof RemoteFlowSource\n  or\n  exists(DataFlow::TypeTracker t2, DataFlow::Node prev | prev = remoteFlow(t2) |\n    t2 = t.smallstep(prev, result)\n    or\n    TaintTracking::sharedTaintStep(prev, result) and\n    t = t2\n  )\n}\n\nprivate DataFlow::Node remoteFlow() { result = remoteFlow(DataFlow::TypeTracker::end()) }\n\nprivate DataFlow::Node endsInCodeInjectionSink(DataFlow::TypeBackTracker t) {\n  t.start() and\n  (\n    result instanceof CodeInjection::Sink\n    or\n    result instanceof HeuristicCodeInjectionSink and\n    not result instanceof StringOps::ConcatenationRoot // the heuristic CodeInjection sink looks for string-concats, we are not interrested in those here.\n  )\n  or\n  exists(DataFlow::TypeBackTracker t2 | t2 = t.smallstep(result, endsInCodeInjectionSink(t2)))\n}\n\nprivate DataFlow::Node endsInCodeInjectionSink() {\n  result = endsInCodeInjectionSink(DataFlow::TypeBackTracker::end())\n}\n\nfrom ImproperCodeSanitizationFlow::PathNode source, ImproperCodeSanitizationFlow::PathNode sink\nwhere\n  ImproperCodeSanitizationFlow::flowPath(source, sink) and\n  // Basic detection of duplicate results with `js/code-injection`.\n  not (\n    sink.getNode().(StringOps::ConcatenationLeaf).getRoot() = endsInCodeInjectionSink() and\n    remoteFlow() = source.getNode().(DataFlow::InvokeNode).getAnArgument()\n  )\nselect sink.getNode(), source, sink, \"Code construction depends on an $@.\", source.getNode(),\n  \"improperly sanitized value\"",
        "description": "Escaping code as HTML does not provide protection against code injection.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-094/ImproperCodeSanitization.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.StackTraceExposureQuery\nimport StackTraceExposureFlow::PathGraph\n\nfrom StackTraceExposureFlow::PathNode source, StackTraceExposureFlow::PathNode sink\nwhere StackTraceExposureFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This information exposed to the user depends on $@.\",\n  source.getNode(), \"stack trace information\"",
        "description": "Propagating stack trace information to an external user can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-209/StackTraceExposure.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.DifferentKindsComparisonBypassQuery\n\nfrom DifferentKindsComparison cmp, DataFlow::Node lSource, DataFlow::Node rSource\nwhere\n  lSource = cmp.getLSource() and\n  rSource = cmp.getRSource() and\n  // Standard names for the double submit cookie pattern (CSRF protection)\n  not exists(DataFlow::PropRead s | s = lSource or s = rSource |\n    s.getPropertyName().regexpMatch(\"(?i).*(csrf|state|token).*\")\n  )\nselect cmp,\n  \"This comparison of $@ and $@ is a potential security risk since it is controlled by the user.\",\n  lSource, lSource.toString(), rSource, rSource.toString()",
        "description": "Comparing different kinds of HTTP request data may be a symptom of an insufficient security check.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-807/DifferentKindsComparisonBypass.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ConditionalBypassQuery\nimport ConditionalBypassFlow::PathGraph\n\nfrom\n  ConditionalBypassFlow::PathNode source, ConditionalBypassFlow::PathNode sink,\n  SensitiveAction action\nwhere\n  isTaintedGuardNodeForSensitiveAction(sink, source, action) and\n  not isEarlyAbortGuardNode(sink, action)\nselect sink.getNode(), source, sink, \"This condition guards a sensitive $@, but a $@ controls it.\",\n  action, \"action\", source.getNode(), \"user-provided value\"",
        "description": "Conditions that the user controls are not suited for making security-related decisions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-807/ConditionalBypass.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.FileAccessToHttpQuery\nimport FileAccessToHttpFlow::PathGraph\n\nfrom FileAccessToHttpFlow::PathNode source, FileAccessToHttpFlow::PathNode sink\nwhere FileAccessToHttpFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Outbound network request depends on $@.\", source.getNode(),\n  \"file data\"",
        "description": "Directly sending file data in an outbound network request can indicate unauthorized information disclosure.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-200/FileAccessToHttp.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nbindingset[folder]\npredicate isNodeModuleFolder(string folder) {\n  folder.regexpMatch(\"(\\\\.?\\\\.?/)*node_modules(/|(/[a-zA-Z@_-]+/?))?\")\n}\n\nDataFlow::Node getANodeModulePath(string path) {\n  result.getStringValue() = path and\n  isNodeModuleFolder(path)\n  or\n  exists(DataFlow::CallNode resolve |\n    resolve = DataFlow::moduleMember(\"path\", [\"resolve\", \"join\"]).getACall()\n  |\n    result = resolve and\n    resolve.getLastArgument() = getANodeModulePath(path)\n  )\n  or\n  exists(StringOps::ConcatenationRoot root | root = result |\n    root.getLastLeaf() = getANodeModulePath(path)\n  )\n  or\n  result.getAPredecessor() = getANodeModulePath(path) // local data-flow\n  or\n  exists(string base, string folder |\n    path = base + folder and\n    folder.regexpMatch(\"(/)?[a-zA-Z@_-]+/?\") and\n    base.regexpMatch(\"(\\\\.?\\\\.?/)*node_modules(/)?\") // node_modules, without any sub-folders.\n  |\n    exists(StringOps::ConcatenationRoot root | root = result |\n      root.getNumOperand() = 2 and\n      root.getFirstLeaf() = getANodeModulePath(base) and\n      root.getLastLeaf().getStringValue() = folder\n    )\n    or\n    exists(DataFlow::CallNode resolve |\n      resolve = DataFlow::moduleMember(\"path\", [\"resolve\", \"join\"]).getACall()\n    |\n      result = resolve and\n      resolve.getNumArgument() = 2 and\n      resolve.getArgument(0) = getANodeModulePath(path) and\n      resolve.getArgument(1).mayHaveStringValue(folder)\n    )\n  )\n}\n\npragma[noinline]\nFolder getAPackageJsonFolder() { result = any(PackageJson json).getFile().getParentContainer() }\n\nDataFlow::Node getALeakingFolder(string description) {\n  exists(ModuleScope ms | result.asExpr() = ms.getVariable(\"__dirname\").getAnAccess()) and\n  result.getFile().getParentContainer() = getAPackageJsonFolder() and\n  (\n    if result.getFile().getParentContainer().getRelativePath().trim() != \"\"\n    then description = \"the folder \" + result.getFile().getParentContainer().getRelativePath()\n    else description = \"the source root folder\"\n  )\n  or\n  result = DataFlow::moduleImport(\"os\").getAMemberCall(\"homedir\") and\n  description = \"the home folder\"\n  or\n  result.mayHaveStringValue(\"/\") and\n  description = \"the root folder\"\n  or\n  result.getStringValue() = [\".\", \"./\"] and\n  description = \"the current working folder\"\n  or\n  result.getAPredecessor() = getALeakingFolder(description)\n  or\n  exists(StringOps::ConcatenationRoot root | root = result |\n    root.getNumOperand() = 2 and\n    root.getOperand(0) = getALeakingFolder(description) and\n    root.getOperand(1).getStringValue() = \"/\"\n  )\n}\n\nDataFlow::Node getAPrivateFolderPath(string description) {\n  exists(string path |\n    result = getANodeModulePath(path) and description = \"the folder \\\"\" + path + \"\\\"\"\n  )\n  or\n  result = getALeakingFolder(description)\n}\n\nDataFlow::CallNode servesAPrivateFolder(string description) {\n  result = DataFlow::moduleMember([\"express\", \"connect\"], \"static\").getACall() and\n  result.getArgument(0) = getAPrivateFolderPath(description)\n  or\n  result = DataFlow::moduleImport(\"serve-static\").getACall() and\n  result.getArgument(0) = getAPrivateFolderPath(description)\n}\n\nExpress::RouteSetup getAnExposingExpressSetup(string path) {\n  result.isUseCall() and\n  result.getArgument([0 .. 1]) = servesAPrivateFolder(path)\n}\n\nDataFlow::CallNode getAnExposingServeSetup(string path) {\n  result = DataFlow::moduleImport(\"serve-handler\").getACall() and\n  result.getOptionArgument(2, \"public\") = getAPrivateFolderPath(path)\n}\n\nfrom DataFlow::Node node, string path\nwhere\n  node = getAnExposingExpressSetup(path)\n  or\n  node = getAnExposingServeSetup(path)\nselect node, \"Serves \" + path + \", which can contain private information.\"",
        "description": "Exposing a node_modules folder, or the project folder to the public, can cause exposure of private information.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-200/PrivateFileExposure.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.frameworks.HTTP\n\nfrom Http::ServerDefinition server\nwhere not exists(server.getARouteHandler().getAResponseHeader(\"x-frame-options\"))\nselect server, \"This server never sets the 'X-Frame-Options' HTTP header.\"",
        "description": "If the 'X-Frame-Options' setting is not provided, a malicious user may be able to overlay their own UI on top of the site by using an iframe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-451/MissingXFrameOptions.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.PasswordInConfigurationFileQuery\n\nfrom string key, string val, Locatable valElement\nwhere\n  config(key, val, valElement) and\n  (\n    val = \"\" and key.toLowerCase() = \"password\"\n    or\n    key.toLowerCase() != \"readme\" and\n    // look for `password=;`, `password=`, `password=  `, `password==`.\n    val.regexpMatch(\"(?is).*password\\\\s*(==?|:)\\\\s*(\\\\\\\"\\\\\\\"|''|``|;|:)?\\\\s*($|;|&|]|\\\\n).*\")\n  )\nselect valElement.(FirstLineOf), \"Empty password in configuration file.\"",
        "description": "Failing to set a password reduces the security of your code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-862/EmptyPasswordInConfigurationFile.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ClientSideUrlRedirectQuery\nimport DataFlow::DeduplicatePathGraph<ClientSideUrlRedirectFlow::PathNode, ClientSideUrlRedirectFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere\n  ClientSideUrlRedirectFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink, \"Untrusted URL redirection depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Client-side URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-601/ClientSideUrlRedirect.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ServerSideUrlRedirectQuery\nimport ServerSideUrlRedirectFlow::PathGraph\n\nfrom ServerSideUrlRedirectFlow::PathNode source, ServerSideUrlRedirectFlow::PathNode sink\nwhere ServerSideUrlRedirectFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Untrusted URL redirection depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Server-side URL redirection based on unvalidated user input may cause redirection to malicious web sites.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-601/ServerSideUrlRedirect.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom CookieWrites::CookieWrite cookie\nwhere\n  cookie.isSensitive() and\n  cookie.isSecure() and // `js/clear-text-cookie` will report it if the cookie is not secure.\n  cookie.getSameSite().toLowerCase() = \"none\"\nselect cookie, \"Sensitive cookie with SameSite set to 'None'.\"",
        "description": "Sensitive cookies where the SameSite attribute is set to \"None\" can in some cases allow for Cross-Site Request Forgery (CSRF) attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-1275/SameSiteNoneCookie.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom CryptographicKeyCreation key, int size, string msg, string algo\nwhere\n  size = key.getSize() and\n  (\n    algo = key.getAlgorithm() + \" \"\n    or\n    not exists(key.getAlgorithm()) and algo = \"\"\n  ) and\n  (\n    size < 128 and\n    key.isSymmetricKey() and\n    msg =\n      \"Creation of an symmetric \" + algo + \"key uses \" + size +\n        \" bits, which is below 128 and considered breakable.\"\n    or\n    size < 2048 and\n    not key.isSymmetricKey() and\n    msg =\n      \"Creation of an asymmetric \" + algo + \"key uses \" + size +\n        \" bits, which is below 2048 and considered breakable.\"\n  )\nselect key, msg",
        "description": "Using a weak cryptographic key can allow an attacker to compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-326/InsufficientKeySize.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nbindingset[s]\nstring toOtherCase(string s) {\n  if s.regexpMatch(\".*[a-z].*\") then result = s.toUpperCase() else result = s.toLowerCase()\n}\n\nprivate import semmle.javascript.security.regexp.RegExpTreeView::RegExpTreeView as TreeView\nimport codeql.regex.nfa.NfaUtils::Make<TreeView> as NfaUtils\n\npredicate isCand(NfaUtils::State s) {\n  s.getRepr() instanceof NfaUtils::RegExpRoot and\n  exists(DataFlow::RegExpCreationNode creation |\n    isCaseSensitiveMiddleware(_, creation, _) and\n    s.getRepr().getRootTerm() = creation.getRoot()\n  )\n}\n\nimport NfaUtils::PrefixConstruction<isCand/1> as Prefix\n\nstring getExampleString(RegExpTerm term) {\n  result = Prefix::prefix(any(NfaUtils::State s | s.getRepr() = term))\n}\n\nstring getCaseSensitiveBypassExample(RegExpTerm term) {\n  exists(string byPassExample |\n    byPassExample = getExampleString(term) and\n    result = toOtherCase(byPassExample) and\n    result != byPassExample // getting an byPassExample string is approximate; ensure we got a proper case-change byPassExample\n  )\n}\n\npredicate isCaseSensitiveMiddleware(\n  Routing::RouteSetup setup, DataFlow::RegExpCreationNode regexp, DataFlow::Node arg\n) {\n  exists(DataFlow::MethodCallNode call |\n    setup = Routing::getRouteSetupNode(call) and\n    (\n      setup.definitelyResumesDispatch()\n      or\n      // If applied to all HTTP methods, be a bit more lenient in detecting middleware\n      setup.mayResumeDispatch() and\n      not exists(setup.getOwnHttpMethod())\n    ) and\n    arg = call.getArgument(0) and\n    regexp.getAReference().flowsTo(arg) and\n    exists(string flags |\n      flags = regexp.tryGetFlags() and\n      not RegExp::maybeIgnoreCase(flags)\n    )\n  )\n}\n\npredicate isGuardedCaseInsensitiveEndpoint(\n  Routing::RouteSetup endpoint, Routing::RouteSetup middleware\n) {\n  isCaseSensitiveMiddleware(middleware, _, _) and\n  exists(DataFlow::MethodCallNode call |\n    endpoint = Routing::getRouteSetupNode(call) and\n    endpoint.isGuardedByNode(middleware) and\n    call.getArgument(0).mayHaveStringValue(_)\n  )\n}\n\nstring getAnEndpointExample(Routing::RouteSetup endpoint) {\n  exists(string raw |\n    raw = endpoint.getRelativePath() and\n    result = raw.regexpReplaceAll(\":\\\\w+\\\\b|\\\\*\", [\"a\", \"1\"])\n  )\n}\n\nimport codeql.regex.nfa.RegexpMatching::Make<TreeView> as RegexpMatching\n\nNfaUtils::RegExpRoot getARoot(DataFlow::RegExpCreationNode creator) {\n  result.getRootTerm() = creator.getRoot()\n}\n\npredicate isMatchingCandidate(\n  RegexpMatching::RootTerm root, string str, boolean ignorePrefix, boolean testWithGroups\n) {\n  exists(\n    Routing::RouteSetup middleware, Routing::RouteSetup endPoint,\n    DataFlow::RegExpCreationNode regexp\n  |\n    isCaseSensitiveMiddleware(middleware, regexp, _) and\n    isGuardedCaseInsensitiveEndpoint(endPoint, middleware)\n  |\n    root = regexp.getRoot() and\n    exists(getCaseSensitiveBypassExample(getARoot(regexp))) and\n    ignorePrefix = true and\n    testWithGroups = false and\n    str =\n      [\n        getCaseSensitiveBypassExample(getARoot(regexp)), getAnEndpointExample(endPoint),\n        toOtherCase(getAnEndpointExample(endPoint))\n      ]\n  )\n}\n\nimport RegexpMatching::RegexpMatching<isMatchingCandidate/4> as Matcher\n\nfrom\n  DataFlow::RegExpCreationNode regexp, Routing::RouteSetup middleware, Routing::RouteSetup endpoint,\n  DataFlow::Node arg, string byPassExample, string endpointExample, string byPassEndPoint\nwhere\n  isCaseSensitiveMiddleware(middleware, regexp, arg) and\n  byPassExample = getCaseSensitiveBypassExample(getARoot(regexp)) and\n  isGuardedCaseInsensitiveEndpoint(endpoint, middleware) and\n  // only report one example.\n  endpointExample =\n    min(string ex | ex = getAnEndpointExample(endpoint) and Matcher::matches(regexp.getRoot(), ex)) and\n  not Matcher::matches(regexp.getRoot(), byPassExample) and\n  byPassEndPoint = toOtherCase(endpointExample) and\n  not Matcher::matches(regexp.getRoot(), byPassEndPoint)\nselect arg,\n  \"This route uses a case-sensitive path $@, but is guarding a $@. A path such as '\" +\n    byPassEndPoint + \"' will bypass the middleware.\", regexp, \"pattern\", endpoint,\n  \"case-insensitive path\"",
        "description": "Middleware with case-sensitive paths do not protect endpoints with case-insensitive paths.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-178/CaseSensitiveMiddlewarePath.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.BrokenCryptoAlgorithmQuery\nimport semmle.javascript.security.SensitiveActions\nimport BrokenCryptoAlgorithmFlow::PathGraph\n\nfrom\n  BrokenCryptoAlgorithmFlow::PathNode source, BrokenCryptoAlgorithmFlow::PathNode sink,\n  Source sourceNode, Sink sinkNode\nwhere\n  BrokenCryptoAlgorithmFlow::flowPath(source, sink) and\n  sourceNode = source.getNode() and\n  sinkNode = sink.getNode() and\n  not sourceNode instanceof CleartextPasswordExpr // flagged by js/insufficient-password-hash\nselect sinkNode, source, sink, \"$@ depends on $@.\", sinkNode.getInitialization(),\n  \"A broken or weak cryptographic algorithm\", sourceNode,\n  \"sensitive data from \" + sourceNode.describe()",
        "description": "Using broken or weak cryptographic algorithms can compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-327/BrokenCryptoAlgorithm.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.dataflow.internal.StepSummary\nprivate import semmle.javascript.security.dataflow.InsecureRandomnessCustomizations\nprivate import semmle.javascript.dataflow.InferredTypes\n\nprivate int powerOfTwo() {\n  result = 1\n  or\n  result = 2 * powerOfTwo() and\n  not result < 0\n}\n\nprivate DataFlow::Node isPowerOfTwo() {\n  result.getIntValue() = powerOfTwo()\n  or\n  // Getting around the 32 bit ints in QL. These are some hex values of the form 0x10000000\n  result.asExpr().(NumberLiteral).getValue() =\n    [\"281474976710656\", \"17592186044416\", \"1099511627776\", \"68719476736\", \"4294967296\"]\n  or\n  result = isPowerOfTwo().getASuccessor()\n}\n\nprivate DataFlow::Node isPowerOfTwoMinusOne() {\n  result.getIntValue() = powerOfTwo() - 1\n  or\n  // Getting around the 32 bit ints in QL. These are some hex values of the form 0xfffffff\n  result.asExpr().(NumberLiteral).getValue() =\n    [\"281474976710655\", \"17592186044415\", \"1099511627775\", \"68719476735\", \"4294967295\"]\n  or\n  result = isPowerOfTwoMinusOne().getASuccessor()\n}\n\nprivate string prop() { result = DataFlow::PseudoProperties::setElement() }\n\nprivate DataFlow::Node goodRandom(DataFlow::TypeTracker t, DataFlow::SourceNode source) {\n  t.startInProp(prop()) and\n  result = InsecureRandomness::randomBufferSource() and\n  result = source\n  or\n  // Loading a number from a `Buffer`.\n  exists(DataFlow::TypeTracker t2 | t = t2.append(LoadStep(prop())) |\n    // the random generators return arrays/Buffers of random numbers, we therefore track through an indexed read.\n    exists(DataFlow::PropRead read | result = read |\n      read.getBase() = goodRandom(t2, source) and\n      not read.getPropertyNameExpr() instanceof Label\n    )\n    or\n    // reading a number from a Buffer.\n    exists(DataFlow::MethodCallNode call | result = call |\n      call.getReceiver() = goodRandom(t2, source) and\n      call.getMethodName()\n          .regexpMatch(\"read(BigInt|BigUInt|Double|Float|Int|UInt)(8|16|32|64)?(BE|LE)?\")\n    )\n  )\n  or\n  exists(DataFlow::TypeTracker t2 | t = t2.smallstep(goodRandom(t2, source), result))\n  or\n  InsecureRandomness::isAdditionalTaintStep(goodRandom(t.continue(), source), result) and\n  // bit shifts and multiplication by powers of two are generally used for constructing larger numbers from smaller numbers.\n  not exists(BinaryExpr binop | binop = result.asExpr() |\n    binop.getOperator().regexpMatch(\".*(<|>).*\")\n    or\n    binop.getOperator() = \"*\" and isPowerOfTwo().asExpr() = binop.getAnOperand()\n    or\n    // string concat does not produce a number\n    unique(InferredType type | type = binop.flow().analyze().getAType()) = TTString()\n  )\n}\n\nDataFlow::Node goodRandom(DataFlow::SourceNode source) {\n  result = goodRandom(DataFlow::TypeTracker::end(), source)\n}\n\nDataFlow::Node isRounded(DataFlow::TypeBackTracker t) {\n  t.start() and\n  result = DataFlow::globalVarRef(\"Math\").getAMemberCall([\"round\", \"floor\", \"ceil\"]).getArgument(0)\n  or\n  exists(DataFlow::TypeBackTracker t2 | t2 = t.smallstep(result, isRounded(t2)))\n  or\n  InsecureRandomness::isAdditionalTaintStep(result, isRounded(t.continue()))\n}\n\nDataFlow::Node badCrypto(string description, DataFlow::SourceNode source) {\n  // addition and multiplication - always bad when both the lhs and rhs are random.\n  exists(BinaryExpr binop | result.asExpr() = binop |\n    goodRandom(_).asExpr() = binop.getLeftOperand() and\n    goodRandom(_).asExpr() = binop.getRightOperand() and\n    goodRandom(source).asExpr() = binop.getAnOperand() and\n    (\n      binop.getOperator() = \"+\" and description = \"addition\"\n      or\n      binop.getOperator() = \"*\" and description = \"multiplication\"\n    )\n  )\n  or\n  // division - bad if result is rounded.\n  exists(DivExpr div | result.asExpr() = div |\n    goodRandom(source).asExpr() = div.getLeftOperand() and\n    description = \"division and rounding the result\" and\n    not div.getRightOperand() = isPowerOfTwoMinusOne().asExpr() and // division by (2^n)-1 most of the time produces a uniformly random number between 0 and 1.\n    div = isRounded(DataFlow::TypeBackTracker::end()).asExpr()\n  )\n  or\n  // modulo - only bad if not by a power of 2 - and the result is not checked for bias\n  exists(ModExpr mod, DataFlow::Node random | result.asExpr() = mod and mod.getOperator() = \"%\" |\n    description = \"modulo\" and\n    goodRandom(source) = random and\n    random.asExpr() = mod.getLeftOperand() and\n    // division by a power of 2 is OK. E.g. if `x` is uniformly random is in the range [0..255] then `x % 32` is uniformly random in the range [0..31].\n    not mod.getRightOperand() = isPowerOfTwo().asExpr() and\n    // not exists a comparison that checks if the result is potentially biased.\n    not exists(BinaryExpr comparison | comparison.getOperator() = [\">\", \"<\", \"<=\", \">=\"] |\n      AccessPath::getAnAliasedSourceNode(random.getALocalSource())\n          .flowsToExpr(comparison.getAnOperand())\n      or\n      exists(DataFlow::PropRead otherRead |\n        otherRead = random.(DataFlow::PropRead).getBase().getALocalSource().getAPropertyRead() and\n        not exists(otherRead.getPropertyName()) and\n        otherRead.flowsToExpr(comparison.getAnOperand())\n      )\n    )\n  )\n  or\n  // create a number from a string - always a bad idea.\n  exists(DataFlow::CallNode number, StringOps::ConcatenationRoot root | result = number |\n    number = DataFlow::globalVarRef([\"Number\", \"parseInt\", \"parseFloat\"]).getACall() and\n    root = number.getArgument(0) and\n    goodRandom(source) = root.getALeaf() and\n    exists(root.getALeaf().getStringValue()) and\n    description = \"string concatenation\"\n  )\n}\n\nfrom DataFlow::Node node, string description, DataFlow::SourceNode source\nwhere node = badCrypto(description, source)\nselect node, \"Using \" + description + \" on a $@ produces biased results.\", source,\n  \"cryptographically secure random number\"",
        "description": "Some mathematical operations on random numbers can cause bias in the results and compromise security.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-327/BadRandomness.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.InsufficientPasswordHashQuery\nimport InsufficientPasswordHashFlow::PathGraph\n\nfrom InsufficientPasswordHashFlow::PathNode source, InsufficientPasswordHashFlow::PathNode sink\nwhere InsufficientPasswordHashFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Password from $@ is hashed insecurely.\", source.getNode(),\n  source.getNode().(Source).describe()",
        "description": "Creating a hash of a password with low computational effort makes the hash vulnerable to password cracking attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-916/InsufficientPasswordHash.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ClientSideRequestForgeryQuery\nimport ClientSideRequestForgeryFlow::PathGraph\n\nfrom\n  ClientSideRequestForgeryFlow::PathNode source, ClientSideRequestForgeryFlow::PathNode sink,\n  DataFlow::Node request\nwhere\n  ClientSideRequestForgeryFlow::flowPath(source, sink) and\n  request = sink.getNode().(Sink).getARequest()\nselect request, source, sink, \"The $@ of this request depends on a $@.\", sink.getNode(),\n  sink.getNode().(Sink).getKind(), source, \"user-provided value\"",
        "description": "Making a client-to-server request with user-controlled data in the URL allows a request forgery attack against the client.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-918/ClientSideRequestForgery.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.RequestForgeryQuery\nimport RequestForgeryFlow::PathGraph\n\nfrom RequestForgeryFlow::PathNode source, RequestForgeryFlow::PathNode sink, DataFlow::Node request\nwhere\n  RequestForgeryFlow::flowPath(source, sink) and\n  request = sink.getNode().(Sink).getARequest()\nselect request, source, sink, \"The $@ of this request depends on a $@.\", sink.getNode(),\n  sink.getNode().(Sink).getKind(), source, \"user-provided value\"",
        "description": "Making a network request with user-controlled data in the URL allows for request forgery attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-918/RequestForgery.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.CorsPermissiveConfigurationQuery as CorsQuery\nimport CorsQuery::CorsPermissiveConfigurationFlow::PathGraph\n\nfrom\n  CorsQuery::CorsPermissiveConfigurationFlow::PathNode source,\n  CorsQuery::CorsPermissiveConfigurationFlow::PathNode sink\nwhere CorsQuery::CorsPermissiveConfigurationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"CORS Origin allows broad access due to $@.\", source.getNode(),\n  \"permissive or user controlled value\"",
        "description": "Cross-origin resource sharing (CORS) policy allows overly broad access.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-942/CorsPermissiveConfiguration.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass FileCheck extends DataFlow::CallNode {\n  string member;\n\n  FileCheck() {\n    member =\n      [\n        \"open\", \"openSync\", \"exists\", \"existsSync\", \"stat\", \"statSync\", \"lstat\", \"lstatSync\",\n        \"fstat\", \"fstatSync\", \"access\", \"accessSync\"\n      ] and\n    this = NodeJSLib::FS::moduleMember(member).getACall()\n  }\n\n  DataFlow::Node getPathArgument() { result = this.getArgument(0) }\n\n  /** Holds if this call is a simple existence check for a file. */\n  predicate isExistsCheck() { member = [\"exists\", \"existsSync\"] }\n}\n\nclass FileUse extends DataFlow::CallNode {\n  string member;\n\n  FileUse() {\n    member =\n      [\n        // these are the six methods that accept file paths and file descriptors\n        \"readFile\", \"readFileSync\", \"writeFile\", \"writeFileSync\", \"appendFile\", \"appendFileSync\",\n        // don't use \"open\" after e.g. \"access\"\n        \"open\", \"openSync\"\n      ] and\n    this = NodeJSLib::FS::moduleMember(member).getACall()\n  }\n\n  DataFlow::Node getPathArgument() { result = this.getArgument(0) }\n\n  /** Holds if this call reads from a file. */\n  predicate isFileRead() { member = [\"readFile\", \"readFileSync\"] }\n}\n\nDataFlow::SourceNode getAFileHandle(DataFlow::TypeTracker t) {\n  t.start() and\n  (\n    result = NodeJSLib::FS::moduleMember(\"openSync\").getACall()\n    or\n    result =\n      NodeJSLib::FS::moduleMember(\"open\")\n          .getACall()\n          .getLastArgument()\n          .getAFunctionValue()\n          .getParameter(1)\n  )\n  or\n  exists(DataFlow::TypeTracker t2 | result = getAFileHandle(t2).track(t2, t))\n}\n\npredicate checkAndUseOnSame(FileCheck check, FileUse use) {\n  exists(string path |\n    check.getPathArgument().mayHaveStringValue(path) and\n    use.getPathArgument().mayHaveStringValue(path)\n  )\n  or\n  AccessPath::getAnAliasedSourceNode(check.getPathArgument()).flowsTo(use.getPathArgument())\n}\n\npragma[inline]\npredicate useAfterCheck(FileCheck check, FileUse use) {\n  check.getCallback(_).getFunction() = use.getContainer()\n  or\n  exists(BasicBlock bb |\n    check.getBasicBlock() = bb and\n    use.getBasicBlock() = bb and\n    exists(int i, int j |\n      bb.getNode(i) = check.asExpr() and\n      bb.getNode(j) = use.asExpr() and\n      i < j\n    )\n  )\n  or\n  check.getBasicBlock().(ReachableBasicBlock).strictlyDominates(use.getBasicBlock())\n}\n\nfrom FileCheck check, FileUse use\nwhere\n  checkAndUseOnSame(check, use) and\n  useAfterCheck(check, use) and\n  not (check.isExistsCheck() and use.isFileRead()) and // a read after an exists check is fine\n  not getAFileHandle(DataFlow::TypeTracker::end()).flowsTo(use.getPathArgument())\nselect use, \"The file may have changed since it $@.\", check, \"was checked\"",
        "description": "Separately checking the state of a file before operating on it may allow an attacker to modify the file between the two operations.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-367/FileSystemRace.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom\n  Routing::RouteSetup setup, Routing::RouteHandler handler, Http::RequestInputAccess input,\n  SensitiveNode sensitive\nwhere\n  setup.getOwnHttpMethod() = \"GET\" and\n  setup.getAChild+() = handler and\n  input.getRouteHandler() = handler.getFunction() and\n  input.getKind() = \"parameter\" and\n  input.(DataFlow::SourceNode).flowsTo(sensitive) and\n  not sensitive.getClassification() = SensitiveDataClassification::id()\nselect input, \"$@ for GET requests uses query parameter as sensitive data.\", handler,\n  \"Route handler\"",
        "description": "Placing sensitive data in a GET request increases the risk of the data being exposed to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-598/SensitiveGetQuery.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.HardcodedDataInterpretedAsCodeQuery\nimport DataFlow::DeduplicatePathGraph<HardcodedDataInterpretedAsCodeFlow::PathNode, HardcodedDataInterpretedAsCodeFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere\n  HardcodedDataInterpretedAsCodeFlow::flowPath(source.getAnOriginalPathNode(),\n    sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink,\n  \"$@ is interpreted as \" + sink.getNode().(Sink).getKind() + \".\", source.getNode(),\n  \"Hard-coded data\"",
        "description": "Transforming hard-coded data (such as hexadecimal constants) into code to be executed is a technique often associated with backdoors and should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-506/HardcodedDataInterpretedAsCode.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nAPI::NewNode getAWebSocketInstance() { result instanceof ClientWebSocket::ClientSocket }\n\nfrom DataFlow::Node handler\nwhere\n  handler = getAWebSocketInstance().getReturn().getMember(\"onmessage\").asSource()\n  or\n  handler = getAWebSocketInstance().getAPropertyWrite(\"onmessage\").getRhs()\nselect handler, \"This is a WebSocket onmessage handler.\"",
        "description": "",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/trest/test.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom CookieWrites::CookieWrite cookie\nwhere cookie.isSensitive() and not cookie.isSecure()\nselect cookie, \"Sensitive cookie sent without enforcing SSL encryption.\"",
        "description": "Sending sensitive information in a cookie without requring SSL encryption can expose the cookie to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-614/ClearTextCookie.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.SqlInjectionQuery as Sql\nimport semmle.javascript.security.dataflow.NosqlInjectionQuery as Nosql\n\nmodule Merged =\n  DataFlow::MergePathGraph<Sql::SqlInjectionFlow::PathNode, Nosql::NosqlInjectionFlow::PathNode,\n    Sql::SqlInjectionFlow::PathGraph, Nosql::NosqlInjectionFlow::PathGraph>;\n\nimport DataFlow::DeduplicatePathGraph<Merged::PathNode, Merged::PathGraph>\n\nfrom PathNode source, PathNode sink, string type\nwhere\n  Sql::SqlInjectionFlow::flowPath(source.getAnOriginalPathNode().asPathNode1(),\n    sink.getAnOriginalPathNode().asPathNode1()) and\n  type = \"string\"\n  or\n  Nosql::NosqlInjectionFlow::flowPath(source.getAnOriginalPathNode().asPathNode2(),\n    sink.getAnOriginalPathNode().asPathNode2()) and\n  type = \"object\"\nselect sink.getNode(), source, sink, \"This query \" + type + \" depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-089/SqlInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.TemplateObjectInjectionQuery\nimport DataFlow::DeduplicatePathGraph<TemplateObjectInjectionFlow::PathNode, TemplateObjectInjectionFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere\n  TemplateObjectInjectionFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink, \"Template object depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Instantiating a template using a user-controlled object is vulnerable to local file read and potential remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-073/TemplateObjectInjection.ql",
        "language": "javascript"
    },
    {
        "query": "private import javascript\nprivate import semmle.javascript.security.regexp.HostnameRegexp as HostnameRegexp\nprivate import codeql.regex.MissingRegExpAnchor as MissingRegExpAnchor\nprivate import semmle.javascript.security.regexp.RegExpTreeView::RegExpTreeView as TreeImpl\n\nprivate module Impl implements\n  MissingRegExpAnchor::MissingRegExpAnchorSig<TreeImpl, HostnameRegexp::Impl>\n{\n  predicate isUsedAsReplace(RegExpPatternSource pattern) {\n    // is used for capture or replace\n    exists(DataFlow::MethodCallNode mcn, string name | name = mcn.getMethodName() |\n      name = \"exec\" and\n      mcn = pattern.getARegExpObject().getAMethodCall() and\n      exists(mcn.getAPropertyRead())\n      or\n      exists(DataFlow::Node arg |\n        arg = mcn.getArgument(0) and\n        (\n          pattern.getARegExpObject().flowsTo(arg) or\n          pattern.getAParse() = arg\n        )\n      |\n        name = \"replace\"\n        or\n        name = [\"match\", \"matchAll\"] and exists(mcn.getAPropertyRead())\n      )\n    )\n  }\n\n  string getEndAnchorText() { result = \"$\" }\n}\n\nimport MissingRegExpAnchor::Make<TreeImpl, HostnameRegexp::Impl, Impl>\n\nfrom DataFlow::Node nd, string msg\nwhere\n  isUnanchoredHostnameRegExp(nd, msg)\n  or\n  isSemiAnchoredHostnameRegExp(nd, msg)\n  or\n  hasMisleadingAnchorPrecedence(nd, msg)\n// isLineAnchoredHostnameRegExp is not used here, as it is not relevant to JS.\nselect nd, msg",
        "description": "Regular expressions without anchors can be vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/MissingRegExpAnchor.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.IncompleteBlacklistSanitizer as IncompleteBlacklistSanitizer\n\nclass DangerousScheme extends string {\n  DangerousScheme() { this = \"data:\" or this = \"javascript:\" or this = \"vbscript:\" }\n\n  /** Gets the name of this scheme without the `:`. */\n  string getWithoutColon() { this = result + \":\" }\n\n  /** Gets the name of this scheme, with or without the `:`. */\n  string getWithOrWithoutColon() { result = this or result = this.getWithoutColon() }\n}\n\nDataFlow::SourceNode schemeOf(DataFlow::Node url) {\n  // url.split(\":\")[0]\n  exists(StringSplitCall split |\n    split.getSeparator() = \":\" and\n    result = split.getASubstringRead(0) and\n    url = split.getBaseString()\n  )\n  or\n  // url.getScheme(), url.getProtocol(), getScheme(url), getProtocol(url)\n  exists(DataFlow::CallNode call |\n    result = call and\n    (call.getCalleeName() = \"getScheme\" or call.getCalleeName() = \"getProtocol\")\n  |\n    call.getNumArgument() = 1 and\n    url = call.getArgument(0)\n    or\n    call.getNumArgument() = 0 and\n    url = call.getReceiver()\n  )\n  or\n  // url.scheme, url.protocol\n  exists(DataFlow::PropRead prop |\n    result = prop and\n    (prop.getPropertyName() = \"scheme\" or prop.getPropertyName() = \"protocol\") and\n    url = prop.getBase()\n  )\n}\n\nclass SchemeReplacementChain extends IncompleteBlacklistSanitizer::StringReplaceCallSequence {\n  SchemeReplacementChain() { this.getAMember().getAReplacedString() instanceof DangerousScheme }\n\n  /**\n   * Gets the source node that the replacement happens on.\n   * The result is the receiver of the first call in the chain.\n   */\n  DataFlow::Node getReplacementSource() {\n    result = this.getReceiver+() and not result instanceof DataFlow::MethodCallNode\n  }\n}\n\nDataFlow::Node schemeCheck(DataFlow::Node nd, DangerousScheme scheme) {\n  // check of the form `nd.startsWith(scheme)`\n  exists(StringOps::StartsWith sw | sw = result |\n    sw.getBaseString() = nd and\n    sw.getSubstring().mayHaveStringValue(scheme)\n  )\n  or\n  exists(MembershipCandidate candidate |\n    result = candidate.getTest()\n    or\n    // fall back to the candidate if the test itself is implicit\n    not exists(candidate.getTest()) and result = candidate\n  |\n    candidate.getAMemberString() = scheme.getWithOrWithoutColon() and\n    schemeOf(nd).flowsTo(candidate)\n  )\n  or\n  exists(SchemeReplacementChain chain | result = chain |\n    scheme = chain.getAMember().getAReplacedString() and\n    nd = chain.getReplacementSource()\n  )\n  or\n  // propagate through trimming, case conversion, and regexp replace\n  exists(DataFlow::MethodCallNode stringop |\n    stringop.getMethodName().matches(\"trim%\") or\n    stringop.getMethodName().matches(\"to%Case\") or\n    stringop.getMethodName() = [\"replace\", \"replaceAll\"]\n  |\n    result = schemeCheck(stringop, scheme) and\n    nd = stringop.getReceiver()\n  )\n  or\n  // propagate through local data flow\n  result = schemeCheck(nd.getASuccessor(), scheme)\n}\n\nDataFlow::Node schemeCheckOn(DataFlow::SourceNode root, string ap, DangerousScheme scheme) {\n  result = schemeCheck(AccessPath::getAReferenceTo(root, ap), scheme)\n}\n\nfrom DataFlow::SourceNode root, string path, int n\nwhere\n  n = strictcount(DangerousScheme s) and\n  strictcount(DangerousScheme s | exists(schemeCheckOn(root, path, s))) < n\nselect schemeCheckOn(root, path, \"javascript:\"),\n  \"This check does not consider \" +\n    strictconcat(DangerousScheme s | not exists(schemeCheckOn(root, path, s)) | s, \" and \") + \".\"",
        "description": "Checking for the \"javascript:\" URL scheme without also checking for \"vbscript:\" and \"data:\" suggests a logic error or even a security vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/IncompleteUrlSchemeCheck.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.CharacterEscapes::CharacterEscapes\n\nnewtype TRegExpPatternMistake =\n  /**\n   * A character escape mistake in regular expression string `src`\n   * for the character `char` at `index` in `rawStringNode`, explained\n   * by `mistake`.\n   */\n  TIdentityEscapeInStringMistake(\n    RegExpPatternSource src, string char, string mistake, AstNode rawStringNode, int index\n  ) {\n    char = getALikelyRegExpPatternMistake(src, mistake, rawStringNode, index)\n  } or\n  /**\n   * A backslash-escaped 'b' at `index` of `rawStringNode` in the\n   * regular expression string `src`, indicating intent to use the\n   * word-boundary assertion '\\b'.\n   */\n  TBackspaceInStringMistake(RegExpPatternSource src, AstNode rawStringNode, int index) {\n    exists(string raw, string cooked |\n      exists(StringLiteral lit | lit = rawStringNode |\n        rawStringNode = src.asExpr() and\n        raw = lit.getRawValue() and\n        cooked = lit.getStringValue()\n      )\n      or\n      exists(TemplateElement elem | elem = rawStringNode |\n        rawStringNode = src.asExpr().(TemplateLiteral).getAnElement() and\n        raw = elem.getRawValue() and\n        cooked = elem.getStringValue()\n      )\n    |\n      \"b\" = getAnEscapedCharacter(raw, index) and\n      // except if the string is exactly \\b\n      cooked.length() != 1\n    )\n  }\n\nclass RegExpPatternMistake extends TRegExpPatternMistake {\n  /**\n   * Holds if this element is at the specified location.\n   * The location spans column `startcolumn` of line `startline` to\n   * column `endcolumn` of line `endline` in file `filepath`.\n   * For more information, see\n   * [Locations](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    exists(int srcStartcolumn, int srcEndcolumn, int index |\n      index = this.getIndex() and\n      this.getRawStringNode()\n          .getLocation()\n          .hasLocationInfo(filepath, startline, srcStartcolumn, endline, srcEndcolumn)\n    |\n      (\n        if startline = endline\n        then startcolumn = srcStartcolumn + index - 1 and endcolumn = srcStartcolumn + index\n        else (\n          startcolumn = srcStartcolumn and endcolumn = srcEndcolumn\n        )\n      )\n    )\n  }\n\n  /** Gets a textual representation of this element. */\n  string toString() { result = this.getMessage() }\n\n  abstract AstNode getRawStringNode();\n\n  abstract RegExpPatternSource getSrc();\n\n  abstract int getIndex();\n\n  abstract string getMessage();\n}\n\nclass IdentityEscapeInStringMistake extends RegExpPatternMistake, TIdentityEscapeInStringMistake {\n  RegExpPatternSource src;\n  string char;\n  string mistake;\n  int index;\n  AstNode rawStringNode;\n\n  IdentityEscapeInStringMistake() {\n    this = TIdentityEscapeInStringMistake(src, char, mistake, rawStringNode, index)\n  }\n\n  override string getMessage() {\n    result = \"'\\\\\" + char + \"' is equivalent to just '\" + char + \"', so the sequence \" + mistake\n  }\n\n  override int getIndex() { result = index }\n\n  override RegExpPatternSource getSrc() { result = src }\n\n  override AstNode getRawStringNode() { result = rawStringNode }\n}\n\nclass BackspaceInStringMistake extends RegExpPatternMistake, TBackspaceInStringMistake {\n  RegExpPatternSource src;\n  int index;\n  AstNode rawStringNode;\n\n  BackspaceInStringMistake() { this = TBackspaceInStringMistake(src, rawStringNode, index) }\n\n  override string getMessage() {\n    result = \"'\\\\b' is a backspace, and not a word-boundary assertion\"\n  }\n\n  override int getIndex() { result = index }\n\n  override RegExpPatternSource getSrc() { result = src }\n\n  override AstNode getRawStringNode() { result = rawStringNode }\n}\n\nfrom RegExpPatternMistake mistake\nselect mistake, \"The escape sequence \" + mistake.getMessage() + \" when it is used in a $@.\",\n  mistake.getSrc().getAParse(), \"regular expression\"",
        "description": "Prepending a backslash to an ordinary character in a string does not have any effect, and may make regular expressions constructed from this string behave unexpectedly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/UselessRegExpCharacterEscape.ql",
        "language": "javascript"
    },
    {
        "query": "private import semmle.javascript.security.regexp.HostnameRegexp as HostnameRegexp\n\nquery predicate problems = HostnameRegexp::incompleteHostnameRegExp/4;",
        "description": "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/IncompleteHostnameRegExp.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass PostMessageHandler extends DataFlow::FunctionNode {\n  override PostMessageEventHandler astNode;\n\n  /** Gets the parameter that contains the event. */\n  DataFlow::ParameterNode getEventParameter() {\n    result = DataFlow::parameterNode(astNode.getEventParameter())\n  }\n}\n\nDataFlow::SourceNode event(DataFlow::TypeTracker t, PostMessageHandler handler) {\n  t.start() and\n  result = handler.getEventParameter()\n  or\n  exists(DataFlow::TypeTracker t2 | result = event(t2, handler).track(t2, t))\n}\n\nDataFlow::SourceNode origin(DataFlow::TypeTracker t, PostMessageHandler handler) {\n  t.start() and\n  result = event(DataFlow::TypeTracker::end(), handler).getAPropertyRead(\"origin\")\n  or\n  result =\n    origin(t.continue(), handler)\n        .getAMethodCall([\n            \"toString\", \"toLowerCase\", \"toUpperCase\", \"toLocaleLowerCase\", \"toLocaleUpperCase\"\n          ])\n  or\n  exists(DataFlow::TypeTracker t2 | result = origin(t2, handler).track(t2, t))\n}\n\nDataFlow::SourceNode source(DataFlow::TypeTracker t, PostMessageHandler handler) {\n  t.start() and\n  result = event(DataFlow::TypeTracker::end(), handler).getAPropertyRead(\"source\")\n  or\n  exists(DataFlow::TypeTracker t2 | result = source(t2, handler).track(t2, t))\n}\n\nDataFlow::SourceNode sourceOrOrigin(PostMessageHandler handler) {\n  result = source(DataFlow::TypeTracker::end(), handler) or\n  result = origin(DataFlow::TypeTracker::end(), handler)\n}\n\npredicate hasOriginCheck(PostMessageHandler handler) {\n  // event.origin === \"constant\"\n  exists(EqualityTest test | sourceOrOrigin(handler).flowsToExpr(test.getAnOperand()))\n  or\n  // set.includes(event.source)\n  exists(InclusionTest test | sourceOrOrigin(handler).flowsTo(test.getContainedNode()))\n  or\n  // \"safeOrigin\".startsWith(event.origin)\n  exists(StringOps::StartsWith starts |\n    origin(DataFlow::TypeTracker::end(), handler).flowsTo(starts.getSubstring())\n  )\n  or\n  // \"safeOrigin\".endsWith(event.origin)\n  exists(StringOps::EndsWith ends |\n    origin(DataFlow::TypeTracker::end(), handler).flowsTo(ends.getSubstring())\n  )\n}\n\nfrom PostMessageHandler handler\nwhere not hasOriginCheck(handler)\nselect handler.getEventParameter(), \"Postmessage handler has no origin check.\"",
        "description": "Missing origin verification in a `postMessage` handler allows any windows to send arbitrary data to the handler.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/MissingOriginCheck.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ExternalAPIUsedWithUntrustedDataQuery\nimport ExternalAPIUsedWithUntrustedDataFlow::PathGraph\n\nfrom\n  ExternalAPIUsedWithUntrustedDataFlow::PathNode source,\n  ExternalAPIUsedWithUntrustedDataFlow::PathNode sink\nwhere ExternalAPIUsedWithUntrustedDataFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"Call to \" + sink.getNode().(Sink).getApiName() + \" with untrusted data from $@.\", source,\n  source.toString()",
        "description": "Data provided remotely is used in this external API without sanitization, which could be a security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/UntrustedDataToExternalAPI.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass IndexOfCall extends DataFlow::MethodCallNode {\n  IndexOfCall() {\n    exists(string name | name = this.getMethodName() |\n      name = \"indexOf\" or\n      name = \"lastIndexOf\"\n    ) and\n    this.getNumArgument() = 1\n  }\n\n  /** Gets the receiver or argument of this call. */\n  DataFlow::Node getAnOperand() {\n    result = this.getReceiver() or\n    result = this.getArgument(0)\n  }\n\n  /**\n   * Holds if `recv` is the local source of the receiver of this call, and `m`\n   * is the name of the invoked method.\n   */\n  private predicate receiverAndMethodName(DataFlow::Node recv, string m) {\n    this.getReceiver().getALocalSource() = recv and\n    this.getMethodName() = m\n  }\n\n  /**\n   * Gets an `indexOf` call with the same receiver, argument, and method name, including this call itself.\n   */\n  IndexOfCall getAnEquivalentIndexOfCall() {\n    result = this\n    or\n    exists(DataFlow::Node recv, string m |\n      this.receiverAndMethodName(recv, m) and result.receiverAndMethodName(recv, m)\n    |\n      // both directly reference the same value\n      result.getArgument(0).getALocalSource() = this.getArgument(0).getALocalSource()\n      or\n      // both use the same string literal\n      result.getArgument(0).getStringValue() = this.getArgument(0).getStringValue()\n      or\n      // both use the same concatenation of a string and a value\n      exists(Expr origin, StringLiteral str, AddExpr otherAdd |\n        this.getArgument(0).asExpr().(AddExpr).hasOperands(origin, str) and\n        otherAdd = result.getArgument(0).asExpr()\n      |\n        otherAdd.getAnOperand().(StringLiteral).getStringValue() = str.getStringValue() and\n        otherAdd.getAnOperand().flow().getALocalSource() = origin.flow().getALocalSource()\n      )\n    )\n  }\n\n  /**\n   * Gets an expression that refers to the return value of this call.\n   */\n  Expr getAUse() { this.flowsToExpr(result) }\n}\n\nDataFlow::SourceNode getStringSource(DataFlow::Node node) {\n  result = node.getALocalSource()\n  or\n  result = StringConcatenation::getAnOperand(node).getALocalSource()\n}\n\nclass LiteralLengthExpr extends DotExpr {\n  LiteralLengthExpr() {\n    this.getPropertyName() = \"length\" and\n    this.getBase() instanceof StringLiteral\n  }\n\n  /**\n   * Gets the value of the string literal whose length is taken.\n   */\n  string getBaseValue() { result = this.getBase().getStringValue() }\n}\n\npredicate isDerivedFromLength(DataFlow::Node length, DataFlow::Node operand) {\n  exists(IndexOfCall call | operand = call.getAnOperand() |\n    length = getStringSource(operand).getAPropertyRead(\"length\")\n    or\n    exists(string val | val = operand.getStringValue() |\n      // Find a literal length with the same string constant\n      exists(LiteralLengthExpr lengthExpr |\n        lengthExpr.getContainer() = call.getContainer() and\n        lengthExpr.getBaseValue() = val and\n        length = lengthExpr.flow()\n      )\n      or\n      // Find an integer constant that equals the length of string constant\n      exists(Expr lengthExpr |\n        lengthExpr.getContainer() = call.getContainer() and\n        lengthExpr.getIntValue() = val.length() and\n        length = lengthExpr.flow()\n      )\n    )\n  )\n  or\n  isDerivedFromLength(length.getAPredecessor(), operand)\n  or\n  exists(BinaryExpr expr | expr instanceof SubExpr or expr instanceof AddExpr |\n    isDerivedFromLength(expr.getAnOperand().flow(), operand) and\n    length = expr.flow()\n  )\n}\n\nclass UnsafeIndexOfComparison extends EqualityTest {\n  IndexOfCall indexOf;\n\n  UnsafeIndexOfComparison() {\n    exists(DataFlow::Node testedValue |\n      this.hasOperands(indexOf.getAUse(), testedValue.asExpr()) and\n      isDerivedFromLength(testedValue, indexOf.getReceiver()) and\n      isDerivedFromLength(testedValue, indexOf.getArgument(0))\n    ) and\n    // Ignore cases like `x.indexOf(\"/\") === x.length - 1` that can only be bypassed if `x` is the empty string.\n    // Sometimes strings are just known to be non-empty from the context, and it is unlikely to be a security issue,\n    // since it's obviously not a domain name check.\n    not indexOf.getArgument(0).mayHaveStringValue(any(string s | s.length() = 1)) and\n    // Relative string length comparison, such as A.length > B.length, or (A.length - B.length) > 0\n    not exists(RelationalComparison compare |\n      isDerivedFromLength(compare.getAnOperand().flow(), indexOf.getReceiver()) and\n      isDerivedFromLength(compare.getAnOperand().flow(), indexOf.getArgument(0))\n    ) and\n    // Check for indexOf being -1\n    not exists(EqualityTest test, Expr minusOne |\n      test.hasOperands(indexOf.getAnEquivalentIndexOfCall().getAUse(), minusOne) and\n      minusOne.getIntValue() = -1\n    ) and\n    // Check for indexOf being >1, or >=0, etc\n    not exists(RelationalComparison test |\n      test.getGreaterOperand() = indexOf.getAnEquivalentIndexOfCall().getAUse() and\n      exists(int value | value = test.getLesserOperand().getIntValue() |\n        value >= 0\n        or\n        not test.isInclusive() and\n        value = -1\n      )\n    ) and\n    // Check for indexOf being <0, or <=-1\n    not exists(RelationalComparison test |\n      test.getLesserOperand() = indexOf.getAnEquivalentIndexOfCall().getAUse() and\n      exists(int value | value = test.getGreaterOperand().getIntValue() |\n        value < 0\n        or\n        not test.isInclusive() and\n        value = 0\n      )\n    )\n  }\n\n  IndexOfCall getIndexOf() { result = indexOf }\n}\n\nfrom UnsafeIndexOfComparison comparison\nselect comparison,\n  \"This suffix check is missing a length comparison to correctly handle \" +\n    comparison.getIndexOf().getMethodName() + \" returning -1.\"",
        "description": "Using indexOf to implement endsWith functionality is error-prone if the -1 case is not explicitly handled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/IncorrectSuffixCheck.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ExternalAPIUsedWithUntrustedDataQuery\n\nfrom ExternalApiUsedWithUntrustedData externalApi\nselect externalApi, count(externalApi.getUntrustedDataNode()) as numberOfUses,\n  externalApi.getNumberOfUntrustedSources() as numberOfUntrustedSources order by\n    numberOfUntrustedSources desc",
        "description": "This reports the external APIs that are used with untrusted data, along with how frequently the API is called, and how many unique sources of untrusted data flow to it.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/ExternalAPIsUsedWithUntrustedData.ql",
        "language": "javascript"
    },
    {
        "query": "import IncompleteUrlSubstringSanitization",
        "description": "Security checks on the substrings of an unparsed URL are often vulnerable to bypassing.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/IncompleteUrlSubstringSanitization.ql",
        "language": "javascript"
    },
    {
        "query": "private import semmle.javascript.security.regexp.RegExpTreeView::RegExpTreeView as TreeView\nimport codeql.regex.OverlyLargeRangeQuery::Make<TreeView>\n\nfrom TreeView::RegExpCharacterRange range, string reason\nwhere problem(range, reason)\nselect range, \"Suspicious character range that \" + reason + \".\"",
        "description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-020/OverlyLargeRange.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.HostHeaderPoisoningInEmailGenerationQuery\nimport HostHeaderPoisoningFlow::PathGraph\n\nfrom HostHeaderPoisoningFlow::PathNode source, HostHeaderPoisoningFlow::PathNode sink\nwhere HostHeaderPoisoningFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Links in this email can be hijacked by poisoning the $@.\",\n  source.getNode(), \"HTTP host header\"",
        "description": "Using the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-640/HostHeaderPoisoningInEmailGeneration.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.DeepObjectResourceExhaustionQuery\nimport DataFlow::DeduplicatePathGraph<DeepObjectResourceExhaustionFlow::PathNode, DeepObjectResourceExhaustionFlow::PathGraph>\n\nfrom PathNode source, PathNode sink, DataFlow::Node link, string reason\nwhere\n  DeepObjectResourceExhaustionFlow::flowPath(source.getAnOriginalPathNode(),\n    sink.getAnOriginalPathNode()) and\n  sink.getNode().(Sink).hasReason(link, reason)\nselect sink, source, sink, \"Denial of service caused by processing $@ with $@.\", source.getNode(),\n  \"user input\", link, reason",
        "description": "Processing user-controlled object hierarchies inefficiently can lead to denial of service.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-400/DeepObjectResourceExhaustion.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.RemotePropertyInjectionQuery\nimport RemotePropertyInjectionFlow::PathGraph\n\nfrom RemotePropertyInjectionFlow::PathNode source, RemotePropertyInjectionFlow::PathNode sink\nwhere RemotePropertyInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, sink.getNode().(Sink).getMessage() + \" depends on a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Allowing writes to arbitrary properties of an object may lead to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-400/RemotePropertyInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.LoopBoundInjectionQuery\nimport LoopBoundInjectionFlow::PathGraph\n\nfrom LoopBoundInjectionFlow::PathNode source, LoopBoundInjectionFlow::PathNode sink\nwhere LoopBoundInjectionFlow::flowPath(source, sink)\nselect sink, source, sink,\n  \"Iteration over a user-controlled object with a potentially unbounded .length property from a $@.\",\n  source, \"user-provided value\"",
        "description": "Iterating over an object with a user-controlled .length property can cause indefinite looping.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-834/LoopBoundInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nDataFlow::InvokeNode tlsInvocation() {\n  result instanceof ClientRequest\n  or\n  result = DataFlow::moduleMember(\"https\", \"Agent\").getAnInstantiation()\n  or\n  result = DataFlow::moduleMember(\"https\", \"createServer\").getACall()\n  or\n  exists(DataFlow::NewNode new |\n    new = DataFlow::moduleMember(\"tls\", \"TLSSocket\").getAnInstantiation()\n  |\n    result = new or\n    result = new.getAMethodCall(\"renegotiate\")\n  )\n  or\n  result = DataFlow::moduleMember(\"tls\", [\"connect\", \"createServer\"]).getACall()\n}\n\nDataFlow::ObjectLiteralNode tlsOptions() { result.flowsTo(tlsInvocation().getAnArgument()) }\n\nfrom DataFlow::PropWrite disable\nwhere\n  exists(DataFlow::SourceNode env |\n    env.(ThreatModelSource).getThreatModel() = \"environment\" and\n    disable = env.getAPropertyWrite(\"NODE_TLS_REJECT_UNAUTHORIZED\") and\n    disable.getRhs().mayHaveStringValue(\"0\")\n  )\n  or\n  (\n    disable = tlsOptions().getAPropertyWrite(\"rejectUnauthorized\")\n    or\n    // the same thing, but with API-nodes if they happen to be available\n    exists(API::Node tlsInvk | tlsInvk.getAnInvocation() = tlsInvocation() |\n      disable.getRhs() = tlsInvk.getAParameter().getMember(\"rejectUnauthorized\").asSink()\n    )\n  ) and\n  disable.getRhs().(AnalyzedNode).getTheBooleanValue() = false\nselect disable, \"Disabling certificate validation is strongly discouraged.\"",
        "description": "Disabling cryptographic certificate validation can cause security vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-295/DisablingCertificateValidation.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.frameworks.ExpressModules\nimport semmle.javascript.frameworks.helmet.Helmet\n\nfrom HelmetProperty helmetProperty, ExpressLibraries::HelmetRouteHandler helmet\nwhere\n  helmetProperty.isFalse() and\n  helmetProperty.isImportantSecuritySetting() and\n  helmetProperty.getHelmet() = helmet\nselect helmet,\n  \"Helmet security middleware, configured with security setting $@ set to 'false', which disables enforcing that feature.\",\n  helmetProperty, helmetProperty.getName()",
        "description": "The Helmet middleware is used to set security-related HTTP headers in Express applications. This query finds instances where the middleware is configured with important security features disabled.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-693/InsecureHelmet.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom DataFlow::CallNode call\nwhere\n  call = DataFlow::moduleMember(\"jsonwebtoken\", \"verify\").getACall() and\n  call.getArgument(1).analyze().getTheBooleanValue() = false\nselect call.getArgument(1),\n  \"This argument disables the integrity enforcement of the token verification.\"",
        "description": "The application does not verify the JWT payload with a cryptographic secret or public key.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-347/MissingJWTKeyVerification.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.PasswordInConfigurationFileQuery\n\nfrom string key, string val, Locatable valElement, string pwd\nwhere\n  config(key, val, valElement) and\n  val != \"\" and\n  (\n    key.toLowerCase() = \"password\" and\n    pwd = val and\n    // exclude interpolations of environment variables\n    not val.regexpMatch(\"\\\\$.*|%.*%\") and\n    not PasswordHeuristics::isDummyPassword(val)\n    or\n    not key.toLowerCase() = [\"readme\", \"run\"] and\n    // look for `password=...`, but exclude `password=;`, `password=\"$(...)\"`, `password=foo()`\n    // `password=%s` and `password==`\n    pwd = val.regexpCapture(\"(?is).*password\\\\s*=\\\\s*(?!;|\\\"?[$`]|%s|=|\\\\w+\\\\(.+\\\\))(\\\\S+).*\", 1)\n  )\nselect valElement.(FirstLineOf), \"Hard-coded password '\" + pwd + \"' in configuration file.\"",
        "description": "Storing unencrypted passwords in configuration files is unsafe.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-313/PasswordInConfigurationFile.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ResourceExhaustionQuery\nimport ResourceExhaustionFlow::PathGraph\n\nfrom ResourceExhaustionFlow::PathNode source, ResourceExhaustionFlow::PathNode sink\nwhere ResourceExhaustionFlow::flowPath(source, sink)\nselect sink, source, sink, sink.getNode().(Sink).getProblemDescription() + \" from a $@.\", source,\n  \"user-provided value\"",
        "description": "Allocating objects or timers with user-controlled sizes or durations can cause resource exhaustion.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-770/ResourceExhaustion.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.MissingRateLimiting\nimport semmle.javascript.RestrictedLocations\n\nfrom\n  Routing::Node useSite, ExpensiveRouteHandler r, string explanation, DataFlow::Node reference,\n  string referenceLabel\nwhere\n  useSite = Routing::getNode(r).getRouteInstallation() and\n  r.explain(explanation, reference, referenceLabel) and\n  not useSite.isGuardedByNode(any(RateLimitingMiddleware m).getRoutingNode())\nselect useSite, \"This route handler \" + explanation + \", but is not rate-limited.\", reference,\n  referenceLabel",
        "description": "An HTTP request handler that performs expensive operations without restricting the rate at which operations can be carried out is vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-770/MissingRateLimiting.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.LogInjectionQuery\nimport LogInjectionFlow::PathGraph\n\nfrom LogInjectionFlow::PathNode source, LogInjectionFlow::PathNode sink\nwhere LogInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Log entry depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building log entries from user-controlled sources is vulnerable to insertion of forged log entries by a malicious user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-117/LogInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CorsMisconfigurationForCredentialsQuery\nimport CorsMisconfigurationFlow::PathGraph\n\nfrom CorsMisconfigurationFlow::PathNode source, CorsMisconfigurationFlow::PathNode sink\nwhere CorsMisconfigurationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"$@ leak vulnerability due to a $@.\",\n  sink.getNode().(Sink).getCredentialsHeader(), \"Credential\", source.getNode(),\n  \"misconfigured CORS header value\"",
        "description": "Misconfiguration of CORS HTTP headers allows for leaks of secret credentials.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-346/CorsMisconfigurationForCredentials.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.InsecureTemporaryFileQuery\nimport InsecureTemporaryFileFlow::PathGraph\n\nfrom InsecureTemporaryFileFlow::PathNode source, InsecureTemporaryFileFlow::PathNode sink\nwhere InsecureTemporaryFileFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Insecure creation of file in $@.\", source.getNode(),\n  \"the os temp dir\"",
        "description": "Creating a temporary file that is accessible by other users can lead to information disclosure and sometimes remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-377/InsecureTemporaryFile.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npragma[inline]\npredicate isLoginSetup(Express::RouteSetup setup) {\n  // some path that contains \"login\" with a write to `req.session`\n  setup.getPath().matches(\"%login%\") and\n  exists(\n    setup\n        .getARouteHandler()\n        .(Express::RouteHandler)\n        .getARequestSource()\n        .ref()\n        .getAPropertyRead(\"session\")\n        .getAPropertyWrite()\n  )\n  // passport used to be recognized, but they have since added built-in protection against session fixation\n}\n\npragma[inline]\npredicate regeneratesSession(Express::RouteSetup setup) {\n  exists(\n    setup\n        .getARouteHandler()\n        .(Express::RouteHandler)\n        .getARequestSource()\n        .ref()\n        .getAPropertyRead(\"session\")\n        .getAPropertyRead(\"regenerate\")\n  )\n}\n\nfrom Express::RouteSetup setup\nwhere\n  isLoginSetup(setup) and\n  not regeneratesSession(setup)\nselect setup, \"Route handler does not invalidate session following login.\"",
        "description": "Reusing an existing session as a different user could allow an attacker to access someone else's account by using their session.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-384/SessionFixation.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nstring metachar() { result = \"'\\\"\\\\&<>\\n\\r\\t*|{}[]%$\".charAt(_) }\n\nstring getAMatchedString(DataFlow::Node e) {\n  result = e.(DataFlow::RegExpCreationNode).getRoot().getAMatchedString()\n  or\n  result = e.getStringValue()\n}\n\npredicate isSimple(RegExpTerm t) {\n  t instanceof RegExpConstant\n  or\n  isSimple(t.(RegExpGroup).getAChild())\n  or\n  isSimpleCharacterClass(t)\n  or\n  isSimpleAlt(t)\n}\n\npredicate isSimpleCharacterClass(RegExpCharacterClass t) {\n  not t.isInverted() and\n  forall(RegExpTerm ch | ch = t.getAChild() | isSimple(ch))\n}\n\npredicate isSimpleAlt(RegExpAlt t) { forall(RegExpTerm ch | ch = t.getAChild() | isSimple(ch)) }\n\npredicate isBackslashEscape(StringReplaceCall mce, DataFlow::RegExpCreationNode re) {\n  mce.maybeGlobal() and\n  re = mce.getRegExp() and\n  (\n    // replacement with `\\$&`, `\\$1` or similar\n    mce.getRawReplacement().getStringValue().regexpMatch(\"\\\\\\\\\\\\$(&|\\\\d)\")\n    or\n    // replacement of `c` with `\\c`\n    exists(string c | mce.replaces(c, \"\\\\\" + c))\n  )\n}\n\npredicate allBackslashesEscaped(DataFlow::Node nd) {\n  // `JSON.stringify` escapes backslashes\n  nd instanceof JsonStringifyCall\n  or\n  // check whether `nd` itself escapes backslashes\n  exists(DataFlow::RegExpCreationNode rel | isBackslashEscape(nd, rel) |\n    // if it's a complex regexp, we conservatively assume that it probably escapes backslashes\n    not isSimple(rel.getRoot()) or\n    getAMatchedString(rel) = \"\\\\\"\n  )\n  or\n  // flow through string methods\n  exists(DataFlow::MethodCallNode mc, string m |\n    m =\n      [\n        \"replace\", \"replaceAll\", \"slice\", \"substr\", \"substring\", \"toLowerCase\", \"toUpperCase\",\n        \"trim\"\n      ]\n  |\n    mc = nd and m = mc.getMethodName() and allBackslashesEscaped(mc.getReceiver())\n  )\n  or\n  // general data flow\n  allBackslashesEscaped(nd.getAPredecessor())\n}\n\npredicate removesFirstOccurrence(StringReplaceCall repl, string str) {\n  not exists(repl.getRegExp()) and repl.replaces(str, \"\")\n}\n\npredicate isDelimiterUnwrapper(\n  DataFlow::MethodCallNode leftUnwrap, DataFlow::MethodCallNode rightUnwrap\n) {\n  exists(string left, string right |\n    left = \"[\" and right = \"]\"\n    or\n    left = \"{\" and right = \"}\"\n    or\n    left = \"(\" and right = \")\"\n    or\n    left = \"\\\"\" and right = \"\\\"\"\n    or\n    left = \"'\" and right = \"'\"\n  |\n    removesFirstOccurrence(leftUnwrap, left) and\n    removesFirstOccurrence(rightUnwrap, right) and\n    leftUnwrap.getAMethodCall() = rightUnwrap\n  )\n}\n\n\npredicate whitelistedRemoval(StringReplaceCall repl) {\n  not repl.isGlobal() and\n  exists(string s | s = \"\\n\" or s = \"%\" or s = \"$\" |\n    repl.replaces(s, \"\") and\n    not exists(StringReplaceCall other |\n      repl.getAMethodCall() = other or\n      other.getAMethodCall() = repl\n    )\n  )\n}\n\nstring getPatternOrValueString(DataFlow::Node node) {\n  if node instanceof DataFlow::RegExpConstructorInvokeNode\n  then result = \"/\" + node.(DataFlow::RegExpConstructorInvokeNode).getRoot() + \"/\"\n  else result = node.toString()\n}\n\nfrom StringReplaceCall repl, DataFlow::Node old, string msg\nwhere\n  (old = repl.getArgument(0) or old = repl.getRegExp()) and\n  (\n    not repl.maybeGlobal() and\n    msg = \"This replaces only the first occurrence of \" + getPatternOrValueString(old) + \".\" and\n    // only flag if this is likely to be a sanitizer or URL encoder or decoder\n    exists(string m | m = getAMatchedString(old) |\n      // sanitizer\n      m = metachar()\n      or\n      exists(string urlEscapePattern | urlEscapePattern = \"(%[0-9A-Fa-f]{2})+\" |\n        // URL decoder\n        m.regexpMatch(urlEscapePattern)\n        or\n        // URL encoder\n        repl.getArgument(1).getStringValue().regexpMatch(urlEscapePattern)\n      )\n      or\n      // path sanitizer\n      (m = \"..\" or m = \"/..\" or m = \"../\" or m = \"/../\")\n    ) and\n    // don't flag replace operations in a loop\n    not repl.getReceiver() = repl.getASuccessor+() and\n    // dont' flag unwrapper\n    not isDelimiterUnwrapper(repl, _) and\n    not isDelimiterUnwrapper(_, repl) and\n    // don't flag replacements of certain characters with whitespace\n    not whitelistedRemoval(repl)\n    or\n    isBackslashEscape(repl, _) and\n    not allBackslashesEscaped(repl) and\n    msg = \"This does not escape backslash characters in the input.\"\n  )\nselect repl.getCalleeNode(), msg",
        "description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-116/IncompleteSanitization.ql",
        "language": "javascript"
    },
    {
        "query": "private import semmle.javascript.security.regexp.RegExpTreeView::RegExpTreeView as TreeView\nimport codeql.regex.nfa.BadTagFilterQuery::Make<TreeView>\n\nfrom HtmlMatchingRegExp regexp, string msg\nwhere msg = min(string m | isBadRegexpFilter(regexp, m) | m order by m.length(), m) // there might be multiple, we arbitrarily pick the shortest one\nselect regexp, msg",
        "description": "Matching HTML tags using regular expressions is hard to do right, and can easily lead to security issues.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-116/BadTagFilter.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass SelfClosingTagRecognizer extends DataFlow::RegExpCreationNode {\n  SelfClosingTagRecognizer() {\n    exists(RegExpSequence seq, RegExpGroup name, RegExpGroup content |\n      // `/.../g`\n      RegExp::isGlobal(this.getFlags()) and\n      this.getRoot() = seq.getRootTerm() and\n      // `/<.../`\n      seq.getChild(0).getConstantValue() = \"<\" and\n      // `/...\\/>/`\n      seq.getLastChild().getPredecessor().getConstantValue() = \"/\" and\n      seq.getLastChild().getConstantValue() = \">\" and\n      // `/...((...)...).../`\n      seq.getAChild() = content and\n      content.getNumber() = 1 and\n      name.getNumber() = 2 and\n      name = content.getChild(0).(RegExpSequence).getChild(0) and\n      // `/...(([a-z]+)...).../` or `/...(([a-z][...]*)...).../`\n      exists(RegExpQuantifier quant | name.getAChild*() = quant |\n        quant instanceof RegExpStar or\n        quant instanceof RegExpPlus\n      ) and\n      // `/...((...)[^>]*).../`\n      exists(RegExpCharacterClass lazy |\n        name.getSuccessor().(RegExpStar).getChild(0) = lazy and\n        lazy.isInverted() and\n        lazy.getAChild().getConstantValue() = \">\"\n      )\n    )\n  }\n}\n\nfrom SelfClosingTagRecognizer regexp, StringReplaceCall replace\nwhere\n  regexp.getAReference().flowsTo(replace.getArgument(0)) and\n  replace.getRawReplacement().mayHaveStringValue(\"<$1></$2>\")\nselect replace,\n  \"This self-closing HTML tag expansion invalidates prior sanitization as $@ may match part of an attribute value.\",\n  regexp, \"this regular expression\"",
        "description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-116/UnsafeHtmlExpansion.ql",
        "language": "javascript"
    },
    {
        "query": "import semmle.javascript.security.IncompleteMultiCharacterSanitizationQuery",
        "description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-116/IncompleteMultiCharacterSanitization.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nDataFlow::Node getASimplePredecessor(DataFlow::Node nd) {\n  result = nd.getAPredecessor() and\n  not exists(SsaDefinition ssa |\n    ssa = nd.(DataFlow::SsaDefinitionNode).getSsaVariable().getDefinition()\n  |\n    ssa instanceof SsaPhiNode or\n    ssa instanceof SsaVariableCapture\n  )\n}\n\npredicate escapingScheme(string metachar, string regex) {\n  metachar = \"&\" and regex = \"&.+;\"\n  or\n  metachar = \"%\" and regex = \"%.+\"\n  or\n  metachar = \"\\\\\" and regex = \"\\\\\\\\.+\"\n}\n\nclass Replacement extends StringReplaceCall {\n  Replacement() { this.isGlobal() }\n\n  /**\n   * Gets the input of this replacement.\n   */\n  DataFlow::Node getInput() { result = this.getReceiver() }\n\n  /**\n   * Gets the output of this replacement.\n   */\n  DataFlow::SourceNode getOutput() { result = this }\n\n  /**\n   * Holds if this replacement escapes `char` using `metachar`.\n   *\n   * For example, during HTML entity escaping `<` is escaped (to `&lt;`)\n   * using `&`.\n   */\n  predicate escapes(string char, string metachar) {\n    exists(string regexp, string repl |\n      escapingScheme(metachar, regexp) and\n      this.replaces(char, repl) and\n      repl.regexpMatch(regexp)\n    )\n  }\n\n  /**\n   * Holds if this replacement unescapes `char` using `metachar`.\n   *\n   * For example, during HTML entity unescaping `<` is unescaped (from\n   * `&lt;`) using `<`.\n   */\n  predicate unescapes(string metachar, string char) {\n    exists(string regexp, string orig |\n      escapingScheme(metachar, regexp) and\n      this.replaces(orig, char) and\n      orig.regexpMatch(regexp)\n    )\n  }\n\n  /**\n   * Gets the previous replacement in this chain of replacements.\n   */\n  Replacement getPreviousReplacement() {\n    result.getOutput() = getASimplePredecessor*(this.getInput())\n  }\n\n  /**\n   * Gets an earlier replacement in this chain of replacements that\n   * performs an escaping.\n   */\n  Replacement getAnEarlierEscaping(string metachar) {\n    exists(Replacement pred | pred = this.getPreviousReplacement() |\n      if pred.escapes(_, metachar)\n      then result = pred\n      else (\n        not pred.unescapes(metachar, _) and result = pred.getAnEarlierEscaping(metachar)\n      )\n    )\n  }\n\n  /**\n   * Gets an earlier replacement in this chain of replacements that\n   * performs a unescaping.\n   */\n  Replacement getALaterUnescaping(string metachar) {\n    exists(Replacement succ | this = succ.getPreviousReplacement() |\n      if succ.unescapes(metachar, _)\n      then result = succ\n      else (\n        not succ.escapes(_, metachar) and result = succ.getALaterUnescaping(metachar)\n      )\n    )\n  }\n}\n\nfrom Replacement primary, Replacement supplementary, string message, string metachar\nwhere\n  primary.escapes(metachar, _) and\n  supplementary = primary.getAnEarlierEscaping(metachar) and\n  message = \"may double-escape '\" + metachar + \"' characters from $@\"\n  or\n  primary.unescapes(_, metachar) and\n  supplementary = primary.getALaterUnescaping(metachar) and\n  message = \"may produce '\" + metachar + \"' characters that are double-unescaped $@\"\nselect primary, \"This replacement \" + message + \".\", supplementary, \"here\"",
        "description": "When escaping special characters using a meta-character like backslash or ampersand, the meta-character has to be escaped first to avoid double-escaping, and conversely it has to be unescaped last to avoid double-unescaping.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-116/DoubleEscaping.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.IncompleteHtmlAttributeSanitizationQuery\nimport semmle.javascript.security.IncompleteBlacklistSanitizer\nimport DataFlow::DeduplicatePathGraph<IncompleteHtmlAttributeSanitizationFlow::PathNode, IncompleteHtmlAttributeSanitizationFlow::PathGraph>\n\nstring prettyPrintDangerousCharaters(Sink sink) {\n  result =\n    strictconcat(string s |\n      s = describeCharacters(sink.getADangerousCharacter())\n    |\n      s, \", \" order by s\n    ).regexpReplaceAll(\",(?=[^,]+$)\", \" or\")\n}\n\nfrom PathNode source, PathNode sink\nwhere\n  IncompleteHtmlAttributeSanitizationFlow::flowPath(source.getAnOriginalPathNode(),\n    sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink,\n  // this message is slightly sub-optimal as we do not have an easy way\n  // to get the flow labels that reach the sink, so the message includes\n  // all of them in a disjunction\n  \"Cross-site scripting vulnerability as the output of $@ may contain \" +\n    prettyPrintDangerousCharaters(sink.getNode()) + \" when it reaches this attribute definition.\",\n  source.getNode(), \"this final HTML sanitizer step\"",
        "description": "Writing incompletely sanitized values to HTML attribute strings can lead to a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-116/IncompleteHtmlAttributeSanitization.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.PrototypePollutingAssignmentQuery\nimport PrototypePollutingAssignmentFlow::PathGraph\n\nfrom\n  PrototypePollutingAssignmentFlow::PathNode source, PrototypePollutingAssignmentFlow::PathNode sink\nwhere\n  PrototypePollutingAssignmentFlow::flowPath(source, sink) and\n  not isIgnoredLibraryFlow(source.getNode(), sink.getNode())\nselect sink, source, sink,\n  \"This assignment may alter Object.prototype if a malicious '__proto__' string is injected from $@.\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "Modifying an object obtained via a user-controlled property name may lead to accidental mutation of the built-in Object prototype, and possibly escalate to remote code execution or cross-site scripting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-915/PrototypePollutingAssignment.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.PrototypePollutionQuery\nimport DataFlow::DeduplicatePathGraph<PrototypePollutionFlow::PathNode, PrototypePollutionFlow::PathGraph>\n\nfrom PathNode source, PathNode sink, string moduleName, Locatable dependencyLoc\nwhere\n  PrototypePollutionFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode()) and\n  sink.getNode().(Sink).dependencyInfo(moduleName, dependencyLoc)\nselect sink.getNode(), source, sink,\n  \"Prototype pollution caused by merging a $@ using a vulnerable version of $@.\", source,\n  \"user-controlled value\", dependencyLoc, moduleName",
        "description": "Recursively merging a user-controlled object into another object can allow an attacker to modify the built-in Object prototype, and possibly escalate to remote code execution or cross-site scripting.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-915/PrototypePollutingMergeCall.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.DynamicPropertyAccess\nprivate import semmle.javascript.dataflow.InferredTypes\n\n// WIN: gained TP in Lucifier/r.js:2757, though not sure why it wasn't flagged to start with.\nclass SplitCall extends StringSplitCall {\n  SplitCall() {\n    this.getSeparator() = \".\" and\n    this.getBaseString().getALocalSource() instanceof DataFlow::ParameterNode\n  }\n}\n\npredicate copyArrayStep(DataFlow::SourceNode pred, DataFlow::SourceNode succ) {\n  // x -> [...x]\n  exists(SpreadElement spread |\n    pred.flowsTo(spread.getOperand().flow()) and\n    succ.asExpr().(ArrayExpr).getAnElement() = spread\n  )\n  or\n  // `x -> y` in `y.push( x[i] )`\n  exists(DataFlow::MethodCallNode push |\n    push = succ.getAMethodCall(\"push\") and\n    (\n      getAnEnumeratedArrayElement(pred).flowsTo(push.getAnArgument())\n      or\n      pred.flowsTo(push.getASpreadArgument())\n    )\n  )\n  or\n  // x -> x.concat(...)\n  exists(DataFlow::MethodCallNode concat_ |\n    concat_.getMethodName() = \"concat\" and\n    (pred = concat_.getReceiver() or pred = concat_.getAnArgument()) and\n    succ = concat_\n  )\n}\n\npredicate isSplitArray(DataFlow::SourceNode node) {\n  node instanceof SplitCall\n  or\n  exists(DataFlow::SourceNode pred | isSplitArray(pred) |\n    copyArrayStep(pred, node)\n    or\n    pred.flowsToExpr(node.(DataFlow::CallNode).getACallee().getAReturnedExpr())\n  )\n}\n\nclass SplitPropName extends DataFlow::SourceNode {\n  DataFlow::SourceNode array;\n\n  SplitPropName() {\n    isSplitArray(array) and\n    this = getAnEnumeratedArrayElement(array)\n  }\n\n  /**\n   * Gets the array from which this property name was obtained (the result from `split`).\n   */\n  DataFlow::SourceNode getArray() { result = array }\n\n  /** Gets an element accessed on the same underlying array. */\n  SplitPropName getAnAlias() { result.getArray() = this.getArray() }\n}\n\npredicate arePropertiesEnumerated(DataFlow::SourceNode node) {\n  node = any(EnumeratedPropName name).getASourceObjectRef()\n}\n\npredicate isPollutedPropNameSource(DataFlow::Node node) {\n  node instanceof EnumeratedPropName\n  or\n  node instanceof SplitPropName\n}\n\npredicate isPollutedPropName(DataFlow::Node node) {\n  isPollutedPropNameSource(node)\n  or\n  exists(DataFlow::Node pred | isPollutedPropName(pred) |\n    node = pred.getASuccessor()\n    or\n    DataFlow::argumentPassingStep(_, pred, _, node)\n    or\n    // Handle one level of callbacks\n    exists(DataFlow::FunctionNode function, DataFlow::ParameterNode callback, int i |\n      pred = callback.getAnInvocation().getArgument(i) and\n      DataFlow::argumentPassingStep(_, function, _, callback) and\n      node = function.getParameter(i)\n    )\n  )\n}\n\npredicate isPotentiallyObjectPrototype(DataFlow::SourceNode node) {\n  exists(DataFlow::Node base, DataFlow::Node key |\n    dynamicPropReadStep(base, key, node) and\n    isPollutedPropName(key) and\n    // Ignore cases where the properties of `base` are enumerated, to avoid FPs\n    // where the key came from that enumeration (and thus will not return Object.prototype).\n    // For example, `src[key]` in `for (let key in src) { ... src[key] ... }` will generally\n    // not return Object.prototype because `key` is an enumerable property of `src`.\n    not arePropertiesEnumerated(base.getALocalSource())\n  )\n  or\n  exists(DataFlow::Node use | isPotentiallyObjectPrototype(use.getALocalSource()) |\n    DataFlow::argumentPassingStep(_, use, _, node)\n  )\n}\n\npredicate dynamicPropWrite(DataFlow::Node base, DataFlow::Node prop, DataFlow::Node rhs) {\n  exists(\n    DataFlow::PropWrite write // includes e.g. Object.defineProperty\n  |\n    write.getBase() = base and\n    write.getPropertyNameExpr().flow() = prop and\n    rhs = write.getRhs()\n  ) and\n  not exists(prop.getStringValue()) and\n  not arePropertiesEnumerated(base.getALocalSource()) and\n  // Prune writes that are unlikely to modify Object.prototype.\n  // This is mainly for performance, but may block certain results due to\n  // not tracking out of function returns and into callbacks.\n  isPotentiallyObjectPrototype(base.getALocalSource()) and\n  // Ignore writes with an obviously safe RHS.\n  not exists(Expr e | e = rhs.asExpr() |\n    e instanceof Literal or\n    e instanceof ObjectExpr or\n    e instanceof ArrayExpr\n  )\n}\n\nstring unsafePropName() {\n  result = \"__proto__\"\n  or\n  result = \"constructor\"\n}\n\nmodule PropNameTrackingConfig implements DataFlow::StateConfigSig {\n  class FlowState extends string {\n    FlowState() { this = unsafePropName() }\n  }\n\n  predicate isSource(DataFlow::Node node, FlowState state) {\n    exists(state) and\n    (\n      isPollutedPropNameSource(node)\n      or\n      node = any(EnumeratedPropName prop).getASourceProp()\n    )\n  }\n\n  predicate isSink(DataFlow::Node node, FlowState state) {\n    exists(state) and\n    (\n      dynamicPropWrite(node, _, _) or\n      dynamicPropWrite(_, node, _) or\n      dynamicPropWrite(_, _, node)\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node, FlowState state) {\n    node = DataFlow::MakeStateBarrierGuard<FlowState, BarrierGuard>::getABarrierNode(state)\n  }\n\n  predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {\n    // Step through `p -> x[p]`\n    exists(DataFlow::PropRead read |\n      node1 = read.getPropertyNameExpr().flow() and\n      not read.(DynamicPropRead).hasDominatingAssignment() and\n      node2 = read\n    )\n    or\n    // Step through `x -> x[p]`\n    exists(DynamicPropRead read |\n      not read.hasDominatingAssignment() and\n      node1 = read.getBase() and\n      node2 = read\n    )\n  }\n\n  predicate isBarrier(DataFlow::Node node) {\n    node instanceof DataFlow::VarAccessBarrier or\n    node = DataFlow::MakeBarrierGuard<BarrierGuard>::getABarrierNode()\n  }\n\n  int accessPathLimit() {\n    // Speed up the query. For the pattern we're looking for the value rarely\n    // flows through any contents, apart from a capture content.\n    result = 1\n  }\n\n  predicate observeDiffInformedIncrementalMode() {\n    none() // Disabled since the alert references some locations other than the source or sink\n  }\n}\n\nclass FlowState = PropNameTrackingConfig::FlowState;\n\nmodule PropNameTracking = DataFlow::GlobalWithState<PropNameTrackingConfig>;\n\nabstract class BarrierGuard extends DataFlow::Node {\n  /**\n   * Holds if this node acts as a barrier for data flow, blocking further flow from `e` if `this` evaluates to `outcome`.\n   */\n  predicate blocksExpr(boolean outcome, Expr e) { none() }\n\n  /**\n   * Holds if this node acts as a barrier for `state`, blocking further flow from `e` if `this` evaluates to `outcome`.\n   */\n  predicate blocksExpr(boolean outcome, Expr e, FlowState state) { none() }\n}\n\nclass DenyListEqualityGuard extends BarrierGuard, DataFlow::ValueNode {\n  override EqualityTest astNode;\n  string propName;\n\n  DenyListEqualityGuard() {\n    astNode.getAnOperand().getStringValue() = propName and\n    propName = unsafePropName()\n  }\n\n  override predicate blocksExpr(boolean outcome, Expr e, FlowState state) {\n    e = astNode.getAnOperand() and\n    outcome = astNode.getPolarity().booleanNot() and\n    state = propName\n  }\n}\n\nclass AllowListEqualityGuard extends BarrierGuard, DataFlow::ValueNode {\n  override EqualityTest astNode;\n\n  AllowListEqualityGuard() {\n    not astNode.getAnOperand().getStringValue() = unsafePropName() and\n    astNode.getAnOperand() instanceof Literal\n  }\n\n  override predicate blocksExpr(boolean outcome, Expr e) {\n    e = astNode.getAnOperand() and\n    outcome = astNode.getPolarity()\n  }\n}\n\nclass HasOwnPropertyGuard extends BarrierGuard instanceof HasOwnPropertyCall {\n  HasOwnPropertyGuard() {\n    // Try to avoid `src.hasOwnProperty` by requiring that the receiver\n    // does not locally have its properties enumerated. Typically there is no\n    // reason to enumerate the properties of the destination object.\n    not arePropertiesEnumerated(super.getObject().getALocalSource())\n  }\n\n  override predicate blocksExpr(boolean outcome, Expr e) {\n    e = super.getProperty().asExpr() and outcome = true\n  }\n}\n\nclass InExprGuard extends BarrierGuard, DataFlow::ValueNode {\n  override InExpr astNode;\n\n  InExprGuard() {\n    // Exclude tests of form `key in src` for the same reason as in HasOwnPropertyGuard\n    not arePropertiesEnumerated(astNode.getRightOperand().flow().getALocalSource())\n  }\n\n  override predicate blocksExpr(boolean outcome, Expr e) {\n    e = astNode.getLeftOperand() and outcome = false\n  }\n}\n\nclass InstanceOfGuard extends BarrierGuard, DataFlow::ValueNode {\n  override InstanceOfExpr astNode;\n\n  override predicate blocksExpr(boolean outcome, Expr e, FlowState state) {\n    e = astNode.getLeftOperand() and outcome = true and state = \"__proto__\"\n  }\n}\n\nclass TypeofGuard extends BarrierGuard, DataFlow::ValueNode {\n  override EqualityTest astNode;\n  Expr operand;\n  TypeofTag tag;\n\n  TypeofGuard() { TaintTracking::isTypeofGuard(astNode, operand, tag) }\n\n  override predicate blocksExpr(boolean outcome, Expr e, FlowState state) {\n    e = operand and\n    outcome = astNode.getPolarity() and\n    (\n      tag = \"object\" and\n      state = \"constructor\"\n      or\n      tag = \"function\" and\n      state = \"__proto__\"\n    )\n    or\n    e = operand and\n    outcome = astNode.getPolarity().booleanNot() and\n    (\n      // If something is not an object, sanitize object, as both must end\n      // in non-function prototype object.\n      tag = \"object\" and\n      exists(state)\n      or\n      tag = \"function\" and\n      state = \"constructor\"\n    )\n  }\n}\n\nclass DenyListInclusionGuard extends BarrierGuard, InclusionTest {\n  string blockedProp;\n\n  DenyListInclusionGuard() {\n    exists(DataFlow::ArrayCreationNode array |\n      array.getAnElement().getStringValue() = blockedProp and\n      array.flowsTo(this.getContainerNode())\n    )\n  }\n\n  override predicate blocksExpr(boolean outcome, Expr e, FlowState state) {\n    outcome = this.getPolarity().booleanNot() and\n    e = this.getContainedNode().asExpr() and\n    blockedProp = state\n  }\n}\n\nclass AllowListInclusionGuard extends BarrierGuard {\n  AllowListInclusionGuard() {\n    this instanceof TaintTracking::PositiveIndexOfSanitizer\n    or\n    this instanceof TaintTracking::MembershipTestSanitizer and\n    not this = any(MembershipCandidate::ObjectPropertyNameMembershipCandidate c).getTest() // handled with more precision in `HasOwnPropertyGuard`\n  }\n\n  override predicate blocksExpr(boolean outcome, Expr e) {\n    this.(TaintTracking::AdditionalBarrierGuard).blocksExpr(outcome, e)\n  }\n}\n\nclass IsPlainObjectGuard extends BarrierGuard, DataFlow::CallNode {\n  IsPlainObjectGuard() {\n    exists(string name | name = \"is-plain-object\" or name = \"is-extendable\" |\n      this = DataFlow::moduleImport(name).getACall()\n    )\n  }\n\n  override predicate blocksExpr(boolean outcome, Expr e, FlowState state) {\n    e = this.getArgument(0).asExpr() and\n    outcome = true and\n    state = \"constructor\"\n  }\n}\n\nstring getExprName(DataFlow::Node node) {\n  result = node.asExpr().(Identifier).getName()\n  or\n  result = node.asExpr().(DotExpr).getPropertyName()\n}\n\nstring deriveExprName(DataFlow::Node node) {\n  result = getExprName(node)\n  or\n  not exists(getExprName(node)) and\n  result = \"here\"\n}\n\npredicate isPrototypePollutingAssignment(\n  DataFlow::Node base, DataFlow::Node prop, DataFlow::Node rhs, DataFlow::Node propNameSource\n) {\n  dynamicPropWrite(base, prop, rhs) and\n  isPollutedPropNameSource(propNameSource) and\n  PropNameTracking::flow(propNameSource, base) and\n  if propNameSource instanceof EnumeratedPropName\n  then\n    PropNameTracking::flow(propNameSource, prop) and\n    PropNameTracking::flow([propNameSource, AccessPath::getAnAliasedSourceNode(propNameSource)]\n          .(EnumeratedPropName)\n          .getASourceProp(), rhs)\n  else (\n    PropNameTracking::flow(propNameSource.(SplitPropName).getAnAlias(), prop) and\n    rhs.getALocalSource() instanceof DataFlow::ParameterNode\n  )\n}\n\nprivate DataFlow::SourceNode getANodeLeadingToBase(DataFlow::TypeBackTracker t, DataFlow::Node base) {\n  t.start() and\n  isPrototypePollutingAssignment(base, _, _, _) and\n  result = base.getALocalSource()\n  or\n  exists(DataFlow::TypeBackTracker t2 | result = getANodeLeadingToBase(t2, base).backtrack(t2, t))\n}\n\nprivate DataFlow::SourceNode getANodeLeadingToBaseBase(\n  DataFlow::TypeBackTracker t, DataFlow::Node base\n) {\n  exists(DynamicPropRead read |\n    read = getANodeLeadingToBase(t, base) and\n    result = read.getBase().getALocalSource()\n  )\n  or\n  exists(DataFlow::TypeBackTracker t2 |\n    result = getANodeLeadingToBaseBase(t2, base).backtrack(t2, t)\n  )\n}\n\nDataFlow::SourceNode getANodeLeadingToBaseBase(DataFlow::Node base) {\n  result = getANodeLeadingToBaseBase(DataFlow::TypeBackTracker::end(), base)\n}\n\nclass ObjectCreateNullCall extends DataFlow::CallNode {\n  ObjectCreateNullCall() {\n    this = DataFlow::globalVarRef(\"Object\").getAMemberCall(\"create\") and\n    this.getArgument(0).asExpr() instanceof NullLiteral\n  }\n}\n\nimport DataFlow::DeduplicatePathGraph<PropNameTracking::PathNode, PropNameTracking::PathGraph>\n\nfrom\n  PathNode source, PathNode sink, DataFlow::Node propNameSource, DataFlow::Node base, string msg,\n  DataFlow::Node col1, DataFlow::Node col2\nwhere\n  isPollutedPropName(propNameSource) and\n  PropNameTracking::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode()) and\n  isPrototypePollutingAssignment(base, _, _, propNameSource) and\n  sink.getNode() = base and\n  source.getNode() = propNameSource and\n  (\n    getANodeLeadingToBaseBase(base) instanceof DataFlow::ObjectLiteralNode\n    or\n    not getANodeLeadingToBaseBase(base) instanceof ObjectCreateNullCall\n  ) and\n  // Generate different messages for deep merge and deep assign cases.\n  if propNameSource instanceof EnumeratedPropName\n  then (\n    col1 = propNameSource.(EnumeratedPropName).getSourceObject() and\n    col2 = base and\n    msg = \"Properties are copied from $@ to $@ without guarding against prototype pollution.\"\n  ) else (\n    col1 = propNameSource and\n    col2 = base and\n    msg =\n      \"The property chain $@ is recursively assigned to $@ without guarding against prototype pollution.\"\n  )\nselect base, source, sink, msg, col1, deriveExprName(col1), col2, deriveExprName(col2)",
        "description": "Functions recursively assigning properties on objects may be the cause of accidental modification of a built-in prototype object.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-915/PrototypePollutingFunction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.HttpToFileAccessQuery\nimport HttpToFileAccessFlow::PathGraph\n\nfrom HttpToFileAccessFlow::PathNode source, HttpToFileAccessFlow::PathNode sink\nwhere HttpToFileAccessFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Write to file system depends on $@.\", source.getNode(),\n  \"Untrusted data\"",
        "description": "Writing network data directly to the file system allows arbitrary file upload and might indicate a backdoor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-912/HttpToFileAccess.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.XmlBombQuery\nimport XmlBombFlow::PathGraph\n\nfrom XmlBombFlow::PathNode source, XmlBombFlow::PathNode sink\nwhere XmlBombFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against uncontrolled entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user input as an XML document with arbitrary internal entity expansion is vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-776/XmlBomb.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CleartextStorageQuery\nimport ClearTextStorageFlow::PathGraph\n\nfrom ClearTextStorageFlow::PathNode source, ClearTextStorageFlow::PathNode sink\nwhere ClearTextStorageFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This stores sensitive data returned by $@ as clear text.\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-312/CleartextStorage.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CleartextLoggingQuery\nimport CleartextLoggingFlow::PathGraph\n\npredicate inBrowserEnvironment(TopLevel tl) {\n  tl instanceof InlineScript\n  or\n  tl instanceof CodeInAttribute\n  or\n  exists(GlobalVarAccess e | e.getTopLevel() = tl | e.getName() = \"window\")\n  or\n  exists(Module m | inBrowserEnvironment(m) |\n    tl = m.getAnImportedModule() or\n    m = tl.(Module).getAnImportedModule()\n  )\n}\n\nfrom CleartextLoggingFlow::PathNode source, CleartextLoggingFlow::PathNode sink\nwhere\n  CleartextLoggingFlow::flowPath(source, sink) and\n  // ignore logging to the browser console (even though it is not a good practice)\n  not inBrowserEnvironment(sink.getNode().asExpr().getTopLevel())\nselect sink.getNode(), source, sink, \"This logs sensitive data returned by $@ as clear text.\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-312/CleartextLogging.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.BuildArtifactLeakQuery\nimport BuildArtifactLeakFlow::PathGraph\n\nfrom BuildArtifactLeakFlow::PathNode source, BuildArtifactLeakFlow::PathNode sink\nwhere BuildArtifactLeakFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This creates a build artifact that depends on $@.\",\n  source.getNode(),\n  \"sensitive data returned by\" + source.getNode().(CleartextLogging::Source).describe()",
        "description": "Including sensitive information in a build artifact can expose it to an attacker.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-312/BuildArtifactLeak.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnvalidatedDynamicMethodCallQuery\nimport DataFlow::DeduplicatePathGraph<UnvalidatedDynamicMethodCallFlow::PathNode, UnvalidatedDynamicMethodCallFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere\n  UnvalidatedDynamicMethodCallFlow::flowPath(source.getAnOriginalPathNode(),\n    sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink,\n  \"Invocation of method with $@ name may dispatch to unexpected target and cause an exception.\",\n  source.getNode(), \"user-controlled\"",
        "description": "Calling a method with a user-controlled name may dispatch to an unexpected target, which could cause an exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-754/UnvalidatedDynamicMethodCall.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.HardcodedCredentialsQuery\nimport HardcodedCredentials::PathGraph\n\nbindingset[s]\npredicate looksLikeATemplate(string s) { s.regexpMatch(\".*((\\\\{\\\\{.*\\\\}\\\\})|(<.*>)|(\\\\(.*\\\\))).*\") }\n\nfrom HardcodedCredentials::PathNode source, HardcodedCredentials::PathNode sink, string value\nwhere\n  HardcodedCredentials::flowPath(source, sink) and\n  // use source value in message if it's available\n  if source.getNode().asExpr() instanceof ConstantString\n  then\n    exists(string val | val = source.getNode().getStringValue() |\n      // exclude dummy passwords and templates\n      not (\n        sink.getNode().(Sink).(DefaultCredentialsSink).getKind() =\n          [\"password\", \"credentials\", \"token\", \"key\"] and\n        PasswordHeuristics::isDummyPassword(val)\n        or\n        sink.getNode().(Sink).getKind() = \"authorization header\" and\n        PasswordHeuristics::isDummyAuthHeader(val)\n        or\n        looksLikeATemplate(val)\n      ) and\n      value = \"The hard-coded value \\\"\" + val + \"\\\"\"\n    )\n  else value = \"This hard-coded value\"\nselect source.getNode(), source, sink, value + \" is used as $@.\", sink.getNode(),\n  sink.getNode().(Sink).getKind()",
        "description": "Hard-coding credentials in source code may enable an attacker to gain unauthorized access.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-798/HardcodedCredentials.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.TaintedFormatStringQuery\nimport TaintedFormatStringFlow::PathGraph\n\nfrom TaintedFormatStringFlow::PathNode source, TaintedFormatStringFlow::PathNode sink\nwhere TaintedFormatStringFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Format string depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using external input in format strings can lead to garbled output.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-134/TaintedFormatString.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nstring cookieProperty() { result = \"session\" or result = \"cookies\" or result = \"user\" }\n\npredicate isRouteHandlerUsingCookies(Routing::RouteHandler handler) {\n  exists(DataFlow::PropRef value |\n    value = handler.getAParameter().ref().getAPropertyRead(cookieProperty()).getAPropertyReference() and\n    // Ignore accesses to values that are part of a CSRF or captcha check\n    not value.getPropertyName().regexpMatch(\"(?i).*(csrf|xsrf|captcha).*\") and\n    // Ignore calls like `req.session.save()`\n    not value = any(DataFlow::InvokeNode call).getCalleeNode()\n  )\n}\n\npredicate hasCookieMiddleware(Routing::Node route, Http::CookieMiddlewareInstance cookie) {\n  route.isGuardedBy(cookie)\n}\n\nDataFlow::SourceNode csrfMiddlewareCreation() {\n  exists(DataFlow::SourceNode callee | result = callee.getACall() |\n    callee = DataFlow::moduleImport([\"csurf\", \"tiny-csrf\"])\n    or\n    callee = DataFlow::moduleImport(\"lusca\") and\n    exists(result.(DataFlow::CallNode).getOptionArgument(0, \"csrf\"))\n    or\n    callee = DataFlow::moduleMember(\"lusca\", \"csrf\")\n    or\n    callee = DataFlow::moduleMember(\"express\", \"csrf\")\n  )\n  or\n  // Note: the 'fastify-csrf' plugin enables the 'fastify.csrfProtection' middleware to be installed.\n  // Simply having the plugin registered is not enough, so we look for the 'csrfProtection' middleware.\n  result = Fastify::server().getAPropertyRead(\"csrfProtection\")\n}\n\npragma[nomagic]\nprivate predicate isCsrfProperty(DataFlow::PropRef ref) {\n  ref.getPropertyName().regexpMatch(\"(?i).*(csrf|xsrf).*\")\n}\n\nprivate DataFlow::SourceNode nodeLeadingToCsrfWriteOrCheck(DataFlow::TypeBackTracker t) {\n  t.start() and\n  exists(DataFlow::PropRef ref |\n    ref = result.getAPropertyRead(cookieProperty()).getAPropertyReference()\n  |\n    // Assignment to property with csrf/xsrf in the name\n    ref instanceof DataFlow::PropWrite and\n    isCsrfProperty(ref)\n    or\n    // Comparison where one of the properties has csrf/xsrf in the name\n    exists(EqualityTest test |\n      test.getAnOperand().flow().getALocalSource() = ref and\n      isCsrfProperty(test.getAnOperand().flow().getALocalSource())\n    )\n    or\n    // Comparison via a call, where one of the properties has csrf/xsrf in the name\n    exists(DataFlow::CallNode call |\n      call.getCalleeName().regexpMatch(\"(?i).*(check|verify|valid|equal).*\") and\n      call.getAnArgument().getALocalSource() = ref and\n      isCsrfProperty(call.getAnArgument().getALocalSource())\n    )\n  )\n  or\n  exists(DataFlow::TypeBackTracker t2 | result = nodeLeadingToCsrfWriteOrCheck(t2).backtrack(t2, t))\n}\n\nprivate Routing::RouteHandler getAHandlerSettingCsrfCookie() {\n  exists(Http::CookieDefinition setCookie |\n    setCookie.getNameArgument().getStringValue().regexpMatch(\"(?i).*(csrf|xsrf).*\") and\n    result = Routing::getRouteHandler(setCookie.getRouteHandler())\n  )\n}\n\npredicate isCsrfProtectionRouteHandler(Routing::RouteHandler handler) {\n  handler.getAParameter() = nodeLeadingToCsrfWriteOrCheck(DataFlow::TypeBackTracker::end())\n  or\n  handler = getAHandlerSettingCsrfCookie()\n}\n\nAPI::CallNode passportAuthenticateCall() {\n  result = API::moduleImport(\"passport\").getMember(\"authenticate\").getACall()\n}\n\nAPI::CallNode nonSessionBasedAuthMiddleware() {\n  result = passportAuthenticateCall() and\n  result.getParameter(1).getMember(\"session\").asSink().mayHaveBooleanValue(false)\n}\n\nAPI::CallNode authMiddlewareImmuneToCsrf() {\n  result = passportAuthenticateCall() and\n  // The local strategy does not provide its own CSRF protection\n  not result.getArgument(0).getStringValue() = \"local\"\n}\n\nRouting::Node getACsrfMiddleware() {\n  result = Routing::getNode(csrfMiddlewareCreation())\n  or\n  result = Routing::getNode(nonSessionBasedAuthMiddleware())\n  or\n  isCsrfProtectionRouteHandler(result)\n}\n\npredicate hasCsrfMiddleware(Routing::RouteHandler handler) {\n  handler.isGuardedByNode(getACsrfMiddleware())\n}\n\nfrom\n  Routing::RouteSetup setup, Routing::Node setupArg, Routing::RouteHandler handler,\n  Http::CookieMiddlewareInstance cookie\nwhere\n  // Require that the handler uses cookies and has cookie middleware.\n  //\n  // In practice, handlers that use cookies always have the cookie middleware or\n  // the handler wouldn't work. However, if we can't find the cookie middleware, it\n  // indicates that our middleware model is too incomplete, so in that case we\n  // don't trust it to detect the presence of CSRF middleware either.\n  setup.getAChild() = setupArg and\n  setupArg.getAChild*() = handler and\n  isRouteHandlerUsingCookies(handler) and\n  hasCookieMiddleware(handler, cookie) and\n  // Only flag the cookie parser registered first.\n  not hasCookieMiddleware(Routing::getNode(cookie), _) and\n  not hasCsrfMiddleware(handler) and\n  // Sometimes the CSRF protection comes later in the same route setup.\n  not setup.getAChild*() = getACsrfMiddleware() and\n  // Ignore auth routes that are immune to Login CSRF\n  not handler.getAChild*() = Routing::getNode(authMiddlewareImmuneToCsrf()) and\n  // Only warn for dangerous handlers, such as for POST and PUT.\n  setup.getOwnHttpMethod().isUnsafe()\nselect cookie, \"This cookie middleware is serving a $@ without CSRF protection.\", setupArg,\n  \"request handler\"",
        "description": "Using cookies without CSRF protection may allow malicious websites to submit requests on behalf of the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-352/MissingCsrfMiddleware.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.InsecureRandomnessQuery\nimport InsecureRandomnessFlow::PathGraph\n\nfrom InsecureRandomnessFlow::PathNode source, InsecureRandomnessFlow::PathNode sink\nwhere InsecureRandomnessFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"This uses a cryptographically insecure random number generated at $@ in a security context.\",\n  source.getNode(), source.getNode().toString()",
        "description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-338/InsecureRandomness.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom PackageJson pack, JsonString val\nwhere\n  [pack.getDependencies(), pack.getDevDependencies()].getPropValue(_) = val and\n  val.getValue().regexpMatch(\"(http|ftp)://.*\")\nselect val, \"Dependency downloaded using unencrypted communication channel.\"",
        "description": "Using unencrypted protocols to fetch dependencies can leave an application open to man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-300/InsecureDependencyResolution.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnsafeDeserializationQuery\nimport UnsafeDeserializationFlow::PathGraph\n\nfrom UnsafeDeserializationFlow::PathNode source, UnsafeDeserializationFlow::PathNode sink\nwhere UnsafeDeserializationFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Unsafe deserialization depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-502/UnsafeDeserialization.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.RegExpInjectionQuery\nimport RegExpInjectionFlow::PathGraph\n\nfrom RegExpInjectionFlow::PathNode source, RegExpInjectionFlow::PathNode sink\nwhere RegExpInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"This regular expression is constructed from a $@.\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "User input should not be used in regular expressions without first being escaped, otherwise a malicious user may be able to inject an expression that could require exponential time on certain inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-730/RegExpInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nFunction invokesCallbackThatThrowsUncaughtException(\n  AsyncSentinelCall async, LikelyExceptionThrower thrower\n) {\n  async.getAsyncCallee() = throwsUncaughtExceptionInAsyncContext(thrower) and\n  result = async.getEnclosingFunction()\n  or\n  exists(DataFlow::InvokeNode invk, Function fun |\n    fun = invokesCallbackThatThrowsUncaughtException(async, thrower) and\n    // purposely not checking for `getEnclosingTryCatchStmt`. An async callback called from inside a try-catch can still crash the server.\n    result = invk.getEnclosingFunction()\n  |\n    invk.getACallee() = fun\n    or\n    // traverse a slightly extended call graph to get additional TPs\n    invk.(AsyncSentinelCall).getAsyncCallee() = fun\n  )\n}\n\nFunction getUncaughtExceptionRethrowerCallee(DataFlow::InvokeNode invk) {\n  not exists(invk.asExpr().getEnclosingStmt().getEnclosingTryCatchStmt()) and\n  result = invk.getACallee()\n}\n\npredicate isUncaughtExceptionThrower(LikelyExceptionThrower thrower) {\n  not exists([thrower.(Expr).getEnclosingStmt(), thrower.(Stmt)].getEnclosingTryCatchStmt())\n}\n\nFunction throwsUncaughtExceptionInAsyncContext(LikelyExceptionThrower thrower) {\n  (\n    isUncaughtExceptionThrower(thrower) and\n    result = thrower.getContainer()\n    or\n    exists(DataFlow::InvokeNode invk |\n      getUncaughtExceptionRethrowerCallee(invk) = throwsUncaughtExceptionInAsyncContext(thrower) and\n      result = invk.getEnclosingFunction()\n    )\n  ) and\n  // Anti-case:\n  // An exception from an `async` function results in a rejected promise.\n  // Unhandled promises requires `node --unhandled-rejections=strict ...` to terminate the process\n  // without that flag, the DEP0018 deprecation warning is printed instead (node.js version 14 and below)\n  not result.isAsync() and\n  // pruning optimization since this predicate always is related to `invokesCallbackThatThrowsUncaughtException`\n  result = reachableFromAsyncCallback()\n}\n\nFunction reachableFromAsyncCallback() {\n  result instanceof AsyncCallback\n  or\n  exists(DataFlow::InvokeNode invk |\n    invk.getEnclosingFunction() = reachableFromAsyncCallback() and\n    result = invk.getACallee()\n  )\n}\n\npredicate main(\n  Http::RouteHandler rh, AsyncSentinelCall async, AsyncCallback cb, LikelyExceptionThrower thrower\n) {\n  async.getAsyncCallee() = cb and\n  rh.getAstNode() = invokesCallbackThatThrowsUncaughtException(async, thrower)\n}\n\nclass AsyncSentinelCall extends DataFlow::CallNode {\n  Function asyncCallee;\n\n  AsyncSentinelCall() {\n    exists(DataFlow::FunctionNode node | node.getAstNode() = asyncCallee |\n      // manual models\n      exists(string memberName |\n        not memberName.matches(\"%Sync\") and\n        this = NodeJSLib::FS::moduleMember(memberName).getACall() and\n        node = this.getCallback([1 .. 2])\n      )\n      // (add additional cases here to improve the query)\n    )\n  }\n\n  /**\n   * Gets the callee that is invoked in an asynchronous context.\n   */\n  Function getAsyncCallee() { result = asyncCallee }\n}\n\nclass AsyncCallback extends Function {\n  AsyncCallback() { any(AsyncSentinelCall c).getAsyncCallee() = this }\n}\n\nabstract class LikelyExceptionThrower extends AstNode { }\n\nclass TrivialThrowStatement extends LikelyExceptionThrower, ThrowStmt { }\n\nclass CompilerConfusingExceptionThrower extends LikelyExceptionThrower {\n  CompilerConfusingExceptionThrower() { none() }\n}\n\nquery predicate edges(AstNode pred, AstNode succ) {\n  exists(LikelyExceptionThrower thrower | main(_, _, _, thrower) |\n    pred = thrower and\n    succ = thrower.getContainer()\n    or\n    exists(DataFlow::InvokeNode invk, Function fun |\n      fun = throwsUncaughtExceptionInAsyncContext(thrower)\n    |\n      succ = invk.getAstNode() and\n      pred = invk.getACallee() and\n      pred = fun\n      or\n      succ = fun and\n      succ = invk.getContainer() and\n      pred = invk.getAstNode()\n    )\n  )\n}\n\nquery predicate nodes(AstNode node) {\n  edges(node, _) or\n  edges(_, node)\n}\n\nfrom\n  Http::RouteHandler rh, AsyncSentinelCall async, DataFlow::Node callbackArg, AsyncCallback cb,\n  ExprOrStmt crasher\nwhere\n  main(rh, async, cb, crasher) and\n  callbackArg.getALocalSource().getAstNode() = cb and\n  async.getAnArgument() = callbackArg\nselect crasher, crasher, cb,\n  \"The server of $@ will terminate when an uncaught exception from this location escapes an $@.\",\n  rh, \"this route handler\", callbackArg, \"asynchronous callback\"",
        "description": "A server that can be forced to crash may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-730/ServerCrash.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom CookieWrites::CookieWrite cookie\nwhere\n  cookie.isSensitive() and\n  cookie.isServerSide() and\n  not cookie.isHttpOnly()\nselect cookie, \"Sensitive server cookie is missing 'httpOnly' flag.\"",
        "description": "Sensitive cookies set by a server can be read by the client if the `httpOnly` flag is not set.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-1004/ClientExposedCookie.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ZipSlipQuery\nimport DataFlow::DeduplicatePathGraph<ZipSlipFlow::PathNode, ZipSlipFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere ZipSlipFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect source.getNode(), source, sink,\n  \"Unsanitized archive entry, which may contain '..', is used in a $@.\", sink.getNode(),\n  \"file system operation\"",
        "description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-022/ZipSlip.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.TaintedPathQuery\nimport DataFlow::DeduplicatePathGraph<TaintedPathFlow::PathNode, TaintedPathFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere TaintedPathFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink, \"This path depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-022/TaintedPath.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.TypeConfusionThroughParameterTamperingQuery\nimport TypeConfusionFlow::PathGraph\n\nfrom TypeConfusionFlow::PathNode source, TypeConfusionFlow::PathNode sink\nwhere TypeConfusionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"Potential type confusion as $@ may be either an array or a string.\", source.getNode(),\n  \"this HTTP request parameter\"",
        "description": "Sanitizing an HTTP request parameter may be ineffective if the user controls its type.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-843/TypeConfusionThroughParameterTampering.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.XxeQuery\nimport XxeFlow::PathGraph\n\nfrom XxeFlow::PathNode source, XxeFlow::PathNode sink\nwhere XxeFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink,\n  \"XML parsing depends on a $@ without guarding against external entity expansion.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Parsing user input as an XML document with external entity expansion is vulnerable to XXE attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-611/Xxe.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.UselessUseOfCat\nimport semmle.javascript.RestrictedLocations\n\nfrom UselessCat cat, string message\nwhere\n  message = \" Can be replaced with: \" + PrettyPrintCatCall::createReadFileCall(cat)\n  or\n  not exists(PrettyPrintCatCall::createReadFileCall(cat)) and\n  if cat.isSync()\n  then message = \" Can be replaced with a call to fs.readFileSync(..).\"\n  else message = \" Can be replaced with a call to fs.readFile(..).\"\nselect cat.asExpr().(FirstLineOf), \"Unnecessary use of `cat` process.\" + message",
        "description": "Using the  `cat` process to read a file is unnecessarily complex, inefficient, unportable, and can lead to subtle bugs, or even security vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-078/UselessUseOfCat.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.CommandInjectionQuery\nimport CommandInjectionFlow::PathGraph\n\nfrom\n  CommandInjectionFlow::PathNode source, CommandInjectionFlow::PathNode sink,\n  DataFlow::Node highlight, Source sourceNode\nwhere\n  CommandInjectionFlow::flowPath(source, sink) and\n  (\n    if isSinkWithHighlight(sink.getNode(), _)\n    then isSinkWithHighlight(sink.getNode(), highlight)\n    else highlight = sink.getNode()\n  ) and\n  sourceNode = source.getNode()\nselect highlight, source, sink, \"This command line depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-078/CommandInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnsafeShellCommandConstructionQuery\nimport UnsafeShellCommandConstructionFlow::PathGraph\n\nfrom\n  UnsafeShellCommandConstructionFlow::PathNode source,\n  UnsafeShellCommandConstructionFlow::PathNode sink, Sink sinkNode\nwhere UnsafeShellCommandConstructionFlow::flowPath(source, sink) and sinkNode = sink.getNode()\nselect sinkNode.getAlertLocation(), source, sink,\n  \"This \" + sinkNode.getSinkType() + \" which depends on $@ is later used in a $@.\",\n  source.getNode(), \"library input\", sinkNode.getCommandExecution(), \"shell command\"",
        "description": "Using externally controlled strings in a command line may allow a malicious user to change the meaning of the command.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-078/UnsafeShellCommandConstruction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.SecondOrderCommandInjectionQuery\nimport DataFlow::DeduplicatePathGraph<SecondOrderCommandInjectionFlow::PathNode, SecondOrderCommandInjectionFlow::PathGraph>\n\nfrom PathNode source, PathNode sink, Sink sinkNode\nwhere\n  SecondOrderCommandInjectionFlow::flowPath(source.getAnOriginalPathNode(),\n    sink.getAnOriginalPathNode()) and\n  sinkNode = sink.getNode()\nselect sink.getNode(), source, sink,\n  \"Command line argument that depends on $@ can execute an arbitrary command if \" +\n    sinkNode.getVulnerableArgumentExample() + \" is used with \" + sinkNode.getCommand() + \".\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "Using user-controlled data as arguments to some commands, such as git clone, can allow arbitrary commands to be executed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-078/SecondOrderCommandInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ShellCommandInjectionFromEnvironmentQuery\nimport ShellCommandInjectionFromEnvironmentFlow::PathGraph\n\nfrom\n  ShellCommandInjectionFromEnvironmentFlow::PathNode source,\n  ShellCommandInjectionFromEnvironmentFlow::PathNode sink, DataFlow::Node highlight,\n  Source sourceNode\nwhere\n  sourceNode = source.getNode() and\n  ShellCommandInjectionFromEnvironmentFlow::flowPath(source, sink) and\n  if ShellCommandInjectionFromEnvironmentConfig::isSinkWithHighlight(sink.getNode(), _)\n  then ShellCommandInjectionFromEnvironmentConfig::isSinkWithHighlight(sink.getNode(), highlight)\n  else highlight = sink.getNode()\nselect highlight, source, sink, \"This shell command depends on an uncontrolled $@.\", sourceNode,\n  sourceNode.getSourceType()",
        "description": "Building a shell command string with values from the enclosing environment may cause subtle bugs or vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-078/ShellCommandInjectionFromEnvironment.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.IndirectCommandInjectionQuery\nimport IndirectCommandInjectionFlow::PathGraph\n\nfrom\n  IndirectCommandInjectionFlow::PathNode source, IndirectCommandInjectionFlow::PathNode sink,\n  DataFlow::Node highlight\nwhere\n  IndirectCommandInjectionFlow::flowPath(source, sink) and\n  if IndirectCommandInjectionConfig::isSinkWithHighlight(sink.getNode(), _)\n  then IndirectCommandInjectionConfig::isSinkWithHighlight(sink.getNode(), highlight)\n  else highlight = sink.getNode()\nselect highlight, source, sink, \"This command depends on an unsanitized $@.\", source.getNode(),\n  source.getNode().(Source).describe()",
        "description": "Forwarding command-line arguments to a child process executed within a shell may indirectly introduce command-line injection vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-078/IndirectCommandInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.XpathInjectionQuery\nimport XpathInjectionFlow::PathGraph\n\nfrom XpathInjectionFlow::PathNode source, XpathInjectionFlow::PathNode sink\nwhere XpathInjectionFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"XPath expression depends on a $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-643/XpathInjection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.InsecureDownloadQuery\nimport DataFlow::DeduplicatePathGraph<InsecureDownloadFlow::PathNode, InsecureDownloadFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere InsecureDownloadFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink, \"$@ of sensitive file from $@.\",\n  sink.getNode().(Sink).getDownloadCall(), \"Download\", source.getNode(), \"HTTP source\"",
        "description": "Downloading executables and other sensitive files over an insecure connection opens up for potential man-in-the-middle attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-829/InsecureDownload.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ReflectedXssQuery\nimport ReflectedXssFlow::PathGraph\n\nfrom ReflectedXssFlow::PathNode source, ReflectedXssFlow::PathNode sink\nwhere ReflectedXssFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Cross-site scripting vulnerability due to a $@.\",\n  source.getNode(), \"user-provided value\"",
        "description": "Writing user input directly to an HTTP response allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-079/ReflectedXss.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.XssThroughDomQuery\nimport XssThroughDomFlow::PathGraph\n\nfrom XssThroughDomFlow::PathNode source, XssThroughDomFlow::PathNode sink\nwhere\n  XssThroughDomFlow::flowPath(source, sink) and\n  not isIgnoredSourceSinkPair(source.getNode(), sink.getNode())\nselect sink.getNode(), source, sink,\n  \"$@ is reinterpreted as HTML without escaping meta-characters.\", source.getNode(), \"DOM text\"",
        "description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-079/XssThroughDom.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnsafeJQueryPluginQuery\nimport UnsafeJQueryPluginFlow::PathGraph\n\nfrom\n  UnsafeJQueryPluginFlow::PathNode source, UnsafeJQueryPluginFlow::PathNode sink,\n  JQuery::JQueryPluginMethod plugin\nwhere\n  UnsafeJQueryPluginFlow::flowPath(source, sink) and\n  source.getNode().(Source).getPlugin() = plugin\nselect sink.getNode(), source, sink, \"Potential XSS vulnerability in the $@.\", plugin,\n  \"'$.fn.\" + plugin.getPluginName() + \"' plugin\"",
        "description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-079/UnsafeJQueryPlugin.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.DomBasedXssQuery\nimport DataFlow::DeduplicatePathGraph<DomBasedXssFlow::PathNode, DomBasedXssFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere DomBasedXssFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink,\n  sink.getNode().(Sink).getVulnerabilityKind() + \" vulnerability due to $@.\", source.getNode(),\n  \"user-provided value\"",
        "description": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-079/Xss.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.ExceptionXssQuery\nimport DataFlow::DeduplicatePathGraph<ExceptionXssFlow::PathNode, ExceptionXssFlow::PathGraph>\n\nfrom PathNode source, PathNode sink\nwhere ExceptionXssFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode())\nselect sink.getNode(), source, sink,\n  \"$@ is reinterpreted as HTML without escaping meta-characters.\", source.getNode(),\n  source.getNode().(Source).getDescription()",
        "description": "Reinterpreting text from an exception as HTML can lead to a cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-079/ExceptionXss.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.UnsafeHtmlConstructionQuery\nimport DataFlow::DeduplicatePathGraph<UnsafeHtmlConstructionFlow::PathNode, UnsafeHtmlConstructionFlow::PathGraph>\n\nfrom PathNode source, PathNode sink, Sink sinkNode\nwhere\n  UnsafeHtmlConstructionFlow::flowPath(source.getAnOriginalPathNode(), sink.getAnOriginalPathNode()) and\n  sink.getNode() = sinkNode\nselect sinkNode, source, sink,\n  \"This \" + sinkNode.describe() + \" which depends on $@ might later allow $@.\", source.getNode(),\n  \"library input\", sinkNode.getSink(), sinkNode.getVulnerabilityKind().toLowerCase()",
        "description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-079/UnsafeHtmlConstruction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.dataflow.StoredXssQuery\nimport StoredXssFlow::PathGraph\n\nfrom StoredXssFlow::PathNode source, StoredXssFlow::PathNode sink\nwhere StoredXssFlow::flowPath(source, sink)\nselect sink.getNode(), source, sink, \"Stored cross-site scripting vulnerability due to $@.\",\n  source.getNode(), \"stored value\"",
        "description": "Using uncontrolled stored values in HTML allows for a stored cross-site scripting vulnerability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Security/CWE-079/StoredXss.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Vue::Component instance, DataFlow::Node def, DataFlow::FunctionNode arrow, ThisExpr dis\nwhere\n  instance.getABoundFunction() = def and\n  arrow.flowsTo(def) and\n  arrow.asExpr() instanceof ArrowFunctionExpr and\n  arrow.asExpr() = dis.getEnclosingFunction()\nselect def, \"The $@ of this $@ it will not be bound to the Vue instance.\", dis, \"`this` variable\",\n  arrow, \"arrow function\"",
        "description": "An arrow method on a Vue instance doesn't have its `this` variable bound to the Vue instance.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Vue/ArrowMethodOnVueInstance.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate exprWithoutEnclosingStmt(Expr e) {\n  // Function names, parameters, default values and bodies do not have an enclosing statement.\n  exists(Function f | e = f.getAChild()) or\n  exists(Parameter p | e = p.getDefault()) or\n  // Class members do not have enclosing statements.\n  exists(MemberDefinition md | e = md.getAChild()) or\n  // If an expression's parent has no enclosing statement, then neither does the expression itself.\n  exprWithoutEnclosingStmt(e.getParent()) or\n  // Some expressions have non-expression parents that we want to skip over.\n  exprWithoutEnclosingStmt(e.getParent().(Property).getObjectExpr()) or\n  exprWithoutEnclosingStmt(e.getParent().(PropertyPattern).getObjectPattern()) or\n  exprWithoutEnclosingStmt(e.getParent().(JsxAttribute).getElement())\n}\n\npredicate uniqueness_error(int number, string what, string problem) {\n  what =\n    [\n      \"toString\", \"getLocation\", \"getTopLevel\", \"getEnclosingStmt\", \"getContainer\",\n      \"getEnclosingContainer\", \"getEntry\", \"getExit\", \"getFirstControlFlowNode\", \"getOuterScope\",\n      \"getScopeElement\", \"getBaseName\", \"getOperator\", \"getTest\"\n    ] and\n  (\n    number = 0 and problem = \"no results for \" + what + \"()\"\n    or\n    number in [2 .. 10] and problem = number.toString() + \" results for \" + what + \"()\"\n  )\n}\n\npredicate ast_consistency(string clsname, string problem, string what) {\n  exists(Locatable l | clsname = l.getAQlClass() |\n    uniqueness_error(count(l.toString()), \"toString\", problem) and what = \"at \" + l.getLocation()\n    or\n    uniqueness_error(strictcount(l.getLocation()), \"getLocation\", problem) and\n    what = l.getLocation().toString()\n    or\n    not exists(l.getLocation()) and problem = \"no location\" and what = l.toString()\n  )\n  or\n  exists(AstNode nd | clsname = nd.getAQlClass() |\n    uniqueness_error(count(nd.getTopLevel()), \"getTopLevel\", problem) and\n    what = \"at \" + nd.getLocation()\n  )\n  or\n  exists(Expr e | clsname = e.getAQlClass() |\n    uniqueness_error(count(e.getContainer()), \"getContainer\", problem) and\n    what = \"at \" + e.getLocation()\n    or\n    not exprWithoutEnclosingStmt(e) and\n    uniqueness_error(count(e.getEnclosingStmt()), \"getEnclosingStmt\", problem) and\n    what = \"at \" + e.getLocation()\n  )\n  or\n  exists(Stmt s | clsname = s.getAQlClass() |\n    uniqueness_error(count(s.getContainer()), \"getContainer\", problem) and\n    what = \"at \" + s.getLocation()\n  )\n  or\n  exists(StmtContainer cont | not cont instanceof TopLevel and clsname = cont.getAQlClass() |\n    uniqueness_error(count(cont.getEnclosingContainer()), \"getEnclosingContainer\", problem) and\n    what = \"at \" + cont.getLocation()\n  )\n  or\n  exists(UnaryExpr ue | clsname = ue.getAQlClass() |\n    uniqueness_error(count(ue.getOperator()), \"getOperator\", problem) and\n    what = \"at \" + ue.getLocation()\n  )\n  or\n  exists(UpdateExpr ue | clsname = ue.getAQlClass() |\n    uniqueness_error(count(ue.getOperator()), \"getOperator\", problem) and\n    what = \"at \" + ue.getLocation()\n  )\n  or\n  exists(BinaryExpr be | clsname = be.getAQlClass() |\n    uniqueness_error(count(be.getOperator()), \"getOperator\", problem) and\n    what = \"at \" + be.getLocation()\n  )\n}\n\npredicate location_consistency(string clsname, string problem, string what) {\n  exists(Location l | clsname = l.getAQlClass() |\n    uniqueness_error(count(l.toString()), \"toString\", problem) and what = \"at \" + l\n    or\n    not exists(l.toString()) and problem = \"no toString\" and what = \"a location\"\n  )\n}\n\npredicate hasCfg(StmtContainer sc) { not exists(Error err | err.getFile() = sc.getFile()) }\n\npredicate cfg_consistency(string clsname, string problem, string what) {\n  exists(StmtContainer cont | clsname = cont.getAQlClass() and hasCfg(cont) |\n    uniqueness_error(count(cont.getEntry()), \"getEntry\", problem) and\n    what = \"at \" + cont.getLocation()\n    or\n    uniqueness_error(count(cont.getExit()), \"getExit\", problem) and\n    what = \"at \" + cont.getLocation()\n  )\n  or\n  exists(AstNode nd | clsname = nd.getAQlClass() and hasCfg(nd.getTopLevel()) |\n    uniqueness_error(count(nd.getFirstControlFlowNode()), \"getFirstControlFlowNode\", problem) and\n    what = \"at \" + nd.getLocation()\n  )\n}\n\npredicate scope_consistency(string clsname, string problem, string what) {\n  exists(Scope s | clsname = s.getAQlClass() |\n    uniqueness_error(count(s.toString()), \"toString\", problem) and what = \"a scope\"\n    or\n    not s instanceof GlobalScope and\n    (\n      uniqueness_error(count(s.getOuterScope()), \"getOuterScope\", problem) and what = s.toString()\n      or\n      uniqueness_error(count(s.getScopeElement()), \"getScopeElement\", problem) and\n      what = s.toString()\n    )\n  )\n  or\n  exists(int n | n = count(GlobalScope g) and n != 1 |\n    clsname = \"GlobalScope\" and what = \"\" and problem = n + \" instances\"\n  )\n}\n\npredicate jsdoc_consistency(string clsname, string problem, string what) {\n  exists(JSDocTypeExprParent jsdtep | clsname = jsdtep.getAQlClass() |\n    uniqueness_error(count(jsdtep.toString()), \"toString\", problem) and what = \"\"\n  )\n}\n\npredicate varref_consistency(string clsname, string problem, string what) {\n  exists(VarRef vr, int n | n = count(vr.getVariable()) and n != 1 |\n    clsname = vr.getAQlClass() and\n    what = vr.getName() and\n    problem = n + \" target variables instead of one\"\n  )\n}\n\nfrom string clsname, string problem, string what\nwhere\n  ast_consistency(clsname, problem, what) or\n  location_consistency(clsname, problem, what) or\n  scope_consistency(clsname, problem, what) or\n  cfg_consistency(clsname, problem, what) or\n  jsdoc_consistency(clsname, problem, what) or\n  varref_consistency(clsname, problem, what)\nselect clsname + \" \" + what + \" has \" + problem",
        "description": "If the snapshot database or the QL library violates an API contract described in the documentation, queries that rely on the contract may yield unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/Consistency.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.meta.ExtractionMetrics::ExtractionMetrics\n\nFileWithExtractionMetrics getACacheMember(string cacheFile) { cacheFile = result.getCacheFile() }\n\nFileWithExtractionMetrics getACacheHit(FileWithExtractionMetrics f) {\n  result = getACacheMember(f.getCacheFile()) and\n  result.isFromCache()\n}\n\nfrom FileWithExtractionMetrics fileWithMetrics, boolean fromCache\nwhere (if fileWithMetrics.isFromCache() then fromCache = true else fromCache = false)\nselect fileWithMetrics.getAbsolutePath() as file, fileWithMetrics.getCpuTime() as cpu_nano,\n  fileWithMetrics.getNumberOfLines() as lines,\n  count(Locatable n | n.getFile() = fileWithMetrics) as locatables,\n  count(TypeAnnotation n | n.getFile() = fileWithMetrics) as types,\n  fileWithMetrics.getLength() as length, fromCache as from_cache,\n  count(getACacheMember(fileWithMetrics.getCacheFile())) as cache_members,\n  count(getACacheHit(fileWithMetrics)) as cache_hits, fileWithMetrics.getCacheFile() as cache_file",
        "description": "Extraction metrics and related information for profiling the extraction of individual files.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/extraction-metrics/FileData.ql",
        "language": "javascript"
    },
    {
        "query": "import semmle.javascript.meta.ExtractionMetrics::ExtractionMetrics\n\nfrom PhaseName phaseName\nselect phaseName, Aggregated::getCpuTime(phaseName) as cpu_nano,\n  Aggregated::getWallclockTime(phaseName) as wallclock_nano",
        "description": "An overview of how time was spent during extraction",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/extraction-metrics/PhaseTimings.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.meta.ExtractionMetrics::ExtractionMetrics\n\nfrom File f, string cause\nwhere\n  not extraction_data(f, _, _, _) and cause = \"No extraction_data for this file\"\n  or\n  not extraction_time(f, _, _, _) and cause = \"No extraction_time for this file\"\nselect f, cause",
        "description": "A file missing extraction metrics is indicative of a faulty extractor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/extraction-metrics/MissingMetrics.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.MetaMetrics\n\nselect projectRoot(), count(API::Node pred, API::Node succ | pred.refersTo(succ))",
        "description": "The number of points-to edges in the API graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/ApiGraphs/ApiGraphPointsToEdges.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.MetaMetrics\n\nselect projectRoot(), count(any(API::Node nd).getAValueReachableFromSource())",
        "description": "The number of data-flow nodes corresponding to a use of an API-graph node.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/ApiGraphs/ApiGraphUseNodes.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.MetaMetrics\n\nselect projectRoot(), count(API::Node nd)",
        "description": "The number of nodes in the API graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/ApiGraphs/ApiGraphNodes.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.MetaMetrics\n\nselect projectRoot(), count(any(API::Node nd).asSink())",
        "description": "The number of data-flow nodes corresponding to a right-hand side of a definition of an API-graph node.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/ApiGraphs/ApiGraphRhsNodes.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.MetaMetrics\n\nselect projectRoot(),\n  count(API::Node pred, API::Label::ApiLabel lbl, API::Node succ | succ = pred.getASuccessor(lbl))",
        "description": "The number of edges (other than points-to edges) in the API graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/ApiGraphs/ApiGraphEdges.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), 100.0 * count(FunctionWithCallers f) / count(RelevantFunction f).(float)",
        "description": "The percentage of relevant functions for which a call site was found.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/CalledFunctionRatio.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\npredicate relevantStep(DataFlow::Node pred, DataFlow::Node succ) {\n  (\n    TaintTracking::sharedTaintStep(pred, succ)\n    or\n    DataFlow::SharedFlowStep::step(pred, succ)\n    or\n    DataFlow::SharedFlowStep::loadStep(pred, succ, _)\n    or\n    DataFlow::SharedFlowStep::storeStep(pred, succ, _)\n    or\n    DataFlow::SharedFlowStep::loadStoreStep(pred, succ, _, _)\n    or\n    DataFlow::SharedFlowStep::loadStoreStep(pred, succ, _)\n  ) and\n  not pred.getFile() instanceof IgnoredFile and\n  not succ.getFile() instanceof IgnoredFile\n}\n\nselect projectRoot(), count(DataFlow::Node pred, DataFlow::Node succ | relevantStep(pred, succ))",
        "description": "The number of default taint steps.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/TaintSteps.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nImport unresolvableImport() { not exists(result.getImportedModule()) }\n\nselect projectRoot(), count(unresolvableImport())",
        "description": "The number of imports that could not be resolved to a module.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/UnresolvableImports.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), 100.0 * count(ResolvableCall call) / count(RelevantInvoke call).(float)",
        "description": "The percentage of non-external calls that can be resolved to a target.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/ResolvableCallRatio.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import Expressions.ExprHasNoEffect\nimport meta.internal.TaintMetrics\n\npredicate unmodeled(API::Node callee, API::CallNode call, DataFlow::Node pred, DataFlow::Node succ) {\n  callee.getACall() = call and\n  pred = call.getAnArgument() and\n  succ = call and\n  not inVoidContext(succ.asExpr()) and // void calls are irrelevant\n  not call.getAnArgument() = relevantTaintSink() and // calls with sinks are considered modeled\n  // we assume taint to the return value means the call is modeled\n  not (\n    TaintTracking::sharedTaintStep(_, succ)\n    or\n    DataFlow::SharedFlowStep::step(_, succ)\n    or\n    DataFlow::SharedFlowStep::loadStep(_, succ, _)\n    or\n    DataFlow::SharedFlowStep::storeStep(_, succ, _)\n    or\n    DataFlow::SharedFlowStep::loadStoreStep(_, succ, _, _)\n    or\n    DataFlow::SharedFlowStep::loadStoreStep(_, succ, _)\n  ) and\n  not pred.getFile() instanceof IgnoredFile and\n  not succ.getFile() instanceof IgnoredFile\n}\n\nselect projectRoot(), count(DataFlow::Node pred, DataFlow::Node succ | unmodeled(_, _, pred, succ))",
        "description": "A potential step from an argument to a return that has no data/taint step.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/UnmodelledSteps.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nHttp::RouteHandler relevantRouteHandler() { not result.getFile() instanceof IgnoredFile }\n\nselect projectRoot(), count(relevantRouteHandler())",
        "description": "The number of HTTP route handler functions found.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/RouteHandlers.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(DOM::domValueRef())",
        "description": "The number of references to a DOM value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/DomValueRefs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(Module mod)",
        "description": "The number of modules in the snapshot.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/NumModules.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(ResolvableCall call)",
        "description": "The number of calls that could be resolved to its target.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/ResolvableCalls.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nmodule BasicTaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node = relevantTaintSource() }\n\n  predicate isSink(DataFlow::Node node) { node = relevantSanitizerInput() }\n}\n\nmodule BasicTaintFlow = TaintTracking::Global<BasicTaintConfig>;\n\nselect projectRoot(), count(DataFlow::Node node | BasicTaintFlow::flowTo(node))",
        "description": "The number of sanitizers reachable from a recognized taint source.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/SanitizersReachableFromSource.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CandidateTracking\n\nfrom Http::RouteHandlerCandidate rh\nwhere\n  not rh instanceof Http::RouteHandler and\n  not exists(Http::RouteSetupCandidate setup |\n    track(rh, DataFlow::TypeTracker::end()).flowsTo(setup.getARouteHandlerArg())\n  )\nselect rh,\n  \"A `RouteHandlerCandidate` that did not get promoted to `RouteHandler`, and it is not used in a `RouteSetupCandidate`.\"",
        "description": "If a function that looks like a route handler is not detected as such, this may indicate incomplete library modeling.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/UnpromotedRouteHandlerCandidate.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(FunctionWithoutCallers f)",
        "description": "The number of functions for which no call site could be found.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/UncalledFunctions.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nImport relevantImport() { not result.getFile() instanceof IgnoredFile }\n\nselect projectRoot(),\n  count(Import imprt | imprt = relevantImport() and exists(imprt.getImportedModule()))",
        "description": "The number of imports that could be resolved to its target.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/ResolvableImports.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(FunctionWithCallers f)",
        "description": "The number of functions for which a call site was found.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/CalledFunctions.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(RelevantInvoke call)",
        "description": "The number of non-external calls in the program.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/ResolvableCallCandidates.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nselect projectRoot(), count(relevantTaintSink())",
        "description": "The number of high-severity taint sinks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/TaintSinks.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(UnresolvableCall call)",
        "description": "The number of calls that could not be resolved to a target.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/UnresolvableCalls.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nmodule BasicTaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node = relevantSanitizerOutput() }\n\n  predicate isSink(DataFlow::Node node) { node = relevantTaintSink() }\n}\n\nmodule BasicTaintFlow = TaintTracking::Global<BasicTaintConfig>;\n\nselect projectRoot(), count(DataFlow::Node node | BasicTaintFlow::flowTo(node))",
        "description": "The number of sinks reachable from a recognized sanitizer call.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/SinksReachableFromSanitizer.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nmodule BasicTaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node = relevantTaintSource() }\n\n  predicate isSink(DataFlow::Node node) {\n    // To reduce noise from synthetic nodes, only count value nodes\n    node instanceof DataFlow::ValueNode and\n    not node.getFile() instanceof IgnoredFile\n  }\n}\n\nmodule BasicTaintFlow = TaintTracking::Global<BasicTaintConfig>;\n\nselect projectRoot(), count(DataFlow::Node node | BasicTaintFlow::flowTo(node))",
        "description": "The number of expressions reachable from a remote flow source via default taint-tracking steps.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/TaintedNodes.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nselect projectRoot(), count(relevantTaintSource())",
        "description": "The number of remote flow sources and document.location sources",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/TaintSources.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CallGraphQuality\n\nselect projectRoot(), count(RelevantFunction f)",
        "description": "The number of functions for which finding call sites is relevant for analysis quality.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/CalledFunctionCandidates.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport CandidateTracking\n\nfrom Http::RouteSetupCandidate setup\nwhere\n  not setup instanceof Http::RouteSetup and\n  track(_, DataFlow::TypeTracker::end()).flowsTo(setup.getARouteHandlerArg())\nselect setup,\n  \"A `RouteSetupCandidate` that did not get promoted to `RouteSetup`, and it is using at least one `RouteHandlerCandidate`.\"",
        "description": "If a call that looks like a route setup is not detected as such, this may indicate incomplete library modeling.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/analysis-quality/UnpromotedRouteSetupCandidate.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nfrom ThreatModelSource node, string threatModel\nwhere\n  node = relevantTaintSource() and\n  threatModel = node.getThreatModel() and\n  threatModel != \"remote\" // \"remote\" is reported by TaintSources.ql\nselect node, getTaintSourceName(node) + \" (\\\"\" + threatModel + \"\\\" threat model)\"",
        "description": "Sources of possibly untrusted input that can be configured via threat models.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/alerts/ThreatModelSources.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Import imprt, Module target\nwhere target = imprt.getImportedModule()\nselect imprt, \"Import targeting $@\", target, target.getFile().getRelativePath()",
        "description": "An edge in the import graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/alerts/ImportGraph.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.PackageExports\n\nselect getALibraryInputParameter(), \"Library input\"",
        "description": "An input coming from the client of a library",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/alerts/LibraryInputs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DataFlow::Node invoke, Function f, string kind\nwhere\n  (\n    invoke.(DataFlow::InvokeNode).getACallee() = f and kind = \"Call\"\n    or\n    invoke.(DataFlow::PropRef).getAnAccessorCallee().getFunction() = f and kind = \"Accessor call\"\n  ) and\n  not f.getTopLevel().isExterns()\nselect invoke, kind + \" to $@\", f, f.describe()",
        "description": "An edge in the call graph.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/alerts/CallGraph.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nfrom string kind\nselect relevantTaintSink(kind), kind + \" sink\"",
        "description": "Sinks that are sensitive to untrusted data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/alerts/TaintSinks.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nmodule BasicTaintConfig implements DataFlow::ConfigSig {\n  predicate isSource(DataFlow::Node node) { node = relevantTaintSource() }\n\n  predicate isSink(DataFlow::Node node) {\n    // To reduce noise from synthetic nodes, only count value nodes\n    node instanceof DataFlow::ValueNode and\n    not node.getFile() instanceof IgnoredFile\n  }\n}\n\nmodule BasicTaintFlow = TaintTracking::Global<BasicTaintConfig>;\n\n// Avoid linking to the source as this would upset the statistics: nodes reachable\n// from multiple sources would be counted multiple times, and that's not what we intend to measure.\nfrom DataFlow::Node node\nwhere BasicTaintFlow::flowTo(node)\nselect node, \"Tainted node\"",
        "description": "The number of expressions reachable from a remote flow source via default taint-tracking steps.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/alerts/TaintedNodes.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nfrom ThreatModelSource node\nwhere node = relevantTaintSource() and node.getThreatModel() = \"remote\"\nselect node, getTaintSourceName(node)",
        "description": "Sources of untrusted input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/alerts/TaintSources.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom VarUse u, int n, SsaVariable v\nwhere\n  u.getVariable() instanceof SsaSourceVariable and\n  exists(ReachableBasicBlock bb | u = bb.getANode()) and\n  n = count(u.getSsaVariable()) and\n  n > 1 and\n  v = u.getSsaVariable()\nselect u, \"Variable use has \" + n + \" corresponding SSA variables: $@.\", v, v.toString()",
        "description": "Every reachable use of an SSA-convertible variable should correspond to exactly one SSA variable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/MultipleDefs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom SsaRefinementNode ref, int n, SsaDefinition input\nwhere\n  n = count(ref.getAnInput()) and\n  n > 1 and\n  input = ref.getAnInput()\nselect ref, \"Refinement node has \" + n + \" inputs: $@.\", input, input.toString()",
        "description": "Every SSA refinement node should have exactly one input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/MultipleRefinementInputs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom VarUse u\nwhere\n  u.getVariable() instanceof SsaSourceVariable and\n  exists(ReachableBasicBlock bb | u = bb.getANode()) and\n  not exists(u.getSsaVariable())\nselect u, \"Variable use has no corresponding SSA variable.\"",
        "description": "Every reachable use of an SSA-convertible variable should correspond to exactly one SSA variable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/NoDefs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate dominates(SsaDefinition def, VarUse use) {\n  exists(\n    SsaSourceVariable v, ReachableBasicBlock defbb, int defidx, ReachableBasicBlock usebb,\n    int useidx\n  |\n    def.definesAt(defbb, defidx, v) and usebb.useAt(useidx, v, use)\n  |\n    defbb = usebb and defidx <= useidx\n    or\n    defbb.strictlyDominates(usebb)\n  )\n}\n\nfrom VarUse u, SsaDefinition d\nwhere\n  u.getVariable() instanceof SsaSourceVariable and\n  exists(ReachableBasicBlock bb | u = bb.getANode()) and\n  u = d.getVariable().getAUse() and\n  not dominates(d, u)\nselect u, \"Variable use is not dominated by its definition $@.\", d, d.toString()",
        "description": "Every use of an SSA variable should be dominated by its definition.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/Dominance.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom SsaPhiNode phi\nwhere count(phi.getAnInput()) = 1\nselect phi, \"Phi node with exactly one input $@.\", phi.getAnInput(), phi.getAnInput().toString()",
        "description": "Every SSA phi node should have two or more inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/SinglePhiInput.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom SsaVariable d\nwhere\n  not exists(d.getAUse()) and\n  not d = any(SsaPseudoDefinition phi).getAnInput() and\n  d.getSourceVariable() instanceof PurelyLocalVariable\nselect d, \"Dead SSA definition \" + d + \".\"",
        "description": "Each SSA definition should have at least one use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/DeadDef.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom SsaRefinementNode ref\nwhere not exists(ref.getAnInput())\nselect ref, \"Refinement node without inputs.\"",
        "description": "Every SSA refinement node should have exactly one input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/NoRefinementInputs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom SsaPhiNode phi\nwhere not exists(phi.getAnInput())\nselect phi, \"Phi node without inputs.\"",
        "description": "Every SSA phi node should have two or more inputs.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/meta/SSA/NoPhiInputs.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom PropertySetter s, FunctionExpr f, SimpleParameter p\nwhere\n  f = s.getInit() and\n  p = f.getAParameter() and\n  not exists(p.getVariable().getAnAccess()) and\n  not f.usesArgumentsObject() and\n  // the setter body is either empty, or it is not just a single 'throw' statement\n  (\n    not exists(f.getABodyStmt())\n    or\n    exists(Stmt stmt | stmt = f.getABodyStmt() | not stmt instanceof ThrowStmt)\n  )\nselect s.(FirstLineOf), \"This setter function does not use its parameter $@.\", p, p.getName()",
        "description": "A setter function can silently ignore the new value that the property is meant to be set to, but this may result in unexpected behavior and could indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/SetterIgnoresParameter.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Comment c\nwhere c.getText().trim().matches(\"@cc\\\\_on%\")\nselect c, \"Do not use conditional comments.\"",
        "description": "Conditional comments are an IE-specific feature and not portable.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/ConditionalComments.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate isFixedArity(Function fn) {\n  not fn.usesArgumentsObject() and\n  not fn.hasRestParameter() and\n  not fn.(ExternalFunction).isVarArgs()\n}\n\nint maxArity(DataFlow::InvokeNode invk) {\n  forall(Function callee | callee = invk.getACallee() | isFixedArity(callee)) and\n  result = max(invk.getACallee().getNumParameter())\n}\n\nclass SpuriousArguments extends Expr {\n  DataFlow::InvokeNode invk;\n\n  SpuriousArguments() {\n    this = invk.getArgument(maxArity(invk)).asExpr() and\n    not invk.isIncomplete() and\n    not invk.getAstNode() instanceof TaggedTemplateExpr\n  }\n\n  /**\n   * Gets the call site at which the spurious arguments are passed.\n   */\n  DataFlow::InvokeNode getCall() { result = invk }\n\n  /**\n   * Gets the number of spurious arguments, that is, the number of\n   * actual arguments minus the maximum number of arguments\n   * expected by any potential callee.\n   */\n  int getCount() {\n    result = count(int i | exists(invk.getArgument(i)) and i >= maxArity(this.getCall()))\n  }\n\n  /**\n   * Holds if this element is at the specified location.\n   * The location spans column `startcolumn` of line `startline` to\n   * column `endcolumn` of line `endline` in file `filepath`.\n   * For more information, see\n   * [Locations](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    this.getLocation().hasLocationInfo(filepath, startline, startcolumn, _, _) and\n    exists(DataFlow::Node lastArg |\n      lastArg = max(DataFlow::Node arg, int i | arg = invk.getArgument(i) | arg order by i)\n    |\n      lastArg.hasLocationInfo(_, _, _, endline, endcolumn)\n    )\n  }\n}\n\nfrom SpuriousArguments args, Function f, string arguments\nwhere\n  f = args.getCall().getACallee() and\n  (if args.getCount() = 1 then arguments = \"argument\" else arguments = \"arguments\") and\n  (\n    // exclude empty functions, they are probably commented out debug utilities ...\n    exists(f.getABodyStmt()) or\n    // ... but include: constructors, arrows and externals/ambients\n    f instanceof Constructor or // unlikely to be a debug utility\n    f instanceof ArrowFunctionExpr or // cannot be empty\n    f instanceof ExternalFunction or // always empty\n    f.isAmbient() // always empty\n  ) and\n  not (\n    // exclude no-param functions that trivially throw exceptions, they are probably placeholders\n    f.getNumParameter() = 0 and\n    f.getBodyStmt(0) instanceof ThrowStmt\n  )\nselect args, \"Superfluous \" + arguments + \" passed to $@.\", f, f.describe()",
        "description": "A function is invoked with extra trailing arguments that are ignored.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/SpuriousArguments.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate calls(DataFlow::InvokeNode cs, Function callee, string how) {\n  callee = cs.getACallee() and\n  (\n    cs instanceof DataFlow::CallNode and\n    not cs.asExpr() instanceof SuperCall and\n    how = \"as a function\"\n    or\n    cs instanceof DataFlow::NewNode and\n    how = \"using 'new'\"\n  )\n}\n\npredicate illegalInvocation(DataFlow::InvokeNode cs, Function callee, string calleeDesc, string how) {\n  calls(cs, callee, how) and\n  (\n    how = \"as a function\" and\n    callee instanceof Constructor and\n    calleeDesc = \"a constructor\"\n    or\n    how = \"using 'new'\" and\n    callee.isNonConstructible(calleeDesc)\n  )\n}\n\npredicate isCallToFunction(DataFlow::InvokeNode ce) {\n  ce instanceof DataFlow::CallNode and\n  exists(Function f | f = ce.getACallee() | not f instanceof Constructor)\n}\n\nfrom DataFlow::InvokeNode cs, Function callee, string calleeDesc, string how\nwhere\n  illegalInvocation(cs, callee, calleeDesc, how) and\n  // filter out some easy cases\n  not isCallToFunction(cs) and\n  // conservatively only flag call sites where _all_ callees are illegal\n  forex(DataFlow::InvokeNode cs2, Function otherCallee |\n    cs2.getInvokeExpr() = cs.getInvokeExpr() and otherCallee = cs2.getACallee()\n  |\n    illegalInvocation(cs, otherCallee, _, _)\n  ) and\n  // require that all callees are known\n  not cs.isIncomplete()\nselect cs, \"Illegal invocation of $@ \" + how + \".\", callee, calleeDesc",
        "description": "Attempting to invoke a method or an arrow function using 'new', or invoking a constructor as a function, will cause a runtime error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/IllegalInvocation.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.dataflow.InferredTypes\n\npredicate isProto(DataFlow::AnalyzedNode e) {\n  // `o.__proto__ = e`, `{ __proto__: e }`, ...\n  e = any(DataFlow::PropWrite pwn | pwn.getPropertyName() = \"__proto__\").getRhs()\n  or\n  // Object.create(e)\n  e = DataFlow::globalVarRef(\"Object\").getAMemberCall(\"create\").getArgument(0)\n  or\n  // Object.setPrototypeOf(o, e)\n  e = DataFlow::globalVarRef(\"Object\").getAMemberCall(\"setPrototypeOf\").getArgument(1)\n  or\n  // e.isPrototypeOf(o)\n  any(MethodCallExpr mce).calls(e.asExpr(), \"isPrototypeOf\")\n}\n\nfrom DataFlow::AnalyzedNode proto\nwhere\n  isProto(proto) and\n  forex(InferredType tp | tp = proto.getAType() | tp instanceof PrimitiveType and tp != TTNull())\nselect proto, \"Values of type \" + proto.ppTypes() + \" cannot be used as prototypes.\"",
        "description": "An attempt to use a value that is not an object or 'null' as a prototype will either be ignored or result in a runtime error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/InvalidPrototype.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\npredicate needsGuard(Expr e, string kind) {\n  e instanceof ThisExpr and kind = \"this\"\n  or\n  e instanceof SuperPropAccess and kind = \"super\"\n}\n\npredicate unguardedBB(BasicBlock bb, Function ctor) {\n  exists(ClassDefinition c | exists(c.getSuperClass()) |\n    ctor = c.getConstructor().getBody() and\n    bb = ctor.getStartBB()\n  )\n  or\n  exists(BasicBlock pred | pred = bb.getAPredecessor() |\n    unguardedBB(pred, ctor) and\n    not pred.getANode() instanceof SuperCall\n  )\n}\n\npredicate unguarded(ControlFlowNode nd, Function ctor) {\n  exists(BasicBlock bb, int i | nd = bb.getNode(i) |\n    unguardedBB(bb, ctor) and\n    not bb.getNode([0 .. i - 1]) instanceof SuperCall\n  )\n}\n\nfrom Expr e, string kind, Function ctor\nwhere\n  needsGuard(e, kind) and\n  unguarded(e, ctor) and\n  // don't flag if there is a super call in a nested arrow function\n  not exists(SuperCall sc |\n    sc.getBinder() = ctor and\n    sc.getEnclosingFunction() != ctor\n  )\nselect ctor.(FirstLineOf), \"The super constructor must be called before using $@.\", e, kind",
        "description": "Accessing 'this' or a property of 'super' in the constructor of a subclass before calling the super constructor will cause a runtime error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/ThisBeforeSuper.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass EqOrSwitch extends AstNode {\n  EqOrSwitch() {\n    this instanceof EqualityTest or\n    this instanceof Case\n  }\n\n  /**\n   * Gets an operand of this comparison.\n   *\n   * For equality tests, the result is one of the operands; for switch cases,\n   * the result is either the case expression or the discriminant of the\n   * switch statement.\n   *\n   * Thus, the operands of `x !== 0` are `x` and `0`, while the operands\n   * of `case 1:` in `switch (y) { case 1: ... }` are `y` and `1`.\n   */\n  Expr getAnOperand() {\n    result = this.(EqualityTest).getAnOperand()\n    or\n    exists(Case c | c = this |\n      result = c.getSwitch().getExpr() or\n      result = c.getExpr()\n    )\n  }\n}\n\nfrom EqOrSwitch et, TypeofExpr typeof, ConstantString str\nwhere\n  typeof = et.getAnOperand().getUnderlyingValue() and\n  str = et.getAnOperand().getUnderlyingValue() and\n  not str.getStringValue() =\n    [\n      \"undefined\", \"boolean\", \"number\", \"string\", \"object\", \"function\", \"symbol\", \"unknown\", \"date\",\n      \"bigint\"\n    ]\nselect typeof,\n  \"The result of this 'typeof' expression is compared to $@, but the two can never be equal.\", str,\n  str.getStringValue()",
        "description": "Comparing the result of a typeof test against a string other than 'undefined', 'boolean', 'number', 'string', 'object', 'function' or 'symbol' is useless, since this comparison can never succeed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/BadTypeof.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass CandidateTopLevel extends TopLevel {\n  CandidateTopLevel() { exists(TemplateLiteral template | template.getTopLevel() = this) }\n}\n\nclass CandidateStringLiteral extends StringLiteral {\n  string v;\n\n  CandidateStringLiteral() {\n    this.getTopLevel() instanceof CandidateTopLevel and\n    v = this.getStringValue()\n  }\n\n  /**\n   * Extracts a `${...}` part from this string literal using an inexact regular expression.\n   *\n   * Breakdown of the sequence matched by the expression:\n   * - any prefix and then `${`\n   * - any amount of whitespace and simple unary operators\n   * - name of the variable\n   * - optionally: a character terminating the identifier token, followed by anything\n   * - `}`, followed by anything\n   */\n  string getAReferencedVariable() {\n    result = v.regexpCapture(\".*\\\\$\\\\{[\\\\s+\\\\-!]*([\\\\w\\\\p{L}$]+)([^\\\\w\\\\p{L}$].*)?\\\\}.*\", 1)\n  }\n\n  /**\n   * Gets an ancestor node of this string literal in the AST that can be reached without\n   * stepping over scope elements.\n   */\n  AstNode getIntermediate() {\n    result = this\n    or\n    exists(AstNode mid | mid = this.getIntermediate() |\n      not mid instanceof ScopeElement and\n      result = mid.getParent()\n    )\n  }\n\n  /**\n   * Holds if this string literal is in the given `scope`.\n   */\n  predicate isInScope(Scope scope) {\n    scope instanceof GlobalScope or\n    this.getIntermediate().(ScopeElement).getScope() = scope.getAnInnerScope*()\n  }\n}\n\npredicate hasObjectProvidingTemplateVariables(CandidateStringLiteral lit) {\n  exists(DataFlow::CallNode call, DataFlow::ObjectLiteralNode obj |\n    call.getAnArgument() = [lit.flow(), StringConcatenation::getRoot(lit.flow())] and\n    obj.flowsTo(call.getAnArgument()) and\n    forex(string name | name = lit.getAReferencedVariable() | exists(obj.getAPropertyWrite(name)))\n  )\n}\n\nVarDecl getDeclIn(Variable v, Scope scope, string name, CandidateTopLevel tl) {\n  v.getName() = name and\n  v.getADeclaration() = result and\n  v.getScope() = scope and\n  result.getTopLevel() = tl\n}\n\nDataFlow::SourceNode trackStringWithTemplateSyntax(\n  CandidateStringLiteral lit, DataFlow::TypeTracker t\n) {\n  t.start() and result = lit.flow() and exists(lit.getAReferencedVariable())\n  or\n  exists(DataFlow::TypeTracker t2 | result = trackStringWithTemplateSyntax(lit, t2).track(t2, t))\n}\n\nDataFlow::SourceNode trackStringWithTemplateSyntax(CandidateStringLiteral lit) {\n  result = trackStringWithTemplateSyntax(lit, DataFlow::TypeTracker::end())\n}\n\npredicate hasReplaceMethodCall(CandidateStringLiteral lit) {\n  trackStringWithTemplateSyntax(lit).getAMethodCall() instanceof StringReplaceCall\n}\n\nfrom CandidateStringLiteral lit, Variable v, Scope s, string name, VarDecl decl\nwhere\n  decl = getDeclIn(v, s, name, lit.getTopLevel()) and\n  lit.getAReferencedVariable() = name and\n  lit.isInScope(s) and\n  not hasObjectProvidingTemplateVariables(lit) and\n  not lit.getStringValue() = \"${\" + name + \"}\" and\n  not hasReplaceMethodCall(lit)\nselect lit, \"This string is not a template literal, but appears to reference the variable $@.\",\n  decl, v.getName()",
        "description": "A string literal appears to use template syntax but is not quoted with backticks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/TemplateSyntaxInStringLiteral.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass NewFunction extends DataFlow::NewNode {\n  NewFunction() { this = DataFlow::globalVarRef(\"Function\").getAnInvocation() }\n}\n\nclass EvalCall extends DataFlow::CallNode {\n  EvalCall() { this = DataFlow::globalVarRef(\"eval\").getACall() }\n}\n\nclass EvalUse extends DataFlow::Node {\n  EvalUse() { this instanceof NewFunction or this instanceof EvalCall }\n}\n\nfrom EvalUse eval\nselect eval, \"Do not use eval or the Function constructor.\"",
        "description": "The 'eval' function and the 'Function' constructor execute strings as code. This is dangerous and impedes program analysis and understanding. Consequently, these two functions should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/Eval.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom WithStmt ws\nselect ws.(FirstLineOf), \"Do not use 'with'.\"",
        "description": "The 'with' statement has subtle semantics and should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/WithStatement.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.dataflow.InferredTypes\n\nstring describeProp(DataFlow::PropWrite pwn) {\n  result = \"property \" + pwn.getPropertyName()\n  or\n  not exists(pwn.getPropertyName()) and result = \"a property\"\n}\n\nfrom DataFlow::PropWrite pwn, DataFlow::AnalyzedNode base\nwhere\n  base = pwn.getBase() and\n  forex(InferredType tp | tp = base.getAType() |\n    tp instanceof PrimitiveType and\n    // assignments on `null` and `undefined` are covered by\n    // the query 'Property access on null or undefined'\n    tp != TTNull() and\n    tp != TTUndefined()\n  )\nselect base,\n  \"Assignment to \" + describeProp(pwn) + \" of a primitive value with type \" + base.ppTypes() + \".\"",
        "description": "Assigning to a property of a primitive value has no effect and may trigger a runtime error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/PropertyWriteOnPrimitive.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DeleteExpr del\nwhere not del.getOperand().stripParens() instanceof PropAccess\nselect del, \"Only properties should be deleted.\"",
        "description": "The operand of the 'delete' operator should always be a property accessor.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/DeleteVar.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom FunctionExpr f, ReturnStmt ret\nwhere\n  ret.getContainer() = f and\n  f.isSetter() and\n  exists(ret.getExpr())\nselect ret, \"Useless return statement in setter function.\"",
        "description": "Returning a value from a setter function is useless, since it will always be ignored.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/SetterReturn.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass OmittedArrayElement extends ArrayExpr {\n  int idx;\n\n  OmittedArrayElement() { idx = min(int i | this.elementIsOmitted(i)) }\n\n  /**\n   * Holds if this element is at the specified location.\n   * The location spans column `startcolumn` of line `startline` to\n   * column `endcolumn` of line `endline` in file `filepath`.\n   * For more information, see\n   * [Locations](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    exists(Token pre, Location before, Location after |\n      idx = 0 and pre = this.getFirstToken()\n      or\n      pre = this.getElement(idx - 1).getLastToken().getNextToken()\n    |\n      before = pre.getLocation() and\n      after = pre.getNextToken().getLocation() and\n      before.hasLocationInfo(filepath, startline, startcolumn, _, _) and\n      after.hasLocationInfo(_, _, _, endline, endcolumn)\n    )\n  }\n}\n\nfrom OmittedArrayElement ae\nselect ae, \"Avoid omitted array elements.\"",
        "description": "Omitted elements in array literals are easy to miss and should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/EmptyArrayInit.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom PropAccess acc, ArgumentsVariable args\nwhere\n  acc.getBase() = args.getAnAccess() and\n  acc.getPropertyName() = [\"caller\", \"callee\"] and\n  // don't flag cases where the variable can never contain an arguments object\n  not exists(Function fn | args = fn.getVariable()) and\n  not exists(Parameter p | args = p.getAVariable()) and\n  // arguments.caller/callee in strict mode causes runtime errors,\n  // this is covered by the query 'Use of call stack introspection in strict mode'\n  not acc.getContainer().isStrict()\nselect acc, \"Avoid using arguments.caller and arguments.callee.\"",
        "description": "The properties 'arguments.caller' and 'argument.callee' have subtle semantics and make code non-modular and hard to maintain. Consequently, they should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/ArgumentsCallerCallee.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nPropAccess arrayLen(Variable array) { result.accesses(array.getAnAccess(), \"length\") }\n\nConditionGuardNode getLengthLEGuard(Variable index, Variable array) {\n  exists(RelationalComparison cmp | cmp instanceof GEExpr or cmp instanceof LEExpr |\n    cmp = result.getTest() and\n    result.getOutcome() = true and\n    cmp.getGreaterOperand() = arrayLen(array) and\n    cmp.getLesserOperand() = index.getAnAccess()\n  )\n}\n\nConditionGuardNode getLengthLTGuard(Variable index, Variable array) {\n  exists(RelationalComparison cmp | cmp instanceof GTExpr or cmp instanceof LTExpr |\n    cmp = result.getTest() and\n    result.getOutcome() = true and\n    cmp.getGreaterOperand() = arrayLen(array) and\n    cmp.getLesserOperand() = index.getAnAccess()\n  )\n}\n\nConditionGuardNode getLengthNEGuard(Variable index, Variable array) {\n  exists(EqualityTest eq |\n    eq = result.getTest() and\n    result.getOutcome() = eq.getPolarity().booleanNot() and\n    eq.hasOperands(index.getAnAccess(), arrayLen(array))\n  )\n}\n\npredicate elementRead(IndexExpr ea, Variable array, Variable index, BasicBlock bb) {\n  ea.getBase() = array.getAnAccess() and\n  ea.getIndex() = index.getAnAccess() and\n  ea instanceof RValue and\n  bb = ea.getBasicBlock()\n}\n\nfrom ConditionGuardNode cond, Variable array, Variable index, IndexExpr ea, BasicBlock bb\nwhere\n  // there is a comparison `index <= array.length`\n  cond = getLengthLEGuard(index, array) and\n  // there is a read from `array[index]`\n  elementRead(ea, array, index, bb) and\n  // and the read is guarded by the comparison\n  cond.dominates(bb) and\n  // but the read is not guarded by another check that `index != array.length` or `index < array.length`\n  not getLengthNEGuard(index, array).dominates(bb) and\n  not getLengthLTGuard(index, array).dominates(bb)\nselect cond.getTest(), \"Off-by-one index comparison against length may lead to out-of-bounds $@.\",\n  ea, \"read\"",
        "description": "An array index is compared to be less than or equal to the 'length' property, and then used in an indexing operation that could be out of bounds.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/LengthComparisonOffByOne.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport LanguageFeatures.UnusedIndexVariable\n\nfrom RelationalComparison rel, Variable idx, Variable v\nwhere unusedIndexVariable(rel, idx, v)\nselect rel, \"Index variable \" + idx + \" is never used to access elements of \" + v + \".\"",
        "description": "Iterating over an array but not using the index variable to access array elements may indicate a typo or logic error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/UnusedIndexVariable.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate deprecated_feature(AstNode nd, string type, string replacement) {\n  exists(FunctionExpr fe | fe = nd and fe.getBody() instanceof Expr |\n    type = \"expression closures\" and replacement = \"arrow expressions\"\n  )\n  or\n  nd instanceof LegacyLetExpr and type = \"let expressions\" and replacement = \"let declarations\"\n  or\n  nd instanceof LegacyLetStmt and type = \"let statements\" and replacement = \"let declarations\"\n  or\n  nd instanceof ForEachStmt and type = \"for each statements\" and replacement = \"for of statements\"\n  or\n  nd.(ComprehensionExpr).isPostfix() and\n  type = \"postfix comprehensions\" and\n  replacement = \"prefix comprehensions\"\n  or\n  nd.(ExprStmt).isDoubleColonMethod(_, _, _) and\n  type = \"double colon method declarations\" and\n  replacement = \"standard method definitions\"\n}\n\nfrom AstNode depr, string type, string replacement\nwhere deprecated_feature(depr, type, replacement)\nselect depr, \"Use \" + replacement + \" instead of \" + type + \".\"",
        "description": "Non-standard language features such as expression closures or let expressions make it harder to reuse code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/ExpressionClosures.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom JSParseError pe\nwhere not pe.getTopLevel() instanceof Angular2::TemplateTopLevel\nselect pe, pe.getMessage()",
        "description": "A piece of code could not be parsed due to syntax errors.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/SyntaxError.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom JsonValue v, File f\nwhere\n  f = v.getFile() and\n  f.getExtension().regexpMatch(\"(?i)jsx?\") and\n  not exists(v.getParent())\nselect v, \"JSON data in file with extension '\" + f.getExtension() + \"'.\"",
        "description": "Storing JSON in files with extension 'js' or 'jsx' is error-prone.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/WrongExtensionJSON.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom ForInComprehensionBlock ficb\nselect ficb, \"For-in comprehension blocks are a non-standard language feature.\"",
        "description": "'for'-'in' comprehension blocks are a Mozilla-specific language extension that is no longer supported.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/ForInComprehensionBlocks.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass Jump extends Stmt {\n  Jump() {\n    this instanceof BreakOrContinueStmt or\n    this instanceof ReturnStmt\n  }\n\n  /** Gets the target to which this jump refers. */\n  Stmt getTarget() {\n    result = this.(BreakOrContinueStmt).getTarget() or\n    result = this.(ReturnStmt).getContainer().(Function).getBody()\n  }\n}\n\nfrom TryStmt try, BlockStmt finally, Jump jump\nwhere\n  finally = try.getFinally() and\n  jump.getContainer() = try.getContainer() and\n  jump.getParentStmt+() = finally and\n  finally.getParentStmt+() = jump.getTarget()\nselect jump, \"This statement jumps out of the finally block, potentially hiding an exception.\"",
        "description": "Avoid using unstructured control flow statements (return, continue, or break) inside a 'finally' block.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/JumpFromFinally.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate illegalPropAccess(AbstractValue baseVal, string baseDesc, string prop) {\n  baseVal instanceof AbstractArguments and\n  baseDesc = \"arguments\" and\n  (prop = \"caller\" or prop = \"callee\")\n  or\n  baseVal instanceof AbstractFunction and\n  baseDesc = \"Function.prototype\" and\n  (prop = \"caller\" or prop = \"arguments\")\n}\n\nfrom PropAccess acc, DataFlow::AnalyzedNode baseNode, string base, string prop\nwhere\n  acc.accesses(baseNode.asExpr(), prop) and\n  acc.getContainer().isStrict() and\n  illegalPropAccess(baseNode.getAValue(), base, prop) and\n  forex(AbstractValue av | av = baseNode.getAValue() | illegalPropAccess(av, _, prop)) and\n  not acc = any(ExprStmt stmt).getExpr() // reported by js/useless-expression\nselect acc, \"Strict mode code cannot use \" + base + \".\" + prop + \".\"",
        "description": "Accessing properties 'arguments.caller', 'arguments.callee', 'Function.prototype.caller' or 'Function.prototype.arguments' in strict mode will cause a runtime error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/StrictModeCallStackIntrospection.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\npredicate asi(StmtContainer sc, Stmt s, boolean asi) {\n  exists(TopLevel tl | tl = sc.getTopLevel() |\n    not tl instanceof EventHandlerCode and\n    not tl.isExterns()\n  ) and\n  sc = s.getContainer() and\n  s.isSubjectToSemicolonInsertion() and\n  (if s.hasSemicolonInserted() then asi = true else asi = false)\n}\n\nfrom Stmt s, StmtContainer sc, string sctype, float asi, int nstmt, int perc\nwhere\n  s.hasSemicolonInserted() and\n  sc = s.getContainer() and\n  (if sc instanceof Function then sctype = \"function\" else sctype = \"script\") and\n  asi = strictcount(Stmt ss | asi(sc, ss, true)) and\n  nstmt = strictcount(Stmt ss | asi(sc, ss, _)) and\n  perc = ((1 - asi / nstmt) * 100).floor() and\n  perc >= 90\nselect s.(LastLineOf),\n  \"Avoid automated semicolon insertion \" + \"(\" + perc +\n    \"% of all statements in $@ have an explicit semicolon).\", sc, \"the enclosing \" + sctype",
        "description": "Code that uses automatic semicolon insertion inconsistently is hard to read and maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/SemicolonInsertion.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\npredicate guardsAgainstMissingNew(Function f) {\n  exists(DataFlow::NewNode new |\n    new.asExpr().getEnclosingFunction() = f and\n    f = new.getACallee()\n  )\n}\n\nFunction getALikelyCallee(DataFlow::InvokeNode cs, boolean isNew) {\n  result =\n    min(Function callee, int imprecision |\n      callee = cs.getACallee(imprecision)\n    |\n      callee order by imprecision\n    ) and\n  not cs.isUncertain() and\n  not whitelistedCall(cs) and\n  not whitelistedCallee(result) and\n  (\n    cs instanceof DataFlow::NewNode and isNew = true\n    or\n    cs instanceof DataFlow::CallNode and isNew = false\n  )\n}\n\npredicate whitelistedCallee(Function f) {\n  // externs are special, so don't flag them\n  f.inExternsFile()\n  or\n  // illegal constructor calls are flagged by query 'Illegal invocation',\n  // so don't flag them\n  f instanceof Constructor\n  or\n  // if `f` itself guards against missing `new`, don't flag it\n  guardsAgainstMissingNew(f)\n}\n\npredicate whitelistedCall(DataFlow::CallNode call) {\n  // super constructor calls behave more like `new`, so don't flag them\n  call.asExpr() instanceof SuperCall\n  or\n  // don't flag if there is a receiver object\n  exists(call.getReceiver())\n}\n\nDataFlow::InvokeNode getFirstInvocation(Function f, boolean isNew) {\n  result =\n    min(DataFlow::InvokeNode invk, string path, int line, int col |\n      f = getALikelyCallee(invk, isNew) and invk.hasLocationInfo(path, line, col, _, _)\n    |\n      invk order by path, line, col\n    )\n}\n\nfrom Function f, DataFlow::NewNode new, DataFlow::CallNode call\nwhere\n  new = getFirstInvocation(f, true) and\n  call = getFirstInvocation(f, false)\nselect f.(FirstLineOf),\n  capitalize(f.describe()) + \" is sometimes invoked as a constructor \" +\n    \"(for example $@), and sometimes as a normal function (for example $@).\", new, \"here\", call,\n  \"here\"",
        "description": "If a function is intended to be a constructor, it should always be invoked with 'new'. Otherwise, it should always be invoked as a normal function, that is, without 'new'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/InconsistentNew.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DebuggerStmt ds\nselect ds, \"Do not use 'debugger'.\"",
        "description": "The 'debugger' statement should not be used in production code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/DebuggerStatement.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass RootDestructuringPattern extends DestructuringPattern {\n  RootDestructuringPattern() {\n    not this = any(PropertyPattern p).getValuePattern() and\n    not this = any(ArrayPattern p).getAnElement()\n  }\n\n  /** Holds if this pattern has multiple bindings for `name`. */\n  predicate hasConflictingBindings(string name) {\n    exists(VarRef v, VarRef w |\n      v = this.getABindingVarRef() and\n      w = this.getABindingVarRef() and\n      name = v.getName() and\n      name = w.getName() and\n      v != w\n    )\n  }\n\n  /** Gets the first occurrence of the conflicting binding `name`. */\n  VarDecl getFirstClobberedVarDecl(string name) {\n    this.hasConflictingBindings(name) and\n    result =\n      min(VarDecl decl |\n        decl = this.getABindingVarRef() and decl.getName() = name\n      |\n        decl order by decl.getLocation().getStartLine(), decl.getLocation().getStartColumn()\n      )\n  }\n\n  /** Holds if variables in this pattern may resemble type annotations. */\n  predicate resemblesTypeAnnotation() {\n    this.hasConflictingBindings(_) and // Restrict size of predicate.\n    this instanceof Parameter and\n    this instanceof ObjectPattern and\n    not exists(this.getTypeAnnotation()) and\n    this.getFile().getFileType().isTypeScript()\n  }\n}\n\nfrom RootDestructuringPattern p, string n, VarDecl v, VarDecl w, string message\nwhere\n  v = p.getFirstClobberedVarDecl(n) and\n  w = p.getABindingVarRef() and\n  w.getName() = n and\n  v != w and\n  if p.resemblesTypeAnnotation()\n  then message = \"The pattern variable '\" + n + \"' appears to be a type, but is a variable $@.\"\n  else message = \"Repeated binding of pattern variable '\" + n + \"' $@.\"\nselect w, message, v, \"previously bound\"",
        "description": "If the same pattern variable appears twice in an array or object pattern, the second binding will silently overwrite the first binding, which is probably unintentional.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/NonLinearPattern.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom YieldExpr yield, Function f\nwhere\n  f = yield.getEnclosingFunction() and\n  not is_generator(f)\nselect yield, \"This yield expression is contained in $@ which is not marked as a generator.\",\n  f.getFirstToken(), f.describe()",
        "description": "'yield' should only be used in generator functions.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/LanguageFeatures/YieldInNonGenerator.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport UnusedParameter\n\nfrom Parameter p\nwhere isAnAccidentallyUnusedParameter(p)\nselect p, \"The parameter '\" + p.getVariable().getName() + \"' is never used.\"",
        "description": "Unused parameters make functions hard to read and hard to use, and should be removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/UnusedParameter.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate hasMethod(ClassDefinition base, string name, MethodDeclaration m) {\n  m = base.getMethod(name) or\n  hasMethod(base.getSuperClassDefinition(), name, m)\n}\n\npredicate isLocalMethodAccess(\n  PropAccess access, MethodDefinition fromMethod, string fromKind, MethodDeclaration toMethod,\n  string toKind\n) {\n  hasMethod(fromMethod.getDeclaringClass(), access.getPropertyName(), toMethod) and\n  access.getEnclosingFunction() = fromMethod.getBody() and\n  access.getBase() instanceof ThisExpr and\n  fromKind = getKind(fromMethod) and\n  toKind = getKind(toMethod)\n}\n\nstring getKind(MethodDeclaration m) {\n  if m.isStatic() then result = \"static\" else result = \"instance\"\n}\n\nfrom\n  PropAccess access, MethodDefinition fromMethod, MethodDefinition toMethod, string fromKind,\n  string toKind\nwhere\n  isLocalMethodAccess(access, fromMethod, fromKind, toMethod, toKind) and\n  toKind != fromKind and\n  // exceptions\n  not (\n    // the class has a second member with the same name and the right kind\n    isLocalMethodAccess(access, fromMethod, _, _, fromKind)\n    or\n    // there is a dynamically assigned second member with the same name and the right kind\n    exists(AnalyzedPropertyWrite apw, AbstractClass declaringClass, AbstractValue base |\n      \"static\" = fromKind and base = declaringClass\n      or\n      \"instance\" = fromKind and base = TAbstractInstance(declaringClass)\n    |\n      declaringClass = TAbstractClass(fromMethod.getDeclaringClass()) and\n      apw.writes(base, access.getPropertyName(), _)\n    )\n    or\n    // the access is an assignment, probably deliberate\n    access instanceof LValue\n  )\nselect access,\n  \"Access to \" + toKind + \" method $@ from \" + fromKind +\n    \" method $@ is not possible through `this`.\", toMethod, toMethod.getName(), fromMethod,\n  fromMethod.getName()",
        "description": "A reference to a static method from within an instance method needs to be qualified with the class name, not `this`.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/MixedStaticInstanceThisAccess.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom VarRef d\nwhere\n  d.getVariable().(LocalVariable).getName() = \"arguments\" and\n  (d instanceof LValue or d instanceof VarDecl) and\n  not d.isAmbient() and\n  not d.inExternsFile()\nselect d, \"Redefinition of arguments.\"",
        "description": "The special 'arguments' variable can be redefined, but this should be avoided since it makes code hard to read and maintain and may prevent compiler optimizations.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/ArgumentsRedefined.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate accessToNestedFunction(VarAccess va, FunctionDeclStmt inner, Function outer) {\n  va.getVariable() = inner.getVariable() and\n  inner.getEnclosingContainer() = outer\n}\n\nfrom Function f, VarAccess va, FunctionDeclStmt g\nwhere\n  accessToNestedFunction(va, g, f) and\n  va.getParentExpr*() = f.getAParameter().getDefault()\nselect va, \"This expression refers to $@ before it is defined.\", g, g.getName()",
        "description": "If a default parameter value references a function that is nested inside the function to which the parameter belongs, a runtime error will occur, since the function is not yet defined at the point where it is referenced.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/DefaultArgumentReferencesNestedFunction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate parmBinds(Function f, int i, Parameter p, string name) {\n  p = f.getParameter(i) and\n  p.getAVariable().getName() = name\n}\n\npredicate isDummy(SimpleParameter p) {\n  p.getName() = \"_\" and\n  not exists(p.getVariable().getAnAccess())\n}\n\nfrom Function f, Parameter p, Parameter q, int i, int j, string name\nwhere\n  parmBinds(f, i, p, name) and\n  parmBinds(f, j, q, name) and\n  i < j and\n  j = max(int k | parmBinds(f, k, _, name) | k) and\n  not isDummy(p) and\n  // ignore functions without bodies or empty bodies\n  f.hasBody() and\n  exists(f.getABodyStmt()) and\n  // duplicate parameters in strict mode functions are flagged by the 'Syntax error' rule\n  not f.isStrict()\nselect p, \"This parameter has the same name as $@ of the same function.\", q, \"another parameter\"",
        "description": "If a function has two parameters with the same name, the second parameter shadows the first one, which makes the code hard to understand and error-prone.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/UniqueParameterNames.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nSimpleParameter getParameter(MethodSignature sig, int i) { result = sig.getBody().getParameter(i) }\n\nstring getParameterTypeAnnotation(MethodSignature sig, int i) {\n  result = getParameter(sig, i).getTypeAnnotation().toString()\n}\n\nMethodSignature getOtherMatchingSignatures(MethodSignature sig) {\n  signaturesMatch(result, sig) and\n  result != sig\n}\n\nstring getKind(MemberDeclaration m) {\n  if m.isStatic() then result = \"static\" else result = \"instance\"\n}\n\nprivate class MethodCallSig extends Function {\n  MethodCallSig() { this = any(MethodSignature signature).getBody() }\n\n  int getNumOptionalParameter() {\n    result = count(Parameter p | p = this.getParameter(_) and p.isDeclaredOptional())\n  }\n\n  int getNumRequiredParameter() {\n    result = count(Parameter p | p = this.getParameter(_) and not p.isDeclaredOptional())\n  }\n\n  SignatureKind getKind() { result = SignatureKind::function() }\n\n  TypeExpr getTypeParameterBound(int i) { result = this.getTypeParameter(i).getBound() }\n}\n\npragma[noinline]\nprivate MethodCallSig getMethodCallSigWithFingerprint(\n  string name, int optionalParams, int numParams, int requiredParms, SignatureKind kind\n) {\n  name = result.getName() and\n  optionalParams = result.getNumOptionalParameter() and\n  numParams = result.getNumParameter() and\n  requiredParms = result.getNumRequiredParameter() and\n  kind = result.getKind()\n}\n\npragma[inline]\npredicate matchingCallSignature(MethodCallSig method, MethodCallSig other) {\n  other =\n    getMethodCallSigWithFingerprint(method.getName(), method.getNumOptionalParameter(),\n      method.getNumParameter(), method.getNumRequiredParameter(), method.getKind()) and\n  // purposely not looking at number of type arguments.\n  forall(int i | i in [0 .. -1 + method.getNumParameter()] |\n    method.getParameter(i) = other.getParameter(i) // This is sometimes imprecise, so it is still a good idea to compare type annotations.\n  ) and\n  // shared type parameters are equal.\n  forall(int i |\n    i in [0 .. -1 +\n          min(int num | num = method.getNumTypeParameter() or num = other.getNumTypeParameter())]\n  |\n    method.getTypeParameterBound(i) = other.getTypeParameterBound(i)\n  )\n}\n\nint getOverloadIndex(MethodSignature sig) {\n  sig.getDeclaringType().getMethodOverload(sig.getName(), result) = sig\n}\n\npragma[noinline]\nprivate MethodSignature getMethodSignatureWithFingerprint(\n  ClassOrInterface declaringType, string name, int numParameters, string kind\n) {\n  result.getDeclaringType() = declaringType and\n  result.getName() = name and\n  getKind(result) = kind and\n  result.getBody().getNumParameter() = numParameters\n}\n\nbindingset[t1, t2]\npragma[inline_late]\nprivate predicate sameType(TypeExpr t1, TypeExpr t2) {\n  t1.(PredefinedTypeExpr).getName() = t2.(PredefinedTypeExpr).getName()\n  or\n  t1 instanceof ThisTypeExpr and t2 instanceof ThisTypeExpr\n  or\n  t1.(LocalTypeAccess).getLocalTypeName() = t2.(LocalTypeAccess).getLocalTypeName()\n}\n\npredicate signaturesMatch(MethodSignature method, MethodSignature other) {\n  // the initial search for another overload in a single call for better join-order.\n  other =\n    getMethodSignatureWithFingerprint(method.getDeclaringType(), method.getName(),\n      method.getBody().getNumParameter(), getKind(method)) and\n  // same this parameter (if exists)\n  (\n    not exists(method.getBody().getThisTypeAnnotation()) and\n    not exists(other.getBody().getThisTypeAnnotation())\n    or\n    sameType(method.getBody().getThisTypeAnnotation(), other.getBody().getThisTypeAnnotation())\n  ) and\n  // The types are compared in matchingCallSignature. This is a consistency check that the textual representation of the type-annotations are somewhat similar.\n  forall(int i | i in [0 .. -1 + method.getBody().getNumParameter()] |\n    getParameterTypeAnnotation(method, i) = getParameterTypeAnnotation(other, i)\n  ) and\n  matchingCallSignature(method.getBody(), other.getBody())\n}\n\nfrom ClassOrInterface decl, string name, MethodSignature previous, MethodSignature unreachable\nwhere\n  previous = decl.getMethod(name) and\n  unreachable = getOtherMatchingSignatures(previous) and\n  // If the method is part of inheritance between classes/interfaces, then there can sometimes be reasons for having this pattern.\n  not exists(decl.getASuperTypeDeclaration().getMethod(name)) and\n  not exists(ClassOrInterface sub |\n    decl = sub.getASuperTypeDeclaration() and\n    exists(sub.getMethod(name))\n  ) and\n  // If a later method overload has more type parameters, then that overload can be selected by explicitly declaring the type arguments at the callsite.\n  // This comparison removes those cases.\n  unreachable.getBody().getNumTypeParameter() <= previous.getBody().getNumTypeParameter() and\n  // We always select the first of the overloaded methods.\n  not exists(MethodSignature later | later = getOtherMatchingSignatures(previous) |\n    getOverloadIndex(later) < getOverloadIndex(previous)\n  )\nselect unreachable,\n  \"This overload of \" + name + \"() is unreachable, the $@ overload will always be selected.\",\n  previous, \"previous\"",
        "description": "Having multiple overloads with the same parameter types in TypeScript makes all overloads except the first one unreachable, as the compiler always resolves calls to the textually first matching overload.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/UnreachableMethodOverloads.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.dataflow.LocalObjects\nimport Declarations.UnusedVariable\nimport UnusedParameter\nimport Expressions.ExprHasNoEffect\n\npredicate hasUnknownPropertyRead(LocalObject obj) {\n  // dynamic reads\n  exists(DataFlow::PropRead r | obj.getAPropertyRead() = r | not exists(r.getPropertyName()))\n  or\n  // reflective reads\n  obj.flowsToExpr(any(EnhancedForLoop l).getIterationDomain())\n  or\n  obj.flowsToExpr(any(InExpr l).getRightOperand())\n  or\n  obj.flowsToExpr(any(SpreadElement e).getOperand())\n  or\n  exists(obj.getAPropertyRead(\"hasOwnProperty\"))\n  or\n  obj.flowsTo(DataFlow::globalVarRef(\"Object\").getAMemberCall(\"hasOwn\").getArgument(0))\n  or\n  exists(obj.getAPropertyRead(\"propertyIsEnumerable\"))\n}\n\npredicate flowsToTypeRestrictedExpression(LocalObject obj) {\n  exists(Expr restricted, TypeExpr type |\n    obj.flowsToExpr(restricted) and\n    not type.isAny()\n  |\n    exists(TypeAssertion assertion |\n      type = assertion.getTypeAnnotation() and\n      restricted = assertion.getExpression()\n    )\n    or\n    exists(SatisfiesExpr assertion |\n      type = assertion.getTypeAnnotation() and\n      restricted = assertion.getExpression()\n    )\n    or\n    exists(BindingPattern v |\n      type = v.getTypeAnnotation() and\n      restricted = v.getAVariable().getAnAssignedExpr()\n    )\n    // no need to reason about writes to typed fields, captured nodes do not reach them\n  )\n}\n\nfrom DataFlow::PropWrite write, LocalObject obj, string name\nwhere\n  write = obj.getAPropertyWrite(name) and\n  not exists(obj.getAPropertyRead(name)) and\n  // `obj` is the only base object for the write: it is not spurious\n  not write.getBase().analyze().getAValue() != obj.analyze().getAValue() and\n  not hasUnknownPropertyRead(obj) and\n  // avoid reporting if the definition is unreachable\n  write.getAstNode().getFirstControlFlowNode().getBasicBlock() instanceof ReachableBasicBlock and\n  // avoid implicitly read properties\n  not (\n    name = \"toString\" or\n    name = \"valueOf\" or\n    name.matches(\"@@%\") // @@iterator, for example\n  ) and\n  // avoid flagging properties that a type system requires\n  not flowsToTypeRestrictedExpression(obj) and\n  // flagged by js/unused-local-variable\n  not exists(UnusedLocal l | l.getAnAssignedExpr().getUnderlyingValue().flow() = obj) and\n  // flagged by js/unused-parameter\n  not exists(Parameter p | isAnAccidentallyUnusedParameter(p) |\n    p.getDefault().getUnderlyingValue().flow() = obj\n  ) and\n  // flagged by js/useless-expression\n  not inVoidContext(obj.asExpr())\nselect write, \"Unused property \" + name + \".\"",
        "description": "Unused properties may be a symptom of a bug and should be examined carefully.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/UnusedProperty.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate isImmediatelyExecutedContainer(StmtContainer container) {\n  container instanceof TopLevel\n  or\n  // Namespaces are immediately executed (they cannot be declared inside a function).\n  container instanceof NamespaceDeclaration\n  or\n  // IIFEs at the top-level are immediately executed\n  exists(ImmediatelyInvokedFunctionExpr function | container = function |\n    not function.isAsync() and\n    not function.isGenerator() and\n    isImmediatelyExecutedContainer(container.getEnclosingContainer())\n  )\n}\n\npredicate isAmbientImport(ImportDeclaration decl) {\n  decl.getFile().getFileType().isTypeScript() and\n  exists(decl.getASpecifier()) and\n  not exists(decl.getASpecifier().getLocal().getVariable().getAnAccess())\n}\n\nImport getARuntimeImport(Module source, Module destination) {\n  result = source.getAnImport() and\n  result.getImportedModule() = destination and\n  not isAmbientImport(result)\n}\n\npredicate isImportedAtRuntime(Module source, Module destination) {\n  exists(getARuntimeImport(source, destination))\n}\n\nclass CandidateVarAccess extends VarAccess {\n  CandidateVarAccess() {\n    isImmediatelyExecutedContainer(this.getContainer()) and\n    not exists(ExportSpecifier spec | spec.getLocal() = this)\n  }\n}\n\nVarAccess getFirstCandidateAccess(ImportDeclaration decl) {\n  result =\n    min(decl.getASpecifier().getLocal().getVariable().getAnAccess().(CandidateVarAccess) as p\n      order by\n        p.getLocation().getStartLine(), p.getLocation().getStartColumn()\n    )\n}\n\npredicate cycleAlert(Module mod, ImportDeclaration import_, Module importedModule, VarAccess access) {\n  import_ = mod.getAnImport() and\n  access = getFirstCandidateAccess(import_) and\n  importedModule = import_.getImportedModule() and\n  importedModule != mod and // don't report self-imports\n  // Suppress warning if this is the unique importer of that module.\n  // That's a sufficient and somewhat maintainable safety guarantee.\n  exists(Module otherEntry | isImportedAtRuntime(otherEntry, importedModule) and otherEntry != mod)\n}\n\npredicate numberOfStepsToModule(Module source, Module destination, int steps) =\n  shortestDistances(anyModule/1, isImportedAtRuntime/2)(source, destination, steps)\n\npredicate anyModule(Module m) { any() }\n\nstring repr(Import import_) { result = import_.getEnclosingModule().getName() }\n\nstring pathToModule(Module source, Module destination, int steps) {\n  // Restrict paths to those that are relevant for building a path from the imported module of an alert back to the importer.\n  exists(Module m | cycleAlert(destination, _, m, _) and numberOfStepsToModule(m, source, _)) and\n  numberOfStepsToModule(source, destination, steps) and\n  (\n    steps = 1 and\n    result = repr(getARuntimeImport(source, destination))\n    or\n    steps > 1 and\n    exists(Module next |\n      // Only extend the path to one of the potential successors, as we only need one example.\n      next =\n        min(Module mod |\n          isImportedAtRuntime(source, mod) and\n          numberOfStepsToModule(mod, destination, steps - 1)\n        |\n          mod order by mod.getName()\n        ) and\n      result =\n        repr(getARuntimeImport(source, next)) + \" => \" + pathToModule(next, destination, steps - 1)\n    )\n  )\n}\n\nfrom Module mod, ImportDeclaration import_, Module importedModule, VarAccess access\nwhere cycleAlert(mod, import_, importedModule, access)\nselect access,\n  access.getName() + \" is uninitialized if $@ is loaded first in the cyclic import:\" + \" \" +\n    repr(import_) + \" => \" + min(pathToModule(importedModule, mod, _)) + \" => \" + repr(import_) +\n    \".\", import_.getImportedPathExpr(), importedModule.getName()",
        "description": "If the top-level of a module accesses a variable from a cyclic import, its value depends on which module is globally imported first.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/UnstableCyclicImport.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DeclStmt vds, VariableDeclarator vd1, int i, VariableDeclarator vd2, int j, Variable v\nwhere\n  vd1 = vds.getDecl(i) and\n  vd2 = vds.getDecl(j) and\n  vd1.getBindingPattern().getAVariable() = v and\n  vd2.getBindingPattern().getAVariable() = v and\n  i < j\nselect vd2, \"Variable \" + v.getName() + \" has already $@.\", vd1, \"been previously declared\"",
        "description": "A variable declaration statement that declares the same variable twice is confusing and hard to maintain.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/DuplicateVarDecl.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom FunctionDeclStmt f, FunctionDeclStmt g\nwhere\n  f.getVariable() = g.getVariable() and\n  // ignore global functions; conflicts across scripts are usually false positives\n  not f.getVariable().isGlobal() and\n  // only report each pair once\n  f.getLocation().startsBefore(g.getLocation()) and\n  // ignore ambient, abstract, and overloaded declarations in TypeScript\n  f.hasBody() and\n  g.hasBody()\nselect f.getIdentifier(),\n  \"Declaration of \" + f.describe() + \" conflicts with $@ in the same scope.\", g.getIdentifier(),\n  \"another declaration\"",
        "description": "If two functions with the same name are declared in the same scope, one of the declarations overrides the other without warning. This makes the code hard to read and maintain, and may even lead to platform-dependent behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/ConflictingFunctions.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate isCommonPredefinedTypeName(string name) {\n  name = \"string\" or\n  name = \"number\" or\n  name = \"boolean\"\n}\n\nclass DefiniteTypeDecl extends TypeDecl {\n  DefiniteTypeDecl() {\n    this = any(ImportSpecifier im).getLocal() implies exists(this.getLocalTypeName().getAnAccess())\n  }\n}\n\nfrom SimpleParameter parameter, Function function, Locatable link, string linkText\nwhere\n  function.getFile().getFileType().isTypeScript() and\n  function.getAParameter() = parameter and\n  not function.hasBody() and\n  not exists(parameter.getTypeAnnotation()) and\n  (\n    isCommonPredefinedTypeName(parameter.getName()) and\n    link = parameter and\n    linkText = \"predefined type '\" + parameter.getName() + \"'\"\n    or\n    exists(DefiniteTypeDecl decl, LocalTypeName typename |\n      decl = typename.getFirstDeclaration() and\n      parameter.getVariable().getScope().getOuterScope*() = typename.getScope() and\n      decl.getName() = parameter.getName() and\n      link = decl and\n      linkText = decl.describe()\n    )\n  )\nselect parameter,\n  \"The parameter '\" + parameter.getName() + \"' has type 'any', but its name coincides with the $@.\",\n  link, linkText",
        "description": "Omitting the name of a parameter causes its type annotation to be parsed as the name.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/IneffectiveParameterType.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom DeclStmt cds, VariableDeclarator decl, VarDef def, Variable v\nwhere\n  (cds instanceof ConstDeclStmt or cds instanceof UsingDeclStmt) and\n  decl = cds.getADecl() and\n  def.getAVariable() = v and\n  decl.getBindingPattern().getAVariable() = v and\n  def != decl and\n  def.(ExprOrStmt).getTopLevel() = decl.getTopLevel()\nselect def.(FirstLineOf), \"Assignment to variable \" + v.getName() + \", which is $@ constant.\", cds,\n  \"declared\"",
        "description": "Assigning to a variable that is declared 'const' has either no effect or leads to a runtime error, depending on the platform.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/AssignmentToConst.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import Declarations.Declarations\n\nfrom VarAccess acc, VarDecl decl, Variable var, StmtContainer sc\nwhere\n  // the first reference to `var` in `sc` is `acc` (that is, an access, not a declaration)\n  acc = firstRefInContainer(var, Ref(), sc) and\n  // `decl` is a declaration of `var` in `sc` (which must come after `acc`)\n  decl = refInContainer(var, Decl(), sc) and\n  // exclude globals declared by a linter directive\n  not exists(Linting::GlobalDeclaration glob | glob.declaresGlobalForAccess(acc)) and\n  // exclude declarations in synthetic constructors\n  not acc.getEnclosingFunction() instanceof SyntheticConstructor and\n  // exclude results in ambient contexts\n  not acc.isAmbient() and\n  // a class may be referenced in its own decorators\n  not exists(ClassDefinition cls |\n    decl = cls.getIdentifier() and\n    acc.getParent*() = cls.getADecorator()\n  )\nselect acc, \"Variable '\" + acc.getName() + \"' is used before its $@.\", decl, \"declaration\"",
        "description": "Variables should be declared before their first use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/DeclBeforeUse.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate isSuspiciousMethodName(string name, ClassOrInterface container) {\n  name = \"function\" and exists(container) // suspicious in any container\n  or\n  // \"constructor\" is only suspicious outside a class.\n  name = \"constructor\" and not container instanceof ClassDefinition\n  or\n  // \"new\" is only suspicious inside a class.\n  name = \"new\" and container instanceof ClassDefinition\n}\n\nfrom MethodDeclaration member, ClassOrInterface container, string name, string msg\nwhere\n  container.getLocation().getFile().getFileType().isTypeScript() and\n  container.getMember(name) = member and\n  isSuspiciousMethodName(name, container) and\n  // Cases to ignore.\n  not (\n    // Assume that a \"new\" method is intentional if the class has an explicit constructor.\n    name = \"new\" and\n    container instanceof ClassDefinition and\n    exists(ConstructorDeclaration constructor |\n      container.getMember(\"constructor\") = constructor and\n      not constructor.isSynthetic()\n    )\n    or\n    // Explicitly declared static methods are fine.\n    container instanceof ClassDefinition and\n    member.isStatic()\n    or\n    // Only looking for declared methods. Methods with a body are OK.\n    exists(member.getBody().getBody())\n    or\n    // The developer was not confused about \"function\" when there are other methods in the interface.\n    name = \"function\" and\n    exists(MethodDeclaration other | other = container.getAMethod() |\n      other.getName() != \"function\" and\n      not other.(ConstructorDeclaration).isSynthetic()\n    )\n  ) and\n  (\n    name = \"constructor\" and\n    msg =\n      \"The member name 'constructor' does not declare a constructor in interfaces, but it does in classes.\"\n    or\n    name = \"new\" and\n    msg =\n      \"The member name 'new' does not declare a constructor, but 'constructor' does in class declarations.\"\n    or\n    name = \"function\" and\n    msg =\n      \"The member name 'function' does not declare a function, it declares a method named 'function'.\"\n  )\nselect member, msg",
        "description": "A method declaration with a name that is a special keyword in another context is suspicious.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/SuspiciousMethodNameDeclaration.ql",
        "language": "javascript"
    },
    {
        "query": "import Expressions.Clones\n\npredicate hasProperty(ObjectExpr o, Property p, string name, int kind, int i) {\n  p = o.getProperty(i) and\n  name = p.getName() and\n  kind = p.getKind()\n}\n\npredicate overwrittenBy(Property p, Property q) {\n  exists(ObjectExpr o, string name, int i, int j, int kind |\n    hasProperty(o, p, name, kind, i) and\n    hasProperty(o, q, name, kind, j) and\n    i < j\n  ) and\n  // exclude structurally identical properties: they are flagged by\n  // the DuplicateProperty query\n  not p.getInit().(DuplicatePropertyInitDetector).same(q.getInit())\n}\n\nfrom Property p, Property q\nwhere\n  overwrittenBy(p, q) and\n  // ensure that `q` is the last property with the same name as `p`\n  not overwrittenBy(q, _)\nselect p, \"This property is overwritten by $@ in the same object literal.\", q, \"another property\"",
        "description": "If an object literal has two properties with the same name, the second property overwrites the first one, which makes the code hard to understand and error-prone.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/UniquePropertyNames.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import Declarations.Declarations\n\nfrom Variable v, TopLevel tl, VarDecl decl, VarDecl redecl\nwhere\n  decl = firstRefInTopLevel(v, Decl(), tl) and\n  redecl = refInTopLevel(v, Decl(), tl) and\n  redecl != decl and\n  not tl.isExterns() and\n  // Ignore redeclared ambient declarations, such as overloaded functions.\n  not decl.isAmbient() and\n  not redecl.isAmbient() and\n  // Redeclaring a namespace extends the previous definition.\n  not decl = any(NamespaceDeclaration ns).getIdentifier() and\n  not redecl = any(NamespaceDeclaration ns).getIdentifier()\nselect redecl, \"This variable has already $@.\", decl, \"been declared\"",
        "description": "Declaring the same variable twice is confusing and may even suggest a latent bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/RedeclaredVariable.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate onlyWritten(Variable v) {\n  forall(VarAccess va | va = v.getAnAccess() | exists(Assignment assgn | assgn.getTarget() = va))\n}\n\nfrom Variable v, GlobalVarAccess gva\nwhere\n  v = gva.getVariable() and\n  onlyWritten(v) and\n  // 'v' is not externally declared...\n  not exists(ExternalVarDecl d | d.getName() = v.getName() |\n    // ...as a member of {Window,Worker,WebWorker}.prototype\n    d.(ExternalInstanceMemberDecl).getBaseName() = [\"Window\", \"Worker\", \"WebWorker\"]\n    or\n    // ...or as a member of window\n    d.(ExternalStaticMemberDecl).getBaseName() = \"window\"\n    or\n    // ...or as a global\n    d instanceof ExternalGlobalDecl\n  ) and\n  // it isn't declared using a linter directive\n  not exists(Linting::GlobalDeclaration decl | decl.declaresGlobalForAccess(gva)) and\n  // ignore accesses under 'with', since they may well refer to properties of the with'ed object\n  not exists(WithStmt with | with.mayAffect(gva))\nselect gva, \"This definition of \" + v.getName() + \" is useless, since its value is never read.\"",
        "description": "An assignment to a global variable that is never used has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/DeadStoreOfGlobal.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport DeadStore\n\npredicate deadStoreOfLocal(VarDef vd, PurelyLocalVariable v) {\n  v = vd.getAVariable() and\n  (exists(vd.getSource()) or exists(vd.getDestructuringSource())) and\n  // the definition is not in dead code\n  exists(ReachableBasicBlock rbb | vd = rbb.getANode()) and\n  // but it has no associated SSA definition, that is, it is dead\n  not exists(SsaExplicitDefinition ssa | ssa.defines(vd, v))\n}\n\nfrom VarDef dead, PurelyLocalVariable v, string msg\nwhere\n  deadStoreOfLocal(dead, v) and\n  // the variable should be accessed somewhere; otherwise it will be flagged by UnusedVariable\n  exists(v.getAnAccess()) and\n  // don't flag ambient variable definitions\n  not dead.(AstNode).isAmbient() and\n  // don't flag variables with ambient uses\n  not exists(LexicalAccess access |\n    access.getALexicalName() = v.getADeclaration().getALexicalName() and\n    access.isAmbient()\n  ) and\n  // don't flag function expressions\n  not exists(FunctionExpr fe | dead = fe.getIdentifier()) and\n  // don't flag function declarations nested inside blocks or other compound statements;\n  // their meaning is only partially specified by the standard\n  not exists(FunctionDeclStmt fd, StmtContainer outer |\n    dead = fd.getIdentifier() and outer = fd.getEnclosingContainer()\n  |\n    not fd = outer.getBody().(BlockStmt).getAStmt()\n  ) and\n  // don't flag overwrites with `null` or `undefined`\n  not SyntacticConstants::isNullOrUndefined(dead.getSource()) and\n  // don't flag default inits that are later overwritten\n  not (isDefaultInit(dead.getSource().(Expr).getUnderlyingValue()) and dead.isOverwritten(v)) and\n  // don't flag assignments in externs\n  not dead.(AstNode).inExternsFile() and\n  // don't flag exported variables\n  not any(ES2015Module m).exportsAs(v, _) and\n  // don't flag 'exports' assignments in closure modules\n  not any(Closure::ClosureModule mod).getExportsVariable() = v and\n  (\n    // To avoid confusion about the meaning of \"definition\" and \"declaration\" we avoid\n    // the term \"definition\" when the alert location is a variable declaration.\n    if\n      dead instanceof VariableDeclarator and\n      not exists(SsaImplicitInit init | init.getVariable().getSourceVariable() = v) // the variable is dead at the hoisted implicit initialization.\n    then msg = \"The initial value of \" + v.getName() + \" is unused, since it is always overwritten.\"\n    else msg = \"The value assigned to \" + v.getName() + \" here is unused.\"\n  ) and\n  // ignore Angular templates\n  not dead.(AstNode).getTopLevel() instanceof Angular2::TemplateTopLevel\nselect dead, msg",
        "description": "An assignment to a local variable that is not used later on, or whose value is always overwritten, has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/DeadStoreOfLocal.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom Function f\nwhere\n  not f.inExternsFile() and\n  f.getNumParameter() > 7 and\n  // exclude AMD modules\n  not exists(AmdModuleDefinition m | f = m.getFactoryNode().(DataFlow::FunctionNode).getAstNode())\nselect f.(FirstLineOf),\n  capitalize(f.describe()) + \" has too many parameters (\" + f.getNumParameter() + \").\"",
        "description": "Functions with many parameters are hard to read and hard to use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/TooManyParameters.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport Expressions.DOMProperties\nimport DeadStore\n\npredicate unambiguousPropWrite(DataFlow::PropWrite write) {\n  exists(DataFlow::SourceNode base, string name |\n    write = base.getAPropertyWrite(name) and\n    not exists(DataFlow::SourceNode otherBase |\n      otherBase != base and\n      write = otherBase.getAPropertyWrite(name)\n    )\n  )\n}\n\npredicate postDominatedPropWrite(\n  string name, DataFlow::PropWrite assign1, DataFlow::PropWrite assign2, boolean local\n) {\n  exists(DataFlow::SourceNode base |\n    assign1 = base.getAPropertyWrite(name) and\n    assign2 = base.getAPropertyWrite(name)\n  ) and\n  exists(\n    ControlFlowNode write1, ControlFlowNode write2, ReachableBasicBlock block1,\n    ReachableBasicBlock block2\n  |\n    write1 = assign1.getWriteNode() and\n    write2 = assign2.getWriteNode() and\n    block1 = write1.getBasicBlock() and\n    block2 = write2.getBasicBlock() and\n    unambiguousPropWrite(assign1) and\n    unambiguousPropWrite(assign2) and\n    (\n      block2.strictlyPostDominates(block1) and local = false\n      or\n      block1 = block2 and\n      local = true and\n      getRank(block1, write1, name) < getRank(block2, write2, name)\n    )\n  )\n}\n\nint getRank(ReachableBasicBlock bb, ControlFlowNode ref, string name) {\n  ref =\n    rank[result](ControlFlowNode e |\n      isAPropertyWrite(e, name) or\n      isAPropertyRead(e, name)\n    |\n      e order by any(int i | e = bb.getNode(i))\n    )\n}\n\npredicate isAPropertyRead(Expr e, string name) {\n  exists(DataFlow::PropRead read | read.asExpr() = e and read.getPropertyName() = name)\n}\n\npredicate isAPropertyWrite(ControlFlowNode e, string name) {\n  exists(DataFlow::PropWrite write | write.getWriteNode() = e and write.getPropertyName() = name)\n}\n\nbindingset[name]\npredicate maybeAccessesProperty(Expr e, string name) {\n  isAPropertyRead(e, name)\n  or\n  // conservatively reject all side-effects\n  e.isImpure()\n}\n\npredicate isDeadAssignment(string name, DataFlow::PropWrite assign1, DataFlow::PropWrite assign2) {\n  (\n    noPropAccessBetweenInsideBasicBlock(name, assign1, assign2) or\n    noPropAccessBetweenAcrossBasicBlocks(name, assign1, assign2)\n  ) and\n  not isDomProperty(name)\n}\n\npredicate noPropAccessBetweenInsideBasicBlock(\n  string name, DataFlow::PropWrite assign1, DataFlow::PropWrite assign2\n) {\n  assign2.getWriteNode() = getANodeWithNoPropAccessBetweenInsideBlock(name, assign1) and\n  postDominatedPropWrite(name, assign1, assign2, true)\n}\n\npredicate maybeAssignsAccessedPropInBlock(DataFlow::PropWrite assign, boolean after) {\n  (\n    // early pruning - manual magic\n    after = true and postDominatedPropWrite(_, assign, _, false)\n    or\n    after = false and postDominatedPropWrite(_, _, assign, false)\n  ) and\n  (\n    // direct property write before/after assign\n    exists(ReachableBasicBlock block, int i, int j, Expr e, string name |\n      i = getRank(block, assign.getWriteNode(), name) and\n      j = getRank(block, e, name) and\n      isAPropertyRead(e, name)\n    |\n      after = true and i < j\n      or\n      after = false and j < i\n    )\n    or\n    // impure expression that might access the property before/after assign\n    exists(ReachableBasicBlock block | assign.getWriteNode().getBasicBlock() = block |\n      after = true and PurityCheck::isBeforeImpure(assign, block)\n      or\n      after = false and PurityCheck::isAfterImpure(assign, block)\n    )\n  )\n}\n\nprivate module PurityCheck {\n  /**\n   * Holds if `write` is before an impure expression inside `bb`.\n   */\n  predicate isBeforeImpure(DataFlow::PropWrite write, ReachableBasicBlock bb) {\n    getANodeAfterWrite(write, bb).(Expr).isImpure()\n  }\n\n  /**\n   * Gets a ControlFlowNode that comes after `write` inside `bb`.\n   * Stops after finding the first impure expression.\n   *\n   * This predicate is used as a helper to check if one of the successors to `write` inside `bb` is impure (see `isBeforeImpure`).\n   */\n  private ControlFlowNode getANodeAfterWrite(DataFlow::PropWrite write, ReachableBasicBlock bb) {\n    // base case\n    result.getBasicBlock() = bb and\n    postDominatedPropWrite(_, write, _, false) and // early pruning - manual magic\n    result = write.getWriteNode().getASuccessor()\n    or\n    // recursive case\n    exists(ControlFlowNode prev | prev = getANodeAfterWrite(write, bb) |\n      not result instanceof BasicBlock and\n      not prev.(Expr).isImpure() and\n      result = prev.getASuccessor()\n    )\n  }\n\n  /**\n   * Holds if `write` is after an impure expression inside `bb`.\n   */\n  predicate isAfterImpure(DataFlow::PropWrite write, ReachableBasicBlock bb) {\n    getANodeBeforeWrite(write, bb).(Expr).isImpure()\n  }\n\n  /**\n   * Gets a ControlFlowNode that comes before `write` inside `bb`.\n   * Stops after finding the first impure expression.\n   *\n   * This predicate is used as a helper to check if one of the predecessors to `write` inside `bb` is impure (see `isAfterImpure`).\n   */\n  private ControlFlowNode getANodeBeforeWrite(DataFlow::PropWrite write, ReachableBasicBlock bb) {\n    // base case\n    result.getBasicBlock() = bb and\n    postDominatedPropWrite(_, _, write, false) and // early pruning - manual magic\n    result = write.getWriteNode().getAPredecessor()\n    or\n    // recursive case\n    exists(ControlFlowNode prev | prev = getANodeBeforeWrite(write, bb) |\n      not prev instanceof BasicBlock and\n      not prev.(Expr).isImpure() and\n      result = prev.getAPredecessor()\n    )\n  }\n}\n\nControlFlowNode getANodeWithNoPropAccessBetweenInsideBlock(string name, DataFlow::PropWrite write) {\n  (\n    // base case.\n    result = write.getWriteNode().getASuccessor() and\n    postDominatedPropWrite(name, write, _, true) // manual magic - cheap check that there might exist a result we are interrested in,\n    or\n    // recursive case\n    result = getANodeWithNoPropAccessBetweenInsideBlock(name, write).getASuccessor()\n  ) and\n  // stop at basic-block boundaries\n  not result instanceof BasicBlock and\n  // stop at reads of `name` and at impure expressions (except writes to `name`)\n  not (\n    maybeAccessesProperty(result, name) and\n    not isAPropertyWrite(result, name)\n  ) and\n  // stop at the first write to `name` that comes after `write`.\n  (\n    not isAPropertyWrite(result.getAPredecessor(), name)\n    or\n    result.getAPredecessor() = write.getWriteNode()\n  )\n}\n\npragma[nomagic]\npredicate noPropAccessBetweenAcrossBasicBlocks(\n  string name, DataFlow::PropWrite assign1, DataFlow::PropWrite assign2\n) {\n  exists(\n    ControlFlowNode write1, ControlFlowNode write2, ReachableBasicBlock block1,\n    ReachableBasicBlock block2\n  |\n    postDominatedPropWrite(name, assign1, assign2, false) and // manual magic - early pruning\n    write1 = assign1.getWriteNode() and\n    not maybeAssignsAccessedPropInBlock(assign1, true) and\n    write2 = assign2.getWriteNode() and\n    not maybeAssignsAccessedPropInBlock(assign2, false) and\n    write1.getBasicBlock() = block1 and\n    write2.getBasicBlock() = block2 and\n    not block1 = block2 and\n    // check for an access between the two write blocks\n    not exists(ReachableBasicBlock mid |\n      block1.getASuccessor+() = mid and\n      mid.getASuccessor+() = block2\n    |\n      maybeAccessesProperty(mid.getANode(), name)\n    )\n  )\n}\n\nfrom string name, DataFlow::PropWrite assign1, DataFlow::PropWrite assign2\nwhere\n  isDeadAssignment(name, assign1, assign2) and\n  // whitelist\n  not (\n    // Google Closure Compiler pattern: `o.p = o['p'] = v`\n    exists(PropAccess p1, PropAccess p2 |\n      p1 = assign1.getAstNode() and\n      p2 = assign2.getAstNode()\n    |\n      p1 instanceof DotExpr and p2 instanceof IndexExpr\n      or\n      p2 instanceof DotExpr and p1 instanceof IndexExpr\n    )\n    or\n    // don't flag overwrites for default values\n    isDefaultInit(assign1.getRhs().asExpr().getUnderlyingValue())\n    or\n    // don't flag assignments in externs\n    assign1.getAstNode().inExternsFile()\n    or\n    // exclude result from js/overwritten-property\n    assign2.getBase() instanceof DataFlow::ObjectLiteralNode\n    or\n    // exclude result from accessor declarations\n    assign1.getWriteNode() instanceof AccessorMethodDeclaration\n  ) and\n  // exclude results from non-value definitions from `Object.defineProperty`\n  (\n    assign1 instanceof CallToObjectDefineProperty\n    implies\n    assign1.(CallToObjectDefineProperty).hasPropertyAttributeWrite(\"value\", _)\n  ) and\n  // ignore Angular templates\n  not assign1.getTopLevel() instanceof Angular2::TemplateTopLevel\nselect assign1.getWriteNode(),\n  \"This write to property '\" + name + \"' is useless, since $@ always overrides it.\",\n  assign2.getWriteNode(), \"another property write\"",
        "description": "An assignment to a property whose value is always overwritten has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/DeadStoreOfProperty.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom DeclStmt vds, VariableDeclarator vd1, VariableDeclarator vd2, int i, int j, Variable v\nwhere\n  vd1 = vds.getDecl(i) and\n  vd2 = vds.getDecl(j) and\n  v = vd1.getBindingPattern().getAVariable() and\n  v = vd2.getBindingPattern().getAVariable() and\n  i < j and\n  // exclude a somewhat common pattern where the first declaration is used as a temporary\n  exists(Expr e1, Expr e2 | e1 = vd1.getInit() and e2 = vd2.getInit() |\n    not v.getAnAccess().getParentExpr*() = e2\n  )\nselect vd2.(FirstLineOf), \"This initialization of \" + v.getName() + \" overwrites an $@.\", vd1,\n  \"earlier initialization\"",
        "description": "If a variable is declared and initialized twice inside the same variable declaration statement, the second initialization immediately overwrites the first one.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/ClobberingVarInit.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nint letDeclAt(BlockStmt blk, Variable v, LetStmt let) {\n  let.getADecl().getBindingPattern().getAVariable() = v and\n  let.getParentStmt*() = blk.getStmt(result)\n}\n\nfrom VarAccess va, LetStmt let, BlockStmt blk, int i, int j, Variable v\nwhere\n  v = va.getVariable() and\n  j = letDeclAt(blk, v, let) and\n  blk.getStmt(i) = va.getEnclosingStmt().getParentStmt*() and\n  i < j and\n  // don't flag uses in different functions\n  blk.getContainer() = va.getContainer() and\n  not letDeclAt(blk, v, _) < i\nselect va, \"This expression refers to $@ inside its temporal dead zone.\", let, va.getName()",
        "description": "Accessing a let-bound variable before its declaration will lead to a runtime error on ECMAScript 2015-compatible platforms.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/TemporalDeadZone.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nGlobalVariable undeclaredGlobalIn(Function f) {\n  exists(GlobalVarAccess gva | gva = result.getAnAccess() |\n    gva.getEnclosingFunction() = f and\n    not result.declaredIn(f.getTopLevel()) and\n    not exists(Linting::GlobalDeclaration gd | gd.declaresGlobalForAccess(gva))\n  )\n}\n\nGlobalVariable accidentalGlobalIn(Function f) {\n  result = undeclaredGlobalIn(f) and\n  exists(BasicBlock startBB | startBB = f.getStartBB() | not startBB.isLiveAtEntry(result))\n}\n\nGlobalVariable candidateVariable(Function f) {\n  result = accidentalGlobalIn(f) and\n  f.getStartBB().getASuccessor*().useAt(_, result, _)\n}\n\nGlobalVarAccess getAccessIn(GlobalVariable v, Function f) {\n  result.getEnclosingFunction() = f and\n  result = v.getAnAccess()\n}\n\nGlobalVarAccess getFirstAccessIn(GlobalVariable v, Function f) {\n  result =\n    min(getAccessIn(v, f) as gva\n      order by\n        gva.getLocation().getStartLine(), gva.getLocation().getStartColumn()\n    )\n}\n\nfrom Function f, GlobalVariable gv\nwhere gv = candidateVariable(f)\nselect getFirstAccessIn(gv, f),\n  \"Variable \" + gv.getName() + \" is used like a local variable, but is missing a declaration.\"",
        "description": "If a variable is not declared as a local variable, it becomes a global variable by default, which may be unintentional and could lead to unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/MissingVarDecl.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate maybeMissingThis(CallExpr call, MethodDeclaration intendedTarget, GlobalVariable gv) {\n  call.getCallee() = gv.getAnAccess() and\n  call.getCalleeName() = intendedTarget.getName() and\n  exists(MethodDefinition caller |\n    caller.getBody() = getRelevantCallExprContainer(call) and\n    intendedTarget.getDeclaringClass() = caller.getDeclaringClass()\n  )\n}\n\npragma[noinline]\nprivate StmtContainer getRelevantCallExprContainer(CallExpr c) {\n  result = c.getContainer() and\n  c.getCallee() = any(GlobalVariable v).getAnAccess()\n}\n\nfrom CallExpr call, MethodDeclaration intendedTarget, GlobalVariable gv\nwhere\n  maybeMissingThis(call, intendedTarget, gv) and\n  // exceptions:\n  not (\n    // affected by `with`\n    exists(WithStmt with | with.mayAffect(call.getCallee()))\n    or\n    // locally declared, so probably intentional\n    gv.getADeclaration().getTopLevel() = call.getTopLevel()\n    or\n    // linter declaration for the variable\n    exists(Linting::GlobalDeclaration glob | glob.declaresGlobalForAccess(call.getCallee()))\n    or\n    // externs declaration for the variable\n    exists(ExternalGlobalDecl egd | egd.getName() = call.getCalleeName())\n    or\n    // variable available through a namespace\n    exists(Variable decl |\n      decl.getName() = gv.getName() and\n      decl.isNamespaceExport() and\n      getRelevantCallExprContainer(call).getEnclosingContainer*() instanceof NamespaceDeclaration\n    )\n    or\n    // call to global function with additional arguments\n    exists(Function self |\n      intendedTarget.getBody() = self and\n      call.getEnclosingFunction() = self and\n      call.flow().(DataFlow::CallNode).getNumArgument() > self.getNumParameter() and\n      not self.hasRestParameter() and\n      not self.usesArgumentsObject()\n    )\n  )\nselect call, \"This call refers to a global function, and not the local method $@.\", intendedTarget,\n  intendedTarget.getName()",
        "description": "Referencing an undeclared global variable in a class that has a member of the same name is confusing and may indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/MissingThisQualifier.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport Declarations.UnusedVariable\n\npredicate mentionedInJSDocComment(UnusedLocal v) {\n  exists(Externs ext, JSDoc jsdoc |\n    ext = v.getADeclaration().getTopLevel() and jsdoc.getComment().getTopLevel() = ext\n  |\n    jsdoc.getComment().getText().regexpMatch(\"(?s).*\\\\b\" + v.getName() + \"\\\\b.*\")\n  )\n}\n\npredicate isPropertyFilter(UnusedLocal v) {\n  exists(ObjectPattern op | exists(op.getRest()) |\n    op.getAPropertyPattern().getValuePattern() = v.getADeclaration()\n  )\n}\n\npredicate hasJsxInScope(UnusedLocal v) {\n  any(JsxNode n).getParent+() = v.getScope().getScopeElement()\n}\n\npredicate isReactForJsx(UnusedLocal v) {\n  hasJsxInScope(v) and\n  (\n    v.getName() = \"React\"\n    or\n    exists(TopLevel tl | tl = v.getADeclaration().getTopLevel() |\n      // legacy `@jsx` pragmas\n      exists(JsxPragma p | p.getTopLevel() = tl | p.getDomName() = v.getName())\n      or\n      // JSX pragma from a .babelrc file\n      exists(Babel::TransformReactJsxConfig plugin |\n        plugin.appliesTo(tl) and\n        plugin.getJsxFactoryVariableName() = v.getName()\n      )\n    )\n    or\n    exists(JsonObject tsconfig |\n      tsconfig.isTopLevel() and tsconfig.getFile().getBaseName() = \"tsconfig.json\"\n    |\n      v.getName() =\n        tsconfig\n            .getPropValue(\"compilerOptions\")\n            .getPropValue([\"jsxFactory\", \"jsxFragmentFactory\"])\n            .getStringValue()\n    )\n  )\n}\n\npredicate isUsedAsType(VarDecl decl) { exists(decl.(TypeDecl).getLocalTypeName().getAnAccess()) }\n\npredicate isUsedAsNamespace(VarDecl decl) {\n  exists(decl.(LocalNamespaceDecl).getLocalNamespaceName().getAnAccess())\n}\n\npredicate isDecorated(VarDecl decl) {\n  exists(ClassDefinition cd | cd.getIdentifier() = decl | exists(cd.getDecorator(_)))\n  or\n  exists(EnumDeclaration cd | cd.getIdentifier() = decl | exists(cd.getDecorator(_)))\n}\n\npredicate isEnumMember(VarDecl decl) { decl = any(EnumMember member).getIdentifier() }\n\nstring describeVarDecl(VarDecl vd) {\n  if vd = any(Function f).getIdentifier()\n  then result = \"function \" + vd.getName()\n  else\n    if vd = any(ClassDefinition c).getIdentifier()\n    then result = \"class \" + vd.getName()\n    else result = \"variable \" + vd.getName()\n}\n\nclass ImportVarDeclProvider extends Stmt {\n  ImportVarDeclProvider() {\n    this instanceof ImportDeclaration or\n    this instanceof ImportEqualsDeclaration\n  }\n\n  /**\n   * Gets a variable declaration of this import.\n   */\n  VarDecl getAVarDecl() {\n    result = this.(ImportDeclaration).getASpecifier().getLocal() or\n    result = this.(ImportEqualsDeclaration).getIdentifier()\n  }\n\n  /**\n   * Gets an unacceptable unused variable declared by this import.\n   */\n  UnusedLocal getAnUnacceptableUnusedLocal() {\n    result = this.getAVarDecl().getVariable() and\n    not whitelisted(result)\n  }\n}\n\npredicate whitelisted(UnusedLocal v) {\n  // exclude variables mentioned in JSDoc comments in externs\n  mentionedInJSDocComment(v)\n  or\n  // the attributes in .vue files are not extracted, so we can get false positives in those.\n  v.getADeclaration().getFile().getExtension() = \"vue\"\n  or\n  // exclude variables used to filter out unwanted properties\n  isPropertyFilter(v)\n  or\n  // exclude imports of React that are implicitly referenced by JSX\n  isReactForJsx(v)\n  or\n  // exclude names that are used as types\n  exists(VarDecl vd | v = vd.getVariable() |\n    isUsedAsType(vd)\n    or\n    // exclude names that are used as namespaces from inside a type\n    isUsedAsNamespace(vd)\n    or\n    // exclude decorated functions and classes\n    isDecorated(vd)\n    or\n    // exclude names of enum members; they also define property names\n    isEnumMember(vd)\n    or\n    // ignore ambient declarations - too noisy\n    vd.isAmbient()\n    or\n    // ignore variables in template placeholders, as each placeholder sees a different copy of the variable\n    vd.getTopLevel() instanceof Templating::TemplateTopLevel\n  )\n  or\n  exists(Expr eval | eval instanceof DirectEval or eval instanceof GeneratedCodeExpr |\n    // eval nearby\n    eval.getEnclosingFunction() = v.getADeclaration().getEnclosingFunction() and\n    // ... but not on the RHS\n    not v.getAnAssignedExpr() = eval\n  )\n}\n\npredicate unusedNonImports(VarDecl vd, string msg) {\n  exists(UnusedLocal v |\n    v = vd.getVariable() and\n    msg = \"Unused \" + describeVarDecl(vd) + \".\" and\n    not vd = any(ImportVarDeclProvider p).getAVarDecl() and\n    not whitelisted(v)\n  )\n}\n\npredicate unusedImports(ImportVarDeclProvider provider, string msg) {\n  exists(string imports, string names |\n    imports = pluralize(\"import\", count(provider.getAnUnacceptableUnusedLocal())) and\n    names = strictconcat(provider.getAnUnacceptableUnusedLocal().getName(), \", \") and\n    msg = \"Unused \" + imports + \" \" + names + \".\"\n  )\n}\n\nfrom AstNode sel, string msg\nwhere\n  (\n    unusedNonImports(sel, msg) or\n    unusedImports(sel, msg)\n  ) and\n  // avoid reporting if the definition is unreachable\n  sel.getFirstControlFlowNode().getBasicBlock() instanceof ReachableBasicBlock\nselect sel, msg",
        "description": "Unused variables, imports, functions or classes may be a symptom of a bug and should be examined carefully.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Declarations/UnusedVariable.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom JSDocParamTag parm, string missing\nwhere\n  // JSDoc comments in externs files are not necessarily meant for human readers, so don't complain\n  not parm.getFile().getATopLevel().isExterns() and\n  (\n    not exists(parm.getName()) and missing = \"name\"\n    or\n    (not exists(parm.getDescription()) or parm.getDescription().regexpMatch(\"\\\\s*\")) and\n    missing = \"description\"\n  )\nselect parm, \"@param tag is missing \" + missing + \".\"",
        "description": "A 'param' tag that does not include a name is confusing since it is unclear which parameter it is meant to document. A 'param' tag that does not include a description is useless and should be removed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/JSDoc/BadParamTag.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Function f, Parameter parm, Variable v, JSDoc doc\nwhere\n  parm = f.getAParameter() and\n  doc = f.getDocumentation() and\n  v = parm.getAVariable() and\n  // at least one parameter is documented\n  exists(doc.getATag().(JSDocParamTag).getDocumentedParameter()) and\n  // but v is not\n  not doc.getATag().(JSDocParamTag).getDocumentedParameter() = v and\n  // don't report an alert in ambiguous cases\n  strictcount(JSDoc d | d = f.getDocumentation() and d.getATag() instanceof JSDocParamTag) = 1\nselect parm, \"Parameter \" + v.getName() + \" is not documented.\"",
        "description": "If some parameters of a function are documented by JSDoc 'param' tags while others are not, this may indicate badly maintained code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/JSDoc/UndocumentedParameter.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Function f, JSDoc doc, JSDocParamTag tag, string parmName\nwhere\n  doc = f.getDocumentation() and\n  tag = doc.getATag() and\n  parmName = tag.getName() and\n  tag.documentsSimpleName() and\n  not exists(f.getParameterByName(parmName)) and\n  // don't report functions without declared parameters that use `arguments`\n  not (f.getNumParameter() = 0 and f.usesArgumentsObject()) and\n  // don't report a violation in ambiguous cases\n  strictcount(JSDoc d | d = f.getDocumentation() and d.getATag() instanceof JSDocParamTag) = 1\nselect tag, \"@param tag refers to non-existent parameter \" + parmName + \".\"",
        "description": "A JSDoc 'param' tag that refers to a non-existent parameter is confusing and may indicate badly maintained code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/JSDoc/JSDocForNonExistentParameter.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom LabeledStmt l, Case c\nwhere\n  l = c.getAChildStmt+() and\n  l.getLocation().getStartColumn() = c.getLocation().getStartColumn()\nselect l.getChildExpr(0), \"Non-case labels in switch statements are confusing.\"",
        "description": "A non-case label appearing in a switch statement that is textually aligned with a case label is confusing to read, or may even indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/LabelInCase.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport Expressions.ExprHasNoEffect\n\nDataFlow::SourceNode callsArray(DataFlow::TypeBackTracker t, DataFlow::MethodCallNode call) {\n  isIgnoredPureArrayCall(call) and\n  t.start() and\n  result = call.getReceiver().getALocalSource()\n  or\n  exists(DataFlow::TypeBackTracker t2 | result = callsArray(t2, call).backtrack(t2, t))\n}\n\nDataFlow::SourceNode callsArray(DataFlow::MethodCallNode call) {\n  result = callsArray(DataFlow::TypeBackTracker::end(), call)\n}\n\npredicate isIgnoredPureArrayCall(DataFlow::MethodCallNode call) {\n  inVoidContext(call.asExpr()) and\n  (\n    call.getMethodName() = \"concat\" and\n    call.getNumArgument() = 1\n    or\n    call.getMethodName() = \"join\" and\n    call.getNumArgument() < 2\n    or\n    call.getMethodName() = \"slice\" and\n    call.getNumArgument() < 3\n  )\n}\n\nfrom DataFlow::MethodCallNode call\nwhere\n  callsArray(call) instanceof DataFlow::ArrayCreationNode and\n  not call.getReceiver().asExpr().(ArrayExpr).getSize() = 0\nselect call, \"Result from call to \" + call.getMethodName() + \" ignored.\"",
        "description": "Ignoring the result of an array method that does not modify its receiver is generally an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/IgnoreArrayResult.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate bounds(RelationalComparison test, Variable v, string direction) {\n  test.getLesserOperand() = v.getAnAccess() and direction = \"upward\"\n  or\n  test.getGreaterOperand() = v.getAnAccess() and direction = \"downward\"\n}\n\npredicate updates(UpdateExpr upd, Variable v, string direction) {\n  upd.getOperand() = v.getAnAccess() and\n  (\n    upd instanceof IncExpr and direction = \"upward\"\n    or\n    upd instanceof DecExpr and direction = \"downward\"\n  )\n}\n\nfrom ForStmt l, Variable v, string d1, string d2\nwhere\n  bounds(l.getTest(), v, d1) and\n  updates(l.getUpdate(), v, d2) and\n  d1 != d2\nselect l, \"This loop counts \" + d2 + \", but its variable is bounded \" + d1 + \".\"",
        "description": "A 'for' loop that increments its loop variable but checks it against a lower bound, or decrements its loop variable but checks it against an upper bound, will either stop iterating immediately or keep iterating indefinitely, and is usually indicative of a typo.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/InconsistentLoopOrientation.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom ReturnStmt ret, TopLevel tl\nwhere\n  tl = ret.getContainer() and\n  not tl instanceof EventHandlerCode and\n  not tl instanceof NodeModule\nselect ret.(FirstLineOf), \"Return statement outside function.\"",
        "description": "A 'return' statement appearing outside a function will cause an error when it is executed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/ReturnOutsideFunction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom Stmt s\nwhere\n  // `s` is unreachable in the CFG\n  s.getFirstControlFlowNode().isUnreachable() and\n  // the CFG does not model all possible exceptional control flow, so be conservative about catch clauses\n  not s instanceof CatchClause and\n  // function declarations are special and always reachable\n  not s instanceof FunctionDeclStmt and\n  // allow a spurious 'break' statement at the end of a switch-case\n  not exists(Case c, int i | i = c.getNumBodyStmt() | s.(BreakStmt) = c.getBodyStmt(i - 1)) and\n  // ignore ambient statements\n  not s.isAmbient() and\n  // ignore empty statements\n  not s instanceof EmptyStmt and\n  // ignore unreachable throws\n  not s instanceof ThrowStmt\nselect s.(FirstLineOf), \"This statement is unreachable.\"",
        "description": "Unreachable statements are often indicative of missing code or latent bugs and should be avoided.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/UnreachableStatement.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\nimport semmle.javascript.dataflow.Refinements\nimport semmle.javascript.DefensiveProgramming\nimport UselessConditional\n\nVarDef getSingleDef(Variable v) {\n  strictcount(VarDef vd | vd.getAVariable() = v) = 1 and\n  result.getTarget() = v.getAReference()\n}\n\npredicate isSymbolicConstant(Variable v) {\n  exists(VarDef vd | vd = getSingleDef(v) |\n    vd.(VariableDeclarator).getDeclStmt() instanceof ConstDeclStmt\n    or\n    vd.(VariableDeclarator).getDeclStmt() instanceof UsingDeclStmt\n    or\n    isConstant(vd.getSource())\n  )\n}\n\npredicate isConstant(Expr e) {\n  e instanceof Literal or\n  isSymbolicConstant(e.(VarAccess).getVariable())\n}\n\npredicate isInitialParameterUse(Expr e) {\n  // unlike `SimpleParameter.getAnInitialUse` this will not include uses we have refinement information for\n  exists(SimpleParameter p, SsaExplicitDefinition ssa |\n    ssa.getDef() = p and\n    ssa.getVariable().getAUse() = e and\n    not p.isRestParameter()\n  )\n  or\n  // same as above, but for captured variables\n  exists(SimpleParameter p, LocalVariable var |\n    var = p.getVariable() and\n    var.isCaptured() and\n    e = var.getAnAccess() and\n    not p.isRestParameter()\n  )\n  or\n  isInitialParameterUse(e.(LogNotExpr).getOperand())\n}\n\npredicate isConstantBooleanReturnValue(Expr e) {\n  // unlike `SourceNode.flowsTo` this will not include uses we have refinement information for\n  exists(string b | (b = \"true\" or b = \"false\") |\n    forex(DataFlow::CallNode call, Expr ret |\n      ret = call.getACallee().getAReturnedExpr() and\n      (\n        e = call.asExpr()\n        or\n        // also support return values that are assigned to variables\n        exists(SsaExplicitDefinition ssa |\n          ssa.getDef().getSource() = call.asExpr() and\n          ssa.getVariable().getAUse() = e\n        )\n      )\n    |\n      ret.(BooleanLiteral).getValue() = b\n    )\n  )\n  or\n  isConstantBooleanReturnValue(e.(LogNotExpr).getOperand())\n}\n\nprivate Expr maybeStripLogNot(Expr e) {\n  result = maybeStripLogNot(e.(LogNotExpr).getOperand()) or\n  result = e\n}\n\npredicate isConstantDefensive(Expr e) {\n  exists(DefensiveExpressionTest defensive |\n    maybeStripLogNot(defensive.asExpr()) = e and\n    exists(defensive.getTheTestResult())\n  )\n}\n\npredicate whitelist(Expr e) {\n  isConstant(e) or\n  isConstant(e.(LogNotExpr).getOperand()) or\n  isConstantDefensive(e) or // flagged by js/useless-defensive-code\n  isInitialParameterUse(e) or\n  isConstantBooleanReturnValue(e)\n}\n\npredicate isConditional(AstNode cond, Expr e) {\n  isExplicitConditional(cond, e) or\n  e = cond.(LogicalBinaryExpr).getLeftOperand()\n}\n\nfrom AstNode cond, DataFlow::AnalyzedNode op, boolean cv, AstNode sel, string msg\nwhere\n  isConditional(cond, op.asExpr()) and\n  cv = op.getTheBooleanValue() and\n  not whitelist(op.asExpr()) and\n  // if `cond` is of the form `<non-trivial truthy expr> && <something>`,\n  // we suggest replacing it with `<non-trivial truthy expr>, <something>`\n  if cond.(LogAndExpr).getLeftOperand() = op.asExpr() and cv = true and not op.asExpr().isPure()\n  then (\n    sel = cond and msg = \"This logical 'and' expression can be replaced with a comma expression.\"\n  ) else (\n    // otherwise we just report that `op` always evaluates to `cv`\n    sel = op.asExpr().stripParens() and\n    msg = \"This \" + describeExpression(sel) + \" always evaluates to \" + cv + \".\"\n  )\nselect sel, msg",
        "description": "If a conditional expression always evaluates to true or always evaluates to false, this suggests incomplete code or a logic error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/UselessConditional.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate hasContradictoryGuardNodes(StmtContainer container) {\n  exists(ConditionGuardNode guard |\n    RangeAnalysis::isContradictoryGuardNode(guard) and\n    container = guard.getContainer()\n  )\n}\n\npredicate isReachable(BasicBlock block) {\n  exists(StmtContainer container |\n    hasContradictoryGuardNodes(container) and\n    block = container.getEntryBB()\n  )\n  or\n  isReachable(block.getAPredecessor()) and\n  not RangeAnalysis::isContradictoryGuardNode(block.getANode())\n}\n\npredicate isBlockedByContradictoryGuardNodes(BasicBlock block, ConditionGuardNode guard) {\n  RangeAnalysis::isContradictoryGuardNode(guard) and\n  isReachable(block.getAPredecessor()) and // the guard itself is reachable\n  block = guard.getBasicBlock()\n  or\n  isBlockedByContradictoryGuardNodes(block.getAPredecessor(), guard) and\n  not isReachable(block)\n}\n\npredicate isGuardNodeWithDeadCode(ConditionGuardNode guard) {\n  exists(BasicBlock block |\n    isBlockedByContradictoryGuardNodes(block, guard) and\n    block.getANode() instanceof ExprOrStmt\n  )\n}\n\nfrom ConditionGuardNode guard\nwhere isGuardNodeWithDeadCode(guard)\nselect guard.getTest(),\n  \"The condition '\" + guard.getTest() + \"' is always \" + guard.getOutcome().booleanNot() + \".\"",
        "description": "A comparison that always evaluates to true or always evaluates to false may indicate faulty logic and dead code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/UselessComparisonTest.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\nimport semmle.javascript.frameworks.Emscripten\n\nfrom LoopStmt l, BasicBlock body\nwhere\n  body = l.getBody().getBasicBlock() and\n  not body.getASuccessor+() = body and\n  not l instanceof EnhancedForLoop and\n  // Emscripten generates lots of `do { ... } while(0);` loops, so exclude\n  not l.getTopLevel() instanceof EmscriptenGeneratedToplevel\nselect l.(FirstLineOf), \"This loop executes at most once.\"",
        "description": "A loop that executes at most once is confusing and should be rewritten as a conditional.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/EphemeralLoop.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Function f, ReturnStmt explicit, ReturnStmt implicit\nwhere\n  explicit.getContainer() = f and\n  implicit.getContainer() = f and\n  exists(explicit.getExpr()) and\n  not exists(implicit.getExpr())\nselect implicit,\n  \"This return statement implicitly returns 'undefined', whereas $@ returns an explicit value.\",\n  explicit, \"another return statement in the same function\"",
        "description": "A function should either always return an explicit value, or never return a value.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/InconsistentReturn.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass RelevantToken extends Token {\n  RelevantToken() { exists(string v | v = this.getValue() | v = \"if\" or v = \"else\" or v = \"}\") }\n}\n\npredicate prevTokenOnSameLine(RelevantToken tk, string val, Token prev, string prevVal) {\n  val = tk.getValue() and\n  prev = tk.getPreviousToken() and\n  prev.getLocation().getEndLine() = tk.getLocation().getStartLine() and\n  prevVal = prev.getValue()\n}\n\nint semanticIndent(RelevantToken tk) {\n  not prevTokenOnSameLine(tk, _, _, _) and\n  result = tk.getLocation().getStartColumn()\n  or\n  exists(RelevantToken prev |\n    prevTokenOnSameLine(tk, \"if\", prev, \"else\") or\n    prevTokenOnSameLine(tk, \"else\", prev, \"}\")\n  |\n    result = semanticIndent(prev)\n  )\n}\n\nint ifIndent(IfStmt i) { result = semanticIndent(i.getIfToken()) }\n\nint elseIndent(IfStmt i) { result = semanticIndent(i.getElseToken()) }\n\nfrom IfStmt outer, IfStmt inner, Token outerIf, Token innerIf, Token innerElse, int outerIndent\nwhere\n  inner = outer.getThen().getAChildStmt*() and\n  outerIf = outer.getIfToken() and\n  outerIndent = ifIndent(outer) and\n  innerIf = inner.getIfToken() and\n  innerElse = inner.getElseToken() and\n  outerIndent < ifIndent(inner) and\n  outerIndent = elseIndent(inner) and\n  not outer.getTopLevel().isMinified()\nselect innerElse, \"This else branch belongs to $@, but its indentation suggests it belongs to $@.\",\n  innerIf, \"this if statement\", outerIf, \"this other if statement\"",
        "description": "The 'else' clause of an 'if' statement should be aligned with the 'if' it belongs to.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/DanglingElse.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\npredicate isThrowOrReturn(Stmt s) {\n  s instanceof ReturnStmt or\n  s instanceof ThrowStmt or\n  s.(ExprStmt).getExpr().(CallExpr).getCalleeName().matches(\"%throw%\")\n}\n\nclass ValueReturn extends ReturnStmt {\n  ValueReturn() { exists(this.getExpr()) }\n}\n\nValueReturn getFirstExplicitReturn(Function f) {\n  result =\n    min(ValueReturn ret |\n      ret.getContainer() = f\n    |\n      ret order by ret.getLocation().getStartLine(), ret.getLocation().getStartColumn()\n    )\n}\n\nint numRet(Function f) { result = strictcount(ReturnStmt ret | ret.getContainer() = f) }\n\npredicate isDualUseConstructor(Function f) {\n  numRet(f) = 1 and\n  exists(ReturnStmt ret, DataFlow::NewNode new | ret.getContainer() = f |\n    new.asExpr() = ret.getExpr().getUnderlyingValue() and\n    new.getACallee() = f\n  )\n}\n\nStmt getAFallThroughStmt(Function f) {\n  exists(ReachableBasicBlock bb, ControlFlowNode nd |\n    bb.getANode() = nd and\n    nd.isAFinalNode() and\n    f = bb.getContainer() and\n    (result = nd or result = nd.(Expr).getEnclosingStmt()) and\n    not isThrowOrReturn(result) and\n    not exists(TryStmt try | result.getParentStmt+() = try.getFinally())\n  )\n}\n\nfrom Function f, Stmt fallthrough\nwhere\n  fallthrough = getAFallThroughStmt(f) and\n  // no control path ends with an implicit return statement of the form `return;`\n  not exists(ReturnStmt ret | ret.getContainer() = f and not exists(ret.getExpr())) and\n  // f doesn't look like a dual-use constructor (which otherwise would trigger a violation)\n  not isDualUseConstructor(f)\nselect fallthrough.(FirstLineOf),\n  \"$@ may implicitly return 'undefined' here, while $@ an explicit value is returned.\", f,\n  capitalize(f.describe()), getFirstExplicitReturn(f), \"elsewhere\"",
        "description": "Functions where some execution paths return an explicit value while others \"fall off\" the end of the function and return 'undefined' are hard to maintain and use.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/ImplicitReturn.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport Declarations.UnusedVariable\nimport Expressions.ExprHasNoEffect\nimport Statements.UselessConditional\n\npredicate returnsVoid(Function f) {\n  not f.isGenerator() and\n  not f.isAsync() and\n  not exists(f.getAReturnedExpr())\n}\n\npredicate isStub(Function f) {\n  f.getBody().(BlockStmt).getNumChild() = 0\n  or\n  f instanceof ExternalDecl\n}\n\npredicate benignContext(Expr e) {\n  inVoidContext(e)\n  or\n  // A return statement is often used to just end the function.\n  e = any(Function f).getBody()\n  or\n  e = any(ReturnStmt r).getExpr()\n  or\n  exists(ConditionalExpr cond | cond.getABranch() = e and benignContext(cond))\n  or\n  exists(LogicalBinaryExpr bin | bin.getAnOperand() = e and benignContext(bin))\n  or\n  exists(Expr parent | parent.getUnderlyingValue() = e and benignContext(parent))\n  or\n  any(VoidExpr voidExpr).getOperand() = e\n  or\n  // weeds out calls inside HTML-attributes.\n  e.getParent().(ExprStmt).getParent() instanceof CodeInAttribute\n  or\n  // and JSX-attributes.\n  e = any(JsxAttribute attr).getValue()\n  or\n  exists(AwaitExpr await | await.getOperand() = e and benignContext(await))\n  or\n  // Avoid double reporting with js/trivial-conditional\n  isExplicitConditional(_, e)\n  or\n  // Avoid double reporting with js/comparison-between-incompatible-types\n  any(Comparison binOp).getAnOperand() = e\n  or\n  // Avoid double reporting with js/property-access-on-non-object\n  any(PropAccess ac).getBase() = e\n  or\n  // Avoid double-reporting with js/unused-local-variable\n  exists(VariableDeclarator v |\n    v.getInit() = e and v.getBindingPattern().getVariable() instanceof UnusedLocal\n  )\n  or\n  // Avoid double reporting with js/call-to-non-callable\n  any(InvokeExpr invoke).getCallee() = e\n  or\n  // arguments to Promise.resolve (and promise library variants) are benign.\n  e = any(PromiseCreationCall promise).getValue().asExpr()\n  or\n  // arguments to other (unknown) promise creations.\n  e = any(DataFlow::CallNode call | call.getCalleeName() = \"resolve\").getAnArgument().asExpr()\n}\n\npredicate oneshotClosure(DataFlow::CallNode call) {\n  call.getCalleeNode().asExpr().getUnderlyingValue() instanceof ImmediatelyInvokedFunctionExpr\n}\n\npredicate alwaysThrows(Function f) {\n  exists(ReachableBasicBlock entry, DataFlow::Node throwNode |\n    entry = f.getEntryBB() and\n    throwNode.asExpr() = any(ThrowStmt t).getExpr() and\n    entry.dominates(throwNode.getBasicBlock())\n  )\n}\n\npredicate lastStatementHasNoEffect(Function f) { hasNoEffect(f.getExit().getAPredecessor()) }\n\npredicate callToVoidFunction(DataFlow::CallNode call, Function func) {\n  not call.isIncomplete() and\n  func = call.getACallee() and\n  forall(Function f | f = call.getACallee() |\n    returnsVoid(f) and not isStub(f) and not alwaysThrows(f)\n  )\n}\n\npredicate hasNonVoidCallbackMethod(string name) {\n  name =\n    [\n      \"every\", \"filter\", \"find\", \"findIndex\", \"flatMap\", \"map\", \"reduce\", \"reduceRight\", \"some\",\n      \"sort\", \"findLastIndex\", \"findLast\"\n    ]\n}\n\nDataFlow::SourceNode array(DataFlow::TypeTracker t) {\n  t.start() and result instanceof DataFlow::ArrayCreationNode\n  or\n  exists(DataFlow::TypeTracker t2 | result = array(t2).track(t2, t))\n}\n\nDataFlow::SourceNode array() { result = array(DataFlow::TypeTracker::end()) }\n\npredicate voidArrayCallback(DataFlow::CallNode call, Function func) {\n  hasNonVoidCallbackMethod(call.getCalleeName()) and\n  exists(int index |\n    index = min(int i | exists(call.getCallback(i))) and\n    func = call.getCallback(index).getFunction()\n  ) and\n  returnsVoid(func) and\n  not isStub(func) and\n  not alwaysThrows(func) and\n  (\n    call.getReceiver().getALocalSource() = array()\n    or\n    call.getCalleeNode().getALocalSource() instanceof LodashUnderscore::Member\n  )\n}\n\npredicate hasNonVoidReturnType(Function f) {\n  exists(TypeAnnotation type | type = f.getReturnTypeAnnotation() | not type.isVoid())\n}\n\nfrom DataFlow::CallNode call, Function func, string name, string msg\nwhere\n  (\n    callToVoidFunction(call, func) and\n    msg = \"the $@ does not return anything, yet the return value is used.\" and\n    name = func.describe()\n    or\n    voidArrayCallback(call, func) and\n    msg =\n      \"the $@ does not return anything, yet the return value from the call to \" +\n        call.getCalleeName() + \" is used.\" and\n    name = \"callback function\"\n  ) and\n  not benignContext(call.getEnclosingExpr()) and\n  not lastStatementHasNoEffect(func) and\n  // anonymous one-shot closure. Those are used in weird ways and we ignore them.\n  not oneshotClosure(call) and\n  not hasNonVoidReturnType(func) and\n  not call.getEnclosingExpr() instanceof SuperCall\nselect call, msg, func, name",
        "description": "Using the return value of a function that does not return an expression is indicative of a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/UseOfReturnlessFunction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom ReturnStmt r, AssignExpr assgn, Variable v\nwhere\n  assgn = r.getExpr().stripParens() and\n  v = r.getContainer().(Function).getScope().getAVariable() and\n  not v.isCaptured() and\n  assgn.getLhs() = v.getAnAccess()\nselect r.(FirstLineOf),\n  \"The assignment to \" + v.getName() +\n    \" is useless, since it is a local variable and will go out of scope.\"",
        "description": "An assignment to a local variable in a return statement is useless, since the variable will immediately go out of scope and its value is lost.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/ReturnAssignsLocal.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass ArrayShiftingCall extends DataFlow::MethodCallNode {\n  string name;\n\n  ArrayShiftingCall() {\n    name = this.getMethodName() and\n    (name = \"splice\" or name = \"shift\" or name = \"unshift\")\n  }\n\n  DataFlow::SourceNode getArray() { result = this.getReceiver().getALocalSource() }\n}\n\nclass SpliceCall extends ArrayShiftingCall {\n  SpliceCall() { name = \"splice\" }\n\n  /**\n   * Gets the index from which elements are removed and possibly new elemenst are inserted.\n   */\n  DataFlow::Node getIndex() { result = this.getArgument(0) }\n\n  /**\n   * Gets the number of removed elements.\n   */\n  int getNumRemovedElements() {\n    result = this.getArgument(1).asExpr().getIntValue() and\n    result >= 0\n  }\n\n  /**\n   * Gets the number of inserted elements.\n   */\n  int getNumInsertedElements() {\n    result = this.getNumArgument() - 2 and\n    result >= 0\n  }\n}\n\nclass ArrayIterationLoop extends ForStmt {\n  DataFlow::SourceNode array;\n  LocalVariable indexVariable;\n\n  ArrayIterationLoop() {\n    exists(RelationalComparison compare | compare = this.getTest() |\n      compare.getLesserOperand() = indexVariable.getAnAccess() and\n      compare.getGreaterOperand() = array.getAPropertyRead(\"length\").asExpr()\n    ) and\n    this.getUpdate().(IncExpr).getOperand() = indexVariable.getAnAccess()\n  }\n\n  /**\n   * Gets the variable holding the loop variable and current array index.\n   */\n  LocalVariable getIndexVariable() { result = indexVariable }\n\n  /**\n   * Gets the loop entry point.\n   */\n  ReachableBasicBlock getLoopEntry() {\n    result = this.getTest().getFirstControlFlowNode().getBasicBlock()\n  }\n\n  /**\n   * Gets a call that potentially shifts the elements of the given array.\n   */\n  ArrayShiftingCall getAnArrayShiftingCall() { result.getArray() = array }\n\n  /**\n   * Gets a call to `splice` that removes elements from the looped-over array at the current index\n   *\n   * The `splice` call is not guaranteed to be inside the loop body.\n   */\n  SpliceCall getACandidateSpliceCall() {\n    result = this.getAnArrayShiftingCall() and\n    result.getIndex().asExpr() = this.getIndexVariable().getAnAccess() and\n    result.getNumRemovedElements() > result.getNumInsertedElements()\n  }\n\n  /**\n   * Holds if `cfg` modifies the index variable or shifts array elements, disturbing the\n   * relationship between the array and the index variable.\n   */\n  predicate hasIndexingManipulation(ControlFlowNode cfg) {\n    cfg.(VarDef).getAVariable() = this.getIndexVariable() or\n    cfg = this.getAnArrayShiftingCall().asExpr()\n  }\n\n  /**\n   * Holds if there is a `loop entry -> cfg` path that does not involve index manipulation or a successful index equality check.\n   */\n  predicate hasPathTo(ControlFlowNode cfg) {\n    exists(this.getACandidateSpliceCall()) and // restrict size of predicate\n    cfg = this.getLoopEntry().getFirstNode()\n    or\n    this.hasPathTo(cfg.getAPredecessor()) and\n    this.getLoopEntry().dominates(cfg.getBasicBlock()) and\n    not this.hasIndexingManipulation(cfg) and\n    // Ignore splice calls guarded by an index equality check.\n    // This indicates that the index of an element is the basis for removal, not its value,\n    // which means it may be okay to skip over elements.\n    not exists(ConditionGuardNode guard, EqualityTest test | cfg = guard |\n      test = guard.getTest() and\n      test.getAnOperand() = this.getIndexVariable().getAnAccess() and\n      guard.getOutcome() = test.getPolarity()\n    ) and\n    // Block flow after inspecting an array element other than that at the current index.\n    // For example, if the splice happens after inspecting `array[i + 1]`, then the next\n    // element has already been \"looked at\" and so it doesn't matter if we skip it.\n    not exists(IndexExpr index | cfg = index |\n      array.flowsToExpr(index.getBase()) and\n      not index.getIndex() = this.getIndexVariable().getAnAccess()\n    )\n  }\n\n  /**\n   * Holds if there is a `loop entry -> splice -> cfg` path that does not involve index manipulation,\n   * other than the `splice` call.\n   */\n  predicate hasPathThrough(SpliceCall splice, ControlFlowNode cfg) {\n    splice = this.getACandidateSpliceCall() and\n    cfg = splice.asExpr() and\n    this.hasPathTo(cfg.getAPredecessor())\n    or\n    this.hasPathThrough(splice, cfg.getAPredecessor()) and\n    this.getLoopEntry().dominates(cfg.getBasicBlock()) and\n    not this.hasIndexingManipulation(cfg) and\n    // Don't continue through a branch that tests the splice call's return value\n    not exists(ConditionGuardNode guard | cfg = guard |\n      guard.getTest() = splice.asExpr() and\n      guard.getOutcome() = false\n    )\n  }\n}\n\nfrom ArrayIterationLoop loop, SpliceCall splice\nwhere loop.hasPathThrough(splice, loop.getUpdate().getFirstControlFlowNode())\nselect splice,\n  \"Removing an array item without adjusting the loop index '\" + loop.getIndexVariable().getName() +\n    \"' causes the subsequent array item to be skipped.\"",
        "description": "Removing elements from an array while iterating over it can cause the loop to skip over some elements, unless the loop index is decremented accordingly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/LoopIterationSkippedDueToShifting.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\npredicate misleadingIndentationCandidate(ControlStmt ctrl, Stmt s1, Stmt s2) {\n  not ctrl.getTopLevel().isMinified() and\n  s1 = ctrl.getAControlledStmt() and\n  s1.getLastToken().getNextToken() = s2.getFirstToken() and\n  not s2 = ctrl.getAControlledStmt()\n}\n\nfrom\n  ControlStmt ctrl, Stmt s1, Stmt s2, string indent, int ctrlStartColumn, int startColumn, File f,\n  int ctrlStartLine, int startLine1, int startLine2\nwhere\n  misleadingIndentationCandidate(ctrl, s1, s2) and\n  ctrl.getLocation().hasLocationInfo(f.getAbsolutePath(), ctrlStartLine, ctrlStartColumn, _, _) and\n  // `s1` and `s2` are indented the same\n  s1.getLocation().hasLocationInfo(f.getAbsolutePath(), startLine1, startColumn, _, _) and\n  s2.getLocation().hasLocationInfo(f.getAbsolutePath(), startLine2, startColumn, _, _) and\n  // `s1` is indented relative to `ctrl`\n  startColumn > ctrlStartColumn and\n  // `ctrl`, `s1` and `s2` all have the same indentation character\n  f.hasIndentation(ctrlStartLine, indent, _) and\n  f.hasIndentation(startLine1, indent, _) and\n  f.hasIndentation(startLine2, indent, _) and\n  not s2 instanceof EmptyStmt\nselect s2.(FirstLineOf),\n  \"The indentation of this statement suggests that it is controlled by $@, while in fact it is not.\",\n  ctrl.(FirstLineOf), \"this statement\"",
        "description": "The body of a control statement should have appropriate indentation to clarify which statements it controls and which ones it does not control.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/MisleadingIndentationAfterControlStmt.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass IncrementExpr extends Expr {\n  IncrementExpr() {\n    // x += e\n    this instanceof AssignAddExpr\n    or\n    // ++x or x++\n    this instanceof PreIncExpr\n    or\n    this instanceof PostIncExpr\n    or\n    // x = x + e\n    exists(AssignExpr assgn, Variable v | assgn = this |\n      assgn.getTarget() = v.getAnAccess() and\n      assgn.getRhs().(AddExpr).getAnOperand().getUnderlyingReference() = v.getAnAccess()\n    )\n  }\n}\n\npredicate countingLoop(EnhancedForLoop efl) {\n  exists(ExprStmt inc | inc.getExpr().stripParens() instanceof IncrementExpr |\n    inc = efl.getBody() or\n    inc = efl.getBody().(BlockStmt).getAStmt()\n  )\n}\n\npredicate isNonLastDestructedArrayElement(PurelyLocalVariable iter) {\n  exists(ArrayPattern pattern | pattern = any(EnhancedForLoop loop).getLValue() |\n    iter = pattern.getAVariable() and\n    iter =\n      pattern\n          .getElement([0 .. pattern.getSize() - 2])\n          .(BindingPattern)\n          .getABindingVarRef()\n          .getVariable()\n  )\n}\n\nfrom EnhancedForLoop efl, PurelyLocalVariable iter\nwhere\n  iter = efl.getAnIterationVariable() and\n  not exists(SsaExplicitDefinition ssa | ssa.defines(efl.getIteratorExpr(), iter)) and\n  exists(ReachableBasicBlock body | body.getANode() = efl.getBody() | body.getASuccessor+() = body) and\n  not countingLoop(efl) and\n  not isNonLastDestructedArrayElement(iter) and\n  not iter.getName().toLowerCase().regexpMatch(\"(_|dummy|unused).*\")\nselect efl.getIterator(), \"For loop variable \" + iter.getName() + \" is not used in the loop body.\"",
        "description": "A loop iteration variable is unused, which suggests an error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/SuspiciousUnusedLoopIterationVariable.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nVariable getAnIterationVariable(ForStmt for, Expr upAccess) {\n  result.getAnAccess().getParentExpr*() = for.getTest() and\n  exists(UpdateExpr upd | upd.getParentExpr*() = for.getUpdate() |\n    upAccess = upd.getOperand() and upAccess = result.getAnAccess()\n  )\n}\n\nfrom ForStmt outer, ForStmt inner, Variable iteration, Expr upAccess\nwhere\n  inner.nestedIn(outer) and\n  iteration = getAnIterationVariable(outer, _) and\n  iteration = getAnIterationVariable(inner, upAccess)\nselect inner.getTest(), \"Nested for statement uses loop variable $@ of enclosing $@.\", upAccess,\n  iteration.getName(), outer, \"for statement\"",
        "description": "Nested loops in which the iteration variable is the same for each loop are difficult to understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Statements/NestedLoopsSameVariable.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.dataflow.InferredTypes\n\nabstract class ImplicitConversion extends DataFlow::AnalyzedNode {\n  Expr parent;\n\n  ImplicitConversion() { this.asExpr() = parent.getAChildExpr() }\n\n  /**\n   * Gets a description of the type(s) to which the value `v`, which is\n   * a possible runtime value of this expression, is converted.\n   *\n   * This predicate only considers conversions that are likely to be\n   * unintentional or have unexpected results, for example `null` being\n   * converted to a string as part of a string concatenation.\n   */\n  abstract string getAnImplicitConversionTarget(AbstractValue v);\n}\n\nabstract class ImplicitConversionWithWhitelist extends ImplicitConversion {\n  /** Gets a type for which this implicit conversion is harmless. */\n  abstract InferredType getAWhitelistedType();\n\n  /**\n   * Gets a description of the type(s) to which any value of this expression\n   * is converted.\n   */\n  abstract string getConversionTarget();\n\n  override string getAnImplicitConversionTarget(AbstractValue v) {\n    v = this.getAValue() and\n    not v.getType() = this.getAWhitelistedType() and\n    result = this.getConversionTarget()\n  }\n}\n\nclass PropertyNameConversion extends ImplicitConversionWithWhitelist {\n  PropertyNameConversion() { this.asExpr() = parent.(InExpr).getLeftOperand() }\n\n  override InferredType getAWhitelistedType() { result = TTString() or result = TTNumber() }\n\n  override string getConversionTarget() { result = \"string\" }\n}\n\nclass IndexExprConversion extends ImplicitConversionWithWhitelist {\n  IndexExprConversion() { this.asExpr() = parent.(IndexExpr).getIndex() }\n\n  override InferredType getAWhitelistedType() {\n    result = TTBoolean() or result = TTString() or result = TTNumber()\n  }\n\n  override string getConversionTarget() { result = \"string\" }\n}\n\nclass ObjectConversion extends ImplicitConversionWithWhitelist {\n  ObjectConversion() {\n    this.asExpr() = parent.(InExpr).getRightOperand() or\n    this.asExpr() = parent.(InstanceofExpr).getLeftOperand()\n  }\n\n  override InferredType getAWhitelistedType() { result instanceof NonPrimitiveType }\n\n  override string getConversionTarget() { result = \"object\" }\n}\n\nclass ConstructorConversion extends ImplicitConversionWithWhitelist {\n  ConstructorConversion() { this.asExpr() = parent.(InstanceofExpr).getRightOperand() }\n\n  override InferredType getAWhitelistedType() { result = TTFunction() or result = TTClass() }\n\n  override string getConversionTarget() { result = \"function\" }\n}\n\nclass RelationalOperandConversion extends ImplicitConversionWithWhitelist {\n  RelationalOperandConversion() { parent instanceof RelationalComparison }\n\n  override InferredType getAWhitelistedType() {\n    result = TTString() or result = TTNumber() or result = TTDate()\n  }\n\n  override string getConversionTarget() { result = \"number or string\" }\n}\n\nclass NumericConversion extends ImplicitConversion {\n  NumericConversion() {\n    parent instanceof BitwiseExpr\n    or\n    parent instanceof ArithmeticExpr and not parent instanceof AddExpr\n    or\n    parent.(CompoundAssignExpr).isNumeric()\n    or\n    parent instanceof UpdateExpr\n  }\n\n  override string getAnImplicitConversionTarget(AbstractValue v) {\n    v = this.getAValue() and\n    not v.isCoercibleToNumber() and\n    result = \"number\"\n  }\n}\n\nabstract class NullOrUndefinedConversion extends ImplicitConversion {\n  abstract string getConversionTarget();\n\n  override string getAnImplicitConversionTarget(AbstractValue v) {\n    v = this.getAValue() and\n    (v instanceof AbstractNull or v instanceof AbstractUndefined) and\n    result = this.getConversionTarget()\n  }\n}\n\nclass PlusConversion extends NullOrUndefinedConversion {\n  PlusConversion() { parent instanceof AddExpr or parent instanceof AssignAddExpr }\n\n  override string getConversionTarget() {\n    result = this.getDefiniteSiblingType()\n    or\n    not exists(this.getDefiniteSiblingType()) and\n    result = \"number or string\"\n  }\n\n  /**\n   * Gets the sibling of this implicit conversion.\n   * E.g. if this is `a` in the expression `a + b`, then the sibling is `b`.\n   */\n  private Expr getSibling() { result = parent.getAChild() and not result = this.getEnclosingExpr() }\n\n  /**\n   * Gets the unique type of the sibling expression, if that type is `string` or `number`.\n   */\n  private string getDefiniteSiblingType() {\n    result =\n      unique(InferredType t | t = this.getSibling().flow().analyze().getAType()).getTypeofTag() and\n    result = [\"string\", \"number\"]\n  }\n}\n\nclass TemplateElementConversion extends NullOrUndefinedConversion {\n  TemplateElementConversion() { parent instanceof TemplateLiteral }\n\n  override string getConversionTarget() { result = \"string\" }\n}\n\nfrom ImplicitConversion e, string convType\nwhere\n  convType = e.getAnImplicitConversionTarget(_) and\n  forall(AbstractValue v | v = e.getAValue() | exists(e.getAnImplicitConversionTarget(v)))\nselect e,\n  \"This expression will be implicitly converted from \" + e.ppTypes() + \" to \" + convType + \".\"",
        "description": "Relying on implicit conversion of operands is error-prone and makes code hard to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/ImplicitOperandConversion.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass AssocNestedExpr extends BinaryExpr {\n  AssocNestedExpr() {\n    exists(BinaryExpr parent, int idx | this = parent.getChildExpr(idx) |\n      // +, *, &&, || and the bitwise operations are associative\n      (\n        this instanceof AddExpr or\n        this instanceof MulExpr or\n        this instanceof BitwiseExpr or\n        this instanceof LogicalBinaryExpr\n      ) and\n      parent.getOperator() = this.getOperator()\n      or\n      // (x*y)/z = x*(y/z)\n      this instanceof MulExpr and parent instanceof DivExpr and idx = 0\n      or\n      // (x/y)%z = x/(y%z)\n      this instanceof DivExpr and parent instanceof ModExpr and idx = 0\n      or\n      // (x+y)-z = x+(y-z)\n      this instanceof AddExpr and parent instanceof SubExpr and idx = 0\n    )\n  }\n}\n\nclass HarmlessNestedExpr extends BinaryExpr {\n  HarmlessNestedExpr() {\n    exists(BinaryExpr parent | this = parent.getAChildExpr() |\n      parent instanceof Comparison and\n      (this instanceof ArithmeticExpr or this instanceof ShiftExpr)\n      or\n      parent instanceof LogicalExpr and this instanceof Comparison\n    )\n  }\n}\n\npredicate benignWhitespace(BinaryExpr binop) {\n  // asm.js like `expr |0` binary expression.\n  not binop.getParent() instanceof BinaryExpr and\n  binop.getOperator() = \"|\" and\n  binop.getRightOperand().getIntValue() = 0\n}\n\npredicate interestingNesting(BinaryExpr inner, BinaryExpr outer) {\n  inner = outer.getAChildExpr() and\n  not inner instanceof AssocNestedExpr and\n  not inner instanceof HarmlessNestedExpr and\n  not benignWhitespace(outer)\n}\n\nfrom BinaryExpr inner, BinaryExpr outer\nwhere\n  interestingNesting(inner, outer) and\n  inner.getWhitespaceAroundOperator() > outer.getWhitespaceAroundOperator() and\n  not outer.getTopLevel().isMinified()\nselect outer, \"Whitespace around nested operators contradicts precedence.\"",
        "description": "Nested expressions where the formatting contradicts the grouping enforced by operator precedence are difficult to read and may even indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/WhitespaceContradictsPrecedence.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nExpr rightChild(Expr e) {\n  result = e.(ParExpr).getExpression() or\n  result = e.(AddExpr).getRightOperand()\n}\n\nExpr leftChild(Expr e) {\n  result = e.(ParExpr).getExpression() or\n  result = e.(AddExpr).getLeftOperand()\n}\n\npredicate isInConcat(Expr e) {\n  exists(ParExpr par | isInConcat(par) and par.getExpression() = e)\n  or\n  exists(AddExpr a | a.getAnOperand() = e)\n}\n\nclass ConcatenationLiteral extends Expr {\n  ConcatenationLiteral() {\n    (\n      this instanceof TemplateLiteral\n      or\n      this instanceof Literal\n    ) and\n    isInConcat(this)\n  }\n}\n\nExpr getConcatChild(Expr e) {\n  result = rightChild(e) or\n  result = leftChild(e)\n}\n\nExpr getConcatParent(Expr e) { e = getConcatChild(result) }\n\npredicate isWordLike(ConcatenationLiteral lit) {\n  lit.getStringValue().regexpMatch(\"(?i).*[a-z]{3,}.*\")\n}\n\nclass ConcatRoot extends AddExpr {\n  ConcatRoot() { not isInConcat(this) }\n}\n\nConcatRoot getAddRoot(AddExpr e) { result = getConcatParent*(e) }\n\npredicate hasWordLikeFragment(AddExpr e) { isWordLike(getConcatChild*(getAddRoot(e))) }\n\nfrom AddExpr e, ConcatenationLiteral l, ConcatenationLiteral r, string word\nwhere\n  // l and r are appended together\n  l = rightChild*(e.getLeftOperand()) and\n  r = leftChild*(e.getRightOperand()) and\n  // `l + r` is of the form `... word\" + \"word2...`, possibly including some\n  // punctuation after `word`.\n  // Only the first character of `word2` is matched, whereas `word` is matched\n  // completely to distinguish grammatical punctuation after which a space is\n  // needed, and intra-identifier punctuation in, for example, a qualified name.\n  word = l.getStringValue().regexpCapture(\".* (([-A-Za-z/'\\\\.:,]*[a-zA-Z]|[0-9]+)[\\\\.:,!?']*)\", 1) and\n  r.getStringValue().regexpMatch(\"[a-zA-Z].*\") and\n  not word.regexpMatch(\".*[,\\\\.:].*[a-zA-Z].*[^a-zA-Z]\") and\n  // There must be a constant-string in the concatenation that looks like a word.\n  hasWordLikeFragment(e)\nselect l, \"This string appears to be missing a space after '\" + word + \"'.\"",
        "description": "Joining constant strings into a longer string where two words are concatenated without a separating space usually indicates a text error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/MissingSpaceInAppend.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nprivate predicate isBoundInMethod(MethodDeclaration method) {\n  exists(DataFlow::ThisNode thiz, MethodDeclaration bindingMethod, string name |\n    bindingMethod.getDeclaringClass() = method.getDeclaringClass() and\n    not bindingMethod.isStatic() and\n    thiz.getBinder().getAstNode() = bindingMethod.getBody() and\n    name = method.getName()\n  |\n    // binding assignments: `this[x] = <expr>.bind(...)`\n    exists(DataFlow::MethodCallNode bind, DataFlow::PropWrite w |\n      not exists(w.getPropertyName()) or // unknown name, assume everything is bound\n      w.getPropertyName() = name\n    |\n      w = thiz.getAPropertyWrite() and\n      bind.getMethodName() = \"bind\" and\n      bind.flowsTo(w.getRhs())\n    )\n    or\n    // library binders\n    exists(string mod |\n      mod = \"auto-bind\" or\n      mod = \"react-autobind\"\n    |\n      thiz.flowsTo(DataFlow::moduleImport(mod).getACall().getArgument(0))\n    )\n    or\n    // heuristic reflective binders\n    exists(DataFlow::CallNode binder, string calleeName |\n      (\n        binder.(DataFlow::MethodCallNode).getMethodName() = calleeName or\n        binder.getCalleeNode().asExpr().(VarAccess).getVariable().getName() = calleeName\n      ) and\n      calleeName.regexpMatch(\"(?i).*bind.*\") and\n      thiz.flowsTo(binder.getAnArgument()) and\n      // exclude the binding assignments\n      not thiz.getAPropertySource() = binder\n    |\n      // `myBindAll(this)`\n      binder.getNumArgument() = 1\n      or\n      // `myBindSome(this, [<name1>, <name2>])`\n      exists(DataFlow::ArrayCreationNode names |\n        names.flowsTo(binder.getAnArgument()) and\n        names.getAnElement().mayHaveStringValue(name)\n      )\n      or\n      // `myBindSome(this, <name1>, <name2>)`\n      binder.getAnArgument().mayHaveStringValue(name)\n    )\n  )\n  or\n  exists(Expr decoration, string name |\n    (\n      decoration = method.getADecorator().getExpression()\n      or\n      decoration = method.getDeclaringType().(ClassDefinition).getADecorator().getExpression()\n    ) and\n    name.regexpMatch(\"(?i).*(bind|bound).*\")\n  |\n    // `@autobind`\n    decoration.(Identifier).getName() = name\n    or\n    // `@action.bound`\n    decoration.(PropAccess).getPropertyName() = name\n  )\n}\n\nprivate DOM::AttributeDefinition getAnEventHandlerAttribute() {\n  exists(ReactComponent c, JsxNode rendered, string attributeName |\n    c.getRenderMethod().getAReturnedExpr().flow().getALocalSource().asExpr() = rendered and\n    result = rendered.getABodyElement*().(JsxElement).getAttributeByName(attributeName) and\n    attributeName.regexpMatch(\"on[A-Z][a-zA-Z]+\") // camelCased with 'on'-prefix\n  )\n}\n\nfrom MethodDeclaration callback, DOM::AttributeDefinition attribute, ThisExpr unbound\nwhere\n  attribute = getAnEventHandlerAttribute() and\n  attribute.getValueNode().analyze().getAValue().(AbstractFunction).getFunction() =\n    callback.getBody() and\n  unbound.getBinder() = callback.getBody() and\n  not isBoundInMethod(callback)\nselect attribute,\n  \"The receiver of this event handler call is unbound, `$@` will be `undefined` in the call to $@.\",\n  unbound, \"this\", callback, callback.getName()",
        "description": "Invoking an event handler method as a function can cause a runtime error.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/UnboundEventHandlerReceiver.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom ShiftExpr shift\nwhere\n  shift.getRightOperand().getIntValue() > 31 and\n  not shift.getRightOperand().stripParens() instanceof BigIntLiteral\nselect shift, \"Shift out of range.\"",
        "description": "The integer shift operators '<<', '>>' and '>>>' only take the five least significant bits of their right operand into account. Thus, it is not possible to shift an integer by more than 31 bits.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/ShiftOutOfRange.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate acceptableSignCheck(BitwiseExpr b) {\n  // projecting out constant bit patterns not containing the sign bit is fine\n  b.(BitAndExpr).getRightOperand().getIntValue() <= 2147483647\n  or\n  /*\n   * `| 0` and `0 |` are popular ways of converting a value to an integer;\n   * `>> 0`, `<< 0`, `^ 0` and `0 ^` achieve the same effect;\n   * `& 0` is zero, as are `0 <<`, `0 >>` and `0 >>>`;\n   * so any binary bitwise operation involving zero is acceptable, _except_ for `x >>> 0`,\n   * which amounts to a cast to unsigned int\n   */\n\n  exists(int i |\n    b.(BinaryExpr).getChildExpr(i).getIntValue() = 0 and\n    not (b instanceof URShiftExpr and i = 1)\n  )\n  or\n  /*\n   * `<< 16 >> 16` is how Emscripten converts values to short integers; since this\n   * is sign-preserving, we shouldn't flag it (and we allow arbitrary shifts, not just 16-bit ones)\n   */\n\n  exists(RShiftExpr rsh, LShiftExpr lsh |\n    rsh = b and\n    lsh = rsh.getLeftOperand().getUnderlyingValue() and\n    lsh.getRightOperand().getIntValue() = rsh.getRightOperand().getIntValue()\n  )\n}\n\nfrom Comparison e, BitwiseExpr b\nwhere\n  b = e.getLeftOperand().getUnderlyingValue() and\n  not e instanceof EqualityTest and\n  e.getRightOperand().getIntValue() = 0 and\n  not acceptableSignCheck(b)\nselect e, \"Potentially unsafe sign check of a bitwise operation.\"",
        "description": "Checking the sign of the result of a bitwise operation may yield unexpected results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/BitwiseSignCheck.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate contradictoryAccess(RelationalComparison compare, IndexExpr lookup) {\n  exists(SsaVariable base, SsaVariable index |\n    base != index and\n    compare.hasOperands(base.getAUse(), index.getAUse()) and\n    lookup.getBase() = base.getAUse() and\n    lookup.getIndex() = index.getAUse()\n  )\n  or\n  // We allow `base` to be a global, since globals rarely undergo radical type changes\n  // that depend on local control flow.\n  // We could do the same for `index`, but it rarely matters for the pattern we are looking for.\n  sameIndex(compare, lookup) and\n  exists(GlobalVariable base |\n    compare.getAnOperand() = base.getAnAccess() and\n    lookup.getBase() = base.getAnAccess()\n  )\n}\n\npredicate sameIndex(RelationalComparison compare, IndexExpr lookup) {\n  exists(SsaVariable index |\n    compare.getAnOperand() = index.getAUse() and\n    lookup.getIndex() = index.getAUse()\n  )\n}\n\npredicate relevantBasicBlocks(ReachableBasicBlock b1, ReachableBasicBlock b2) {\n  contradictoryAccess(b1.getANode(), b2.getANode())\n}\n\npredicate sameBranch(ReachableBasicBlock b1, ReachableBasicBlock b2) {\n  relevantBasicBlocks(b1, b2) and\n  (b1 = b2 or b1.strictlyDominates(b2) or b2.strictlyDominates(b1))\n}\n\nfrom RelationalComparison compare, IndexExpr lookup\nwhere\n  contradictoryAccess(compare, lookup) and\n  sameBranch(compare.getBasicBlock(), lookup.getBasicBlock())\nselect compare, \"Missing .length in comparison, or erroneous $@.\", lookup, \"index expression\"",
        "description": "Two variables are being compared using a relational operator, but one is also used to index into the other, suggesting a \".length\" is missing from the comparison.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/MissingDotLengthInComparison.ql",
        "language": "javascript"
    },
    {
        "query": "import Clones\n\nabstract class RedundantOperand extends StructurallyCompared {\n  RedundantOperand() { exists(BinaryExpr parent | this = parent.getLeftOperand()) }\n\n  override Expr candidate() { result = this.getParent().(BinaryExpr).getRightOperand() }\n\n  /** Gets the expression to report when a pair of clones is found. */\n  Expr toReport() { result = this.getParent() }\n}\n\nclass IdemnecantExpr extends BinaryExpr {\n  IdemnecantExpr() {\n    this instanceof SubExpr or\n    this instanceof DivExpr or\n    this instanceof ModExpr or\n    this instanceof XOrExpr\n  }\n}\n\nclass RedundantIdemnecantOperand extends RedundantOperand {\n  RedundantIdemnecantOperand() {\n    exists(IdemnecantExpr parent |\n      parent = this.getParent() and\n      // exclude trivial cases like `1-1`\n      not parent.getRightOperand().getUnderlyingValue() instanceof Literal\n    )\n  }\n}\n\nclass RedundantIdempotentOperand extends RedundantOperand {\n  RedundantIdempotentOperand() {\n    this.getParent() instanceof LogicalBinaryExpr and\n    not exists(UpdateExpr e | e.getParentExpr+() = this)\n  }\n}\n\nclass AverageExpr extends DivExpr {\n  AverageExpr() {\n    this.getLeftOperand().getUnderlyingValue() instanceof AddExpr and\n    this.getRightOperand().getIntValue() = 2\n  }\n}\n\nclass RedundantAverageOperand extends RedundantOperand {\n  RedundantAverageOperand() {\n    exists(AverageExpr aver |\n      this.getParent().(AddExpr) = aver.getLeftOperand().getUnderlyingValue()\n    )\n  }\n\n  override AverageExpr toReport() {\n    this.getParent() = result.getLeftOperand().getUnderlyingValue()\n  }\n}\n\nfrom RedundantOperand e, Expr f\nwhere e.same(f)\nselect e.toReport(), \"Operands $@ and $@ are identical.\", e, e.toString(), f, f.toString()",
        "description": "Passing identical, or seemingly identical, operands to an operator such as subtraction or conjunction may indicate a typo; even if it is intentional, it makes the code hard to read.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/RedundantExpression.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Comparison cmp\nwhere cmp.getAnOperand().(GlobalVarAccess).getName() = \"NaN\"\nselect cmp, \"Useless comparison with NaN.\"",
        "description": "Arithmetic comparisons with NaN are useless: nothing is considered to be equal to NaN, not even NaN itself, and similarly nothing is considered greater or less than NaN.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/ComparisonWithNaN.ql",
        "language": "javascript"
    },
    {
        "query": "import Clones\n\nfrom ObjectExpr oe, int i, int j, Property p, Property q, DuplicatePropertyInitDetector dpid\nwhere\n  p = oe.getProperty(i) and\n  q = oe.getProperty(j) and\n  dpid = p.getInit() and\n  dpid.same(q.getInit()) and\n  i < j and\n  // only report the next duplicate\n  not exists(int mid | mid in [i + 1 .. j - 1] | dpid.same(oe.getProperty(mid).getInit()))\nselect p, \"This property is duplicated $@.\", q, \"in a later property\"",
        "description": "Listing the same property twice in one object literal is redundant and may indicate a copy-paste mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/DuplicateProperty.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom BitwiseBinaryExpr bit, Comparison rel, Expr other\nwhere\n  bit.hasOperands(rel, other) and\n  // only flag if whitespace doesn't clarify the nesting (note that if `bit` has less\n  // whitespace than `rel`, it will be reported by `js/whitespace-contradicts-precedence`)\n  bit.getWhitespaceAroundOperator() = rel.getWhitespaceAroundOperator() and\n  // don't flag if the other operand is itself a comparison,\n  // since the nesting tends to be visually more obvious in such cases\n  not other instanceof Comparison and\n  // don't flag occurrences in minified code\n  not rel.getTopLevel().isMinified()\nselect rel,\n  \"The '\" + rel.getOperator() + \"' operator binds more tightly than \" + \"'\" + bit.getOperator() +\n    \"', which may not be obvious in this case.\"",
        "description": "Nested expressions involving binary bitwise operators and comparisons are easy to misunderstand without additional disambiguating parentheses or whitespace.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/UnclearOperatorPrecedence.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Directive d\nwhere\n  not d instanceof Directive::KnownDirective and\n  // ignore \":\" pseudo-directive sometimes seen in dual-use shell/node.js scripts\n  not d.getExpr().getStringValue() = \":\" and\n  // but exclude attribute top-levels: `<a href=\"javascript:'some-attribute-string'\">`\n  not d.getParent() instanceof CodeInAttribute and\n  // exclude babel generated directives like \"@babel/helpers - typeof\".\n  not d.getDirectiveText().matches(\"@babel/helpers%\")\nselect d, \"Unknown directive: '\" + truncate(d.getDirectiveText(), 20, \" ... (truncated)\") + \"'.\"",
        "description": "An unknown directive has no effect and may indicate a misspelling.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/UnknownDirective.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nprivate string getALikelyRegExpPattern() {\n  result =\n    [\n      \"/.*/[gimuy]{1,5}\", // pattern with at least one flag: /foo/i\n      \"/\\\\^.*/[gimuy]{0,5}\", // pattern with anchor: /^foo/\n      \"/.*\\\\$/[gimuy]{0,5}\", // pattern with anchor: /foo$/\n      \"\\\\^.*\\\\$\", // pattern body with anchors: ^foo$\n      \".*(?<!\\\\\\\\)\\\\\\\\[dDwWsSB].*\", // contains a builtin character class: \\s\n      \".*(?<!\\\\\\\\)\\\\\\\\[\\\\[\\\\]()*+?{}|^$.].*\", // contains an escaped meta-character: \\(\n      \".*\\\\[\\\\^?[\\\\p{Alnum}\\\\p{Blank}_-]+\\\\][*+].*\" // contains a quantified custom character class: [^a-zA-Z123]+\n    ]\n}\n\npredicate isStringSplitOrReplace(MethodCallExpr mce) {\n  exists(string name, int arity |\n    mce.getMethodName() = name and\n    mce.getNumArgument() = arity\n  |\n    name = [\"replace\", \"replaceAll\"] and arity = 2\n    or\n    name = \"split\" and\n    (arity = 1 or arity = 2)\n  )\n}\n\npredicate mayReferToString(DataFlow::Node nd, StringLiteral s) {\n  s = nd.asExpr() or mayReferToString(nd.getAPredecessor(), s)\n}\n\nfrom MethodCallExpr mce, StringLiteral arg, string raw, string s\nwhere\n  isStringSplitOrReplace(mce) and\n  mayReferToString(mce.getArgument(0).flow(), arg) and\n  raw = arg.getRawValue() and\n  s = raw.substring(1, raw.length() - 1) and\n  s.regexpMatch(getALikelyRegExpPattern())\nselect mce,\n  \"String argument $@ looks like a regular expression, but it will be interpreted as a string.\",\n  arg, s",
        "description": "Calling 'String.prototype.replace' or 'String.prototype.split' with a string argument that looks like a regular expression is probably a mistake because the called function will not convert the string into a regular expression.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/StringInsteadOfRegex.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.DefensiveProgramming\n\npredicate isFalsyObjectCheck(LogicalBinaryExpr e) {\n  exists(Variable v |\n    e.getAnOperand().(DefensiveExpressionTest::TypeofUndefinedTest).getOperand() = v.getAnAccess() and\n    e.getAnOperand().(DefensiveExpressionTest::UndefinedComparison).getOperand() = v.getAnAccess()\n  )\n}\n\npredicate isPartOfFalsyObjectCheck(Expr e) {\n  exists(LogicalBinaryExpr binary |\n    isFalsyObjectCheck(binary) and\n    e = binary.getAnOperand()\n  )\n  or\n  isFalsyObjectCheck(e)\n}\n\nfrom DefensiveExpressionTest e, boolean cv\nwhere\n  not isPartOfFalsyObjectCheck(e.asExpr()) and\n  e.getTheTestResult() = cv and\n  // whitelist\n  not (\n    // module environment detection\n    exists(VarAccess access, string name | name = \"exports\" or name = \"module\" |\n      e.asExpr().(DefensiveExpressionTest::TypeofUndefinedTest).getOperand() = access and\n      access.getName() = name and\n      not exists(access.getVariable().getADeclaration())\n    )\n    or\n    // too benign in practice\n    e instanceof DefensiveExpressionTest::DefensiveInit\n    or\n    // functions might be written overly general\n    e.getALocalSource() instanceof DataFlow::ParameterNode\n  )\nselect e, \"This guard always evaluates to \" + cv + \".\"",
        "description": "Defensive code that guards against a situation that never happens is not needed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/UnneededDefensiveProgramming.ql",
        "language": "javascript"
    },
    {
        "query": "import Clones\n\nclass DuplicateSwitchCase extends StructurallyCompared {\n  DuplicateSwitchCase() { exists(Case c | this = c.getExpr()) }\n\n  override Expr candidate() {\n    exists(SwitchStmt s, int i, int j |\n      this = s.getCase(i).getExpr() and\n      result = s.getCase(j).getExpr() and\n      i < j\n    )\n  }\n}\n\nfrom DuplicateSwitchCase e, Expr f\nwhere e.same(f)\nselect f, \"This case label is a duplicate of $@.\", e, e.toString()",
        "description": "If two cases in a switch statement have the same label, the second case will never be executed.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/DuplicateSwitchCase.ql",
        "language": "javascript"
    },
    {
        "query": "import Clones\n\nExpr getCondition(IfStmt stmt, int i) {\n  i = 0 and result = stmt.getCondition()\n  or\n  result = getCondition(stmt.getElse(), i - 1)\n}\n\nclass DuplicateIfCondition extends StructurallyCompared {\n  DuplicateIfCondition() { this = getCondition(_, 0) }\n\n  override Expr candidate() {\n    exists(IfStmt stmt, int j | this = getCondition(stmt, 0) |\n      j > 0 and result = getCondition(stmt, j)\n    )\n  }\n}\n\nfrom DuplicateIfCondition e, Expr f\nwhere e.same(f)\nselect f, \"This condition is a duplicate of $@.\", e, e.toString()",
        "description": "If two conditions in an 'if'-'else if' chain are identical, the second condition will never hold.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/DuplicateCondition.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport Expressions.ExprHasNoEffect\nimport semmle.javascript.RestrictedLocations\n\nfrom Expr e\nwhere hasNoEffect(e)\nselect e.(FirstLineOf), \"This expression has no effect.\"",
        "description": "An expression that has no effect and is used in a void context is most likely redundant and may indicate a bug.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/ExprHasNoEffect.ql",
        "language": "javascript"
    },
    {
        "query": "import Clones\nimport Expressions.DOMProperties\n\nstring describe(Expr e) {\n  exists(VarAccess va | va = e | result = \"variable \" + va.getName())\n  or\n  exists(string name | name = e.(PropAccess).getPropertyName() |\n    if exists(name.toInt()) then result = \"element \" + name else result = \"property \" + name\n  )\n}\n\nfrom SelfAssignment e, string dsc\nwhere\n  e.same(_) and\n  dsc = describe(e) and\n  // exclude properties for which there is an accessor somewhere\n  not exists(string propName | propName = e.(PropAccess).getPropertyName() |\n    propName = any(PropertyAccessor acc).getName() or\n    propName = any(AccessorMethodDeclaration amd).getName()\n  ) and\n  // exclude DOM properties\n  not isDomProperty(e.(PropAccess).getPropertyName()) and\n  // exclude self-assignments that have been inserted to satisfy the TypeScript JS-checker\n  not e.getAssignment().getParent().(ExprStmt).getDocumentation().getATag().getTitle() = \"type\" and\n  // exclude self-assignments in speculatively parsed template files\n  // named arguments may be incorrectly parsed as assignments\n  not e.getTopLevel() instanceof Templating::TemplateTopLevel\nselect e.getParent(), \"This expression assigns \" + dsc + \" to itself.\"",
        "description": "Assigning a variable to itself has no effect.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/SelfAssignment.ql",
        "language": "javascript"
    },
    {
        "query": "import Misspelling\n\nclass IdentifierPart extends string {\n  IdentifierPart() { idPart(_, this, _) }\n\n  /**\n   * Holds if this element is at the specified location.\n   * The location spans column `startcolumn` of line `startline` to\n   * column `endcolumn` of line `endline` in file `filepath`.\n   * For more information, see\n   * [Locations](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).\n   */\n  predicate hasLocationInfo(\n    string filepath, int startline, int startcolumn, int endline, int endcolumn\n  ) {\n    exists(Identifier id, int start, Location l, int len |\n      this.occursIn(id, start, len) and l = id.getLocation()\n    |\n      filepath = l.getFile().getAbsolutePath() and\n      startline = l.getStartLine() and\n      startcolumn = l.getStartColumn() + start and\n      // identifiers cannot span more than one line\n      endline = startline and\n      endcolumn = startcolumn + len - 1\n    )\n  }\n\n  /**\n   * Holds if this identifier part occurs at offset `start` inside identifier `id`,\n   * and has length `len`.\n   */\n  predicate occursIn(Identifier id, int start, int len) {\n    idPart(id, this, start) and len = this.length()\n  }\n}\n\nclass WrongIdentifierPart extends IdentifierPart {\n  WrongIdentifierPart() { normalized_typos(this, _, _, _, _, _) }\n\n  /**\n   * Gets an identifier part that corresponds to a correction of this typo.\n   */\n  string getASuggestion() {\n    exists(IdentifierPart right | normalized_typos(this, right, _, _, _, _) |\n      result = \"'\" + right + \"'\"\n    )\n  }\n\n  /**\n   * Gets a pretty-printed string representation of all corrections of\n   * this typo that appear as identifier parts in the code.\n   */\n  string ppSuggestions() {\n    exists(string cat |\n      // first, concatenate with commas\n      cat = concat(this.getASuggestion(), \", \") and\n      // then, replace last comma with \"or\"\n      result = cat.regexpReplaceAll(\", ([^,]++)$\", \" or $1\")\n    )\n  }\n\n  override predicate occursIn(Identifier id, int start, int len) {\n    super.occursIn(id, start, len) and\n    // throw out cases where the wrong word appears as a prefix or suffix of a right word,\n    // and thus the result is most likely a false positive caused by our word segmentation algorithm\n    exists(string lowerid | lowerid = id.getName().toLowerCase() |\n      not exists(string right, int rightlen |\n        this.prefixOf(right, rightlen) and lowerid.substring(start, start + rightlen) = right\n        or\n        this.suffixOf(right, rightlen) and\n        lowerid.substring(start + len - rightlen, start + len) = right\n      )\n    ) and\n    // also throw out cases flagged by another query\n    not misspelledVariableName(id, _)\n  }\n\n  /**\n   * Holds if this identifier part is a (proper) prefix of `right`, which is\n   * a correct spelling with length `rightlen`.\n   */\n  predicate prefixOf(string right, int rightlen) {\n    exists(string c, int wronglen |\n      normalized_typos(this, _, c, _, _, _) and\n      normalized_typos(_, right, _, _, c, _) and\n      wronglen = this.length() and\n      rightlen = right.length() and\n      wronglen < rightlen and\n      right.prefix(wronglen) = this\n    )\n  }\n\n  /**\n   * Holds if this identifier part is a (proper) suffix of `right`, which is\n   * a correct spelling with length `rightlen`.\n   */\n  predicate suffixOf(string right, int rightlen) {\n    exists(string c, int wronglen |\n      normalized_typos(this, _, _, c, _, _) and\n      normalized_typos(_, right, _, _, _, c) and\n      wronglen = this.length() and\n      rightlen = right.length() and\n      wronglen < rightlen and\n      right.suffix(rightlen - wronglen) = this\n    )\n  }\n}\n\nfrom WrongIdentifierPart wrong\nwhere\n  // make sure we have at least one occurrence of a correction\n  exists(wrong.getASuggestion()) and\n  // make sure we have at least one unambiguous occurrence of the wrong word\n  wrong.occursIn(_, _, _)\nselect wrong, \"'\" + wrong + \"' may be a typo for \" + wrong.ppSuggestions() + \".\"",
        "description": "Misspelled identifiers make code harder to read and understand.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/MisspelledIdentifier.ql",
        "language": "javascript"
    },
    {
        "query": "import Misspelling\n\nbindingset[name]\nint localAcceses(string name) {\n  result = count(VarAccess acc | acc.getName() = name and not acc instanceof GlobalVarAccess)\n}\n\nbindingset[name]\nint globalAccesses(string name) { result = count(GlobalVarAccess acc | acc.getName() = name) }\n\npredicate globalIsLikelyCorrect(GlobalVarAccess gva, VarDecl lvd) {\n  // If there are more occurrences of the global (by a margin of at least 2), and the local is missing one letter compared to the global.\n  globalAccesses(gva.getName()) >= localAcceses(lvd.getName()) + 2 and\n  lvd.getName().length() = gva.getName().length() - 1\n  or\n  // Or if there are many more of the global.\n  globalAccesses(gva.getName()) > 2 * localAcceses(lvd.getName()) + 2\n}\n\nfrom GlobalVarAccess gva, VarDecl lvd, string msg\nwhere\n  misspelledVariableName(gva, lvd) and\n  if globalIsLikelyCorrect(gva, lvd)\n  then msg = \"$@ may be a typo for '\" + gva + \"'.\"\n  else msg = \"'\" + gva + \"' may be a typo for variable $@.\"\nselect gva, msg, lvd, lvd.getName()",
        "description": "Misspelling a variable name implicitly introduces a global variable, which may not lead to a runtime error, but is likely to give wrong results.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/MisspelledVariableName.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.dataflow.InferredTypes\n\nfrom InvokeExpr invk, DataFlow::AnalyzedNode callee\nwhere\n  callee.asExpr() = invk.getCallee() and\n  forex(InferredType tp | tp = callee.getAType() | tp != TTFunction() and tp != TTClass()) and\n  not invk.isAmbient() and\n  not invk instanceof OptionalUse\nselect invk, \"Callee is not a function: it has type \" + callee.ppTypes() + \".\"",
        "description": "Trying to invoke a value that is not a function will result in a runtime exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/SuspiciousInvocation.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate isAsyncCall(DataFlow::CallNode call, boolean nullable) {\n  // If a callee is known, and all known callees are async, assume all\n  // possible callees are async.\n  forex(Function callee | call.getACallee() = callee | callee.isAsync()) and\n  if call.asExpr() instanceof OptionalUse then nullable = true else nullable = false\n}\n\npredicate isPromise(DataFlow::SourceNode node, boolean nullable) {\n  isAsyncCall(node, nullable)\n  or\n  not isAsyncCall(node, _) and\n  node.asExpr().getTypeBinding().isPromiseType() and\n  nullable = true\n}\n\npredicate isBadPromiseContext(Expr expr) {\n  exists(BinaryExpr binary |\n    expr = binary.getAnOperand() and\n    not binary instanceof LogicalExpr and\n    not binary instanceof InstanceofExpr\n  )\n  or\n  expr = any(LogicalBinaryExpr e).getLeftOperand()\n  or\n  exists(UnaryExpr e |\n    expr = e.getOperand() and\n    not e instanceof VoidExpr and\n    not e instanceof DeleteExpr\n  )\n  or\n  expr = any(UpdateExpr e).getOperand()\n  or\n  expr = any(ConditionalExpr e).getCondition()\n  or\n  expr = any(IfStmt stmt).getCondition()\n  or\n  expr = any(ForInStmt stmt).getIterationDomain()\n  or\n  expr = any(IndexExpr e).getIndex()\n}\n\nstring tryGetPromiseExplanation(Expr e) {\n  result = \"The value '\" + e.(VarAccess).getName() + \"' is always a promise.\"\n  or\n  result = \"The call to '\" + e.(CallExpr).getCalleeName() + \"' always returns a promise.\"\n}\n\nstring getPromiseExplanation(Expr e) {\n  result = tryGetPromiseExplanation(e)\n  or\n  not exists(tryGetPromiseExplanation(e)) and\n  result = \"This value is always a promise.\"\n}\n\nfrom Expr expr, boolean nullable\nwhere\n  isBadPromiseContext(expr) and\n  isPromise(expr.flow().getImmediatePredecessor*(), nullable) and\n  (\n    nullable = false\n    or\n    expr.inNullSensitiveContext()\n  )\nselect expr, \"Missing await. \" + getPromiseExplanation(expr)",
        "description": "Using a promise without awaiting its result can lead to unexpected behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/MissingAwait.ql",
        "language": "javascript"
    },
    {
        "query": "import Clones\n\npredicate accessWithConversions(Expr e, Variable v) {\n  e = v.getAnAccess()\n  or\n  accessWithConversions(e.(ParExpr).getExpression(), v)\n  or\n  exists(UnaryExpr ue | ue instanceof NegExpr or ue instanceof PlusExpr |\n    ue = e and accessWithConversions(ue.getOperand(), v)\n  )\n  or\n  exists(CallExpr ce | ce = e |\n    ce = DataFlow::globalVarRef(\"Number\").getACall().asExpr() and\n    ce.getNumArgument() = 1 and\n    accessWithConversions(ce.getArgument(0), v)\n  )\n}\n\npredicate isNaNComment(Comment c, string filePath, int startLine) {\n  c.getText().matches(\"%NaN%\") and\n  c.getLocation().hasLocationInfo(filePath, startLine, _, _, _)\n}\n\npredicate isNaNCheck(EqualityTest eq) {\n  exists(Variable v |\n    accessWithConversions(eq.getLeftOperand(), v) and\n    accessWithConversions(eq.getRightOperand(), v)\n  |\n    // `v` is a parameter of the enclosing function, which is called `isNaN`\n    exists(Function isNaN |\n      isNaN = eq.getEnclosingFunction() and\n      isNaN.getName().toLowerCase() = \"isnan\" and\n      v = isNaN.getAParameter().getAVariable()\n    )\n    or\n    // there is a comment containing the word \"NaN\" next to the comparison\n    exists(string f, int l |\n      eq.getLocation().hasLocationInfo(f, l, _, _, _) and\n      isNaNComment(_, f, [l - 1 .. l + 1])\n    )\n  )\n}\n\nfrom Comparison selfComparison, OperandComparedToSelf e\nwhere\n  e = selfComparison.getAnOperand() and\n  e.same(_) and\n  not isNaNCheck(selfComparison)\nselect selfComparison, \"This expression compares $@ to itself.\", e, e.toString()",
        "description": "If the same expression occurs on both sides of a comparison operator, the operator is redundant, and probably indicates a mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/CompareIdenticalValues.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.dataflow.InferredTypes\nprivate import semmle.javascript.DefensiveProgramming\n\npredicate comparisonOperands(AstNode nd, Expr left, Expr right) {\n  exists(Comparison cmp | cmp = nd | left = cmp.getLeftOperand() and right = cmp.getRightOperand())\n  or\n  exists(SwitchStmt switch | switch = nd |\n    right = switch.getExpr() and left = switch.getACase().getExpr()\n  )\n}\n\npredicate hasImplicitConversionMethod(DefiniteAbstractValue av) {\n  // look for assignments to `toString` or `valueOf` on `av` or its prototypes\n  exists(AnalyzedPropertyWrite apw, string p | p = \"toString\" or p = \"valueOf\" |\n    apw.writes(av.getAPrototype*(), p, _)\n  )\n}\n\nInferredType strictEqualityOperandType(AstNode eq, DataFlow::AnalyzedNode operand) {\n  // strict equality tests do no conversion at all\n  operand.asExpr() = eq.(StrictEqualityTest).getAChildExpr() and result = operand.getAType()\n  or\n  // switch behaves like a strict equality test\n  exists(SwitchStmt switch | switch = eq |\n    (operand.asExpr() = switch.getExpr() or operand.asExpr() = switch.getACase().getExpr()) and\n    result = operand.getAType()\n  )\n}\n\npredicate implicitlyConvertedOperand(AstNode parent, DataFlow::AnalyzedNode operand) {\n  (parent instanceof NonStrictEqualityTest or parent instanceof RelationalComparison) and\n  operand.asExpr() = parent.getAChildExpr() and\n  hasImplicitConversionMethod(operand.getAValue())\n}\n\nInferredType nonStrictOperandType(AstNode parent, DataFlow::AnalyzedNode operand) {\n  // non-strict equality tests perform conversions\n  operand.asExpr() = parent.(NonStrictEqualityTest).getAChildExpr() and\n  exists(InferredType tp | tp = operand.getAValue().getType() |\n    result = tp\n    or\n    // Booleans are converted to numbers\n    tp = TTBoolean() and result = TTNumber()\n    or\n    // and so are strings\n    tp = TTString() and\n    // exclude cases where the string is guaranteed to coerce to NaN\n    not exists(ConstantString l | l = operand.asExpr() | not exists(l.getStringValue().toFloat())) and\n    result = TTNumber()\n    or\n    // Dates are converted to strings (which are guaranteed to coerce to NaN)\n    tp = TTDate() and result = TTString()\n    or\n    // other objects are converted to strings, numbers or Booleans\n    (tp = TTObject() or tp = TTFunction() or tp = TTClass() or tp = TTRegExp()) and\n    (result = TTBoolean() or result = TTNumber() or result = TTString())\n    or\n    // `undefined` and `null` are equated\n    tp = TTUndefined() and result = TTNull()\n  )\n  or\n  // relational operators convert their operands to numbers or strings\n  operand.asExpr() = parent.(RelationalComparison).getAChildExpr() and\n  exists(AbstractValue v | v = operand.getAValue() |\n    result = v.getType()\n    or\n    v.isCoercibleToNumber() and result = TTNumber()\n  )\n}\n\nInferredType convertedOperandType(AstNode parent, DataFlow::AnalyzedNode operand) {\n  result = strictEqualityOperandType(parent, operand)\n  or\n  // if `operand` might have `toString`/`valueOf`, just assume it could\n  // convert to any type at all\n  implicitlyConvertedOperand(parent, operand)\n  or\n  result = nonStrictOperandType(parent, operand)\n}\n\npredicate isHeterogeneousComparison(\n  AstNode cmp, DataFlow::AnalyzedNode left, DataFlow::AnalyzedNode right, string leftTypes,\n  string rightTypes\n) {\n  comparisonOperands(cmp, left.asExpr(), right.asExpr()) and\n  not convertedOperandType(cmp, left) = convertedOperandType(cmp, right) and\n  leftTypes = left.ppTypes() and\n  rightTypes = right.ppTypes()\n}\n\npredicate isPseudoKeyword(string name) {\n  name = \"Infinity\" or\n  name = \"NaN\" or\n  name = \"undefined\"\n}\n\nstring getDescription(VarAccess e) {\n  exists(string name | name = e.getName() |\n    if isPseudoKeyword(name) then result = \"'\" + name + \"'\" else result = \"variable '\" + name + \"'\"\n  )\n}\n\nbindingset[default]\nstring getDescription(Expr e, string default) {\n  if exists(getDescription(e)) then result = getDescription(e) else result = default\n}\n\nbindingset[message1, message2, complexity1, complexity2]\nstring getTypeDescription(string message1, string message2, int complexity1, int complexity2) {\n  if complexity1 > 4 and complexity2 <= 2 then result = message2 else result = message1\n}\n\npredicate isInitialParameterUse(Expr e) {\n  // unlike `SimpleParameter.getAnInitialUse` this will not include uses we have refinement information for\n  exists(SimpleParameter p, SsaExplicitDefinition ssa |\n    ssa.getDef() = p and\n    ssa.getVariable().getAUse() = e and\n    not p.isRestParameter()\n  )\n}\n\npredicate whitelist(Expr e) { isInitialParameterUse(e) }\n\nfrom\n  AstNode cmp, DataFlow::AnalyzedNode left, DataFlow::AnalyzedNode right, string leftTypes,\n  string rightTypes, string leftExprDescription, string rightExprDescription, int leftTypeCount,\n  int rightTypeCount, string leftTypeDescription, string rightTypeDescription\nwhere\n  isHeterogeneousComparison(cmp, left, right, leftTypes, rightTypes) and\n  not exists(cmp.(Expr).flow().(DefensiveExpressionTest).getTheTestResult()) and\n  not whitelist(left.asExpr()) and\n  not whitelist(right.asExpr()) and\n  leftExprDescription = capitalize(getDescription(left.asExpr(), \"this expression\")) and\n  rightExprDescription = getDescription(right.asExpr(), \"an expression\") and\n  leftTypeCount = strictcount(left.getAType()) and\n  rightTypeCount = strictcount(right.getAType()) and\n  leftTypeDescription =\n    getTypeDescription(\"is of type \" + leftTypes, \"cannot be of type \" + rightTypes, leftTypeCount,\n      rightTypeCount) and\n  rightTypeDescription =\n    getTypeDescription(\"of type \" + rightTypes, \", which cannot be of type \" + leftTypes,\n      rightTypeCount, leftTypeCount)\nselect left,\n  leftExprDescription + \" \" + leftTypeDescription + \", but it is compared to $@ \" +\n    rightTypeDescription + \".\", right, rightExprDescription",
        "description": "An equality comparison between two values that cannot be meaningfully converted to the same type will always yield 'false', and an inequality comparison will always yield 'true'.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/HeterogeneousComparison.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.dataflow.InferredTypes\n\npredicate namespaceOrConstEnumAccess(VarAccess e) {\n  exists(NamespaceDeclaration decl | e.getVariable().getADeclaration() = decl.getIdentifier())\n  or\n  exists(EnumDeclaration decl | e.getVariable().getADeclaration() = decl.getIdentifier() |\n    decl.isConst()\n  )\n}\n\nfrom PropAccess pacc, DataFlow::AnalyzedNode base\nwhere\n  base.asExpr() = pacc.getBase() and\n  forex(InferredType tp | tp = base.getAType() | tp = TTNull() or tp = TTUndefined()) and\n  not namespaceOrConstEnumAccess(pacc.getBase()) and\n  not pacc.isAmbient() and\n  not pacc instanceof OptionalUse\nselect pacc, \"The base expression of this property access is always \" + base.ppTypes() + \".\"",
        "description": "Trying to access a property of \"null\" or \"undefined\" will result in a runtime exception.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Expressions/SuspiciousPropAccess.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nint getSeverity() { result = 2 }\n\nfrom Error error\nwhere\n  exists(error.getFile().getRelativePath()) and\n  error.isFatal()\nselect error, \"Extraction failed in \" + error.getFile() + \" with error \" + error.getMessage(),\n  getSeverity()",
        "description": "List all extraction errors for files in the source code directory.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Diagnostics/ExtractionErrors.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom File f\nwhere exists(f.getRelativePath())\nselect f, \"\"",
        "description": "Lists all files in the source code directory that were extracted.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Diagnostics/ExtractedFiles.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DOM::AttributeDefinition id, string reason\nwhere\n  DOM::isInvalidHtmlIdAttributeValue(id, reason) and\n  // exclude attribute values that look like they might be templated\n  not id.mayHaveTemplateValue()\nselect id, \"The value of the id attribute \" + reason + \".\"",
        "description": "If the id of an HTML attribute is malformed, its interpretation may be browser-dependent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/DOM/MalformedIdAttribute.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nselect DataFlow::globalVarRef(\"alert\").getACall(), \"Avoid calling alert.\"",
        "description": "'alert' should not be used in production code.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/DOM/Alert.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate conflict(DOM::AttributeDefinition earlier, DOM::AttributeDefinition later) {\n  exists(DOM::ElementDefinition elt, int i, int j |\n    earlier = elt.getAttribute(i) and later = elt.getAttribute(j)\n  |\n    i < j and\n    earlier.getName() = later.getName() and\n    not earlier.getStringValue() = later.getStringValue()\n  )\n}\n\nfrom DOM::AttributeDefinition earlier, DOM::AttributeDefinition later\nwhere conflict(earlier, later) and not conflict(_, earlier)\nselect earlier,\n  \"This attribute has the same name as $@ of the same element, \" + \"but a different value.\", later,\n  \"another attribute\"",
        "description": "If an HTML element has two attributes with the same name but different values, its behavior may be browser-dependent.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/DOM/ConflictingAttributes.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass EvilTwin extends DataFlow::CallNode {\n  EvilTwin() {\n    exists(string fn | fn = \"setTimeout\" or fn = \"setInterval\" |\n      this = DataFlow::globalVarRef(fn).getACall() and\n      this.getArgument(0).asExpr() instanceof ConstantString\n    )\n  }\n}\n\nclass DocumentWrite extends DataFlow::CallNode {\n  DocumentWrite() {\n    exists(string writeln |\n      this = DataFlow::globalVarRef(\"document\").getAMemberCall(writeln) and\n      writeln.regexpMatch(\"write(ln)?\")\n    )\n  }\n}\n\nclass ExecScript extends DataFlow::CallNode {\n  ExecScript() { this = DataFlow::globalVarRef(\"execScript\").getACall() }\n}\n\nclass PseudoEval extends DataFlow::Node {\n  PseudoEval() {\n    this instanceof EvilTwin or\n    this instanceof DocumentWrite or\n    this instanceof ExecScript\n  }\n}\n\nfrom PseudoEval pe\nselect pe, \"Avoid using functions that evaluate strings as code.\"",
        "description": "DOM functions that act like 'eval' and execute strings as code are dangerous and impede program analysis and understanding. Consequently, they should not be used.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/DOM/PseudoEval.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate idAt(\n  DOM::AttributeDefinition attr, string id, DOM::ElementDefinition root, int line, int column\n) {\n  exists(DOM::ElementDefinition elt | attr = elt.getAttributeByName(\"id\") |\n    id = attr.getStringValue() and\n    root = elt.getRoot() and\n    elt.getLocation().hasLocationInfo(_, line, column, _, _) and\n    // exclude invalid ids (reported by another query)\n    not DOM::isInvalidHtmlIdAttributeValue(attr, _)\n  )\n}\n\npredicate sameId(\n  DOM::ElementDefinition root, DOM::AttributeDefinition earlier, DOM::AttributeDefinition later\n) {\n  exists(string id, int l1, int c1, int l2, int c2 |\n    idAt(earlier, id, root, l1, c1) and idAt(later, id, root, l2, c2)\n  |\n    l1 < l2\n    or\n    l1 = l2 and c1 < c2\n  )\n}\n\npredicate mayContainTemplates(DOM::ElementDefinition root) {\n  exists(DOM::AttributeDefinition attr |\n    attr.mayHaveTemplateValue() and\n    root = attr.getElement().getRoot()\n  )\n}\n\nfrom DOM::ElementDefinition root, DOM::AttributeDefinition earlier, DOM::AttributeDefinition later\nwhere\n  sameId(root, earlier, later) and\n  // only flag the first ambiguity if there are many\n  not sameId(root, _, earlier) and\n  // exclude templates\n  not mayContainTemplates(root)\nselect earlier, \"This element has the same id as $@.\", later, \"another element\"",
        "description": "If an HTML document contains two elements with the same id attribute, it may be interpreted differently by different browsers.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/DOM/AmbiguousIdAttribute.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate duplicate(DOM::AttributeDefinition earlier, DOM::AttributeDefinition later) {\n  exists(DOM::ElementDefinition elt, int i, int j |\n    earlier = elt.getAttribute(i) and later = elt.getAttribute(j)\n  |\n    i < j and\n    earlier.getName() = later.getName() and\n    earlier.getStringValue() = later.getStringValue()\n  )\n}\n\nfrom DOM::AttributeDefinition earlier, DOM::AttributeDefinition later\nwhere duplicate(earlier, later) and not duplicate(_, earlier)\nselect earlier, \"This attribute $@.\", later, \"is duplicated later\"",
        "description": "Specifying the same attribute twice on the same HTML element is redundant and may indicate a copy-paste mistake.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/DOM/DuplicateAttributes.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.frameworks.Templating\nimport semmle.javascript.RestrictedLocations\n\npredicate maybeInjectedByAngular() {\n  DataFlow::moduleMember(\"@angular/core\", \"HostBinding\")\n      .getACall()\n      .getArgument(0)\n      .mayHaveStringValue(\"attr.rel\")\n}\n\npredicate hasDynamicHrefHostAttributeValue(DOM::ElementDefinition elem) {\n  exists(DOM::AttributeDefinition attr |\n    attr = elem.getAnAttribute() and\n    attr.getName().matches(\"%href%\")\n  |\n    // unknown string\n    not exists(attr.getStringValue())\n    or\n    exists(string url | url = attr.getStringValue() |\n      // fixed string with templating\n      url.regexpMatch(Templating::getDelimiterMatchingRegexpWithPrefix(\"[^?#]*\")) and\n      // ... that does not start with a fixed host or a relative path (common formats)\n      not url.regexpMatch(\"(?i)((https?:)?//)?[-a-z0-9.]*/.*\") and\n      // .. that is not a call to `url_for` in a Flask / nunjucks application\n      not url.regexpMatch(\"\\\\{\\\\{\\\\s*url(_for)?\\\\(.+\\\\).*\") and\n      // .. that is not a call to `url` in a Django application\n      not url.regexpMatch(\"\\\\{%\\\\s*url.*\")\n    )\n  )\n}\n\nfrom DOM::ElementDefinition e\nwhere\n  // `e` is a link that opens in a new browsing context (that is, it has `target=\"_blank\"`)\n  e.getName() = \"a\" and\n  // and the host in the href is not hard-coded\n  hasDynamicHrefHostAttributeValue(e) and\n  // disable for Angular applications that dynamically inject the 'rel' attribute\n  not maybeInjectedByAngular() and\n  e.getAttributeByName(\"target\").getStringValue() = \"_blank\" and\n  // there is no `rel` attribute specifying link type `noopener`/`noreferrer`;\n  // `rel` attributes with non-constant value are handled conservatively\n  forall(DOM::AttributeDefinition relAttr | relAttr = e.getAttributeByName(\"rel\") |\n    exists(string rel | rel = relAttr.getStringValue() |\n      not exists(string linkType | linkType = rel.splitAt(\" \") |\n        linkType = \"noopener\" or\n        linkType = \"noreferrer\"\n      )\n    )\n  ) and\n  // exclude elements with spread attributes or dynamically computed attribute names\n  not exists(DOM::AttributeDefinition attr | attr = e.getAnAttribute() | not exists(attr.getName()))\nselect e.(FirstLineOf), \"External links without noopener/noreferrer are a potential security risk.\"",
        "description": "External links that open in a new tab or window but do not specify link type 'noopener' or 'noreferrer' are a potential security risk.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/DOM/TargetBlank.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom Function f, Function g, float percent\nwhere none()\nselect f.(FirstLineOf),\n  percent.floor() + \"% of statements in \" + f.describe() + \" are similar to statements in $@.\",\n  g.(FirstLineOf), g.describe()",
        "description": "There is another function that shares a lot of code with this function. Extract the common parts to a shared utility function to improve maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/external/SimilarFunction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom TopLevel one, TopLevel another, float percent\nwhere none()\nselect one.(FirstLineOf), percent.floor() + \"% of statements in this script are duplicated in $@.\",\n  another.(FirstLineOf), \"another script\"",
        "description": "There is another script that shares a lot of code with this script. Consider combining the two scripts to improve maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/external/DuplicateToplevel.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom TopLevel one, TopLevel another, float percent\nwhere none()\nselect one.(FirstLineOf),\n  percent.floor() + \"% of statements in this script are similar to statements in $@.\",\n  another.(FirstLineOf), \"another script\"",
        "description": "There is another script that shares a lot of code with this script. Extract the common parts to a new script to improve maintainability..",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/external/SimilarToplevel.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.RestrictedLocations\n\nfrom Function f, Function g, float percent\nwhere none()\nselect f.(FirstLineOf),\n  percent.floor() + \"% of statements in \" + f.describe() + \" are duplicated in $@.\",\n  g.(FirstLineOf), g.describe()",
        "description": "There is another function that shares a lot of code with this function. Extract the common parts to a shared utility function to improve maintainability.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/external/DuplicateFunction.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nprivate import semmle.javascript.security.regexp.RegExpTreeView::RegExpTreeView as TreeView\nimport codeql.regex.nfa.ExponentialBackTracking::Make<TreeView>\n\nfrom RegExpTerm t, string pump, State s, string prefixMsg\nwhere hasReDoSResult(t, pump, s, prefixMsg)\nselect t,\n  \"This part of the regular expression may cause exponential backtracking on strings \" + prefixMsg +\n    \"containing many repetitions of '\" + pump + \"'.\"",
        "description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Performance/ReDoS.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.security.regexp.PolynomialReDoSQuery\nimport PolynomialReDoSFlow::PathGraph\n\nfrom\n  PolynomialReDoSFlow::PathNode source, PolynomialReDoSFlow::PathNode sink, Sink sinkNode,\n  PolynomialBackTrackingTerm regexp\nwhere\n  PolynomialReDoSFlow::flowPath(source, sink) and\n  sinkNode = sink.getNode() and\n  regexp = sinkNode.getRegExp() and\n  not (\n    source.getNode().(Source).getKind() = \"url\" and\n    regexp.isAtEndLine()\n  )\nselect sinkNode.getHighlight(), source, sink,\n  \"This $@ that depends on $@ may run slow on strings \" + regexp.getPrefixMessage() +\n    \"with many repetitions of '\" + regexp.getPumpString() + \"'.\", regexp, \"regular expression\",\n  source.getNode(), source.getNode().(Source).describe()",
        "description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Performance/PolynomialReDoS.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom Function f, SimpleParameter p, VarAccess assgn\nwhere\n  p = f.getAParameter() and\n  f.usesArgumentsObject() and\n  assgn = p.getVariable().getAnAccess() and\n  assgn.isLValue()\nselect p,\n  \"This parameter $@, \" + \"which may prevent optimization because the surrounding function \" +\n    \"uses the arguments object.\", assgn, \"is reassigned\"",
        "description": "A function that reassigns one of its parameters and also uses the arguments object may not be optimized properly.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Performance/ReassignParameterAndUseArguments.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\npredicate nonLocalIterator(EnhancedForLoop f, string descr) {\n  // iterator is a property as in `for (x.p in o) ...`\n  f.getIterator() instanceof PropAccess and descr = \"a property\"\n  or\n  // iterator is not a purely local variable:\n  exists(Variable v | v = f.getAnIterationVariable() |\n    // either it is global...\n    v.isGlobal() and descr = \"a global variable\"\n    or\n    // ...or it is captured by an inner function\n    v.isLocal() and v.isCaptured() and descr = \"captured\"\n  )\n}\n\nfrom EnhancedForLoop f, string reason\nwhere\n  nonLocalIterator(f, reason) and\n  // exclude toplevel statements, since the toplevel is unlikely to be optimized anyway\n  not f.getContainer() instanceof TopLevel\nselect f.getIterator(),\n  \"This loop may prevent optimization because its iteration variable is \" + reason + \".\"",
        "description": "For-in/for-of loops whose iteration variable is not a purely local variable may prevent optimization of the surrounding function.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Performance/NonLocalForIn.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DataFlow::PropWrite allowRunningInsecureContent, Electron::WebPreferences preferences\nwhere\n  allowRunningInsecureContent = preferences.getAPropertyWrite(\"allowRunningInsecureContent\") and\n  allowRunningInsecureContent.getRhs().mayHaveBooleanValue(true)\nselect allowRunningInsecureContent, \"Enabling allowRunningInsecureContent is strongly discouraged.\"",
        "description": "Enabling allowRunningInsecureContent can allow remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Electron/AllowRunningInsecureContent.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nstring getNodeIntegrationWarning(Electron::WebPreferences pref) {\n  exists(string feature |\n    feature = \"nodeIntegration\" or\n    feature = \"nodeIntegrationInWorker\"\n  |\n    pref.getAPropertyWrite(feature).getRhs().mayHaveBooleanValue(true) and\n    result = \"The `\" + feature + \"` feature has been enabled.\"\n  )\n  or\n  exists(string feature | feature = \"nodeIntegration\" |\n    not exists(pref.getAPropertyWrite(feature)) and\n    result = \"The `\" + feature + \"` feature is enabled by default.\"\n  )\n}\n\nfrom Electron::WebPreferences preferences\nselect preferences, getNodeIntegrationWarning(preferences)",
        "description": "Enabling `nodeIntegration` or `nodeIntegrationInWorker` can expose the application to remote code execution.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Electron/EnablingNodeIntegration.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nfrom DataFlow::PropWrite webSecurity, Electron::WebPreferences preferences\nwhere\n  webSecurity = preferences.getAPropertyWrite(\"webSecurity\") and\n  webSecurity.getRhs().mayHaveBooleanValue(false)\nselect webSecurity, \"Disabling webSecurity is strongly discouraged.\"",
        "description": "Disabling webSecurity can cause critical security vulnerabilities.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Electron/DisablingWebSecurity.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nclass CallOnSelf extends DataFlow::CallNode {\n  CallOnSelf() {\n    exists(Function binder | binder = this.getEnclosingFunction().getThisBinder() |\n      exists(DataFlow::ThisNode thiz |\n        this = thiz.getAMethodCall(_) and\n        thiz.getBinder().getAstNode() = binder\n      )\n      or\n      this.getACallee().(ArrowFunctionExpr).getThisBinder() = binder\n    )\n  }\n\n  /**\n   * Gets a `CallOnSelf` in the callee of this call.\n   */\n  CallOnSelf getACalleCallOnSelf() { result.getEnclosingFunction() = this.getACallee() }\n}\n\nclass UnconditionalCallOnSelf extends CallOnSelf {\n  UnconditionalCallOnSelf() { isUnconditionalCall(this) }\n\n  override UnconditionalCallOnSelf getACalleCallOnSelf() {\n    result = CallOnSelf.super.getACalleCallOnSelf()\n  }\n}\n\npredicate isUnconditionalCall(DataFlow::CallNode call) {\n  exists(ReachableBasicBlock callBlock, ReachableBasicBlock entryBlock |\n    callBlock.postDominates(entryBlock) and\n    callBlock = call.getBasicBlock() and\n    entryBlock = call.getEnclosingFunction().getEntryBB()\n  )\n}\n\npredicate isStateUpdateMethodCall(DataFlow::MethodCallNode mce) {\n  exists(string updateMethodName |\n    updateMethodName = \"setState\" or\n    updateMethodName = \"replaceState\" or\n    updateMethodName = \"forceUpdate\"\n  |\n    mce.getMethodName() = updateMethodName\n  )\n}\n\nclass StateUpdateVolatileMethod extends Function {\n  string methodName;\n\n  StateUpdateVolatileMethod() {\n    // methods that are known to be ok:\n    // - componentWillUnmount\n    // - componentsWillMount\n    // - componentsDidMount\n    exists(ReactComponent c |\n      methodName =\n        [\n          \"componentDidUnmount\", \"componentDidUpdate\", \"componentWillUpdate\", \"getDefaultProps\",\n          \"getInitialState\", \"render\", \"shouldComponentUpdate\"\n        ]\n    |\n      this = c.getInstanceMethod(methodName)\n    )\n    or\n    this = any(ES2015Component c).getConstructor().getBody() and\n    methodName = \"constructor\"\n  }\n\n  /**\n   * Holds if conditional state updates are benign in this method.\n   */\n  predicate conditionalStateUpatesAreBenign() {\n    methodName = \"componentDidUpdate\" or\n    methodName = \"componentWillUpdate\" or\n    methodName = \"shouldComponentUpdate\"\n  }\n}\n\nfrom\n  StateUpdateVolatileMethod root, CallOnSelf initCall, DataFlow::MethodCallNode stateUpdate,\n  string callDescription\nwhere\n  initCall.getEnclosingFunction() = root and\n  stateUpdate = initCall.getACalleCallOnSelf*() and\n  isStateUpdateMethodCall(stateUpdate) and\n  if root.conditionalStateUpatesAreBenign()\n  then\n    initCall instanceof UnconditionalCallOnSelf and\n    callDescription = \"Unconditional call\"\n  else callDescription = \"Call\"\nselect initCall,\n  callDescription + \" to state update method $@ is not allowed from within this method.\",\n  stateUpdate, \" .\" + stateUpdate.getMethodName()",
        "description": "Attempting to update the state of a React component at the wrong time can cause undesired behavior.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/React/UnsupportedStateUpdateInLifecycleMethod.ql",
        "language": "javascript"
    },
    {
        "query": "import semmle.javascript.frameworks.React\nimport semmle.javascript.RestrictedLocations\n\nDataFlow::SourceNode potentialStateSource(ReactComponent c) {\n  result = c.getACandidateStateSource() or\n  result = c.getADirectStateAccess() or\n  result = c.getAPreviousStateSource()\n}\n\nDataFlow::PropRef getAPotentialStateAccess(ReactComponent c) {\n  potentialStateSource(c).flowsTo(result.getBase())\n}\n\npredicate hasAStateEscape(ReactComponent c) {\n  exists(DataFlow::InvokeNode invk |\n    not invk = c.getAMethodCall(\"setState\") and\n    potentialStateSource(c).flowsTo(invk.getAnArgument())\n  )\n}\n\npredicate hasUnknownStatePropertyWrite(ReactComponent c) {\n  exists(DataFlow::PropWrite pwn |\n    pwn = getAPotentialStateAccess(c) and\n    not exists(pwn.getPropertyName())\n  )\n  or\n  exists(DataFlow::SourceNode source |\n    source = c.getACandidateStateSource() and\n    not source instanceof DataFlow::ObjectLiteralNode\n  )\n}\n\npredicate hasUnknownStatePropertyRead(ReactComponent c) {\n  exists(DataFlow::PropRead prn |\n    prn = getAPotentialStateAccess(c) and\n    not exists(prn.getPropertyName())\n  )\n  or\n  exists(SpreadElement spread | potentialStateSource(c).flowsToExpr(spread.getOperand()))\n}\n\npredicate usesMixins(ES5Component c) {\n  c.flow().(DataFlow::SourceNode).hasPropertyWrite(\"mixins\", _)\n}\n\nDataFlow::PropWrite getAnUnusedStateProperty(ReactComponent c) {\n  result = getAPotentialStateAccess(c) and\n  exists(string name | name = result.getPropertyName() |\n    not exists(DataFlow::PropRead prn |\n      prn = getAPotentialStateAccess(c) and\n      prn.getPropertyName() = name\n    )\n  )\n}\n\nDataFlow::PropRead getAnUndefinedStateProperty(ReactComponent c) {\n  result = getAPotentialStateAccess(c) and\n  exists(string name | name = result.getPropertyName() |\n    not exists(DataFlow::PropWrite pwn |\n      pwn = getAPotentialStateAccess(c) and\n      pwn.getPropertyName() = name\n    )\n  )\n}\n\nfrom ReactComponent c, DataFlow::PropRef n, string action, string nonAction\nwhere\n  (\n    action = \"written\" and\n    nonAction = \"read\" and\n    n = getAnUnusedStateProperty(c) and\n    not hasUnknownStatePropertyRead(c)\n    or\n    action = \"read\" and\n    nonAction = \"written\" and\n    n = getAnUndefinedStateProperty(c) and\n    not hasUnknownStatePropertyWrite(c)\n  ) and\n  not hasAStateEscape(c) and\n  not usesMixins(c)\nselect c.(FirstLineOf),\n  \"Component state property '\" + n.getPropertyName() + \"' is $@, but it is never \" + nonAction + \".\",\n  n, action",
        "description": "Unused or undefined component state properties may be a symptom of a bug and should be examined carefully.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/React/UnusedOrUndefinedStateProperty.ql",
        "language": "javascript"
    },
    {
        "query": "import semmle.javascript.frameworks.React\n\nfrom DataFlow::PropWrite pwn, ReactComponent c\nwhere\n  pwn.getBase() = c.getAStateAccess() and\n  // writes in constructors are ok\n  not pwn.getContainer() instanceof Constructor\nselect pwn, \"Use `setState` instead of directly modifying component state.\"",
        "description": "Mutating the state of a React component directly may lead to lost updates.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/React/DirectStateMutation.ql",
        "language": "javascript"
    },
    {
        "query": "import semmle.javascript.frameworks.React\n\nDataFlow::PropRead getAnUnsafeAccess(ReactComponent c) {\n  result = c.getAPropRead() or\n  result = c.getAStateAccess()\n}\n\nDataFlow::PropRead getAnOutermostUnsafeAccess(ReactComponent c) {\n  result = getAnUnsafeAccess(c) and\n  not exists(DataFlow::PropRead outer | outer = getAnUnsafeAccess(c) | result = outer.getBase())\n}\n\nDataFlow::PropWrite getAStateUpdate(ReactComponent c, string name) {\n  exists(DataFlow::ObjectLiteralNode newState |\n    newState.flowsTo(c.getAMethodCall(\"setState\").getArgument(0)) and\n    result = newState.getAPropertyWrite(name)\n  )\n}\n\nDataFlow::PropWrite getAUniqueStateUpdate(ReactComponent c) {\n  exists(string name |\n    count(getAStateUpdate(c, name)) = 1 and\n    result = getAStateUpdate(c, name)\n  )\n}\n\npredicate isAStateUpdateFromSelf(ReactComponent c, DataFlow::PropWrite pwn, DataFlow::PropRead prn) {\n  exists(string name |\n    pwn = getAStateUpdate(c, name) and\n    c.getADirectStateAccess().flowsTo(prn.getBase()) and\n    prn.getPropertyName() = name and\n    pwn.getRhs().asExpr() = prn.asExpr().getParentExpr*() and\n    pwn.getContainer() = prn.getContainer()\n  )\n}\n\nfrom ReactComponent c, MethodCallExpr setState, Expr getState\nwhere\n  setState = c.getAMethodCall(\"setState\").asExpr() and\n  getState = getAnOutermostUnsafeAccess(c).asExpr() and\n  getState.getParentExpr*() = setState.getArgument(0) and\n  getState.getEnclosingFunction() = setState.getEnclosingFunction() and\n  // ignore self-updates that only occur in one location: `setState({toggled: !this.state.toggled})`, they are most likely safe in practice\n  not exists(DataFlow::PropWrite pwn |\n    pwn = getAUniqueStateUpdate(c) and\n    isAStateUpdateFromSelf(c, pwn, DataFlow::valueNode(getState))\n  )\nselect setState, \"Component state update uses $@.\", getState, \"potentially inconsistent value\"",
        "description": "Updating the state of a component based on the current value of 'this.state' or 'this.props' may lead to inconsistent component state.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/React/InconsistentStateUpdate.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\n\nselect sum(File f | not f.getATopLevel().isExterns() | f.getNumberOfLinesOfCode())",
        "description": "The total number of lines of JavaScript or TypeScript code across all files checked into the repository, except in `node_modules`. This is a useful metric of the size of a database. For all files that were seen during extraction, this query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Summary/LinesOfCode.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nfrom string kind\nselect relevantTaintSink(kind), kind + \" sink\"",
        "description": "Expressions that are vulnerable if containing untrusted data.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Summary/TaintSinks.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport semmle.javascript.GeneratedCode\n\nselect sum(File f |\n    not f.getATopLevel().isExterns() and\n    exists(f.getRelativePath()) and\n    not isGeneratedCode(f)\n  |\n    f.getNumberOfLinesOfCode()\n  )",
        "description": "The total number of lines of JavaScript and TypeScript code from the source code directory, excluding auto-generated files and files in `node_modules`. This query counts the lines of code, excluding whitespace or comments.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Summary/LinesOfUserCode.ql",
        "language": "javascript"
    },
    {
        "query": "import javascript\nimport meta.internal.TaintMetrics\n\nfrom RemoteFlowSource node\nwhere node = relevantTaintSource()\nselect node, node.getSourceType()",
        "description": "Sources of untrusted input.",
        "path": "/Users/timchu/Desktop/codeql/vscode-codeql-starter/ql/javascript/ql/src/Summary/TaintSources.ql",
        "language": "javascript"
    }
]